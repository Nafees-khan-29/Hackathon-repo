function Yae(e,t){for(var n=0;n<t.length;n++){const r=t[n];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in e)){const a=Object.getOwnPropertyDescriptor(r,s);a&&Object.defineProperty(e,s,a.get?a:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const a of s)if(a.type==="childList")for(const i of a.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function n(s){const a={};return s.integrity&&(a.integrity=s.integrity),s.referrerPolicy&&(a.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?a.credentials="include":s.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function r(s){if(s.ep)return;s.ep=!0;const a=n(s);fetch(s.href,a)}})();var a1t=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function ty(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function Zae(e){if(Object.prototype.hasOwnProperty.call(e,"__esModule"))return e;var t=e.default;if(typeof t=="function"){var n=function r(){return this instanceof r?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};n.prototype=t.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(e).forEach(function(r){var s=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:function(){return e[r]}})}),n}var Z$={exports:{}},Cb={},J$={exports:{}},mn={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var iB;function Jae(){if(iB)return mn;iB=1;var e=Symbol.for("react.element"),t=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),a=Symbol.for("react.provider"),i=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),u=Symbol.for("react.memo"),c=Symbol.for("react.lazy"),d=Symbol.iterator;function p(P){return P===null||typeof P!="object"?null:(P=d&&P[d]||P["@@iterator"],typeof P=="function"?P:null)}var h={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(P,X,Q){this.props=P,this.context=X,this.refs=g,this.updater=Q||h}y.prototype.isReactComponent={},y.prototype.setState=function(P,X){if(typeof P!="object"&&typeof P!="function"&&P!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,P,X,"setState")},y.prototype.forceUpdate=function(P){this.updater.enqueueForceUpdate(this,P,"forceUpdate")};function b(){}b.prototype=y.prototype;function v(P,X,Q){this.props=P,this.context=X,this.refs=g,this.updater=Q||h}var k=v.prototype=new b;k.constructor=v,m(k,y.prototype),k.isPureReactComponent=!0;var I=Array.isArray,S=Object.prototype.hasOwnProperty,N={current:null},T={key:!0,ref:!0,__self:!0,__source:!0};function A(P,X,Q){var re,le={},ke=null,Ne=null;if(X!=null)for(re in X.ref!==void 0&&(Ne=X.ref),X.key!==void 0&&(ke=""+X.key),X)S.call(X,re)&&!T.hasOwnProperty(re)&&(le[re]=X[re]);var we=arguments.length-2;if(we===1)le.children=Q;else if(1<we){for(var _e=Array(we),Le=0;Le<we;Le++)_e[Le]=arguments[Le+2];le.children=_e}if(P&&P.defaultProps)for(re in we=P.defaultProps,we)le[re]===void 0&&(le[re]=we[re]);return{$$typeof:e,type:P,key:ke,ref:Ne,props:le,_owner:N.current}}function R(P,X){return{$$typeof:e,type:P.type,key:X,ref:P.ref,props:P.props,_owner:P._owner}}function D(P){return typeof P=="object"&&P!==null&&P.$$typeof===e}function $(P){var X={"=":"=0",":":"=2"};return"$"+P.replace(/[=:]/g,function(Q){return X[Q]})}var _=/\/+/g;function L(P,X){return typeof P=="object"&&P!==null&&P.key!=null?$(""+P.key):X.toString(36)}function z(P,X,Q,re,le){var ke=typeof P;(ke==="undefined"||ke==="boolean")&&(P=null);var Ne=!1;if(P===null)Ne=!0;else switch(ke){case"string":case"number":Ne=!0;break;case"object":switch(P.$$typeof){case e:case t:Ne=!0}}if(Ne)return Ne=P,le=le(Ne),P=re===""?"."+L(Ne,0):re,I(le)?(Q="",P!=null&&(Q=P.replace(_,"$&/")+"/"),z(le,X,Q,"",function(Le){return Le})):le!=null&&(D(le)&&(le=R(le,Q+(!le.key||Ne&&Ne.key===le.key?"":(""+le.key).replace(_,"$&/")+"/")+P)),X.push(le)),1;if(Ne=0,re=re===""?".":re+":",I(P))for(var we=0;we<P.length;we++){ke=P[we];var _e=re+L(ke,we);Ne+=z(ke,X,Q,_e,le)}else if(_e=p(P),typeof _e=="function")for(P=_e.call(P),we=0;!(ke=P.next()).done;)ke=ke.value,_e=re+L(ke,we++),Ne+=z(ke,X,Q,_e,le);else if(ke==="object")throw X=String(P),Error("Objects are not valid as a React child (found: "+(X==="[object Object]"?"object with keys {"+Object.keys(P).join(", ")+"}":X)+"). If you meant to render a collection of children, use an array instead.");return Ne}function W(P,X,Q){if(P==null)return P;var re=[],le=0;return z(P,re,"","",function(ke){return X.call(Q,ke,le++)}),re}function G(P){if(P._status===-1){var X=P._result;X=X(),X.then(function(Q){(P._status===0||P._status===-1)&&(P._status=1,P._result=Q)},function(Q){(P._status===0||P._status===-1)&&(P._status=2,P._result=Q)}),P._status===-1&&(P._status=0,P._result=X)}if(P._status===1)return P._result.default;throw P._result}var q={current:null},B={transition:null},j={ReactCurrentDispatcher:q,ReactCurrentBatchConfig:B,ReactCurrentOwner:N};function H(){throw Error("act(...) is not supported in production builds of React.")}return mn.Children={map:W,forEach:function(P,X,Q){W(P,function(){X.apply(this,arguments)},Q)},count:function(P){var X=0;return W(P,function(){X++}),X},toArray:function(P){return W(P,function(X){return X})||[]},only:function(P){if(!D(P))throw Error("React.Children.only expected to receive a single React element child.");return P}},mn.Component=y,mn.Fragment=n,mn.Profiler=s,mn.PureComponent=v,mn.StrictMode=r,mn.Suspense=l,mn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=j,mn.act=H,mn.cloneElement=function(P,X,Q){if(P==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+P+".");var re=m({},P.props),le=P.key,ke=P.ref,Ne=P._owner;if(X!=null){if(X.ref!==void 0&&(ke=X.ref,Ne=N.current),X.key!==void 0&&(le=""+X.key),P.type&&P.type.defaultProps)var we=P.type.defaultProps;for(_e in X)S.call(X,_e)&&!T.hasOwnProperty(_e)&&(re[_e]=X[_e]===void 0&&we!==void 0?we[_e]:X[_e])}var _e=arguments.length-2;if(_e===1)re.children=Q;else if(1<_e){we=Array(_e);for(var Le=0;Le<_e;Le++)we[Le]=arguments[Le+2];re.children=we}return{$$typeof:e,type:P.type,key:le,ref:ke,props:re,_owner:Ne}},mn.createContext=function(P){return P={$$typeof:i,_currentValue:P,_currentValue2:P,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},P.Provider={$$typeof:a,_context:P},P.Consumer=P},mn.createElement=A,mn.createFactory=function(P){var X=A.bind(null,P);return X.type=P,X},mn.createRef=function(){return{current:null}},mn.forwardRef=function(P){return{$$typeof:o,render:P}},mn.isValidElement=D,mn.lazy=function(P){return{$$typeof:c,_payload:{_status:-1,_result:P},_init:G}},mn.memo=function(P,X){return{$$typeof:u,type:P,compare:X===void 0?null:X}},mn.startTransition=function(P){var X=B.transition;B.transition={};try{P()}finally{B.transition=X}},mn.unstable_act=H,mn.useCallback=function(P,X){return q.current.useCallback(P,X)},mn.useContext=function(P){return q.current.useContext(P)},mn.useDebugValue=function(){},mn.useDeferredValue=function(P){return q.current.useDeferredValue(P)},mn.useEffect=function(P,X){return q.current.useEffect(P,X)},mn.useId=function(){return q.current.useId()},mn.useImperativeHandle=function(P,X,Q){return q.current.useImperativeHandle(P,X,Q)},mn.useInsertionEffect=function(P,X){return q.current.useInsertionEffect(P,X)},mn.useLayoutEffect=function(P,X){return q.current.useLayoutEffect(P,X)},mn.useMemo=function(P,X){return q.current.useMemo(P,X)},mn.useReducer=function(P,X,Q){return q.current.useReducer(P,X,Q)},mn.useRef=function(P){return q.current.useRef(P)},mn.useState=function(P){return q.current.useState(P)},mn.useSyncExternalStore=function(P,X,Q){return q.current.useSyncExternalStore(P,X,Q)},mn.useTransition=function(){return q.current.useTransition()},mn.version="18.3.1",mn}var oB;function kR(){return oB||(oB=1,J$.exports=Jae()),J$.exports}/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var lB;function Qae(){if(lB)return Cb;lB=1;var e=kR(),t=Symbol.for("react.element"),n=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,s=e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,a={key:!0,ref:!0,__self:!0,__source:!0};function i(o,l,u){var c,d={},p=null,h=null;u!==void 0&&(p=""+u),l.key!==void 0&&(p=""+l.key),l.ref!==void 0&&(h=l.ref);for(c in l)r.call(l,c)&&!a.hasOwnProperty(c)&&(d[c]=l[c]);if(o&&o.defaultProps)for(c in l=o.defaultProps,l)d[c]===void 0&&(d[c]=l[c]);return{$$typeof:t,type:o,key:p,ref:h,props:d,_owner:s.current}}return Cb.Fragment=n,Cb.jsx=i,Cb.jsxs=i,Cb}var uB;function eie(){return uB||(uB=1,Z$.exports=Qae()),Z$.exports}var J=eie(),ee=kR();const Lt=ty(ee);var Ek={},Q$={exports:{}},ui={},eE={exports:{}},tE={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var cB;function tie(){return cB||(cB=1,function(e){function t(B,j){var H=B.length;B.push(j);e:for(;0<H;){var P=H-1>>>1,X=B[P];if(0<s(X,j))B[P]=j,B[H]=X,H=P;else break e}}function n(B){return B.length===0?null:B[0]}function r(B){if(B.length===0)return null;var j=B[0],H=B.pop();if(H!==j){B[0]=H;e:for(var P=0,X=B.length,Q=X>>>1;P<Q;){var re=2*(P+1)-1,le=B[re],ke=re+1,Ne=B[ke];if(0>s(le,H))ke<X&&0>s(Ne,le)?(B[P]=Ne,B[ke]=H,P=ke):(B[P]=le,B[re]=H,P=re);else if(ke<X&&0>s(Ne,H))B[P]=Ne,B[ke]=H,P=ke;else break e}}return j}function s(B,j){var H=B.sortIndex-j.sortIndex;return H!==0?H:B.id-j.id}if(typeof performance=="object"&&typeof performance.now=="function"){var a=performance;e.unstable_now=function(){return a.now()}}else{var i=Date,o=i.now();e.unstable_now=function(){return i.now()-o}}var l=[],u=[],c=1,d=null,p=3,h=!1,m=!1,g=!1,y=typeof setTimeout=="function"?setTimeout:null,b=typeof clearTimeout=="function"?clearTimeout:null,v=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function k(B){for(var j=n(u);j!==null;){if(j.callback===null)r(u);else if(j.startTime<=B)r(u),j.sortIndex=j.expirationTime,t(l,j);else break;j=n(u)}}function I(B){if(g=!1,k(B),!m)if(n(l)!==null)m=!0,G(S);else{var j=n(u);j!==null&&q(I,j.startTime-B)}}function S(B,j){m=!1,g&&(g=!1,b(A),A=-1),h=!0;var H=p;try{for(k(j),d=n(l);d!==null&&(!(d.expirationTime>j)||B&&!$());){var P=d.callback;if(typeof P=="function"){d.callback=null,p=d.priorityLevel;var X=P(d.expirationTime<=j);j=e.unstable_now(),typeof X=="function"?d.callback=X:d===n(l)&&r(l),k(j)}else r(l);d=n(l)}if(d!==null)var Q=!0;else{var re=n(u);re!==null&&q(I,re.startTime-j),Q=!1}return Q}finally{d=null,p=H,h=!1}}var N=!1,T=null,A=-1,R=5,D=-1;function $(){return!(e.unstable_now()-D<R)}function _(){if(T!==null){var B=e.unstable_now();D=B;var j=!0;try{j=T(!0,B)}finally{j?L():(N=!1,T=null)}}else N=!1}var L;if(typeof v=="function")L=function(){v(_)};else if(typeof MessageChannel<"u"){var z=new MessageChannel,W=z.port2;z.port1.onmessage=_,L=function(){W.postMessage(null)}}else L=function(){y(_,0)};function G(B){T=B,N||(N=!0,L())}function q(B,j){A=y(function(){B(e.unstable_now())},j)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(B){B.callback=null},e.unstable_continueExecution=function(){m||h||(m=!0,G(S))},e.unstable_forceFrameRate=function(B){0>B||125<B?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):R=0<B?Math.floor(1e3/B):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return n(l)},e.unstable_next=function(B){switch(p){case 1:case 2:case 3:var j=3;break;default:j=p}var H=p;p=j;try{return B()}finally{p=H}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(B,j){switch(B){case 1:case 2:case 3:case 4:case 5:break;default:B=3}var H=p;p=B;try{return j()}finally{p=H}},e.unstable_scheduleCallback=function(B,j,H){var P=e.unstable_now();switch(typeof H=="object"&&H!==null?(H=H.delay,H=typeof H=="number"&&0<H?P+H:P):H=P,B){case 1:var X=-1;break;case 2:X=250;break;case 5:X=1073741823;break;case 4:X=1e4;break;default:X=5e3}return X=H+X,B={id:c++,callback:j,priorityLevel:B,startTime:H,expirationTime:X,sortIndex:-1},H>P?(B.sortIndex=H,t(u,B),n(l)===null&&B===n(u)&&(g?(b(A),A=-1):g=!0,q(I,H-P))):(B.sortIndex=X,t(l,B),m||h||(m=!0,G(S))),B},e.unstable_shouldYield=$,e.unstable_wrapCallback=function(B){var j=p;return function(){var H=p;p=j;try{return B.apply(this,arguments)}finally{p=H}}}}(tE)),tE}var dB;function nie(){return dB||(dB=1,eE.exports=tie()),eE.exports}/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var pB;function rie(){if(pB)return ui;pB=1;var e=kR(),t=nie();function n(f){for(var x="https://reactjs.org/docs/error-decoder.html?invariant="+f,w=1;w<arguments.length;w++)x+="&args[]="+encodeURIComponent(arguments[w]);return"Minified React error #"+f+"; visit "+x+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var r=new Set,s={};function a(f,x){i(f,x),i(f+"Capture",x)}function i(f,x){for(s[f]=x,f=0;f<x.length;f++)r.add(x[f])}var o=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),l=Object.prototype.hasOwnProperty,u=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,c={},d={};function p(f){return l.call(d,f)?!0:l.call(c,f)?!1:u.test(f)?d[f]=!0:(c[f]=!0,!1)}function h(f,x,w,C){if(w!==null&&w.type===0)return!1;switch(typeof x){case"function":case"symbol":return!0;case"boolean":return C?!1:w!==null?!w.acceptsBooleans:(f=f.toLowerCase().slice(0,5),f!=="data-"&&f!=="aria-");default:return!1}}function m(f,x,w,C){if(x===null||typeof x>"u"||h(f,x,w,C))return!0;if(C)return!1;if(w!==null)switch(w.type){case 3:return!x;case 4:return x===!1;case 5:return isNaN(x);case 6:return isNaN(x)||1>x}return!1}function g(f,x,w,C,E,F,U){this.acceptsBooleans=x===2||x===3||x===4,this.attributeName=C,this.attributeNamespace=E,this.mustUseProperty=w,this.propertyName=f,this.type=x,this.sanitizeURL=F,this.removeEmptyString=U}var y={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(f){y[f]=new g(f,0,!1,f,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(f){var x=f[0];y[x]=new g(x,1,!1,f[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(f){y[f]=new g(f,2,!1,f.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(f){y[f]=new g(f,2,!1,f,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(f){y[f]=new g(f,3,!1,f.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(f){y[f]=new g(f,3,!0,f,null,!1,!1)}),["capture","download"].forEach(function(f){y[f]=new g(f,4,!1,f,null,!1,!1)}),["cols","rows","size","span"].forEach(function(f){y[f]=new g(f,6,!1,f,null,!1,!1)}),["rowSpan","start"].forEach(function(f){y[f]=new g(f,5,!1,f.toLowerCase(),null,!1,!1)});var b=/[\-:]([a-z])/g;function v(f){return f[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(f){var x=f.replace(b,v);y[x]=new g(x,1,!1,f,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(f){var x=f.replace(b,v);y[x]=new g(x,1,!1,f,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(f){var x=f.replace(b,v);y[x]=new g(x,1,!1,f,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(f){y[f]=new g(f,1,!1,f.toLowerCase(),null,!1,!1)}),y.xlinkHref=new g("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(f){y[f]=new g(f,1,!1,f.toLowerCase(),null,!0,!0)});function k(f,x,w,C){var E=y.hasOwnProperty(x)?y[x]:null;(E!==null?E.type!==0:C||!(2<x.length)||x[0]!=="o"&&x[0]!=="O"||x[1]!=="n"&&x[1]!=="N")&&(m(x,w,E,C)&&(w=null),C||E===null?p(x)&&(w===null?f.removeAttribute(x):f.setAttribute(x,""+w)):E.mustUseProperty?f[E.propertyName]=w===null?E.type===3?!1:"":w:(x=E.attributeName,C=E.attributeNamespace,w===null?f.removeAttribute(x):(E=E.type,w=E===3||E===4&&w===!0?"":""+w,C?f.setAttributeNS(C,x,w):f.setAttribute(x,w))))}var I=e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,S=Symbol.for("react.element"),N=Symbol.for("react.portal"),T=Symbol.for("react.fragment"),A=Symbol.for("react.strict_mode"),R=Symbol.for("react.profiler"),D=Symbol.for("react.provider"),$=Symbol.for("react.context"),_=Symbol.for("react.forward_ref"),L=Symbol.for("react.suspense"),z=Symbol.for("react.suspense_list"),W=Symbol.for("react.memo"),G=Symbol.for("react.lazy"),q=Symbol.for("react.offscreen"),B=Symbol.iterator;function j(f){return f===null||typeof f!="object"?null:(f=B&&f[B]||f["@@iterator"],typeof f=="function"?f:null)}var H=Object.assign,P;function X(f){if(P===void 0)try{throw Error()}catch(w){var x=w.stack.trim().match(/\n( *(at )?)/);P=x&&x[1]||""}return`
`+P+f}var Q=!1;function re(f,x){if(!f||Q)return"";Q=!0;var w=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(x)if(x=function(){throw Error()},Object.defineProperty(x.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(x,[])}catch(Ee){var C=Ee}Reflect.construct(f,[],x)}else{try{x.call()}catch(Ee){C=Ee}f.call(x.prototype)}else{try{throw Error()}catch(Ee){C=Ee}f()}}catch(Ee){if(Ee&&C&&typeof Ee.stack=="string"){for(var E=Ee.stack.split(`
`),F=C.stack.split(`
`),U=E.length-1,ne=F.length-1;1<=U&&0<=ne&&E[U]!==F[ne];)ne--;for(;1<=U&&0<=ne;U--,ne--)if(E[U]!==F[ne]){if(U!==1||ne!==1)do if(U--,ne--,0>ne||E[U]!==F[ne]){var de=`
`+E[U].replace(" at new "," at ");return f.displayName&&de.includes("<anonymous>")&&(de=de.replace("<anonymous>",f.displayName)),de}while(1<=U&&0<=ne);break}}}finally{Q=!1,Error.prepareStackTrace=w}return(f=f?f.displayName||f.name:"")?X(f):""}function le(f){switch(f.tag){case 5:return X(f.type);case 16:return X("Lazy");case 13:return X("Suspense");case 19:return X("SuspenseList");case 0:case 2:case 15:return f=re(f.type,!1),f;case 11:return f=re(f.type.render,!1),f;case 1:return f=re(f.type,!0),f;default:return""}}function ke(f){if(f==null)return null;if(typeof f=="function")return f.displayName||f.name||null;if(typeof f=="string")return f;switch(f){case T:return"Fragment";case N:return"Portal";case R:return"Profiler";case A:return"StrictMode";case L:return"Suspense";case z:return"SuspenseList"}if(typeof f=="object")switch(f.$$typeof){case $:return(f.displayName||"Context")+".Consumer";case D:return(f._context.displayName||"Context")+".Provider";case _:var x=f.render;return f=f.displayName,f||(f=x.displayName||x.name||"",f=f!==""?"ForwardRef("+f+")":"ForwardRef"),f;case W:return x=f.displayName||null,x!==null?x:ke(f.type)||"Memo";case G:x=f._payload,f=f._init;try{return ke(f(x))}catch{}}return null}function Ne(f){var x=f.type;switch(f.tag){case 24:return"Cache";case 9:return(x.displayName||"Context")+".Consumer";case 10:return(x._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return f=x.render,f=f.displayName||f.name||"",x.displayName||(f!==""?"ForwardRef("+f+")":"ForwardRef");case 7:return"Fragment";case 5:return x;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return ke(x);case 8:return x===A?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof x=="function")return x.displayName||x.name||null;if(typeof x=="string")return x}return null}function we(f){switch(typeof f){case"boolean":case"number":case"string":case"undefined":return f;case"object":return f;default:return""}}function _e(f){var x=f.type;return(f=f.nodeName)&&f.toLowerCase()==="input"&&(x==="checkbox"||x==="radio")}function Le(f){var x=_e(f)?"checked":"value",w=Object.getOwnPropertyDescriptor(f.constructor.prototype,x),C=""+f[x];if(!f.hasOwnProperty(x)&&typeof w<"u"&&typeof w.get=="function"&&typeof w.set=="function"){var E=w.get,F=w.set;return Object.defineProperty(f,x,{configurable:!0,get:function(){return E.call(this)},set:function(U){C=""+U,F.call(this,U)}}),Object.defineProperty(f,x,{enumerable:w.enumerable}),{getValue:function(){return C},setValue:function(U){C=""+U},stopTracking:function(){f._valueTracker=null,delete f[x]}}}}function Be(f){f._valueTracker||(f._valueTracker=Le(f))}function Ze(f){if(!f)return!1;var x=f._valueTracker;if(!x)return!0;var w=x.getValue(),C="";return f&&(C=_e(f)?f.checked?"true":"false":f.value),f=C,f!==w?(x.setValue(f),!0):!1}function ut(f){if(f=f||(typeof document<"u"?document:void 0),typeof f>"u")return null;try{return f.activeElement||f.body}catch{return f.body}}function ft(f,x){var w=x.checked;return H({},x,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:w??f._wrapperState.initialChecked})}function et(f,x){var w=x.defaultValue==null?"":x.defaultValue,C=x.checked!=null?x.checked:x.defaultChecked;w=we(x.value!=null?x.value:w),f._wrapperState={initialChecked:C,initialValue:w,controlled:x.type==="checkbox"||x.type==="radio"?x.checked!=null:x.value!=null}}function Qe(f,x){x=x.checked,x!=null&&k(f,"checked",x,!1)}function ot(f,x){Qe(f,x);var w=we(x.value),C=x.type;if(w!=null)C==="number"?(w===0&&f.value===""||f.value!=w)&&(f.value=""+w):f.value!==""+w&&(f.value=""+w);else if(C==="submit"||C==="reset"){f.removeAttribute("value");return}x.hasOwnProperty("value")?At(f,x.type,w):x.hasOwnProperty("defaultValue")&&At(f,x.type,we(x.defaultValue)),x.checked==null&&x.defaultChecked!=null&&(f.defaultChecked=!!x.defaultChecked)}function gt(f,x,w){if(x.hasOwnProperty("value")||x.hasOwnProperty("defaultValue")){var C=x.type;if(!(C!=="submit"&&C!=="reset"||x.value!==void 0&&x.value!==null))return;x=""+f._wrapperState.initialValue,w||x===f.value||(f.value=x),f.defaultValue=x}w=f.name,w!==""&&(f.name=""),f.defaultChecked=!!f._wrapperState.initialChecked,w!==""&&(f.name=w)}function At(f,x,w){(x!=="number"||ut(f.ownerDocument)!==f)&&(w==null?f.defaultValue=""+f._wrapperState.initialValue:f.defaultValue!==""+w&&(f.defaultValue=""+w))}var Et=Array.isArray;function dn(f,x,w,C){if(f=f.options,x){x={};for(var E=0;E<w.length;E++)x["$"+w[E]]=!0;for(w=0;w<f.length;w++)E=x.hasOwnProperty("$"+f[w].value),f[w].selected!==E&&(f[w].selected=E),E&&C&&(f[w].defaultSelected=!0)}else{for(w=""+we(w),x=null,E=0;E<f.length;E++){if(f[E].value===w){f[E].selected=!0,C&&(f[E].defaultSelected=!0);return}x!==null||f[E].disabled||(x=f[E])}x!==null&&(x.selected=!0)}}function Xt(f,x){if(x.dangerouslySetInnerHTML!=null)throw Error(n(91));return H({},x,{value:void 0,defaultValue:void 0,children:""+f._wrapperState.initialValue})}function In(f,x){var w=x.value;if(w==null){if(w=x.children,x=x.defaultValue,w!=null){if(x!=null)throw Error(n(92));if(Et(w)){if(1<w.length)throw Error(n(93));w=w[0]}x=w}x==null&&(x=""),w=x}f._wrapperState={initialValue:we(w)}}function Ve(f,x){var w=we(x.value),C=we(x.defaultValue);w!=null&&(w=""+w,w!==f.value&&(f.value=w),x.defaultValue==null&&f.defaultValue!==w&&(f.defaultValue=w)),C!=null&&(f.defaultValue=""+C)}function tt(f){var x=f.textContent;x===f._wrapperState.initialValue&&x!==""&&x!==null&&(f.value=x)}function Rt(f){switch(f){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Dt(f,x){return f==null||f==="http://www.w3.org/1999/xhtml"?Rt(x):f==="http://www.w3.org/2000/svg"&&x==="foreignObject"?"http://www.w3.org/1999/xhtml":f}var Ut,Pn=function(f){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(x,w,C,E){MSApp.execUnsafeLocalFunction(function(){return f(x,w,C,E)})}:f}(function(f,x){if(f.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in f)f.innerHTML=x;else{for(Ut=Ut||document.createElement("div"),Ut.innerHTML="<svg>"+x.valueOf().toString()+"</svg>",x=Ut.firstChild;f.firstChild;)f.removeChild(f.firstChild);for(;x.firstChild;)f.appendChild(x.firstChild)}});function dr(f,x){if(x){var w=f.firstChild;if(w&&w===f.lastChild&&w.nodeType===3){w.nodeValue=x;return}}f.textContent=x}var zn={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Gr=["Webkit","ms","Moz","O"];Object.keys(zn).forEach(function(f){Gr.forEach(function(x){x=x+f.charAt(0).toUpperCase()+f.substring(1),zn[x]=zn[f]})});function Sn(f,x,w){return x==null||typeof x=="boolean"||x===""?"":w||typeof x!="number"||x===0||zn.hasOwnProperty(f)&&zn[f]?(""+x).trim():x+"px"}function pn(f,x){f=f.style;for(var w in x)if(x.hasOwnProperty(w)){var C=w.indexOf("--")===0,E=Sn(w,x[w],C);w==="float"&&(w="cssFloat"),C?f.setProperty(w,E):f[w]=E}}var Fn=H({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Ls(f,x){if(x){if(Fn[f]&&(x.children!=null||x.dangerouslySetInnerHTML!=null))throw Error(n(137,f));if(x.dangerouslySetInnerHTML!=null){if(x.children!=null)throw Error(n(60));if(typeof x.dangerouslySetInnerHTML!="object"||!("__html"in x.dangerouslySetInnerHTML))throw Error(n(61))}if(x.style!=null&&typeof x.style!="object")throw Error(n(62))}}function vs(f,x){if(f.indexOf("-")===-1)return typeof x.is=="string";switch(f){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Ps=null;function Qs(f){return f=f.target||f.srcElement||window,f.correspondingUseElement&&(f=f.correspondingUseElement),f.nodeType===3?f.parentNode:f}var ns=null,rs=null,ea=null;function Pa(f){if(f=cb(f)){if(typeof ns!="function")throw Error(n(280));var x=f.stateNode;x&&(x=Gw(x),ns(f.stateNode,f.type,x))}}function qn(f){rs?ea?ea.push(f):ea=[f]:rs=f}function ss(){if(rs){var f=rs,x=ea;if(ea=rs=null,Pa(f),x)for(f=0;f<x.length;f++)Pa(x[f])}}function ye(f,x){return f(x)}function Me(){}var dt=!1;function Je(f,x,w){if(dt)return f(x,w);dt=!0;try{return ye(f,x,w)}finally{dt=!1,(rs!==null||ea!==null)&&(Me(),ss())}}function We(f,x){var w=f.stateNode;if(w===null)return null;var C=Gw(w);if(C===null)return null;w=C[x];e:switch(x){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(C=!C.disabled)||(f=f.type,C=!(f==="button"||f==="input"||f==="select"||f==="textarea")),f=!C;break e;default:f=!1}if(f)return null;if(w&&typeof w!="function")throw Error(n(231,x,typeof w));return w}var it=!1;if(o)try{var Xe={};Object.defineProperty(Xe,"passive",{get:function(){it=!0}}),window.addEventListener("test",Xe,Xe),window.removeEventListener("test",Xe,Xe)}catch{it=!1}function bt(f,x,w,C,E,F,U,ne,de){var Ee=Array.prototype.slice.call(arguments,3);try{x.apply(w,Ee)}catch(Ge){this.onError(Ge)}}var Yt=!1,Kn=null,fr=!1,kr=null,as={onError:function(f){Yt=!0,Kn=f}};function On(f,x,w,C,E,F,U,ne,de){Yt=!1,Kn=null,bt.apply(as,arguments)}function mr(f,x,w,C,E,F,U,ne,de){if(On.apply(this,arguments),Yt){if(Yt){var Ee=Kn;Yt=!1,Kn=null}else throw Error(n(198));fr||(fr=!0,kr=Ee)}}function zs(f){var x=f,w=f;if(f.alternate)for(;x.return;)x=x.return;else{f=x;do x=f,(x.flags&4098)!==0&&(w=x.return),f=x.return;while(f)}return x.tag===3?w:null}function hu(f){if(f.tag===13){var x=f.memoizedState;if(x===null&&(f=f.alternate,f!==null&&(x=f.memoizedState)),x!==null)return x.dehydrated}return null}function qd(f){if(zs(f)!==f)throw Error(n(188))}function rc(f){var x=f.alternate;if(!x){if(x=zs(f),x===null)throw Error(n(188));return x!==f?null:f}for(var w=f,C=x;;){var E=w.return;if(E===null)break;var F=E.alternate;if(F===null){if(C=E.return,C!==null){w=C;continue}break}if(E.child===F.child){for(F=E.child;F;){if(F===w)return qd(E),f;if(F===C)return qd(E),x;F=F.sibling}throw Error(n(188))}if(w.return!==C.return)w=E,C=F;else{for(var U=!1,ne=E.child;ne;){if(ne===w){U=!0,w=E,C=F;break}if(ne===C){U=!0,C=E,w=F;break}ne=ne.sibling}if(!U){for(ne=F.child;ne;){if(ne===w){U=!0,w=F,C=E;break}if(ne===C){U=!0,C=F,w=E;break}ne=ne.sibling}if(!U)throw Error(n(189))}}if(w.alternate!==C)throw Error(n(190))}if(w.tag!==3)throw Error(n(188));return w.stateNode.current===w?f:x}function Kd(f){return f=rc(f),f!==null?Xd(f):null}function Xd(f){if(f.tag===5||f.tag===6)return f;for(f=f.child;f!==null;){var x=Xd(f);if(x!==null)return x;f=f.sibling}return null}var Yd=t.unstable_scheduleCallback,fn=t.unstable_cancelCallback,_i=t.unstable_shouldYield,Zd=t.unstable_requestPaint,Bn=t.unstable_now,Yx=t.unstable_getCurrentPriorityLevel,_o=t.unstable_ImmediatePriority,Nw=t.unstable_UserBlockingPriority,wm=t.unstable_NormalPriority,xT=t.unstable_LowPriority,fu=t.unstable_IdlePriority,sc=null,eo=null;function bT(f){if(eo&&typeof eo.onCommitFiberRoot=="function")try{eo.onCommitFiberRoot(sc,f,void 0,(f.current.flags&128)===128)}catch{}}var Ai=Math.clz32?Math.clz32:$w,vT=Math.log,Tw=Math.LN2;function $w(f){return f>>>=0,f===0?32:31-(vT(f)/Tw|0)|0}var km=64,Im=4194304;function ac(f){switch(f&-f){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return f&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return f&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return f}}function Jd(f,x){var w=f.pendingLanes;if(w===0)return 0;var C=0,E=f.suspendedLanes,F=f.pingedLanes,U=w&268435455;if(U!==0){var ne=U&~E;ne!==0?C=ac(ne):(F&=U,F!==0&&(C=ac(F)))}else U=w&~E,U!==0?C=ac(U):F!==0&&(C=ac(F));if(C===0)return 0;if(x!==0&&x!==C&&(x&E)===0&&(E=C&-C,F=x&-x,E>=F||E===16&&(F&4194240)!==0))return x;if((C&4)!==0&&(C|=w&16),x=f.entangledLanes,x!==0)for(f=f.entanglements,x&=C;0<x;)w=31-Ai(x),E=1<<w,C|=f[w],x&=~E;return C}function wT(f,x){switch(f){case 1:case 2:case 4:return x+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return x+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function kT(f,x){for(var w=f.suspendedLanes,C=f.pingedLanes,E=f.expirationTimes,F=f.pendingLanes;0<F;){var U=31-Ai(F),ne=1<<U,de=E[U];de===-1?((ne&w)===0||(ne&C)!==0)&&(E[U]=wT(ne,x)):de<=x&&(f.expiredLanes|=ne),F&=~ne}}function Zx(f){return f=f.pendingLanes&-1073741825,f!==0?f:f&1073741824?1073741824:0}function Ew(){var f=km;return km<<=1,(km&4194240)===0&&(km=64),f}function Sm(f){for(var x=[],w=0;31>w;w++)x.push(f);return x}function yl(f,x,w){f.pendingLanes|=x,x!==536870912&&(f.suspendedLanes=0,f.pingedLanes=0),f=f.eventTimes,x=31-Ai(x),f[x]=w}function _w(f,x){var w=f.pendingLanes&~x;f.pendingLanes=x,f.suspendedLanes=0,f.pingedLanes=0,f.expiredLanes&=x,f.mutableReadLanes&=x,f.entangledLanes&=x,x=f.entanglements;var C=f.eventTimes;for(f=f.expirationTimes;0<w;){var E=31-Ai(w),F=1<<E;x[E]=0,C[E]=-1,f[E]=-1,w&=~F}}function Cm(f,x){var w=f.entangledLanes|=x;for(f=f.entanglements;w;){var C=31-Ai(w),E=1<<C;E&x|f[C]&x&&(f[C]|=x),w&=~E}}var En=0;function Nm(f){return f&=-f,1<f?4<f?(f&268435455)!==0?16:536870912:4:1}var Jx,Tm,$m,Qd,ep,ic=!1,tp=[],Ri=null,Di=null,xl=null,te=new Map,Ie=new Map,je=[],Mt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function jt(f,x){switch(f){case"focusin":case"focusout":Ri=null;break;case"dragenter":case"dragleave":Di=null;break;case"mouseover":case"mouseout":xl=null;break;case"pointerover":case"pointerout":te.delete(x.pointerId);break;case"gotpointercapture":case"lostpointercapture":Ie.delete(x.pointerId)}}function Gt(f,x,w,C,E,F){return f===null||f.nativeEvent!==F?(f={blockedOn:x,domEventName:w,eventSystemFlags:C,nativeEvent:F,targetContainers:[E]},x!==null&&(x=cb(x),x!==null&&Tm(x)),f):(f.eventSystemFlags|=C,x=f.targetContainers,E!==null&&x.indexOf(E)===-1&&x.push(E),f)}function pt(f,x,w,C,E){switch(x){case"focusin":return Ri=Gt(Ri,f,x,w,C,E),!0;case"dragenter":return Di=Gt(Di,f,x,w,C,E),!0;case"mouseover":return xl=Gt(xl,f,x,w,C,E),!0;case"pointerover":var F=E.pointerId;return te.set(F,Gt(te.get(F)||null,f,x,w,C,E)),!0;case"gotpointercapture":return F=E.pointerId,Ie.set(F,Gt(Ie.get(F)||null,f,x,w,C,E)),!0}return!1}function Nt(f){var x=np(f.target);if(x!==null){var w=zs(x);if(w!==null){if(x=w.tag,x===13){if(x=hu(w),x!==null){f.blockedOn=x,ep(f.priority,function(){$m(w)});return}}else if(x===3&&w.stateNode.current.memoizedState.isDehydrated){f.blockedOn=w.tag===3?w.stateNode.containerInfo:null;return}}}f.blockedOn=null}function Xn(f){if(f.blockedOn!==null)return!1;for(var x=f.targetContainers;0<x.length;){var w=ST(f.domEventName,f.eventSystemFlags,x[0],f.nativeEvent);if(w===null){w=f.nativeEvent;var C=new w.constructor(w.type,w);Ps=C,w.target.dispatchEvent(C),Ps=null}else return x=cb(w),x!==null&&Tm(x),f.blockedOn=w,!1;x.shift()}return!0}function fa(f,x,w){Xn(f)&&w.delete(x)}function Ao(){ic=!1,Ri!==null&&Xn(Ri)&&(Ri=null),Di!==null&&Xn(Di)&&(Di=null),xl!==null&&Xn(xl)&&(xl=null),te.forEach(fa),Ie.forEach(fa)}function oc(f,x){f.blockedOn===x&&(f.blockedOn=null,ic||(ic=!0,t.unstable_scheduleCallback(t.unstable_NormalPriority,Ao)))}function mu(f){function x(E){return oc(E,f)}if(0<tp.length){oc(tp[0],f);for(var w=1;w<tp.length;w++){var C=tp[w];C.blockedOn===f&&(C.blockedOn=null)}}for(Ri!==null&&oc(Ri,f),Di!==null&&oc(Di,f),xl!==null&&oc(xl,f),te.forEach(x),Ie.forEach(x),w=0;w<je.length;w++)C=je[w],C.blockedOn===f&&(C.blockedOn=null);for(;0<je.length&&(w=je[0],w.blockedOn===null);)Nt(w),w.blockedOn===null&&je.shift()}var lc=I.ReactCurrentBatchConfig,Bs=!0;function uc(f,x,w,C){var E=En,F=lc.transition;lc.transition=null;try{En=1,IT(f,x,w,C)}finally{En=E,lc.transition=F}}function Aw(f,x,w,C){var E=En,F=lc.transition;lc.transition=null;try{En=4,IT(f,x,w,C)}finally{En=E,lc.transition=F}}function IT(f,x,w,C){if(Bs){var E=ST(f,x,w,C);if(E===null)WT(f,x,C,Rw,w),jt(f,C);else if(pt(E,f,x,w,C))C.stopPropagation();else if(jt(f,C),x&4&&-1<Mt.indexOf(f)){for(;E!==null;){var F=cb(E);if(F!==null&&Jx(F),F=ST(f,x,w,C),F===null&&WT(f,x,C,Rw,w),F===E)break;E=F}E!==null&&C.stopPropagation()}else WT(f,x,C,null,w)}}var Rw=null;function ST(f,x,w,C){if(Rw=null,f=Qs(C),f=np(f),f!==null)if(x=zs(f),x===null)f=null;else if(w=x.tag,w===13){if(f=hu(x),f!==null)return f;f=null}else if(w===3){if(x.stateNode.current.memoizedState.isDehydrated)return x.tag===3?x.stateNode.containerInfo:null;f=null}else x!==f&&(f=null);return Rw=f,null}function HP(f){switch(f){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Yx()){case _o:return 1;case Nw:return 4;case wm:case xT:return 16;case fu:return 536870912;default:return 16}default:return 16}}var cc=null,CT=null,Dw=null;function qP(){if(Dw)return Dw;var f,x=CT,w=x.length,C,E="value"in cc?cc.value:cc.textContent,F=E.length;for(f=0;f<w&&x[f]===E[f];f++);var U=w-f;for(C=1;C<=U&&x[w-C]===E[F-C];C++);return Dw=E.slice(f,1<C?1-C:void 0)}function Fw(f){var x=f.keyCode;return"charCode"in f?(f=f.charCode,f===0&&x===13&&(f=13)):f=x,f===10&&(f=13),32<=f||f===13?f:0}function Ow(){return!0}function KP(){return!1}function Fi(f){function x(w,C,E,F,U){this._reactName=w,this._targetInst=E,this.type=C,this.nativeEvent=F,this.target=U,this.currentTarget=null;for(var ne in f)f.hasOwnProperty(ne)&&(w=f[ne],this[ne]=w?w(F):F[ne]);return this.isDefaultPrevented=(F.defaultPrevented!=null?F.defaultPrevented:F.returnValue===!1)?Ow:KP,this.isPropagationStopped=KP,this}return H(x.prototype,{preventDefault:function(){this.defaultPrevented=!0;var w=this.nativeEvent;w&&(w.preventDefault?w.preventDefault():typeof w.returnValue!="unknown"&&(w.returnValue=!1),this.isDefaultPrevented=Ow)},stopPropagation:function(){var w=this.nativeEvent;w&&(w.stopPropagation?w.stopPropagation():typeof w.cancelBubble!="unknown"&&(w.cancelBubble=!0),this.isPropagationStopped=Ow)},persist:function(){},isPersistent:Ow}),x}var Em={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(f){return f.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},NT=Fi(Em),Qx=H({},Em,{view:0,detail:0}),Ise=Fi(Qx),TT,$T,eb,Mw=H({},Qx,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:_T,button:0,buttons:0,relatedTarget:function(f){return f.relatedTarget===void 0?f.fromElement===f.srcElement?f.toElement:f.fromElement:f.relatedTarget},movementX:function(f){return"movementX"in f?f.movementX:(f!==eb&&(eb&&f.type==="mousemove"?(TT=f.screenX-eb.screenX,$T=f.screenY-eb.screenY):$T=TT=0,eb=f),TT)},movementY:function(f){return"movementY"in f?f.movementY:$T}}),XP=Fi(Mw),Sse=H({},Mw,{dataTransfer:0}),Cse=Fi(Sse),Nse=H({},Qx,{relatedTarget:0}),ET=Fi(Nse),Tse=H({},Em,{animationName:0,elapsedTime:0,pseudoElement:0}),$se=Fi(Tse),Ese=H({},Em,{clipboardData:function(f){return"clipboardData"in f?f.clipboardData:window.clipboardData}}),_se=Fi(Ese),Ase=H({},Em,{data:0}),YP=Fi(Ase),Rse={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Dse={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Fse={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Ose(f){var x=this.nativeEvent;return x.getModifierState?x.getModifierState(f):(f=Fse[f])?!!x[f]:!1}function _T(){return Ose}var Mse=H({},Qx,{key:function(f){if(f.key){var x=Rse[f.key]||f.key;if(x!=="Unidentified")return x}return f.type==="keypress"?(f=Fw(f),f===13?"Enter":String.fromCharCode(f)):f.type==="keydown"||f.type==="keyup"?Dse[f.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:_T,charCode:function(f){return f.type==="keypress"?Fw(f):0},keyCode:function(f){return f.type==="keydown"||f.type==="keyup"?f.keyCode:0},which:function(f){return f.type==="keypress"?Fw(f):f.type==="keydown"||f.type==="keyup"?f.keyCode:0}}),Lse=Fi(Mse),Pse=H({},Mw,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),ZP=Fi(Pse),zse=H({},Qx,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:_T}),Bse=Fi(zse),Wse=H({},Em,{propertyName:0,elapsedTime:0,pseudoElement:0}),Vse=Fi(Wse),Use=H({},Mw,{deltaX:function(f){return"deltaX"in f?f.deltaX:"wheelDeltaX"in f?-f.wheelDeltaX:0},deltaY:function(f){return"deltaY"in f?f.deltaY:"wheelDeltaY"in f?-f.wheelDeltaY:"wheelDelta"in f?-f.wheelDelta:0},deltaZ:0,deltaMode:0}),Gse=Fi(Use),jse=[9,13,27,32],AT=o&&"CompositionEvent"in window,tb=null;o&&"documentMode"in document&&(tb=document.documentMode);var Hse=o&&"TextEvent"in window&&!tb,JP=o&&(!AT||tb&&8<tb&&11>=tb),QP=" ",e4=!1;function t4(f,x){switch(f){case"keyup":return jse.indexOf(x.keyCode)!==-1;case"keydown":return x.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function n4(f){return f=f.detail,typeof f=="object"&&"data"in f?f.data:null}var _m=!1;function qse(f,x){switch(f){case"compositionend":return n4(x);case"keypress":return x.which!==32?null:(e4=!0,QP);case"textInput":return f=x.data,f===QP&&e4?null:f;default:return null}}function Kse(f,x){if(_m)return f==="compositionend"||!AT&&t4(f,x)?(f=qP(),Dw=CT=cc=null,_m=!1,f):null;switch(f){case"paste":return null;case"keypress":if(!(x.ctrlKey||x.altKey||x.metaKey)||x.ctrlKey&&x.altKey){if(x.char&&1<x.char.length)return x.char;if(x.which)return String.fromCharCode(x.which)}return null;case"compositionend":return JP&&x.locale!=="ko"?null:x.data;default:return null}}var Xse={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function r4(f){var x=f&&f.nodeName&&f.nodeName.toLowerCase();return x==="input"?!!Xse[f.type]:x==="textarea"}function s4(f,x,w,C){qn(C),x=Ww(x,"onChange"),0<x.length&&(w=new NT("onChange","change",null,w,C),f.push({event:w,listeners:x}))}var nb=null,rb=null;function Yse(f){k4(f,0)}function Lw(f){var x=Om(f);if(Ze(x))return f}function Zse(f,x){if(f==="change")return x}var a4=!1;if(o){var RT;if(o){var DT="oninput"in document;if(!DT){var i4=document.createElement("div");i4.setAttribute("oninput","return;"),DT=typeof i4.oninput=="function"}RT=DT}else RT=!1;a4=RT&&(!document.documentMode||9<document.documentMode)}function o4(){nb&&(nb.detachEvent("onpropertychange",l4),rb=nb=null)}function l4(f){if(f.propertyName==="value"&&Lw(rb)){var x=[];s4(x,rb,f,Qs(f)),Je(Yse,x)}}function Jse(f,x,w){f==="focusin"?(o4(),nb=x,rb=w,nb.attachEvent("onpropertychange",l4)):f==="focusout"&&o4()}function Qse(f){if(f==="selectionchange"||f==="keyup"||f==="keydown")return Lw(rb)}function eae(f,x){if(f==="click")return Lw(x)}function tae(f,x){if(f==="input"||f==="change")return Lw(x)}function nae(f,x){return f===x&&(f!==0||1/f===1/x)||f!==f&&x!==x}var Ro=typeof Object.is=="function"?Object.is:nae;function sb(f,x){if(Ro(f,x))return!0;if(typeof f!="object"||f===null||typeof x!="object"||x===null)return!1;var w=Object.keys(f),C=Object.keys(x);if(w.length!==C.length)return!1;for(C=0;C<w.length;C++){var E=w[C];if(!l.call(x,E)||!Ro(f[E],x[E]))return!1}return!0}function u4(f){for(;f&&f.firstChild;)f=f.firstChild;return f}function c4(f,x){var w=u4(f);f=0;for(var C;w;){if(w.nodeType===3){if(C=f+w.textContent.length,f<=x&&C>=x)return{node:w,offset:x-f};f=C}e:{for(;w;){if(w.nextSibling){w=w.nextSibling;break e}w=w.parentNode}w=void 0}w=u4(w)}}function d4(f,x){return f&&x?f===x?!0:f&&f.nodeType===3?!1:x&&x.nodeType===3?d4(f,x.parentNode):"contains"in f?f.contains(x):f.compareDocumentPosition?!!(f.compareDocumentPosition(x)&16):!1:!1}function p4(){for(var f=window,x=ut();x instanceof f.HTMLIFrameElement;){try{var w=typeof x.contentWindow.location.href=="string"}catch{w=!1}if(w)f=x.contentWindow;else break;x=ut(f.document)}return x}function FT(f){var x=f&&f.nodeName&&f.nodeName.toLowerCase();return x&&(x==="input"&&(f.type==="text"||f.type==="search"||f.type==="tel"||f.type==="url"||f.type==="password")||x==="textarea"||f.contentEditable==="true")}function rae(f){var x=p4(),w=f.focusedElem,C=f.selectionRange;if(x!==w&&w&&w.ownerDocument&&d4(w.ownerDocument.documentElement,w)){if(C!==null&&FT(w)){if(x=C.start,f=C.end,f===void 0&&(f=x),"selectionStart"in w)w.selectionStart=x,w.selectionEnd=Math.min(f,w.value.length);else if(f=(x=w.ownerDocument||document)&&x.defaultView||window,f.getSelection){f=f.getSelection();var E=w.textContent.length,F=Math.min(C.start,E);C=C.end===void 0?F:Math.min(C.end,E),!f.extend&&F>C&&(E=C,C=F,F=E),E=c4(w,F);var U=c4(w,C);E&&U&&(f.rangeCount!==1||f.anchorNode!==E.node||f.anchorOffset!==E.offset||f.focusNode!==U.node||f.focusOffset!==U.offset)&&(x=x.createRange(),x.setStart(E.node,E.offset),f.removeAllRanges(),F>C?(f.addRange(x),f.extend(U.node,U.offset)):(x.setEnd(U.node,U.offset),f.addRange(x)))}}for(x=[],f=w;f=f.parentNode;)f.nodeType===1&&x.push({element:f,left:f.scrollLeft,top:f.scrollTop});for(typeof w.focus=="function"&&w.focus(),w=0;w<x.length;w++)f=x[w],f.element.scrollLeft=f.left,f.element.scrollTop=f.top}}var sae=o&&"documentMode"in document&&11>=document.documentMode,Am=null,OT=null,ab=null,MT=!1;function h4(f,x,w){var C=w.window===w?w.document:w.nodeType===9?w:w.ownerDocument;MT||Am==null||Am!==ut(C)||(C=Am,"selectionStart"in C&&FT(C)?C={start:C.selectionStart,end:C.selectionEnd}:(C=(C.ownerDocument&&C.ownerDocument.defaultView||window).getSelection(),C={anchorNode:C.anchorNode,anchorOffset:C.anchorOffset,focusNode:C.focusNode,focusOffset:C.focusOffset}),ab&&sb(ab,C)||(ab=C,C=Ww(OT,"onSelect"),0<C.length&&(x=new NT("onSelect","select",null,x,w),f.push({event:x,listeners:C}),x.target=Am)))}function Pw(f,x){var w={};return w[f.toLowerCase()]=x.toLowerCase(),w["Webkit"+f]="webkit"+x,w["Moz"+f]="moz"+x,w}var Rm={animationend:Pw("Animation","AnimationEnd"),animationiteration:Pw("Animation","AnimationIteration"),animationstart:Pw("Animation","AnimationStart"),transitionend:Pw("Transition","TransitionEnd")},LT={},f4={};o&&(f4=document.createElement("div").style,"AnimationEvent"in window||(delete Rm.animationend.animation,delete Rm.animationiteration.animation,delete Rm.animationstart.animation),"TransitionEvent"in window||delete Rm.transitionend.transition);function zw(f){if(LT[f])return LT[f];if(!Rm[f])return f;var x=Rm[f],w;for(w in x)if(x.hasOwnProperty(w)&&w in f4)return LT[f]=x[w];return f}var m4=zw("animationend"),g4=zw("animationiteration"),y4=zw("animationstart"),x4=zw("transitionend"),b4=new Map,v4="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function dc(f,x){b4.set(f,x),a(x,[f])}for(var PT=0;PT<v4.length;PT++){var zT=v4[PT],aae=zT.toLowerCase(),iae=zT[0].toUpperCase()+zT.slice(1);dc(aae,"on"+iae)}dc(m4,"onAnimationEnd"),dc(g4,"onAnimationIteration"),dc(y4,"onAnimationStart"),dc("dblclick","onDoubleClick"),dc("focusin","onFocus"),dc("focusout","onBlur"),dc(x4,"onTransitionEnd"),i("onMouseEnter",["mouseout","mouseover"]),i("onMouseLeave",["mouseout","mouseover"]),i("onPointerEnter",["pointerout","pointerover"]),i("onPointerLeave",["pointerout","pointerover"]),a("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),a("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),a("onBeforeInput",["compositionend","keypress","textInput","paste"]),a("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),a("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),a("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var ib="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),oae=new Set("cancel close invalid load scroll toggle".split(" ").concat(ib));function w4(f,x,w){var C=f.type||"unknown-event";f.currentTarget=w,mr(C,x,void 0,f),f.currentTarget=null}function k4(f,x){x=(x&4)!==0;for(var w=0;w<f.length;w++){var C=f[w],E=C.event;C=C.listeners;e:{var F=void 0;if(x)for(var U=C.length-1;0<=U;U--){var ne=C[U],de=ne.instance,Ee=ne.currentTarget;if(ne=ne.listener,de!==F&&E.isPropagationStopped())break e;w4(E,ne,Ee),F=de}else for(U=0;U<C.length;U++){if(ne=C[U],de=ne.instance,Ee=ne.currentTarget,ne=ne.listener,de!==F&&E.isPropagationStopped())break e;w4(E,ne,Ee),F=de}}}if(fr)throw f=kr,fr=!1,kr=null,f}function gr(f,x){var w=x[qT];w===void 0&&(w=x[qT]=new Set);var C=f+"__bubble";w.has(C)||(I4(x,f,2,!1),w.add(C))}function BT(f,x,w){var C=0;x&&(C|=4),I4(w,f,C,x)}var Bw="_reactListening"+Math.random().toString(36).slice(2);function ob(f){if(!f[Bw]){f[Bw]=!0,r.forEach(function(w){w!=="selectionchange"&&(oae.has(w)||BT(w,!1,f),BT(w,!0,f))});var x=f.nodeType===9?f:f.ownerDocument;x===null||x[Bw]||(x[Bw]=!0,BT("selectionchange",!1,x))}}function I4(f,x,w,C){switch(HP(x)){case 1:var E=uc;break;case 4:E=Aw;break;default:E=IT}w=E.bind(null,x,w,f),E=void 0,!it||x!=="touchstart"&&x!=="touchmove"&&x!=="wheel"||(E=!0),C?E!==void 0?f.addEventListener(x,w,{capture:!0,passive:E}):f.addEventListener(x,w,!0):E!==void 0?f.addEventListener(x,w,{passive:E}):f.addEventListener(x,w,!1)}function WT(f,x,w,C,E){var F=C;if((x&1)===0&&(x&2)===0&&C!==null)e:for(;;){if(C===null)return;var U=C.tag;if(U===3||U===4){var ne=C.stateNode.containerInfo;if(ne===E||ne.nodeType===8&&ne.parentNode===E)break;if(U===4)for(U=C.return;U!==null;){var de=U.tag;if((de===3||de===4)&&(de=U.stateNode.containerInfo,de===E||de.nodeType===8&&de.parentNode===E))return;U=U.return}for(;ne!==null;){if(U=np(ne),U===null)return;if(de=U.tag,de===5||de===6){C=F=U;continue e}ne=ne.parentNode}}C=C.return}Je(function(){var Ee=F,Ge=Qs(w),qe=[];e:{var Ue=b4.get(f);if(Ue!==void 0){var mt=NT,kt=f;switch(f){case"keypress":if(Fw(w)===0)break e;case"keydown":case"keyup":mt=Lse;break;case"focusin":kt="focus",mt=ET;break;case"focusout":kt="blur",mt=ET;break;case"beforeblur":case"afterblur":mt=ET;break;case"click":if(w.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":mt=XP;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":mt=Cse;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":mt=Bse;break;case m4:case g4:case y4:mt=$se;break;case x4:mt=Vse;break;case"scroll":mt=Ise;break;case"wheel":mt=Gse;break;case"copy":case"cut":case"paste":mt=_se;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":mt=ZP}var Ct=(x&4)!==0,jr=!Ct&&f==="scroll",Ce=Ct?Ue!==null?Ue+"Capture":null:Ue;Ct=[];for(var ge=Ee,Te;ge!==null;){Te=ge;var Ye=Te.stateNode;if(Te.tag===5&&Ye!==null&&(Te=Ye,Ce!==null&&(Ye=We(ge,Ce),Ye!=null&&Ct.push(lb(ge,Ye,Te)))),jr)break;ge=ge.return}0<Ct.length&&(Ue=new mt(Ue,kt,null,w,Ge),qe.push({event:Ue,listeners:Ct}))}}if((x&7)===0){e:{if(Ue=f==="mouseover"||f==="pointerover",mt=f==="mouseout"||f==="pointerout",Ue&&w!==Ps&&(kt=w.relatedTarget||w.fromElement)&&(np(kt)||kt[gu]))break e;if((mt||Ue)&&(Ue=Ge.window===Ge?Ge:(Ue=Ge.ownerDocument)?Ue.defaultView||Ue.parentWindow:window,mt?(kt=w.relatedTarget||w.toElement,mt=Ee,kt=kt?np(kt):null,kt!==null&&(jr=zs(kt),kt!==jr||kt.tag!==5&&kt.tag!==6)&&(kt=null)):(mt=null,kt=Ee),mt!==kt)){if(Ct=XP,Ye="onMouseLeave",Ce="onMouseEnter",ge="mouse",(f==="pointerout"||f==="pointerover")&&(Ct=ZP,Ye="onPointerLeave",Ce="onPointerEnter",ge="pointer"),jr=mt==null?Ue:Om(mt),Te=kt==null?Ue:Om(kt),Ue=new Ct(Ye,ge+"leave",mt,w,Ge),Ue.target=jr,Ue.relatedTarget=Te,Ye=null,np(Ge)===Ee&&(Ct=new Ct(Ce,ge+"enter",kt,w,Ge),Ct.target=Te,Ct.relatedTarget=jr,Ye=Ct),jr=Ye,mt&&kt)t:{for(Ct=mt,Ce=kt,ge=0,Te=Ct;Te;Te=Dm(Te))ge++;for(Te=0,Ye=Ce;Ye;Ye=Dm(Ye))Te++;for(;0<ge-Te;)Ct=Dm(Ct),ge--;for(;0<Te-ge;)Ce=Dm(Ce),Te--;for(;ge--;){if(Ct===Ce||Ce!==null&&Ct===Ce.alternate)break t;Ct=Dm(Ct),Ce=Dm(Ce)}Ct=null}else Ct=null;mt!==null&&S4(qe,Ue,mt,Ct,!1),kt!==null&&jr!==null&&S4(qe,jr,kt,Ct,!0)}}e:{if(Ue=Ee?Om(Ee):window,mt=Ue.nodeName&&Ue.nodeName.toLowerCase(),mt==="select"||mt==="input"&&Ue.type==="file")var $t=Zse;else if(r4(Ue))if(a4)$t=tae;else{$t=Qse;var Pt=Jse}else(mt=Ue.nodeName)&&mt.toLowerCase()==="input"&&(Ue.type==="checkbox"||Ue.type==="radio")&&($t=eae);if($t&&($t=$t(f,Ee))){s4(qe,$t,w,Ge);break e}Pt&&Pt(f,Ue,Ee),f==="focusout"&&(Pt=Ue._wrapperState)&&Pt.controlled&&Ue.type==="number"&&At(Ue,"number",Ue.value)}switch(Pt=Ee?Om(Ee):window,f){case"focusin":(r4(Pt)||Pt.contentEditable==="true")&&(Am=Pt,OT=Ee,ab=null);break;case"focusout":ab=OT=Am=null;break;case"mousedown":MT=!0;break;case"contextmenu":case"mouseup":case"dragend":MT=!1,h4(qe,w,Ge);break;case"selectionchange":if(sae)break;case"keydown":case"keyup":h4(qe,w,Ge)}var zt;if(AT)e:{switch(f){case"compositionstart":var Ht="onCompositionStart";break e;case"compositionend":Ht="onCompositionEnd";break e;case"compositionupdate":Ht="onCompositionUpdate";break e}Ht=void 0}else _m?t4(f,w)&&(Ht="onCompositionEnd"):f==="keydown"&&w.keyCode===229&&(Ht="onCompositionStart");Ht&&(JP&&w.locale!=="ko"&&(_m||Ht!=="onCompositionStart"?Ht==="onCompositionEnd"&&_m&&(zt=qP()):(cc=Ge,CT="value"in cc?cc.value:cc.textContent,_m=!0)),Pt=Ww(Ee,Ht),0<Pt.length&&(Ht=new YP(Ht,f,null,w,Ge),qe.push({event:Ht,listeners:Pt}),zt?Ht.data=zt:(zt=n4(w),zt!==null&&(Ht.data=zt)))),(zt=Hse?qse(f,w):Kse(f,w))&&(Ee=Ww(Ee,"onBeforeInput"),0<Ee.length&&(Ge=new YP("onBeforeInput","beforeinput",null,w,Ge),qe.push({event:Ge,listeners:Ee}),Ge.data=zt))}k4(qe,x)})}function lb(f,x,w){return{instance:f,listener:x,currentTarget:w}}function Ww(f,x){for(var w=x+"Capture",C=[];f!==null;){var E=f,F=E.stateNode;E.tag===5&&F!==null&&(E=F,F=We(f,w),F!=null&&C.unshift(lb(f,F,E)),F=We(f,x),F!=null&&C.push(lb(f,F,E))),f=f.return}return C}function Dm(f){if(f===null)return null;do f=f.return;while(f&&f.tag!==5);return f||null}function S4(f,x,w,C,E){for(var F=x._reactName,U=[];w!==null&&w!==C;){var ne=w,de=ne.alternate,Ee=ne.stateNode;if(de!==null&&de===C)break;ne.tag===5&&Ee!==null&&(ne=Ee,E?(de=We(w,F),de!=null&&U.unshift(lb(w,de,ne))):E||(de=We(w,F),de!=null&&U.push(lb(w,de,ne)))),w=w.return}U.length!==0&&f.push({event:x,listeners:U})}var lae=/\r\n?/g,uae=/\u0000|\uFFFD/g;function C4(f){return(typeof f=="string"?f:""+f).replace(lae,`
`).replace(uae,"")}function Vw(f,x,w){if(x=C4(x),C4(f)!==x&&w)throw Error(n(425))}function Uw(){}var VT=null,UT=null;function GT(f,x){return f==="textarea"||f==="noscript"||typeof x.children=="string"||typeof x.children=="number"||typeof x.dangerouslySetInnerHTML=="object"&&x.dangerouslySetInnerHTML!==null&&x.dangerouslySetInnerHTML.__html!=null}var jT=typeof setTimeout=="function"?setTimeout:void 0,cae=typeof clearTimeout=="function"?clearTimeout:void 0,N4=typeof Promise=="function"?Promise:void 0,dae=typeof queueMicrotask=="function"?queueMicrotask:typeof N4<"u"?function(f){return N4.resolve(null).then(f).catch(pae)}:jT;function pae(f){setTimeout(function(){throw f})}function HT(f,x){var w=x,C=0;do{var E=w.nextSibling;if(f.removeChild(w),E&&E.nodeType===8)if(w=E.data,w==="/$"){if(C===0){f.removeChild(E),mu(x);return}C--}else w!=="$"&&w!=="$?"&&w!=="$!"||C++;w=E}while(w);mu(x)}function pc(f){for(;f!=null;f=f.nextSibling){var x=f.nodeType;if(x===1||x===3)break;if(x===8){if(x=f.data,x==="$"||x==="$!"||x==="$?")break;if(x==="/$")return null}}return f}function T4(f){f=f.previousSibling;for(var x=0;f;){if(f.nodeType===8){var w=f.data;if(w==="$"||w==="$!"||w==="$?"){if(x===0)return f;x--}else w==="/$"&&x++}f=f.previousSibling}return null}var Fm=Math.random().toString(36).slice(2),bl="__reactFiber$"+Fm,ub="__reactProps$"+Fm,gu="__reactContainer$"+Fm,qT="__reactEvents$"+Fm,hae="__reactListeners$"+Fm,fae="__reactHandles$"+Fm;function np(f){var x=f[bl];if(x)return x;for(var w=f.parentNode;w;){if(x=w[gu]||w[bl]){if(w=x.alternate,x.child!==null||w!==null&&w.child!==null)for(f=T4(f);f!==null;){if(w=f[bl])return w;f=T4(f)}return x}f=w,w=f.parentNode}return null}function cb(f){return f=f[bl]||f[gu],!f||f.tag!==5&&f.tag!==6&&f.tag!==13&&f.tag!==3?null:f}function Om(f){if(f.tag===5||f.tag===6)return f.stateNode;throw Error(n(33))}function Gw(f){return f[ub]||null}var KT=[],Mm=-1;function hc(f){return{current:f}}function yr(f){0>Mm||(f.current=KT[Mm],KT[Mm]=null,Mm--)}function pr(f,x){Mm++,KT[Mm]=f.current,f.current=x}var fc={},ma=hc(fc),si=hc(!1),rp=fc;function Lm(f,x){var w=f.type.contextTypes;if(!w)return fc;var C=f.stateNode;if(C&&C.__reactInternalMemoizedUnmaskedChildContext===x)return C.__reactInternalMemoizedMaskedChildContext;var E={},F;for(F in w)E[F]=x[F];return C&&(f=f.stateNode,f.__reactInternalMemoizedUnmaskedChildContext=x,f.__reactInternalMemoizedMaskedChildContext=E),E}function ai(f){return f=f.childContextTypes,f!=null}function jw(){yr(si),yr(ma)}function $4(f,x,w){if(ma.current!==fc)throw Error(n(168));pr(ma,x),pr(si,w)}function E4(f,x,w){var C=f.stateNode;if(x=x.childContextTypes,typeof C.getChildContext!="function")return w;C=C.getChildContext();for(var E in C)if(!(E in x))throw Error(n(108,Ne(f)||"Unknown",E));return H({},w,C)}function Hw(f){return f=(f=f.stateNode)&&f.__reactInternalMemoizedMergedChildContext||fc,rp=ma.current,pr(ma,f),pr(si,si.current),!0}function _4(f,x,w){var C=f.stateNode;if(!C)throw Error(n(169));w?(f=E4(f,x,rp),C.__reactInternalMemoizedMergedChildContext=f,yr(si),yr(ma),pr(ma,f)):yr(si),pr(si,w)}var yu=null,qw=!1,XT=!1;function A4(f){yu===null?yu=[f]:yu.push(f)}function mae(f){qw=!0,A4(f)}function mc(){if(!XT&&yu!==null){XT=!0;var f=0,x=En;try{var w=yu;for(En=1;f<w.length;f++){var C=w[f];do C=C(!0);while(C!==null)}yu=null,qw=!1}catch(E){throw yu!==null&&(yu=yu.slice(f+1)),Yd(_o,mc),E}finally{En=x,XT=!1}}return null}var Pm=[],zm=0,Kw=null,Xw=0,to=[],no=0,sp=null,xu=1,bu="";function ap(f,x){Pm[zm++]=Xw,Pm[zm++]=Kw,Kw=f,Xw=x}function R4(f,x,w){to[no++]=xu,to[no++]=bu,to[no++]=sp,sp=f;var C=xu;f=bu;var E=32-Ai(C)-1;C&=~(1<<E),w+=1;var F=32-Ai(x)+E;if(30<F){var U=E-E%5;F=(C&(1<<U)-1).toString(32),C>>=U,E-=U,xu=1<<32-Ai(x)+E|w<<E|C,bu=F+f}else xu=1<<F|w<<E|C,bu=f}function YT(f){f.return!==null&&(ap(f,1),R4(f,1,0))}function ZT(f){for(;f===Kw;)Kw=Pm[--zm],Pm[zm]=null,Xw=Pm[--zm],Pm[zm]=null;for(;f===sp;)sp=to[--no],to[no]=null,bu=to[--no],to[no]=null,xu=to[--no],to[no]=null}var Oi=null,Mi=null,Ir=!1,Do=null;function D4(f,x){var w=io(5,null,null,0);w.elementType="DELETED",w.stateNode=x,w.return=f,x=f.deletions,x===null?(f.deletions=[w],f.flags|=16):x.push(w)}function F4(f,x){switch(f.tag){case 5:var w=f.type;return x=x.nodeType!==1||w.toLowerCase()!==x.nodeName.toLowerCase()?null:x,x!==null?(f.stateNode=x,Oi=f,Mi=pc(x.firstChild),!0):!1;case 6:return x=f.pendingProps===""||x.nodeType!==3?null:x,x!==null?(f.stateNode=x,Oi=f,Mi=null,!0):!1;case 13:return x=x.nodeType!==8?null:x,x!==null?(w=sp!==null?{id:xu,overflow:bu}:null,f.memoizedState={dehydrated:x,treeContext:w,retryLane:1073741824},w=io(18,null,null,0),w.stateNode=x,w.return=f,f.child=w,Oi=f,Mi=null,!0):!1;default:return!1}}function JT(f){return(f.mode&1)!==0&&(f.flags&128)===0}function QT(f){if(Ir){var x=Mi;if(x){var w=x;if(!F4(f,x)){if(JT(f))throw Error(n(418));x=pc(w.nextSibling);var C=Oi;x&&F4(f,x)?D4(C,w):(f.flags=f.flags&-4097|2,Ir=!1,Oi=f)}}else{if(JT(f))throw Error(n(418));f.flags=f.flags&-4097|2,Ir=!1,Oi=f}}}function O4(f){for(f=f.return;f!==null&&f.tag!==5&&f.tag!==3&&f.tag!==13;)f=f.return;Oi=f}function Yw(f){if(f!==Oi)return!1;if(!Ir)return O4(f),Ir=!0,!1;var x;if((x=f.tag!==3)&&!(x=f.tag!==5)&&(x=f.type,x=x!=="head"&&x!=="body"&&!GT(f.type,f.memoizedProps)),x&&(x=Mi)){if(JT(f))throw M4(),Error(n(418));for(;x;)D4(f,x),x=pc(x.nextSibling)}if(O4(f),f.tag===13){if(f=f.memoizedState,f=f!==null?f.dehydrated:null,!f)throw Error(n(317));e:{for(f=f.nextSibling,x=0;f;){if(f.nodeType===8){var w=f.data;if(w==="/$"){if(x===0){Mi=pc(f.nextSibling);break e}x--}else w!=="$"&&w!=="$!"&&w!=="$?"||x++}f=f.nextSibling}Mi=null}}else Mi=Oi?pc(f.stateNode.nextSibling):null;return!0}function M4(){for(var f=Mi;f;)f=pc(f.nextSibling)}function Bm(){Mi=Oi=null,Ir=!1}function e$(f){Do===null?Do=[f]:Do.push(f)}var gae=I.ReactCurrentBatchConfig;function db(f,x,w){if(f=w.ref,f!==null&&typeof f!="function"&&typeof f!="object"){if(w._owner){if(w=w._owner,w){if(w.tag!==1)throw Error(n(309));var C=w.stateNode}if(!C)throw Error(n(147,f));var E=C,F=""+f;return x!==null&&x.ref!==null&&typeof x.ref=="function"&&x.ref._stringRef===F?x.ref:(x=function(U){var ne=E.refs;U===null?delete ne[F]:ne[F]=U},x._stringRef=F,x)}if(typeof f!="string")throw Error(n(284));if(!w._owner)throw Error(n(290,f))}return f}function Zw(f,x){throw f=Object.prototype.toString.call(x),Error(n(31,f==="[object Object]"?"object with keys {"+Object.keys(x).join(", ")+"}":f))}function L4(f){var x=f._init;return x(f._payload)}function P4(f){function x(Ce,ge){if(f){var Te=Ce.deletions;Te===null?(Ce.deletions=[ge],Ce.flags|=16):Te.push(ge)}}function w(Ce,ge){if(!f)return null;for(;ge!==null;)x(Ce,ge),ge=ge.sibling;return null}function C(Ce,ge){for(Ce=new Map;ge!==null;)ge.key!==null?Ce.set(ge.key,ge):Ce.set(ge.index,ge),ge=ge.sibling;return Ce}function E(Ce,ge){return Ce=Ic(Ce,ge),Ce.index=0,Ce.sibling=null,Ce}function F(Ce,ge,Te){return Ce.index=Te,f?(Te=Ce.alternate,Te!==null?(Te=Te.index,Te<ge?(Ce.flags|=2,ge):Te):(Ce.flags|=2,ge)):(Ce.flags|=1048576,ge)}function U(Ce){return f&&Ce.alternate===null&&(Ce.flags|=2),Ce}function ne(Ce,ge,Te,Ye){return ge===null||ge.tag!==6?(ge=j$(Te,Ce.mode,Ye),ge.return=Ce,ge):(ge=E(ge,Te),ge.return=Ce,ge)}function de(Ce,ge,Te,Ye){var $t=Te.type;return $t===T?Ge(Ce,ge,Te.props.children,Ye,Te.key):ge!==null&&(ge.elementType===$t||typeof $t=="object"&&$t!==null&&$t.$$typeof===G&&L4($t)===ge.type)?(Ye=E(ge,Te.props),Ye.ref=db(Ce,ge,Te),Ye.return=Ce,Ye):(Ye=wk(Te.type,Te.key,Te.props,null,Ce.mode,Ye),Ye.ref=db(Ce,ge,Te),Ye.return=Ce,Ye)}function Ee(Ce,ge,Te,Ye){return ge===null||ge.tag!==4||ge.stateNode.containerInfo!==Te.containerInfo||ge.stateNode.implementation!==Te.implementation?(ge=H$(Te,Ce.mode,Ye),ge.return=Ce,ge):(ge=E(ge,Te.children||[]),ge.return=Ce,ge)}function Ge(Ce,ge,Te,Ye,$t){return ge===null||ge.tag!==7?(ge=hp(Te,Ce.mode,Ye,$t),ge.return=Ce,ge):(ge=E(ge,Te),ge.return=Ce,ge)}function qe(Ce,ge,Te){if(typeof ge=="string"&&ge!==""||typeof ge=="number")return ge=j$(""+ge,Ce.mode,Te),ge.return=Ce,ge;if(typeof ge=="object"&&ge!==null){switch(ge.$$typeof){case S:return Te=wk(ge.type,ge.key,ge.props,null,Ce.mode,Te),Te.ref=db(Ce,null,ge),Te.return=Ce,Te;case N:return ge=H$(ge,Ce.mode,Te),ge.return=Ce,ge;case G:var Ye=ge._init;return qe(Ce,Ye(ge._payload),Te)}if(Et(ge)||j(ge))return ge=hp(ge,Ce.mode,Te,null),ge.return=Ce,ge;Zw(Ce,ge)}return null}function Ue(Ce,ge,Te,Ye){var $t=ge!==null?ge.key:null;if(typeof Te=="string"&&Te!==""||typeof Te=="number")return $t!==null?null:ne(Ce,ge,""+Te,Ye);if(typeof Te=="object"&&Te!==null){switch(Te.$$typeof){case S:return Te.key===$t?de(Ce,ge,Te,Ye):null;case N:return Te.key===$t?Ee(Ce,ge,Te,Ye):null;case G:return $t=Te._init,Ue(Ce,ge,$t(Te._payload),Ye)}if(Et(Te)||j(Te))return $t!==null?null:Ge(Ce,ge,Te,Ye,null);Zw(Ce,Te)}return null}function mt(Ce,ge,Te,Ye,$t){if(typeof Ye=="string"&&Ye!==""||typeof Ye=="number")return Ce=Ce.get(Te)||null,ne(ge,Ce,""+Ye,$t);if(typeof Ye=="object"&&Ye!==null){switch(Ye.$$typeof){case S:return Ce=Ce.get(Ye.key===null?Te:Ye.key)||null,de(ge,Ce,Ye,$t);case N:return Ce=Ce.get(Ye.key===null?Te:Ye.key)||null,Ee(ge,Ce,Ye,$t);case G:var Pt=Ye._init;return mt(Ce,ge,Te,Pt(Ye._payload),$t)}if(Et(Ye)||j(Ye))return Ce=Ce.get(Te)||null,Ge(ge,Ce,Ye,$t,null);Zw(ge,Ye)}return null}function kt(Ce,ge,Te,Ye){for(var $t=null,Pt=null,zt=ge,Ht=ge=0,Us=null;zt!==null&&Ht<Te.length;Ht++){zt.index>Ht?(Us=zt,zt=null):Us=zt.sibling;var _n=Ue(Ce,zt,Te[Ht],Ye);if(_n===null){zt===null&&(zt=Us);break}f&&zt&&_n.alternate===null&&x(Ce,zt),ge=F(_n,ge,Ht),Pt===null?$t=_n:Pt.sibling=_n,Pt=_n,zt=Us}if(Ht===Te.length)return w(Ce,zt),Ir&&ap(Ce,Ht),$t;if(zt===null){for(;Ht<Te.length;Ht++)zt=qe(Ce,Te[Ht],Ye),zt!==null&&(ge=F(zt,ge,Ht),Pt===null?$t=zt:Pt.sibling=zt,Pt=zt);return Ir&&ap(Ce,Ht),$t}for(zt=C(Ce,zt);Ht<Te.length;Ht++)Us=mt(zt,Ce,Ht,Te[Ht],Ye),Us!==null&&(f&&Us.alternate!==null&&zt.delete(Us.key===null?Ht:Us.key),ge=F(Us,ge,Ht),Pt===null?$t=Us:Pt.sibling=Us,Pt=Us);return f&&zt.forEach(function(Sc){return x(Ce,Sc)}),Ir&&ap(Ce,Ht),$t}function Ct(Ce,ge,Te,Ye){var $t=j(Te);if(typeof $t!="function")throw Error(n(150));if(Te=$t.call(Te),Te==null)throw Error(n(151));for(var Pt=$t=null,zt=ge,Ht=ge=0,Us=null,_n=Te.next();zt!==null&&!_n.done;Ht++,_n=Te.next()){zt.index>Ht?(Us=zt,zt=null):Us=zt.sibling;var Sc=Ue(Ce,zt,_n.value,Ye);if(Sc===null){zt===null&&(zt=Us);break}f&&zt&&Sc.alternate===null&&x(Ce,zt),ge=F(Sc,ge,Ht),Pt===null?$t=Sc:Pt.sibling=Sc,Pt=Sc,zt=Us}if(_n.done)return w(Ce,zt),Ir&&ap(Ce,Ht),$t;if(zt===null){for(;!_n.done;Ht++,_n=Te.next())_n=qe(Ce,_n.value,Ye),_n!==null&&(ge=F(_n,ge,Ht),Pt===null?$t=_n:Pt.sibling=_n,Pt=_n);return Ir&&ap(Ce,Ht),$t}for(zt=C(Ce,zt);!_n.done;Ht++,_n=Te.next())_n=mt(zt,Ce,Ht,_n.value,Ye),_n!==null&&(f&&_n.alternate!==null&&zt.delete(_n.key===null?Ht:_n.key),ge=F(_n,ge,Ht),Pt===null?$t=_n:Pt.sibling=_n,Pt=_n);return f&&zt.forEach(function(Xae){return x(Ce,Xae)}),Ir&&ap(Ce,Ht),$t}function jr(Ce,ge,Te,Ye){if(typeof Te=="object"&&Te!==null&&Te.type===T&&Te.key===null&&(Te=Te.props.children),typeof Te=="object"&&Te!==null){switch(Te.$$typeof){case S:e:{for(var $t=Te.key,Pt=ge;Pt!==null;){if(Pt.key===$t){if($t=Te.type,$t===T){if(Pt.tag===7){w(Ce,Pt.sibling),ge=E(Pt,Te.props.children),ge.return=Ce,Ce=ge;break e}}else if(Pt.elementType===$t||typeof $t=="object"&&$t!==null&&$t.$$typeof===G&&L4($t)===Pt.type){w(Ce,Pt.sibling),ge=E(Pt,Te.props),ge.ref=db(Ce,Pt,Te),ge.return=Ce,Ce=ge;break e}w(Ce,Pt);break}else x(Ce,Pt);Pt=Pt.sibling}Te.type===T?(ge=hp(Te.props.children,Ce.mode,Ye,Te.key),ge.return=Ce,Ce=ge):(Ye=wk(Te.type,Te.key,Te.props,null,Ce.mode,Ye),Ye.ref=db(Ce,ge,Te),Ye.return=Ce,Ce=Ye)}return U(Ce);case N:e:{for(Pt=Te.key;ge!==null;){if(ge.key===Pt)if(ge.tag===4&&ge.stateNode.containerInfo===Te.containerInfo&&ge.stateNode.implementation===Te.implementation){w(Ce,ge.sibling),ge=E(ge,Te.children||[]),ge.return=Ce,Ce=ge;break e}else{w(Ce,ge);break}else x(Ce,ge);ge=ge.sibling}ge=H$(Te,Ce.mode,Ye),ge.return=Ce,Ce=ge}return U(Ce);case G:return Pt=Te._init,jr(Ce,ge,Pt(Te._payload),Ye)}if(Et(Te))return kt(Ce,ge,Te,Ye);if(j(Te))return Ct(Ce,ge,Te,Ye);Zw(Ce,Te)}return typeof Te=="string"&&Te!==""||typeof Te=="number"?(Te=""+Te,ge!==null&&ge.tag===6?(w(Ce,ge.sibling),ge=E(ge,Te),ge.return=Ce,Ce=ge):(w(Ce,ge),ge=j$(Te,Ce.mode,Ye),ge.return=Ce,Ce=ge),U(Ce)):w(Ce,ge)}return jr}var Wm=P4(!0),z4=P4(!1),Jw=hc(null),Qw=null,Vm=null,t$=null;function n$(){t$=Vm=Qw=null}function r$(f){var x=Jw.current;yr(Jw),f._currentValue=x}function s$(f,x,w){for(;f!==null;){var C=f.alternate;if((f.childLanes&x)!==x?(f.childLanes|=x,C!==null&&(C.childLanes|=x)):C!==null&&(C.childLanes&x)!==x&&(C.childLanes|=x),f===w)break;f=f.return}}function Um(f,x){Qw=f,t$=Vm=null,f=f.dependencies,f!==null&&f.firstContext!==null&&((f.lanes&x)!==0&&(ii=!0),f.firstContext=null)}function ro(f){var x=f._currentValue;if(t$!==f)if(f={context:f,memoizedValue:x,next:null},Vm===null){if(Qw===null)throw Error(n(308));Vm=f,Qw.dependencies={lanes:0,firstContext:f}}else Vm=Vm.next=f;return x}var ip=null;function a$(f){ip===null?ip=[f]:ip.push(f)}function B4(f,x,w,C){var E=x.interleaved;return E===null?(w.next=w,a$(x)):(w.next=E.next,E.next=w),x.interleaved=w,vu(f,C)}function vu(f,x){f.lanes|=x;var w=f.alternate;for(w!==null&&(w.lanes|=x),w=f,f=f.return;f!==null;)f.childLanes|=x,w=f.alternate,w!==null&&(w.childLanes|=x),w=f,f=f.return;return w.tag===3?w.stateNode:null}var gc=!1;function i$(f){f.updateQueue={baseState:f.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function W4(f,x){f=f.updateQueue,x.updateQueue===f&&(x.updateQueue={baseState:f.baseState,firstBaseUpdate:f.firstBaseUpdate,lastBaseUpdate:f.lastBaseUpdate,shared:f.shared,effects:f.effects})}function wu(f,x){return{eventTime:f,lane:x,tag:0,payload:null,callback:null,next:null}}function yc(f,x,w){var C=f.updateQueue;if(C===null)return null;if(C=C.shared,($n&2)!==0){var E=C.pending;return E===null?x.next=x:(x.next=E.next,E.next=x),C.pending=x,vu(f,w)}return E=C.interleaved,E===null?(x.next=x,a$(C)):(x.next=E.next,E.next=x),C.interleaved=x,vu(f,w)}function ek(f,x,w){if(x=x.updateQueue,x!==null&&(x=x.shared,(w&4194240)!==0)){var C=x.lanes;C&=f.pendingLanes,w|=C,x.lanes=w,Cm(f,w)}}function V4(f,x){var w=f.updateQueue,C=f.alternate;if(C!==null&&(C=C.updateQueue,w===C)){var E=null,F=null;if(w=w.firstBaseUpdate,w!==null){do{var U={eventTime:w.eventTime,lane:w.lane,tag:w.tag,payload:w.payload,callback:w.callback,next:null};F===null?E=F=U:F=F.next=U,w=w.next}while(w!==null);F===null?E=F=x:F=F.next=x}else E=F=x;w={baseState:C.baseState,firstBaseUpdate:E,lastBaseUpdate:F,shared:C.shared,effects:C.effects},f.updateQueue=w;return}f=w.lastBaseUpdate,f===null?w.firstBaseUpdate=x:f.next=x,w.lastBaseUpdate=x}function tk(f,x,w,C){var E=f.updateQueue;gc=!1;var F=E.firstBaseUpdate,U=E.lastBaseUpdate,ne=E.shared.pending;if(ne!==null){E.shared.pending=null;var de=ne,Ee=de.next;de.next=null,U===null?F=Ee:U.next=Ee,U=de;var Ge=f.alternate;Ge!==null&&(Ge=Ge.updateQueue,ne=Ge.lastBaseUpdate,ne!==U&&(ne===null?Ge.firstBaseUpdate=Ee:ne.next=Ee,Ge.lastBaseUpdate=de))}if(F!==null){var qe=E.baseState;U=0,Ge=Ee=de=null,ne=F;do{var Ue=ne.lane,mt=ne.eventTime;if((C&Ue)===Ue){Ge!==null&&(Ge=Ge.next={eventTime:mt,lane:0,tag:ne.tag,payload:ne.payload,callback:ne.callback,next:null});e:{var kt=f,Ct=ne;switch(Ue=x,mt=w,Ct.tag){case 1:if(kt=Ct.payload,typeof kt=="function"){qe=kt.call(mt,qe,Ue);break e}qe=kt;break e;case 3:kt.flags=kt.flags&-65537|128;case 0:if(kt=Ct.payload,Ue=typeof kt=="function"?kt.call(mt,qe,Ue):kt,Ue==null)break e;qe=H({},qe,Ue);break e;case 2:gc=!0}}ne.callback!==null&&ne.lane!==0&&(f.flags|=64,Ue=E.effects,Ue===null?E.effects=[ne]:Ue.push(ne))}else mt={eventTime:mt,lane:Ue,tag:ne.tag,payload:ne.payload,callback:ne.callback,next:null},Ge===null?(Ee=Ge=mt,de=qe):Ge=Ge.next=mt,U|=Ue;if(ne=ne.next,ne===null){if(ne=E.shared.pending,ne===null)break;Ue=ne,ne=Ue.next,Ue.next=null,E.lastBaseUpdate=Ue,E.shared.pending=null}}while(!0);if(Ge===null&&(de=qe),E.baseState=de,E.firstBaseUpdate=Ee,E.lastBaseUpdate=Ge,x=E.shared.interleaved,x!==null){E=x;do U|=E.lane,E=E.next;while(E!==x)}else F===null&&(E.shared.lanes=0);up|=U,f.lanes=U,f.memoizedState=qe}}function U4(f,x,w){if(f=x.effects,x.effects=null,f!==null)for(x=0;x<f.length;x++){var C=f[x],E=C.callback;if(E!==null){if(C.callback=null,C=w,typeof E!="function")throw Error(n(191,E));E.call(C)}}}var pb={},vl=hc(pb),hb=hc(pb),fb=hc(pb);function op(f){if(f===pb)throw Error(n(174));return f}function o$(f,x){switch(pr(fb,x),pr(hb,f),pr(vl,pb),f=x.nodeType,f){case 9:case 11:x=(x=x.documentElement)?x.namespaceURI:Dt(null,"");break;default:f=f===8?x.parentNode:x,x=f.namespaceURI||null,f=f.tagName,x=Dt(x,f)}yr(vl),pr(vl,x)}function Gm(){yr(vl),yr(hb),yr(fb)}function G4(f){op(fb.current);var x=op(vl.current),w=Dt(x,f.type);x!==w&&(pr(hb,f),pr(vl,w))}function l$(f){hb.current===f&&(yr(vl),yr(hb))}var Ar=hc(0);function nk(f){for(var x=f;x!==null;){if(x.tag===13){var w=x.memoizedState;if(w!==null&&(w=w.dehydrated,w===null||w.data==="$?"||w.data==="$!"))return x}else if(x.tag===19&&x.memoizedProps.revealOrder!==void 0){if((x.flags&128)!==0)return x}else if(x.child!==null){x.child.return=x,x=x.child;continue}if(x===f)break;for(;x.sibling===null;){if(x.return===null||x.return===f)return null;x=x.return}x.sibling.return=x.return,x=x.sibling}return null}var u$=[];function c$(){for(var f=0;f<u$.length;f++)u$[f]._workInProgressVersionPrimary=null;u$.length=0}var rk=I.ReactCurrentDispatcher,d$=I.ReactCurrentBatchConfig,lp=0,Rr=null,ws=null,Ws=null,sk=!1,mb=!1,gb=0,yae=0;function ga(){throw Error(n(321))}function p$(f,x){if(x===null)return!1;for(var w=0;w<x.length&&w<f.length;w++)if(!Ro(f[w],x[w]))return!1;return!0}function h$(f,x,w,C,E,F){if(lp=F,Rr=x,x.memoizedState=null,x.updateQueue=null,x.lanes=0,rk.current=f===null||f.memoizedState===null?wae:kae,f=w(C,E),mb){F=0;do{if(mb=!1,gb=0,25<=F)throw Error(n(301));F+=1,Ws=ws=null,x.updateQueue=null,rk.current=Iae,f=w(C,E)}while(mb)}if(rk.current=ok,x=ws!==null&&ws.next!==null,lp=0,Ws=ws=Rr=null,sk=!1,x)throw Error(n(300));return f}function f$(){var f=gb!==0;return gb=0,f}function wl(){var f={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Ws===null?Rr.memoizedState=Ws=f:Ws=Ws.next=f,Ws}function so(){if(ws===null){var f=Rr.alternate;f=f!==null?f.memoizedState:null}else f=ws.next;var x=Ws===null?Rr.memoizedState:Ws.next;if(x!==null)Ws=x,ws=f;else{if(f===null)throw Error(n(310));ws=f,f={memoizedState:ws.memoizedState,baseState:ws.baseState,baseQueue:ws.baseQueue,queue:ws.queue,next:null},Ws===null?Rr.memoizedState=Ws=f:Ws=Ws.next=f}return Ws}function yb(f,x){return typeof x=="function"?x(f):x}function m$(f){var x=so(),w=x.queue;if(w===null)throw Error(n(311));w.lastRenderedReducer=f;var C=ws,E=C.baseQueue,F=w.pending;if(F!==null){if(E!==null){var U=E.next;E.next=F.next,F.next=U}C.baseQueue=E=F,w.pending=null}if(E!==null){F=E.next,C=C.baseState;var ne=U=null,de=null,Ee=F;do{var Ge=Ee.lane;if((lp&Ge)===Ge)de!==null&&(de=de.next={lane:0,action:Ee.action,hasEagerState:Ee.hasEagerState,eagerState:Ee.eagerState,next:null}),C=Ee.hasEagerState?Ee.eagerState:f(C,Ee.action);else{var qe={lane:Ge,action:Ee.action,hasEagerState:Ee.hasEagerState,eagerState:Ee.eagerState,next:null};de===null?(ne=de=qe,U=C):de=de.next=qe,Rr.lanes|=Ge,up|=Ge}Ee=Ee.next}while(Ee!==null&&Ee!==F);de===null?U=C:de.next=ne,Ro(C,x.memoizedState)||(ii=!0),x.memoizedState=C,x.baseState=U,x.baseQueue=de,w.lastRenderedState=C}if(f=w.interleaved,f!==null){E=f;do F=E.lane,Rr.lanes|=F,up|=F,E=E.next;while(E!==f)}else E===null&&(w.lanes=0);return[x.memoizedState,w.dispatch]}function g$(f){var x=so(),w=x.queue;if(w===null)throw Error(n(311));w.lastRenderedReducer=f;var C=w.dispatch,E=w.pending,F=x.memoizedState;if(E!==null){w.pending=null;var U=E=E.next;do F=f(F,U.action),U=U.next;while(U!==E);Ro(F,x.memoizedState)||(ii=!0),x.memoizedState=F,x.baseQueue===null&&(x.baseState=F),w.lastRenderedState=F}return[F,C]}function j4(){}function H4(f,x){var w=Rr,C=so(),E=x(),F=!Ro(C.memoizedState,E);if(F&&(C.memoizedState=E,ii=!0),C=C.queue,y$(X4.bind(null,w,C,f),[f]),C.getSnapshot!==x||F||Ws!==null&&Ws.memoizedState.tag&1){if(w.flags|=2048,xb(9,K4.bind(null,w,C,E,x),void 0,null),Vs===null)throw Error(n(349));(lp&30)!==0||q4(w,x,E)}return E}function q4(f,x,w){f.flags|=16384,f={getSnapshot:x,value:w},x=Rr.updateQueue,x===null?(x={lastEffect:null,stores:null},Rr.updateQueue=x,x.stores=[f]):(w=x.stores,w===null?x.stores=[f]:w.push(f))}function K4(f,x,w,C){x.value=w,x.getSnapshot=C,Y4(x)&&Z4(f)}function X4(f,x,w){return w(function(){Y4(x)&&Z4(f)})}function Y4(f){var x=f.getSnapshot;f=f.value;try{var w=x();return!Ro(f,w)}catch{return!0}}function Z4(f){var x=vu(f,1);x!==null&&Lo(x,f,1,-1)}function J4(f){var x=wl();return typeof f=="function"&&(f=f()),x.memoizedState=x.baseState=f,f={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:yb,lastRenderedState:f},x.queue=f,f=f.dispatch=vae.bind(null,Rr,f),[x.memoizedState,f]}function xb(f,x,w,C){return f={tag:f,create:x,destroy:w,deps:C,next:null},x=Rr.updateQueue,x===null?(x={lastEffect:null,stores:null},Rr.updateQueue=x,x.lastEffect=f.next=f):(w=x.lastEffect,w===null?x.lastEffect=f.next=f:(C=w.next,w.next=f,f.next=C,x.lastEffect=f)),f}function Q4(){return so().memoizedState}function ak(f,x,w,C){var E=wl();Rr.flags|=f,E.memoizedState=xb(1|x,w,void 0,C===void 0?null:C)}function ik(f,x,w,C){var E=so();C=C===void 0?null:C;var F=void 0;if(ws!==null){var U=ws.memoizedState;if(F=U.destroy,C!==null&&p$(C,U.deps)){E.memoizedState=xb(x,w,F,C);return}}Rr.flags|=f,E.memoizedState=xb(1|x,w,F,C)}function ez(f,x){return ak(8390656,8,f,x)}function y$(f,x){return ik(2048,8,f,x)}function tz(f,x){return ik(4,2,f,x)}function nz(f,x){return ik(4,4,f,x)}function rz(f,x){if(typeof x=="function")return f=f(),x(f),function(){x(null)};if(x!=null)return f=f(),x.current=f,function(){x.current=null}}function sz(f,x,w){return w=w!=null?w.concat([f]):null,ik(4,4,rz.bind(null,x,f),w)}function x$(){}function az(f,x){var w=so();x=x===void 0?null:x;var C=w.memoizedState;return C!==null&&x!==null&&p$(x,C[1])?C[0]:(w.memoizedState=[f,x],f)}function iz(f,x){var w=so();x=x===void 0?null:x;var C=w.memoizedState;return C!==null&&x!==null&&p$(x,C[1])?C[0]:(f=f(),w.memoizedState=[f,x],f)}function oz(f,x,w){return(lp&21)===0?(f.baseState&&(f.baseState=!1,ii=!0),f.memoizedState=w):(Ro(w,x)||(w=Ew(),Rr.lanes|=w,up|=w,f.baseState=!0),x)}function xae(f,x){var w=En;En=w!==0&&4>w?w:4,f(!0);var C=d$.transition;d$.transition={};try{f(!1),x()}finally{En=w,d$.transition=C}}function lz(){return so().memoizedState}function bae(f,x,w){var C=wc(f);if(w={lane:C,action:w,hasEagerState:!1,eagerState:null,next:null},uz(f))cz(x,w);else if(w=B4(f,x,w,C),w!==null){var E=Ba();Lo(w,f,C,E),dz(w,x,C)}}function vae(f,x,w){var C=wc(f),E={lane:C,action:w,hasEagerState:!1,eagerState:null,next:null};if(uz(f))cz(x,E);else{var F=f.alternate;if(f.lanes===0&&(F===null||F.lanes===0)&&(F=x.lastRenderedReducer,F!==null))try{var U=x.lastRenderedState,ne=F(U,w);if(E.hasEagerState=!0,E.eagerState=ne,Ro(ne,U)){var de=x.interleaved;de===null?(E.next=E,a$(x)):(E.next=de.next,de.next=E),x.interleaved=E;return}}catch{}finally{}w=B4(f,x,E,C),w!==null&&(E=Ba(),Lo(w,f,C,E),dz(w,x,C))}}function uz(f){var x=f.alternate;return f===Rr||x!==null&&x===Rr}function cz(f,x){mb=sk=!0;var w=f.pending;w===null?x.next=x:(x.next=w.next,w.next=x),f.pending=x}function dz(f,x,w){if((w&4194240)!==0){var C=x.lanes;C&=f.pendingLanes,w|=C,x.lanes=w,Cm(f,w)}}var ok={readContext:ro,useCallback:ga,useContext:ga,useEffect:ga,useImperativeHandle:ga,useInsertionEffect:ga,useLayoutEffect:ga,useMemo:ga,useReducer:ga,useRef:ga,useState:ga,useDebugValue:ga,useDeferredValue:ga,useTransition:ga,useMutableSource:ga,useSyncExternalStore:ga,useId:ga,unstable_isNewReconciler:!1},wae={readContext:ro,useCallback:function(f,x){return wl().memoizedState=[f,x===void 0?null:x],f},useContext:ro,useEffect:ez,useImperativeHandle:function(f,x,w){return w=w!=null?w.concat([f]):null,ak(4194308,4,rz.bind(null,x,f),w)},useLayoutEffect:function(f,x){return ak(4194308,4,f,x)},useInsertionEffect:function(f,x){return ak(4,2,f,x)},useMemo:function(f,x){var w=wl();return x=x===void 0?null:x,f=f(),w.memoizedState=[f,x],f},useReducer:function(f,x,w){var C=wl();return x=w!==void 0?w(x):x,C.memoizedState=C.baseState=x,f={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:f,lastRenderedState:x},C.queue=f,f=f.dispatch=bae.bind(null,Rr,f),[C.memoizedState,f]},useRef:function(f){var x=wl();return f={current:f},x.memoizedState=f},useState:J4,useDebugValue:x$,useDeferredValue:function(f){return wl().memoizedState=f},useTransition:function(){var f=J4(!1),x=f[0];return f=xae.bind(null,f[1]),wl().memoizedState=f,[x,f]},useMutableSource:function(){},useSyncExternalStore:function(f,x,w){var C=Rr,E=wl();if(Ir){if(w===void 0)throw Error(n(407));w=w()}else{if(w=x(),Vs===null)throw Error(n(349));(lp&30)!==0||q4(C,x,w)}E.memoizedState=w;var F={value:w,getSnapshot:x};return E.queue=F,ez(X4.bind(null,C,F,f),[f]),C.flags|=2048,xb(9,K4.bind(null,C,F,w,x),void 0,null),w},useId:function(){var f=wl(),x=Vs.identifierPrefix;if(Ir){var w=bu,C=xu;w=(C&~(1<<32-Ai(C)-1)).toString(32)+w,x=":"+x+"R"+w,w=gb++,0<w&&(x+="H"+w.toString(32)),x+=":"}else w=yae++,x=":"+x+"r"+w.toString(32)+":";return f.memoizedState=x},unstable_isNewReconciler:!1},kae={readContext:ro,useCallback:az,useContext:ro,useEffect:y$,useImperativeHandle:sz,useInsertionEffect:tz,useLayoutEffect:nz,useMemo:iz,useReducer:m$,useRef:Q4,useState:function(){return m$(yb)},useDebugValue:x$,useDeferredValue:function(f){var x=so();return oz(x,ws.memoizedState,f)},useTransition:function(){var f=m$(yb)[0],x=so().memoizedState;return[f,x]},useMutableSource:j4,useSyncExternalStore:H4,useId:lz,unstable_isNewReconciler:!1},Iae={readContext:ro,useCallback:az,useContext:ro,useEffect:y$,useImperativeHandle:sz,useInsertionEffect:tz,useLayoutEffect:nz,useMemo:iz,useReducer:g$,useRef:Q4,useState:function(){return g$(yb)},useDebugValue:x$,useDeferredValue:function(f){var x=so();return ws===null?x.memoizedState=f:oz(x,ws.memoizedState,f)},useTransition:function(){var f=g$(yb)[0],x=so().memoizedState;return[f,x]},useMutableSource:j4,useSyncExternalStore:H4,useId:lz,unstable_isNewReconciler:!1};function Fo(f,x){if(f&&f.defaultProps){x=H({},x),f=f.defaultProps;for(var w in f)x[w]===void 0&&(x[w]=f[w]);return x}return x}function b$(f,x,w,C){x=f.memoizedState,w=w(C,x),w=w==null?x:H({},x,w),f.memoizedState=w,f.lanes===0&&(f.updateQueue.baseState=w)}var lk={isMounted:function(f){return(f=f._reactInternals)?zs(f)===f:!1},enqueueSetState:function(f,x,w){f=f._reactInternals;var C=Ba(),E=wc(f),F=wu(C,E);F.payload=x,w!=null&&(F.callback=w),x=yc(f,F,E),x!==null&&(Lo(x,f,E,C),ek(x,f,E))},enqueueReplaceState:function(f,x,w){f=f._reactInternals;var C=Ba(),E=wc(f),F=wu(C,E);F.tag=1,F.payload=x,w!=null&&(F.callback=w),x=yc(f,F,E),x!==null&&(Lo(x,f,E,C),ek(x,f,E))},enqueueForceUpdate:function(f,x){f=f._reactInternals;var w=Ba(),C=wc(f),E=wu(w,C);E.tag=2,x!=null&&(E.callback=x),x=yc(f,E,C),x!==null&&(Lo(x,f,C,w),ek(x,f,C))}};function pz(f,x,w,C,E,F,U){return f=f.stateNode,typeof f.shouldComponentUpdate=="function"?f.shouldComponentUpdate(C,F,U):x.prototype&&x.prototype.isPureReactComponent?!sb(w,C)||!sb(E,F):!0}function hz(f,x,w){var C=!1,E=fc,F=x.contextType;return typeof F=="object"&&F!==null?F=ro(F):(E=ai(x)?rp:ma.current,C=x.contextTypes,F=(C=C!=null)?Lm(f,E):fc),x=new x(w,F),f.memoizedState=x.state!==null&&x.state!==void 0?x.state:null,x.updater=lk,f.stateNode=x,x._reactInternals=f,C&&(f=f.stateNode,f.__reactInternalMemoizedUnmaskedChildContext=E,f.__reactInternalMemoizedMaskedChildContext=F),x}function fz(f,x,w,C){f=x.state,typeof x.componentWillReceiveProps=="function"&&x.componentWillReceiveProps(w,C),typeof x.UNSAFE_componentWillReceiveProps=="function"&&x.UNSAFE_componentWillReceiveProps(w,C),x.state!==f&&lk.enqueueReplaceState(x,x.state,null)}function v$(f,x,w,C){var E=f.stateNode;E.props=w,E.state=f.memoizedState,E.refs={},i$(f);var F=x.contextType;typeof F=="object"&&F!==null?E.context=ro(F):(F=ai(x)?rp:ma.current,E.context=Lm(f,F)),E.state=f.memoizedState,F=x.getDerivedStateFromProps,typeof F=="function"&&(b$(f,x,F,w),E.state=f.memoizedState),typeof x.getDerivedStateFromProps=="function"||typeof E.getSnapshotBeforeUpdate=="function"||typeof E.UNSAFE_componentWillMount!="function"&&typeof E.componentWillMount!="function"||(x=E.state,typeof E.componentWillMount=="function"&&E.componentWillMount(),typeof E.UNSAFE_componentWillMount=="function"&&E.UNSAFE_componentWillMount(),x!==E.state&&lk.enqueueReplaceState(E,E.state,null),tk(f,w,E,C),E.state=f.memoizedState),typeof E.componentDidMount=="function"&&(f.flags|=4194308)}function jm(f,x){try{var w="",C=x;do w+=le(C),C=C.return;while(C);var E=w}catch(F){E=`
Error generating stack: `+F.message+`
`+F.stack}return{value:f,source:x,stack:E,digest:null}}function w$(f,x,w){return{value:f,source:null,stack:w??null,digest:x??null}}function k$(f,x){try{console.error(x.value)}catch(w){setTimeout(function(){throw w})}}var Sae=typeof WeakMap=="function"?WeakMap:Map;function mz(f,x,w){w=wu(-1,w),w.tag=3,w.payload={element:null};var C=x.value;return w.callback=function(){mk||(mk=!0,L$=C),k$(f,x)},w}function gz(f,x,w){w=wu(-1,w),w.tag=3;var C=f.type.getDerivedStateFromError;if(typeof C=="function"){var E=x.value;w.payload=function(){return C(E)},w.callback=function(){k$(f,x)}}var F=f.stateNode;return F!==null&&typeof F.componentDidCatch=="function"&&(w.callback=function(){k$(f,x),typeof C!="function"&&(bc===null?bc=new Set([this]):bc.add(this));var U=x.stack;this.componentDidCatch(x.value,{componentStack:U!==null?U:""})}),w}function yz(f,x,w){var C=f.pingCache;if(C===null){C=f.pingCache=new Sae;var E=new Set;C.set(x,E)}else E=C.get(x),E===void 0&&(E=new Set,C.set(x,E));E.has(w)||(E.add(w),f=Pae.bind(null,f,x,w),x.then(f,f))}function xz(f){do{var x;if((x=f.tag===13)&&(x=f.memoizedState,x=x!==null?x.dehydrated!==null:!0),x)return f;f=f.return}while(f!==null);return null}function bz(f,x,w,C,E){return(f.mode&1)===0?(f===x?f.flags|=65536:(f.flags|=128,w.flags|=131072,w.flags&=-52805,w.tag===1&&(w.alternate===null?w.tag=17:(x=wu(-1,1),x.tag=2,yc(w,x,1))),w.lanes|=1),f):(f.flags|=65536,f.lanes=E,f)}var Cae=I.ReactCurrentOwner,ii=!1;function za(f,x,w,C){x.child=f===null?z4(x,null,w,C):Wm(x,f.child,w,C)}function vz(f,x,w,C,E){w=w.render;var F=x.ref;return Um(x,E),C=h$(f,x,w,C,F,E),w=f$(),f!==null&&!ii?(x.updateQueue=f.updateQueue,x.flags&=-2053,f.lanes&=~E,ku(f,x,E)):(Ir&&w&&YT(x),x.flags|=1,za(f,x,C,E),x.child)}function wz(f,x,w,C,E){if(f===null){var F=w.type;return typeof F=="function"&&!G$(F)&&F.defaultProps===void 0&&w.compare===null&&w.defaultProps===void 0?(x.tag=15,x.type=F,kz(f,x,F,C,E)):(f=wk(w.type,null,C,x,x.mode,E),f.ref=x.ref,f.return=x,x.child=f)}if(F=f.child,(f.lanes&E)===0){var U=F.memoizedProps;if(w=w.compare,w=w!==null?w:sb,w(U,C)&&f.ref===x.ref)return ku(f,x,E)}return x.flags|=1,f=Ic(F,C),f.ref=x.ref,f.return=x,x.child=f}function kz(f,x,w,C,E){if(f!==null){var F=f.memoizedProps;if(sb(F,C)&&f.ref===x.ref)if(ii=!1,x.pendingProps=C=F,(f.lanes&E)!==0)(f.flags&131072)!==0&&(ii=!0);else return x.lanes=f.lanes,ku(f,x,E)}return I$(f,x,w,C,E)}function Iz(f,x,w){var C=x.pendingProps,E=C.children,F=f!==null?f.memoizedState:null;if(C.mode==="hidden")if((x.mode&1)===0)x.memoizedState={baseLanes:0,cachePool:null,transitions:null},pr(qm,Li),Li|=w;else{if((w&1073741824)===0)return f=F!==null?F.baseLanes|w:w,x.lanes=x.childLanes=1073741824,x.memoizedState={baseLanes:f,cachePool:null,transitions:null},x.updateQueue=null,pr(qm,Li),Li|=f,null;x.memoizedState={baseLanes:0,cachePool:null,transitions:null},C=F!==null?F.baseLanes:w,pr(qm,Li),Li|=C}else F!==null?(C=F.baseLanes|w,x.memoizedState=null):C=w,pr(qm,Li),Li|=C;return za(f,x,E,w),x.child}function Sz(f,x){var w=x.ref;(f===null&&w!==null||f!==null&&f.ref!==w)&&(x.flags|=512,x.flags|=2097152)}function I$(f,x,w,C,E){var F=ai(w)?rp:ma.current;return F=Lm(x,F),Um(x,E),w=h$(f,x,w,C,F,E),C=f$(),f!==null&&!ii?(x.updateQueue=f.updateQueue,x.flags&=-2053,f.lanes&=~E,ku(f,x,E)):(Ir&&C&&YT(x),x.flags|=1,za(f,x,w,E),x.child)}function Cz(f,x,w,C,E){if(ai(w)){var F=!0;Hw(x)}else F=!1;if(Um(x,E),x.stateNode===null)ck(f,x),hz(x,w,C),v$(x,w,C,E),C=!0;else if(f===null){var U=x.stateNode,ne=x.memoizedProps;U.props=ne;var de=U.context,Ee=w.contextType;typeof Ee=="object"&&Ee!==null?Ee=ro(Ee):(Ee=ai(w)?rp:ma.current,Ee=Lm(x,Ee));var Ge=w.getDerivedStateFromProps,qe=typeof Ge=="function"||typeof U.getSnapshotBeforeUpdate=="function";qe||typeof U.UNSAFE_componentWillReceiveProps!="function"&&typeof U.componentWillReceiveProps!="function"||(ne!==C||de!==Ee)&&fz(x,U,C,Ee),gc=!1;var Ue=x.memoizedState;U.state=Ue,tk(x,C,U,E),de=x.memoizedState,ne!==C||Ue!==de||si.current||gc?(typeof Ge=="function"&&(b$(x,w,Ge,C),de=x.memoizedState),(ne=gc||pz(x,w,ne,C,Ue,de,Ee))?(qe||typeof U.UNSAFE_componentWillMount!="function"&&typeof U.componentWillMount!="function"||(typeof U.componentWillMount=="function"&&U.componentWillMount(),typeof U.UNSAFE_componentWillMount=="function"&&U.UNSAFE_componentWillMount()),typeof U.componentDidMount=="function"&&(x.flags|=4194308)):(typeof U.componentDidMount=="function"&&(x.flags|=4194308),x.memoizedProps=C,x.memoizedState=de),U.props=C,U.state=de,U.context=Ee,C=ne):(typeof U.componentDidMount=="function"&&(x.flags|=4194308),C=!1)}else{U=x.stateNode,W4(f,x),ne=x.memoizedProps,Ee=x.type===x.elementType?ne:Fo(x.type,ne),U.props=Ee,qe=x.pendingProps,Ue=U.context,de=w.contextType,typeof de=="object"&&de!==null?de=ro(de):(de=ai(w)?rp:ma.current,de=Lm(x,de));var mt=w.getDerivedStateFromProps;(Ge=typeof mt=="function"||typeof U.getSnapshotBeforeUpdate=="function")||typeof U.UNSAFE_componentWillReceiveProps!="function"&&typeof U.componentWillReceiveProps!="function"||(ne!==qe||Ue!==de)&&fz(x,U,C,de),gc=!1,Ue=x.memoizedState,U.state=Ue,tk(x,C,U,E);var kt=x.memoizedState;ne!==qe||Ue!==kt||si.current||gc?(typeof mt=="function"&&(b$(x,w,mt,C),kt=x.memoizedState),(Ee=gc||pz(x,w,Ee,C,Ue,kt,de)||!1)?(Ge||typeof U.UNSAFE_componentWillUpdate!="function"&&typeof U.componentWillUpdate!="function"||(typeof U.componentWillUpdate=="function"&&U.componentWillUpdate(C,kt,de),typeof U.UNSAFE_componentWillUpdate=="function"&&U.UNSAFE_componentWillUpdate(C,kt,de)),typeof U.componentDidUpdate=="function"&&(x.flags|=4),typeof U.getSnapshotBeforeUpdate=="function"&&(x.flags|=1024)):(typeof U.componentDidUpdate!="function"||ne===f.memoizedProps&&Ue===f.memoizedState||(x.flags|=4),typeof U.getSnapshotBeforeUpdate!="function"||ne===f.memoizedProps&&Ue===f.memoizedState||(x.flags|=1024),x.memoizedProps=C,x.memoizedState=kt),U.props=C,U.state=kt,U.context=de,C=Ee):(typeof U.componentDidUpdate!="function"||ne===f.memoizedProps&&Ue===f.memoizedState||(x.flags|=4),typeof U.getSnapshotBeforeUpdate!="function"||ne===f.memoizedProps&&Ue===f.memoizedState||(x.flags|=1024),C=!1)}return S$(f,x,w,C,F,E)}function S$(f,x,w,C,E,F){Sz(f,x);var U=(x.flags&128)!==0;if(!C&&!U)return E&&_4(x,w,!1),ku(f,x,F);C=x.stateNode,Cae.current=x;var ne=U&&typeof w.getDerivedStateFromError!="function"?null:C.render();return x.flags|=1,f!==null&&U?(x.child=Wm(x,f.child,null,F),x.child=Wm(x,null,ne,F)):za(f,x,ne,F),x.memoizedState=C.state,E&&_4(x,w,!0),x.child}function Nz(f){var x=f.stateNode;x.pendingContext?$4(f,x.pendingContext,x.pendingContext!==x.context):x.context&&$4(f,x.context,!1),o$(f,x.containerInfo)}function Tz(f,x,w,C,E){return Bm(),e$(E),x.flags|=256,za(f,x,w,C),x.child}var C$={dehydrated:null,treeContext:null,retryLane:0};function N$(f){return{baseLanes:f,cachePool:null,transitions:null}}function $z(f,x,w){var C=x.pendingProps,E=Ar.current,F=!1,U=(x.flags&128)!==0,ne;if((ne=U)||(ne=f!==null&&f.memoizedState===null?!1:(E&2)!==0),ne?(F=!0,x.flags&=-129):(f===null||f.memoizedState!==null)&&(E|=1),pr(Ar,E&1),f===null)return QT(x),f=x.memoizedState,f!==null&&(f=f.dehydrated,f!==null)?((x.mode&1)===0?x.lanes=1:f.data==="$!"?x.lanes=8:x.lanes=1073741824,null):(U=C.children,f=C.fallback,F?(C=x.mode,F=x.child,U={mode:"hidden",children:U},(C&1)===0&&F!==null?(F.childLanes=0,F.pendingProps=U):F=kk(U,C,0,null),f=hp(f,C,w,null),F.return=x,f.return=x,F.sibling=f,x.child=F,x.child.memoizedState=N$(w),x.memoizedState=C$,f):T$(x,U));if(E=f.memoizedState,E!==null&&(ne=E.dehydrated,ne!==null))return Nae(f,x,U,C,ne,E,w);if(F){F=C.fallback,U=x.mode,E=f.child,ne=E.sibling;var de={mode:"hidden",children:C.children};return(U&1)===0&&x.child!==E?(C=x.child,C.childLanes=0,C.pendingProps=de,x.deletions=null):(C=Ic(E,de),C.subtreeFlags=E.subtreeFlags&14680064),ne!==null?F=Ic(ne,F):(F=hp(F,U,w,null),F.flags|=2),F.return=x,C.return=x,C.sibling=F,x.child=C,C=F,F=x.child,U=f.child.memoizedState,U=U===null?N$(w):{baseLanes:U.baseLanes|w,cachePool:null,transitions:U.transitions},F.memoizedState=U,F.childLanes=f.childLanes&~w,x.memoizedState=C$,C}return F=f.child,f=F.sibling,C=Ic(F,{mode:"visible",children:C.children}),(x.mode&1)===0&&(C.lanes=w),C.return=x,C.sibling=null,f!==null&&(w=x.deletions,w===null?(x.deletions=[f],x.flags|=16):w.push(f)),x.child=C,x.memoizedState=null,C}function T$(f,x){return x=kk({mode:"visible",children:x},f.mode,0,null),x.return=f,f.child=x}function uk(f,x,w,C){return C!==null&&e$(C),Wm(x,f.child,null,w),f=T$(x,x.pendingProps.children),f.flags|=2,x.memoizedState=null,f}function Nae(f,x,w,C,E,F,U){if(w)return x.flags&256?(x.flags&=-257,C=w$(Error(n(422))),uk(f,x,U,C)):x.memoizedState!==null?(x.child=f.child,x.flags|=128,null):(F=C.fallback,E=x.mode,C=kk({mode:"visible",children:C.children},E,0,null),F=hp(F,E,U,null),F.flags|=2,C.return=x,F.return=x,C.sibling=F,x.child=C,(x.mode&1)!==0&&Wm(x,f.child,null,U),x.child.memoizedState=N$(U),x.memoizedState=C$,F);if((x.mode&1)===0)return uk(f,x,U,null);if(E.data==="$!"){if(C=E.nextSibling&&E.nextSibling.dataset,C)var ne=C.dgst;return C=ne,F=Error(n(419)),C=w$(F,C,void 0),uk(f,x,U,C)}if(ne=(U&f.childLanes)!==0,ii||ne){if(C=Vs,C!==null){switch(U&-U){case 4:E=2;break;case 16:E=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:E=32;break;case 536870912:E=268435456;break;default:E=0}E=(E&(C.suspendedLanes|U))!==0?0:E,E!==0&&E!==F.retryLane&&(F.retryLane=E,vu(f,E),Lo(C,f,E,-1))}return U$(),C=w$(Error(n(421))),uk(f,x,U,C)}return E.data==="$?"?(x.flags|=128,x.child=f.child,x=zae.bind(null,f),E._reactRetry=x,null):(f=F.treeContext,Mi=pc(E.nextSibling),Oi=x,Ir=!0,Do=null,f!==null&&(to[no++]=xu,to[no++]=bu,to[no++]=sp,xu=f.id,bu=f.overflow,sp=x),x=T$(x,C.children),x.flags|=4096,x)}function Ez(f,x,w){f.lanes|=x;var C=f.alternate;C!==null&&(C.lanes|=x),s$(f.return,x,w)}function $$(f,x,w,C,E){var F=f.memoizedState;F===null?f.memoizedState={isBackwards:x,rendering:null,renderingStartTime:0,last:C,tail:w,tailMode:E}:(F.isBackwards=x,F.rendering=null,F.renderingStartTime=0,F.last=C,F.tail=w,F.tailMode=E)}function _z(f,x,w){var C=x.pendingProps,E=C.revealOrder,F=C.tail;if(za(f,x,C.children,w),C=Ar.current,(C&2)!==0)C=C&1|2,x.flags|=128;else{if(f!==null&&(f.flags&128)!==0)e:for(f=x.child;f!==null;){if(f.tag===13)f.memoizedState!==null&&Ez(f,w,x);else if(f.tag===19)Ez(f,w,x);else if(f.child!==null){f.child.return=f,f=f.child;continue}if(f===x)break e;for(;f.sibling===null;){if(f.return===null||f.return===x)break e;f=f.return}f.sibling.return=f.return,f=f.sibling}C&=1}if(pr(Ar,C),(x.mode&1)===0)x.memoizedState=null;else switch(E){case"forwards":for(w=x.child,E=null;w!==null;)f=w.alternate,f!==null&&nk(f)===null&&(E=w),w=w.sibling;w=E,w===null?(E=x.child,x.child=null):(E=w.sibling,w.sibling=null),$$(x,!1,E,w,F);break;case"backwards":for(w=null,E=x.child,x.child=null;E!==null;){if(f=E.alternate,f!==null&&nk(f)===null){x.child=E;break}f=E.sibling,E.sibling=w,w=E,E=f}$$(x,!0,w,null,F);break;case"together":$$(x,!1,null,null,void 0);break;default:x.memoizedState=null}return x.child}function ck(f,x){(x.mode&1)===0&&f!==null&&(f.alternate=null,x.alternate=null,x.flags|=2)}function ku(f,x,w){if(f!==null&&(x.dependencies=f.dependencies),up|=x.lanes,(w&x.childLanes)===0)return null;if(f!==null&&x.child!==f.child)throw Error(n(153));if(x.child!==null){for(f=x.child,w=Ic(f,f.pendingProps),x.child=w,w.return=x;f.sibling!==null;)f=f.sibling,w=w.sibling=Ic(f,f.pendingProps),w.return=x;w.sibling=null}return x.child}function Tae(f,x,w){switch(x.tag){case 3:Nz(x),Bm();break;case 5:G4(x);break;case 1:ai(x.type)&&Hw(x);break;case 4:o$(x,x.stateNode.containerInfo);break;case 10:var C=x.type._context,E=x.memoizedProps.value;pr(Jw,C._currentValue),C._currentValue=E;break;case 13:if(C=x.memoizedState,C!==null)return C.dehydrated!==null?(pr(Ar,Ar.current&1),x.flags|=128,null):(w&x.child.childLanes)!==0?$z(f,x,w):(pr(Ar,Ar.current&1),f=ku(f,x,w),f!==null?f.sibling:null);pr(Ar,Ar.current&1);break;case 19:if(C=(w&x.childLanes)!==0,(f.flags&128)!==0){if(C)return _z(f,x,w);x.flags|=128}if(E=x.memoizedState,E!==null&&(E.rendering=null,E.tail=null,E.lastEffect=null),pr(Ar,Ar.current),C)break;return null;case 22:case 23:return x.lanes=0,Iz(f,x,w)}return ku(f,x,w)}var Az,E$,Rz,Dz;Az=function(f,x){for(var w=x.child;w!==null;){if(w.tag===5||w.tag===6)f.appendChild(w.stateNode);else if(w.tag!==4&&w.child!==null){w.child.return=w,w=w.child;continue}if(w===x)break;for(;w.sibling===null;){if(w.return===null||w.return===x)return;w=w.return}w.sibling.return=w.return,w=w.sibling}},E$=function(){},Rz=function(f,x,w,C){var E=f.memoizedProps;if(E!==C){f=x.stateNode,op(vl.current);var F=null;switch(w){case"input":E=ft(f,E),C=ft(f,C),F=[];break;case"select":E=H({},E,{value:void 0}),C=H({},C,{value:void 0}),F=[];break;case"textarea":E=Xt(f,E),C=Xt(f,C),F=[];break;default:typeof E.onClick!="function"&&typeof C.onClick=="function"&&(f.onclick=Uw)}Ls(w,C);var U;w=null;for(Ee in E)if(!C.hasOwnProperty(Ee)&&E.hasOwnProperty(Ee)&&E[Ee]!=null)if(Ee==="style"){var ne=E[Ee];for(U in ne)ne.hasOwnProperty(U)&&(w||(w={}),w[U]="")}else Ee!=="dangerouslySetInnerHTML"&&Ee!=="children"&&Ee!=="suppressContentEditableWarning"&&Ee!=="suppressHydrationWarning"&&Ee!=="autoFocus"&&(s.hasOwnProperty(Ee)?F||(F=[]):(F=F||[]).push(Ee,null));for(Ee in C){var de=C[Ee];if(ne=E!=null?E[Ee]:void 0,C.hasOwnProperty(Ee)&&de!==ne&&(de!=null||ne!=null))if(Ee==="style")if(ne){for(U in ne)!ne.hasOwnProperty(U)||de&&de.hasOwnProperty(U)||(w||(w={}),w[U]="");for(U in de)de.hasOwnProperty(U)&&ne[U]!==de[U]&&(w||(w={}),w[U]=de[U])}else w||(F||(F=[]),F.push(Ee,w)),w=de;else Ee==="dangerouslySetInnerHTML"?(de=de?de.__html:void 0,ne=ne?ne.__html:void 0,de!=null&&ne!==de&&(F=F||[]).push(Ee,de)):Ee==="children"?typeof de!="string"&&typeof de!="number"||(F=F||[]).push(Ee,""+de):Ee!=="suppressContentEditableWarning"&&Ee!=="suppressHydrationWarning"&&(s.hasOwnProperty(Ee)?(de!=null&&Ee==="onScroll"&&gr("scroll",f),F||ne===de||(F=[])):(F=F||[]).push(Ee,de))}w&&(F=F||[]).push("style",w);var Ee=F;(x.updateQueue=Ee)&&(x.flags|=4)}},Dz=function(f,x,w,C){w!==C&&(x.flags|=4)};function bb(f,x){if(!Ir)switch(f.tailMode){case"hidden":x=f.tail;for(var w=null;x!==null;)x.alternate!==null&&(w=x),x=x.sibling;w===null?f.tail=null:w.sibling=null;break;case"collapsed":w=f.tail;for(var C=null;w!==null;)w.alternate!==null&&(C=w),w=w.sibling;C===null?x||f.tail===null?f.tail=null:f.tail.sibling=null:C.sibling=null}}function ya(f){var x=f.alternate!==null&&f.alternate.child===f.child,w=0,C=0;if(x)for(var E=f.child;E!==null;)w|=E.lanes|E.childLanes,C|=E.subtreeFlags&14680064,C|=E.flags&14680064,E.return=f,E=E.sibling;else for(E=f.child;E!==null;)w|=E.lanes|E.childLanes,C|=E.subtreeFlags,C|=E.flags,E.return=f,E=E.sibling;return f.subtreeFlags|=C,f.childLanes=w,x}function $ae(f,x,w){var C=x.pendingProps;switch(ZT(x),x.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ya(x),null;case 1:return ai(x.type)&&jw(),ya(x),null;case 3:return C=x.stateNode,Gm(),yr(si),yr(ma),c$(),C.pendingContext&&(C.context=C.pendingContext,C.pendingContext=null),(f===null||f.child===null)&&(Yw(x)?x.flags|=4:f===null||f.memoizedState.isDehydrated&&(x.flags&256)===0||(x.flags|=1024,Do!==null&&(B$(Do),Do=null))),E$(f,x),ya(x),null;case 5:l$(x);var E=op(fb.current);if(w=x.type,f!==null&&x.stateNode!=null)Rz(f,x,w,C,E),f.ref!==x.ref&&(x.flags|=512,x.flags|=2097152);else{if(!C){if(x.stateNode===null)throw Error(n(166));return ya(x),null}if(f=op(vl.current),Yw(x)){C=x.stateNode,w=x.type;var F=x.memoizedProps;switch(C[bl]=x,C[ub]=F,f=(x.mode&1)!==0,w){case"dialog":gr("cancel",C),gr("close",C);break;case"iframe":case"object":case"embed":gr("load",C);break;case"video":case"audio":for(E=0;E<ib.length;E++)gr(ib[E],C);break;case"source":gr("error",C);break;case"img":case"image":case"link":gr("error",C),gr("load",C);break;case"details":gr("toggle",C);break;case"input":et(C,F),gr("invalid",C);break;case"select":C._wrapperState={wasMultiple:!!F.multiple},gr("invalid",C);break;case"textarea":In(C,F),gr("invalid",C)}Ls(w,F),E=null;for(var U in F)if(F.hasOwnProperty(U)){var ne=F[U];U==="children"?typeof ne=="string"?C.textContent!==ne&&(F.suppressHydrationWarning!==!0&&Vw(C.textContent,ne,f),E=["children",ne]):typeof ne=="number"&&C.textContent!==""+ne&&(F.suppressHydrationWarning!==!0&&Vw(C.textContent,ne,f),E=["children",""+ne]):s.hasOwnProperty(U)&&ne!=null&&U==="onScroll"&&gr("scroll",C)}switch(w){case"input":Be(C),gt(C,F,!0);break;case"textarea":Be(C),tt(C);break;case"select":case"option":break;default:typeof F.onClick=="function"&&(C.onclick=Uw)}C=E,x.updateQueue=C,C!==null&&(x.flags|=4)}else{U=E.nodeType===9?E:E.ownerDocument,f==="http://www.w3.org/1999/xhtml"&&(f=Rt(w)),f==="http://www.w3.org/1999/xhtml"?w==="script"?(f=U.createElement("div"),f.innerHTML="<script><\/script>",f=f.removeChild(f.firstChild)):typeof C.is=="string"?f=U.createElement(w,{is:C.is}):(f=U.createElement(w),w==="select"&&(U=f,C.multiple?U.multiple=!0:C.size&&(U.size=C.size))):f=U.createElementNS(f,w),f[bl]=x,f[ub]=C,Az(f,x,!1,!1),x.stateNode=f;e:{switch(U=vs(w,C),w){case"dialog":gr("cancel",f),gr("close",f),E=C;break;case"iframe":case"object":case"embed":gr("load",f),E=C;break;case"video":case"audio":for(E=0;E<ib.length;E++)gr(ib[E],f);E=C;break;case"source":gr("error",f),E=C;break;case"img":case"image":case"link":gr("error",f),gr("load",f),E=C;break;case"details":gr("toggle",f),E=C;break;case"input":et(f,C),E=ft(f,C),gr("invalid",f);break;case"option":E=C;break;case"select":f._wrapperState={wasMultiple:!!C.multiple},E=H({},C,{value:void 0}),gr("invalid",f);break;case"textarea":In(f,C),E=Xt(f,C),gr("invalid",f);break;default:E=C}Ls(w,E),ne=E;for(F in ne)if(ne.hasOwnProperty(F)){var de=ne[F];F==="style"?pn(f,de):F==="dangerouslySetInnerHTML"?(de=de?de.__html:void 0,de!=null&&Pn(f,de)):F==="children"?typeof de=="string"?(w!=="textarea"||de!=="")&&dr(f,de):typeof de=="number"&&dr(f,""+de):F!=="suppressContentEditableWarning"&&F!=="suppressHydrationWarning"&&F!=="autoFocus"&&(s.hasOwnProperty(F)?de!=null&&F==="onScroll"&&gr("scroll",f):de!=null&&k(f,F,de,U))}switch(w){case"input":Be(f),gt(f,C,!1);break;case"textarea":Be(f),tt(f);break;case"option":C.value!=null&&f.setAttribute("value",""+we(C.value));break;case"select":f.multiple=!!C.multiple,F=C.value,F!=null?dn(f,!!C.multiple,F,!1):C.defaultValue!=null&&dn(f,!!C.multiple,C.defaultValue,!0);break;default:typeof E.onClick=="function"&&(f.onclick=Uw)}switch(w){case"button":case"input":case"select":case"textarea":C=!!C.autoFocus;break e;case"img":C=!0;break e;default:C=!1}}C&&(x.flags|=4)}x.ref!==null&&(x.flags|=512,x.flags|=2097152)}return ya(x),null;case 6:if(f&&x.stateNode!=null)Dz(f,x,f.memoizedProps,C);else{if(typeof C!="string"&&x.stateNode===null)throw Error(n(166));if(w=op(fb.current),op(vl.current),Yw(x)){if(C=x.stateNode,w=x.memoizedProps,C[bl]=x,(F=C.nodeValue!==w)&&(f=Oi,f!==null))switch(f.tag){case 3:Vw(C.nodeValue,w,(f.mode&1)!==0);break;case 5:f.memoizedProps.suppressHydrationWarning!==!0&&Vw(C.nodeValue,w,(f.mode&1)!==0)}F&&(x.flags|=4)}else C=(w.nodeType===9?w:w.ownerDocument).createTextNode(C),C[bl]=x,x.stateNode=C}return ya(x),null;case 13:if(yr(Ar),C=x.memoizedState,f===null||f.memoizedState!==null&&f.memoizedState.dehydrated!==null){if(Ir&&Mi!==null&&(x.mode&1)!==0&&(x.flags&128)===0)M4(),Bm(),x.flags|=98560,F=!1;else if(F=Yw(x),C!==null&&C.dehydrated!==null){if(f===null){if(!F)throw Error(n(318));if(F=x.memoizedState,F=F!==null?F.dehydrated:null,!F)throw Error(n(317));F[bl]=x}else Bm(),(x.flags&128)===0&&(x.memoizedState=null),x.flags|=4;ya(x),F=!1}else Do!==null&&(B$(Do),Do=null),F=!0;if(!F)return x.flags&65536?x:null}return(x.flags&128)!==0?(x.lanes=w,x):(C=C!==null,C!==(f!==null&&f.memoizedState!==null)&&C&&(x.child.flags|=8192,(x.mode&1)!==0&&(f===null||(Ar.current&1)!==0?ks===0&&(ks=3):U$())),x.updateQueue!==null&&(x.flags|=4),ya(x),null);case 4:return Gm(),E$(f,x),f===null&&ob(x.stateNode.containerInfo),ya(x),null;case 10:return r$(x.type._context),ya(x),null;case 17:return ai(x.type)&&jw(),ya(x),null;case 19:if(yr(Ar),F=x.memoizedState,F===null)return ya(x),null;if(C=(x.flags&128)!==0,U=F.rendering,U===null)if(C)bb(F,!1);else{if(ks!==0||f!==null&&(f.flags&128)!==0)for(f=x.child;f!==null;){if(U=nk(f),U!==null){for(x.flags|=128,bb(F,!1),C=U.updateQueue,C!==null&&(x.updateQueue=C,x.flags|=4),x.subtreeFlags=0,C=w,w=x.child;w!==null;)F=w,f=C,F.flags&=14680066,U=F.alternate,U===null?(F.childLanes=0,F.lanes=f,F.child=null,F.subtreeFlags=0,F.memoizedProps=null,F.memoizedState=null,F.updateQueue=null,F.dependencies=null,F.stateNode=null):(F.childLanes=U.childLanes,F.lanes=U.lanes,F.child=U.child,F.subtreeFlags=0,F.deletions=null,F.memoizedProps=U.memoizedProps,F.memoizedState=U.memoizedState,F.updateQueue=U.updateQueue,F.type=U.type,f=U.dependencies,F.dependencies=f===null?null:{lanes:f.lanes,firstContext:f.firstContext}),w=w.sibling;return pr(Ar,Ar.current&1|2),x.child}f=f.sibling}F.tail!==null&&Bn()>Km&&(x.flags|=128,C=!0,bb(F,!1),x.lanes=4194304)}else{if(!C)if(f=nk(U),f!==null){if(x.flags|=128,C=!0,w=f.updateQueue,w!==null&&(x.updateQueue=w,x.flags|=4),bb(F,!0),F.tail===null&&F.tailMode==="hidden"&&!U.alternate&&!Ir)return ya(x),null}else 2*Bn()-F.renderingStartTime>Km&&w!==1073741824&&(x.flags|=128,C=!0,bb(F,!1),x.lanes=4194304);F.isBackwards?(U.sibling=x.child,x.child=U):(w=F.last,w!==null?w.sibling=U:x.child=U,F.last=U)}return F.tail!==null?(x=F.tail,F.rendering=x,F.tail=x.sibling,F.renderingStartTime=Bn(),x.sibling=null,w=Ar.current,pr(Ar,C?w&1|2:w&1),x):(ya(x),null);case 22:case 23:return V$(),C=x.memoizedState!==null,f!==null&&f.memoizedState!==null!==C&&(x.flags|=8192),C&&(x.mode&1)!==0?(Li&1073741824)!==0&&(ya(x),x.subtreeFlags&6&&(x.flags|=8192)):ya(x),null;case 24:return null;case 25:return null}throw Error(n(156,x.tag))}function Eae(f,x){switch(ZT(x),x.tag){case 1:return ai(x.type)&&jw(),f=x.flags,f&65536?(x.flags=f&-65537|128,x):null;case 3:return Gm(),yr(si),yr(ma),c$(),f=x.flags,(f&65536)!==0&&(f&128)===0?(x.flags=f&-65537|128,x):null;case 5:return l$(x),null;case 13:if(yr(Ar),f=x.memoizedState,f!==null&&f.dehydrated!==null){if(x.alternate===null)throw Error(n(340));Bm()}return f=x.flags,f&65536?(x.flags=f&-65537|128,x):null;case 19:return yr(Ar),null;case 4:return Gm(),null;case 10:return r$(x.type._context),null;case 22:case 23:return V$(),null;case 24:return null;default:return null}}var dk=!1,xa=!1,_ae=typeof WeakSet=="function"?WeakSet:Set,xt=null;function Hm(f,x){var w=f.ref;if(w!==null)if(typeof w=="function")try{w(null)}catch(C){Or(f,x,C)}else w.current=null}function _$(f,x,w){try{w()}catch(C){Or(f,x,C)}}var Fz=!1;function Aae(f,x){if(VT=Bs,f=p4(),FT(f)){if("selectionStart"in f)var w={start:f.selectionStart,end:f.selectionEnd};else e:{w=(w=f.ownerDocument)&&w.defaultView||window;var C=w.getSelection&&w.getSelection();if(C&&C.rangeCount!==0){w=C.anchorNode;var E=C.anchorOffset,F=C.focusNode;C=C.focusOffset;try{w.nodeType,F.nodeType}catch{w=null;break e}var U=0,ne=-1,de=-1,Ee=0,Ge=0,qe=f,Ue=null;t:for(;;){for(var mt;qe!==w||E!==0&&qe.nodeType!==3||(ne=U+E),qe!==F||C!==0&&qe.nodeType!==3||(de=U+C),qe.nodeType===3&&(U+=qe.nodeValue.length),(mt=qe.firstChild)!==null;)Ue=qe,qe=mt;for(;;){if(qe===f)break t;if(Ue===w&&++Ee===E&&(ne=U),Ue===F&&++Ge===C&&(de=U),(mt=qe.nextSibling)!==null)break;qe=Ue,Ue=qe.parentNode}qe=mt}w=ne===-1||de===-1?null:{start:ne,end:de}}else w=null}w=w||{start:0,end:0}}else w=null;for(UT={focusedElem:f,selectionRange:w},Bs=!1,xt=x;xt!==null;)if(x=xt,f=x.child,(x.subtreeFlags&1028)!==0&&f!==null)f.return=x,xt=f;else for(;xt!==null;){x=xt;try{var kt=x.alternate;if((x.flags&1024)!==0)switch(x.tag){case 0:case 11:case 15:break;case 1:if(kt!==null){var Ct=kt.memoizedProps,jr=kt.memoizedState,Ce=x.stateNode,ge=Ce.getSnapshotBeforeUpdate(x.elementType===x.type?Ct:Fo(x.type,Ct),jr);Ce.__reactInternalSnapshotBeforeUpdate=ge}break;case 3:var Te=x.stateNode.containerInfo;Te.nodeType===1?Te.textContent="":Te.nodeType===9&&Te.documentElement&&Te.removeChild(Te.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(n(163))}}catch(Ye){Or(x,x.return,Ye)}if(f=x.sibling,f!==null){f.return=x.return,xt=f;break}xt=x.return}return kt=Fz,Fz=!1,kt}function vb(f,x,w){var C=x.updateQueue;if(C=C!==null?C.lastEffect:null,C!==null){var E=C=C.next;do{if((E.tag&f)===f){var F=E.destroy;E.destroy=void 0,F!==void 0&&_$(x,w,F)}E=E.next}while(E!==C)}}function pk(f,x){if(x=x.updateQueue,x=x!==null?x.lastEffect:null,x!==null){var w=x=x.next;do{if((w.tag&f)===f){var C=w.create;w.destroy=C()}w=w.next}while(w!==x)}}function A$(f){var x=f.ref;if(x!==null){var w=f.stateNode;switch(f.tag){case 5:f=w;break;default:f=w}typeof x=="function"?x(f):x.current=f}}function Oz(f){var x=f.alternate;x!==null&&(f.alternate=null,Oz(x)),f.child=null,f.deletions=null,f.sibling=null,f.tag===5&&(x=f.stateNode,x!==null&&(delete x[bl],delete x[ub],delete x[qT],delete x[hae],delete x[fae])),f.stateNode=null,f.return=null,f.dependencies=null,f.memoizedProps=null,f.memoizedState=null,f.pendingProps=null,f.stateNode=null,f.updateQueue=null}function Mz(f){return f.tag===5||f.tag===3||f.tag===4}function Lz(f){e:for(;;){for(;f.sibling===null;){if(f.return===null||Mz(f.return))return null;f=f.return}for(f.sibling.return=f.return,f=f.sibling;f.tag!==5&&f.tag!==6&&f.tag!==18;){if(f.flags&2||f.child===null||f.tag===4)continue e;f.child.return=f,f=f.child}if(!(f.flags&2))return f.stateNode}}function R$(f,x,w){var C=f.tag;if(C===5||C===6)f=f.stateNode,x?w.nodeType===8?w.parentNode.insertBefore(f,x):w.insertBefore(f,x):(w.nodeType===8?(x=w.parentNode,x.insertBefore(f,w)):(x=w,x.appendChild(f)),w=w._reactRootContainer,w!=null||x.onclick!==null||(x.onclick=Uw));else if(C!==4&&(f=f.child,f!==null))for(R$(f,x,w),f=f.sibling;f!==null;)R$(f,x,w),f=f.sibling}function D$(f,x,w){var C=f.tag;if(C===5||C===6)f=f.stateNode,x?w.insertBefore(f,x):w.appendChild(f);else if(C!==4&&(f=f.child,f!==null))for(D$(f,x,w),f=f.sibling;f!==null;)D$(f,x,w),f=f.sibling}var ta=null,Oo=!1;function xc(f,x,w){for(w=w.child;w!==null;)Pz(f,x,w),w=w.sibling}function Pz(f,x,w){if(eo&&typeof eo.onCommitFiberUnmount=="function")try{eo.onCommitFiberUnmount(sc,w)}catch{}switch(w.tag){case 5:xa||Hm(w,x);case 6:var C=ta,E=Oo;ta=null,xc(f,x,w),ta=C,Oo=E,ta!==null&&(Oo?(f=ta,w=w.stateNode,f.nodeType===8?f.parentNode.removeChild(w):f.removeChild(w)):ta.removeChild(w.stateNode));break;case 18:ta!==null&&(Oo?(f=ta,w=w.stateNode,f.nodeType===8?HT(f.parentNode,w):f.nodeType===1&&HT(f,w),mu(f)):HT(ta,w.stateNode));break;case 4:C=ta,E=Oo,ta=w.stateNode.containerInfo,Oo=!0,xc(f,x,w),ta=C,Oo=E;break;case 0:case 11:case 14:case 15:if(!xa&&(C=w.updateQueue,C!==null&&(C=C.lastEffect,C!==null))){E=C=C.next;do{var F=E,U=F.destroy;F=F.tag,U!==void 0&&((F&2)!==0||(F&4)!==0)&&_$(w,x,U),E=E.next}while(E!==C)}xc(f,x,w);break;case 1:if(!xa&&(Hm(w,x),C=w.stateNode,typeof C.componentWillUnmount=="function"))try{C.props=w.memoizedProps,C.state=w.memoizedState,C.componentWillUnmount()}catch(ne){Or(w,x,ne)}xc(f,x,w);break;case 21:xc(f,x,w);break;case 22:w.mode&1?(xa=(C=xa)||w.memoizedState!==null,xc(f,x,w),xa=C):xc(f,x,w);break;default:xc(f,x,w)}}function zz(f){var x=f.updateQueue;if(x!==null){f.updateQueue=null;var w=f.stateNode;w===null&&(w=f.stateNode=new _ae),x.forEach(function(C){var E=Bae.bind(null,f,C);w.has(C)||(w.add(C),C.then(E,E))})}}function Mo(f,x){var w=x.deletions;if(w!==null)for(var C=0;C<w.length;C++){var E=w[C];try{var F=f,U=x,ne=U;e:for(;ne!==null;){switch(ne.tag){case 5:ta=ne.stateNode,Oo=!1;break e;case 3:ta=ne.stateNode.containerInfo,Oo=!0;break e;case 4:ta=ne.stateNode.containerInfo,Oo=!0;break e}ne=ne.return}if(ta===null)throw Error(n(160));Pz(F,U,E),ta=null,Oo=!1;var de=E.alternate;de!==null&&(de.return=null),E.return=null}catch(Ee){Or(E,x,Ee)}}if(x.subtreeFlags&12854)for(x=x.child;x!==null;)Bz(x,f),x=x.sibling}function Bz(f,x){var w=f.alternate,C=f.flags;switch(f.tag){case 0:case 11:case 14:case 15:if(Mo(x,f),kl(f),C&4){try{vb(3,f,f.return),pk(3,f)}catch(Ct){Or(f,f.return,Ct)}try{vb(5,f,f.return)}catch(Ct){Or(f,f.return,Ct)}}break;case 1:Mo(x,f),kl(f),C&512&&w!==null&&Hm(w,w.return);break;case 5:if(Mo(x,f),kl(f),C&512&&w!==null&&Hm(w,w.return),f.flags&32){var E=f.stateNode;try{dr(E,"")}catch(Ct){Or(f,f.return,Ct)}}if(C&4&&(E=f.stateNode,E!=null)){var F=f.memoizedProps,U=w!==null?w.memoizedProps:F,ne=f.type,de=f.updateQueue;if(f.updateQueue=null,de!==null)try{ne==="input"&&F.type==="radio"&&F.name!=null&&Qe(E,F),vs(ne,U);var Ee=vs(ne,F);for(U=0;U<de.length;U+=2){var Ge=de[U],qe=de[U+1];Ge==="style"?pn(E,qe):Ge==="dangerouslySetInnerHTML"?Pn(E,qe):Ge==="children"?dr(E,qe):k(E,Ge,qe,Ee)}switch(ne){case"input":ot(E,F);break;case"textarea":Ve(E,F);break;case"select":var Ue=E._wrapperState.wasMultiple;E._wrapperState.wasMultiple=!!F.multiple;var mt=F.value;mt!=null?dn(E,!!F.multiple,mt,!1):Ue!==!!F.multiple&&(F.defaultValue!=null?dn(E,!!F.multiple,F.defaultValue,!0):dn(E,!!F.multiple,F.multiple?[]:"",!1))}E[ub]=F}catch(Ct){Or(f,f.return,Ct)}}break;case 6:if(Mo(x,f),kl(f),C&4){if(f.stateNode===null)throw Error(n(162));E=f.stateNode,F=f.memoizedProps;try{E.nodeValue=F}catch(Ct){Or(f,f.return,Ct)}}break;case 3:if(Mo(x,f),kl(f),C&4&&w!==null&&w.memoizedState.isDehydrated)try{mu(x.containerInfo)}catch(Ct){Or(f,f.return,Ct)}break;case 4:Mo(x,f),kl(f);break;case 13:Mo(x,f),kl(f),E=f.child,E.flags&8192&&(F=E.memoizedState!==null,E.stateNode.isHidden=F,!F||E.alternate!==null&&E.alternate.memoizedState!==null||(M$=Bn())),C&4&&zz(f);break;case 22:if(Ge=w!==null&&w.memoizedState!==null,f.mode&1?(xa=(Ee=xa)||Ge,Mo(x,f),xa=Ee):Mo(x,f),kl(f),C&8192){if(Ee=f.memoizedState!==null,(f.stateNode.isHidden=Ee)&&!Ge&&(f.mode&1)!==0)for(xt=f,Ge=f.child;Ge!==null;){for(qe=xt=Ge;xt!==null;){switch(Ue=xt,mt=Ue.child,Ue.tag){case 0:case 11:case 14:case 15:vb(4,Ue,Ue.return);break;case 1:Hm(Ue,Ue.return);var kt=Ue.stateNode;if(typeof kt.componentWillUnmount=="function"){C=Ue,w=Ue.return;try{x=C,kt.props=x.memoizedProps,kt.state=x.memoizedState,kt.componentWillUnmount()}catch(Ct){Or(C,w,Ct)}}break;case 5:Hm(Ue,Ue.return);break;case 22:if(Ue.memoizedState!==null){Uz(qe);continue}}mt!==null?(mt.return=Ue,xt=mt):Uz(qe)}Ge=Ge.sibling}e:for(Ge=null,qe=f;;){if(qe.tag===5){if(Ge===null){Ge=qe;try{E=qe.stateNode,Ee?(F=E.style,typeof F.setProperty=="function"?F.setProperty("display","none","important"):F.display="none"):(ne=qe.stateNode,de=qe.memoizedProps.style,U=de!=null&&de.hasOwnProperty("display")?de.display:null,ne.style.display=Sn("display",U))}catch(Ct){Or(f,f.return,Ct)}}}else if(qe.tag===6){if(Ge===null)try{qe.stateNode.nodeValue=Ee?"":qe.memoizedProps}catch(Ct){Or(f,f.return,Ct)}}else if((qe.tag!==22&&qe.tag!==23||qe.memoizedState===null||qe===f)&&qe.child!==null){qe.child.return=qe,qe=qe.child;continue}if(qe===f)break e;for(;qe.sibling===null;){if(qe.return===null||qe.return===f)break e;Ge===qe&&(Ge=null),qe=qe.return}Ge===qe&&(Ge=null),qe.sibling.return=qe.return,qe=qe.sibling}}break;case 19:Mo(x,f),kl(f),C&4&&zz(f);break;case 21:break;default:Mo(x,f),kl(f)}}function kl(f){var x=f.flags;if(x&2){try{e:{for(var w=f.return;w!==null;){if(Mz(w)){var C=w;break e}w=w.return}throw Error(n(160))}switch(C.tag){case 5:var E=C.stateNode;C.flags&32&&(dr(E,""),C.flags&=-33);var F=Lz(f);D$(f,F,E);break;case 3:case 4:var U=C.stateNode.containerInfo,ne=Lz(f);R$(f,ne,U);break;default:throw Error(n(161))}}catch(de){Or(f,f.return,de)}f.flags&=-3}x&4096&&(f.flags&=-4097)}function Rae(f,x,w){xt=f,Wz(f)}function Wz(f,x,w){for(var C=(f.mode&1)!==0;xt!==null;){var E=xt,F=E.child;if(E.tag===22&&C){var U=E.memoizedState!==null||dk;if(!U){var ne=E.alternate,de=ne!==null&&ne.memoizedState!==null||xa;ne=dk;var Ee=xa;if(dk=U,(xa=de)&&!Ee)for(xt=E;xt!==null;)U=xt,de=U.child,U.tag===22&&U.memoizedState!==null?Gz(E):de!==null?(de.return=U,xt=de):Gz(E);for(;F!==null;)xt=F,Wz(F),F=F.sibling;xt=E,dk=ne,xa=Ee}Vz(f)}else(E.subtreeFlags&8772)!==0&&F!==null?(F.return=E,xt=F):Vz(f)}}function Vz(f){for(;xt!==null;){var x=xt;if((x.flags&8772)!==0){var w=x.alternate;try{if((x.flags&8772)!==0)switch(x.tag){case 0:case 11:case 15:xa||pk(5,x);break;case 1:var C=x.stateNode;if(x.flags&4&&!xa)if(w===null)C.componentDidMount();else{var E=x.elementType===x.type?w.memoizedProps:Fo(x.type,w.memoizedProps);C.componentDidUpdate(E,w.memoizedState,C.__reactInternalSnapshotBeforeUpdate)}var F=x.updateQueue;F!==null&&U4(x,F,C);break;case 3:var U=x.updateQueue;if(U!==null){if(w=null,x.child!==null)switch(x.child.tag){case 5:w=x.child.stateNode;break;case 1:w=x.child.stateNode}U4(x,U,w)}break;case 5:var ne=x.stateNode;if(w===null&&x.flags&4){w=ne;var de=x.memoizedProps;switch(x.type){case"button":case"input":case"select":case"textarea":de.autoFocus&&w.focus();break;case"img":de.src&&(w.src=de.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(x.memoizedState===null){var Ee=x.alternate;if(Ee!==null){var Ge=Ee.memoizedState;if(Ge!==null){var qe=Ge.dehydrated;qe!==null&&mu(qe)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(n(163))}xa||x.flags&512&&A$(x)}catch(Ue){Or(x,x.return,Ue)}}if(x===f){xt=null;break}if(w=x.sibling,w!==null){w.return=x.return,xt=w;break}xt=x.return}}function Uz(f){for(;xt!==null;){var x=xt;if(x===f){xt=null;break}var w=x.sibling;if(w!==null){w.return=x.return,xt=w;break}xt=x.return}}function Gz(f){for(;xt!==null;){var x=xt;try{switch(x.tag){case 0:case 11:case 15:var w=x.return;try{pk(4,x)}catch(de){Or(x,w,de)}break;case 1:var C=x.stateNode;if(typeof C.componentDidMount=="function"){var E=x.return;try{C.componentDidMount()}catch(de){Or(x,E,de)}}var F=x.return;try{A$(x)}catch(de){Or(x,F,de)}break;case 5:var U=x.return;try{A$(x)}catch(de){Or(x,U,de)}}}catch(de){Or(x,x.return,de)}if(x===f){xt=null;break}var ne=x.sibling;if(ne!==null){ne.return=x.return,xt=ne;break}xt=x.return}}var Dae=Math.ceil,hk=I.ReactCurrentDispatcher,F$=I.ReactCurrentOwner,ao=I.ReactCurrentBatchConfig,$n=0,Vs=null,is=null,na=0,Li=0,qm=hc(0),ks=0,wb=null,up=0,fk=0,O$=0,kb=null,oi=null,M$=0,Km=1/0,Iu=null,mk=!1,L$=null,bc=null,gk=!1,vc=null,yk=0,Ib=0,P$=null,xk=-1,bk=0;function Ba(){return($n&6)!==0?Bn():xk!==-1?xk:xk=Bn()}function wc(f){return(f.mode&1)===0?1:($n&2)!==0&&na!==0?na&-na:gae.transition!==null?(bk===0&&(bk=Ew()),bk):(f=En,f!==0||(f=window.event,f=f===void 0?16:HP(f.type)),f)}function Lo(f,x,w,C){if(50<Ib)throw Ib=0,P$=null,Error(n(185));yl(f,w,C),(($n&2)===0||f!==Vs)&&(f===Vs&&(($n&2)===0&&(fk|=w),ks===4&&kc(f,na)),li(f,C),w===1&&$n===0&&(x.mode&1)===0&&(Km=Bn()+500,qw&&mc()))}function li(f,x){var w=f.callbackNode;kT(f,x);var C=Jd(f,f===Vs?na:0);if(C===0)w!==null&&fn(w),f.callbackNode=null,f.callbackPriority=0;else if(x=C&-C,f.callbackPriority!==x){if(w!=null&&fn(w),x===1)f.tag===0?mae(Hz.bind(null,f)):A4(Hz.bind(null,f)),dae(function(){($n&6)===0&&mc()}),w=null;else{switch(Nm(C)){case 1:w=_o;break;case 4:w=Nw;break;case 16:w=wm;break;case 536870912:w=fu;break;default:w=wm}w=eB(w,jz.bind(null,f))}f.callbackPriority=x,f.callbackNode=w}}function jz(f,x){if(xk=-1,bk=0,($n&6)!==0)throw Error(n(327));var w=f.callbackNode;if(Xm()&&f.callbackNode!==w)return null;var C=Jd(f,f===Vs?na:0);if(C===0)return null;if((C&30)!==0||(C&f.expiredLanes)!==0||x)x=vk(f,C);else{x=C;var E=$n;$n|=2;var F=Kz();(Vs!==f||na!==x)&&(Iu=null,Km=Bn()+500,dp(f,x));do try{Mae();break}catch(ne){qz(f,ne)}while(!0);n$(),hk.current=F,$n=E,is!==null?x=0:(Vs=null,na=0,x=ks)}if(x!==0){if(x===2&&(E=Zx(f),E!==0&&(C=E,x=z$(f,E))),x===1)throw w=wb,dp(f,0),kc(f,C),li(f,Bn()),w;if(x===6)kc(f,C);else{if(E=f.current.alternate,(C&30)===0&&!Fae(E)&&(x=vk(f,C),x===2&&(F=Zx(f),F!==0&&(C=F,x=z$(f,F))),x===1))throw w=wb,dp(f,0),kc(f,C),li(f,Bn()),w;switch(f.finishedWork=E,f.finishedLanes=C,x){case 0:case 1:throw Error(n(345));case 2:pp(f,oi,Iu);break;case 3:if(kc(f,C),(C&130023424)===C&&(x=M$+500-Bn(),10<x)){if(Jd(f,0)!==0)break;if(E=f.suspendedLanes,(E&C)!==C){Ba(),f.pingedLanes|=f.suspendedLanes&E;break}f.timeoutHandle=jT(pp.bind(null,f,oi,Iu),x);break}pp(f,oi,Iu);break;case 4:if(kc(f,C),(C&4194240)===C)break;for(x=f.eventTimes,E=-1;0<C;){var U=31-Ai(C);F=1<<U,U=x[U],U>E&&(E=U),C&=~F}if(C=E,C=Bn()-C,C=(120>C?120:480>C?480:1080>C?1080:1920>C?1920:3e3>C?3e3:4320>C?4320:1960*Dae(C/1960))-C,10<C){f.timeoutHandle=jT(pp.bind(null,f,oi,Iu),C);break}pp(f,oi,Iu);break;case 5:pp(f,oi,Iu);break;default:throw Error(n(329))}}}return li(f,Bn()),f.callbackNode===w?jz.bind(null,f):null}function z$(f,x){var w=kb;return f.current.memoizedState.isDehydrated&&(dp(f,x).flags|=256),f=vk(f,x),f!==2&&(x=oi,oi=w,x!==null&&B$(x)),f}function B$(f){oi===null?oi=f:oi.push.apply(oi,f)}function Fae(f){for(var x=f;;){if(x.flags&16384){var w=x.updateQueue;if(w!==null&&(w=w.stores,w!==null))for(var C=0;C<w.length;C++){var E=w[C],F=E.getSnapshot;E=E.value;try{if(!Ro(F(),E))return!1}catch{return!1}}}if(w=x.child,x.subtreeFlags&16384&&w!==null)w.return=x,x=w;else{if(x===f)break;for(;x.sibling===null;){if(x.return===null||x.return===f)return!0;x=x.return}x.sibling.return=x.return,x=x.sibling}}return!0}function kc(f,x){for(x&=~O$,x&=~fk,f.suspendedLanes|=x,f.pingedLanes&=~x,f=f.expirationTimes;0<x;){var w=31-Ai(x),C=1<<w;f[w]=-1,x&=~C}}function Hz(f){if(($n&6)!==0)throw Error(n(327));Xm();var x=Jd(f,0);if((x&1)===0)return li(f,Bn()),null;var w=vk(f,x);if(f.tag!==0&&w===2){var C=Zx(f);C!==0&&(x=C,w=z$(f,C))}if(w===1)throw w=wb,dp(f,0),kc(f,x),li(f,Bn()),w;if(w===6)throw Error(n(345));return f.finishedWork=f.current.alternate,f.finishedLanes=x,pp(f,oi,Iu),li(f,Bn()),null}function W$(f,x){var w=$n;$n|=1;try{return f(x)}finally{$n=w,$n===0&&(Km=Bn()+500,qw&&mc())}}function cp(f){vc!==null&&vc.tag===0&&($n&6)===0&&Xm();var x=$n;$n|=1;var w=ao.transition,C=En;try{if(ao.transition=null,En=1,f)return f()}finally{En=C,ao.transition=w,$n=x,($n&6)===0&&mc()}}function V$(){Li=qm.current,yr(qm)}function dp(f,x){f.finishedWork=null,f.finishedLanes=0;var w=f.timeoutHandle;if(w!==-1&&(f.timeoutHandle=-1,cae(w)),is!==null)for(w=is.return;w!==null;){var C=w;switch(ZT(C),C.tag){case 1:C=C.type.childContextTypes,C!=null&&jw();break;case 3:Gm(),yr(si),yr(ma),c$();break;case 5:l$(C);break;case 4:Gm();break;case 13:yr(Ar);break;case 19:yr(Ar);break;case 10:r$(C.type._context);break;case 22:case 23:V$()}w=w.return}if(Vs=f,is=f=Ic(f.current,null),na=Li=x,ks=0,wb=null,O$=fk=up=0,oi=kb=null,ip!==null){for(x=0;x<ip.length;x++)if(w=ip[x],C=w.interleaved,C!==null){w.interleaved=null;var E=C.next,F=w.pending;if(F!==null){var U=F.next;F.next=E,C.next=U}w.pending=C}ip=null}return f}function qz(f,x){do{var w=is;try{if(n$(),rk.current=ok,sk){for(var C=Rr.memoizedState;C!==null;){var E=C.queue;E!==null&&(E.pending=null),C=C.next}sk=!1}if(lp=0,Ws=ws=Rr=null,mb=!1,gb=0,F$.current=null,w===null||w.return===null){ks=1,wb=x,is=null;break}e:{var F=f,U=w.return,ne=w,de=x;if(x=na,ne.flags|=32768,de!==null&&typeof de=="object"&&typeof de.then=="function"){var Ee=de,Ge=ne,qe=Ge.tag;if((Ge.mode&1)===0&&(qe===0||qe===11||qe===15)){var Ue=Ge.alternate;Ue?(Ge.updateQueue=Ue.updateQueue,Ge.memoizedState=Ue.memoizedState,Ge.lanes=Ue.lanes):(Ge.updateQueue=null,Ge.memoizedState=null)}var mt=xz(U);if(mt!==null){mt.flags&=-257,bz(mt,U,ne,F,x),mt.mode&1&&yz(F,Ee,x),x=mt,de=Ee;var kt=x.updateQueue;if(kt===null){var Ct=new Set;Ct.add(de),x.updateQueue=Ct}else kt.add(de);break e}else{if((x&1)===0){yz(F,Ee,x),U$();break e}de=Error(n(426))}}else if(Ir&&ne.mode&1){var jr=xz(U);if(jr!==null){(jr.flags&65536)===0&&(jr.flags|=256),bz(jr,U,ne,F,x),e$(jm(de,ne));break e}}F=de=jm(de,ne),ks!==4&&(ks=2),kb===null?kb=[F]:kb.push(F),F=U;do{switch(F.tag){case 3:F.flags|=65536,x&=-x,F.lanes|=x;var Ce=mz(F,de,x);V4(F,Ce);break e;case 1:ne=de;var ge=F.type,Te=F.stateNode;if((F.flags&128)===0&&(typeof ge.getDerivedStateFromError=="function"||Te!==null&&typeof Te.componentDidCatch=="function"&&(bc===null||!bc.has(Te)))){F.flags|=65536,x&=-x,F.lanes|=x;var Ye=gz(F,ne,x);V4(F,Ye);break e}}F=F.return}while(F!==null)}Yz(w)}catch($t){x=$t,is===w&&w!==null&&(is=w=w.return);continue}break}while(!0)}function Kz(){var f=hk.current;return hk.current=ok,f===null?ok:f}function U$(){(ks===0||ks===3||ks===2)&&(ks=4),Vs===null||(up&268435455)===0&&(fk&268435455)===0||kc(Vs,na)}function vk(f,x){var w=$n;$n|=2;var C=Kz();(Vs!==f||na!==x)&&(Iu=null,dp(f,x));do try{Oae();break}catch(E){qz(f,E)}while(!0);if(n$(),$n=w,hk.current=C,is!==null)throw Error(n(261));return Vs=null,na=0,ks}function Oae(){for(;is!==null;)Xz(is)}function Mae(){for(;is!==null&&!_i();)Xz(is)}function Xz(f){var x=Qz(f.alternate,f,Li);f.memoizedProps=f.pendingProps,x===null?Yz(f):is=x,F$.current=null}function Yz(f){var x=f;do{var w=x.alternate;if(f=x.return,(x.flags&32768)===0){if(w=$ae(w,x,Li),w!==null){is=w;return}}else{if(w=Eae(w,x),w!==null){w.flags&=32767,is=w;return}if(f!==null)f.flags|=32768,f.subtreeFlags=0,f.deletions=null;else{ks=6,is=null;return}}if(x=x.sibling,x!==null){is=x;return}is=x=f}while(x!==null);ks===0&&(ks=5)}function pp(f,x,w){var C=En,E=ao.transition;try{ao.transition=null,En=1,Lae(f,x,w,C)}finally{ao.transition=E,En=C}return null}function Lae(f,x,w,C){do Xm();while(vc!==null);if(($n&6)!==0)throw Error(n(327));w=f.finishedWork;var E=f.finishedLanes;if(w===null)return null;if(f.finishedWork=null,f.finishedLanes=0,w===f.current)throw Error(n(177));f.callbackNode=null,f.callbackPriority=0;var F=w.lanes|w.childLanes;if(_w(f,F),f===Vs&&(is=Vs=null,na=0),(w.subtreeFlags&2064)===0&&(w.flags&2064)===0||gk||(gk=!0,eB(wm,function(){return Xm(),null})),F=(w.flags&15990)!==0,(w.subtreeFlags&15990)!==0||F){F=ao.transition,ao.transition=null;var U=En;En=1;var ne=$n;$n|=4,F$.current=null,Aae(f,w),Bz(w,f),rae(UT),Bs=!!VT,UT=VT=null,f.current=w,Rae(w),Zd(),$n=ne,En=U,ao.transition=F}else f.current=w;if(gk&&(gk=!1,vc=f,yk=E),F=f.pendingLanes,F===0&&(bc=null),bT(w.stateNode),li(f,Bn()),x!==null)for(C=f.onRecoverableError,w=0;w<x.length;w++)E=x[w],C(E.value,{componentStack:E.stack,digest:E.digest});if(mk)throw mk=!1,f=L$,L$=null,f;return(yk&1)!==0&&f.tag!==0&&Xm(),F=f.pendingLanes,(F&1)!==0?f===P$?Ib++:(Ib=0,P$=f):Ib=0,mc(),null}function Xm(){if(vc!==null){var f=Nm(yk),x=ao.transition,w=En;try{if(ao.transition=null,En=16>f?16:f,vc===null)var C=!1;else{if(f=vc,vc=null,yk=0,($n&6)!==0)throw Error(n(331));var E=$n;for($n|=4,xt=f.current;xt!==null;){var F=xt,U=F.child;if((xt.flags&16)!==0){var ne=F.deletions;if(ne!==null){for(var de=0;de<ne.length;de++){var Ee=ne[de];for(xt=Ee;xt!==null;){var Ge=xt;switch(Ge.tag){case 0:case 11:case 15:vb(8,Ge,F)}var qe=Ge.child;if(qe!==null)qe.return=Ge,xt=qe;else for(;xt!==null;){Ge=xt;var Ue=Ge.sibling,mt=Ge.return;if(Oz(Ge),Ge===Ee){xt=null;break}if(Ue!==null){Ue.return=mt,xt=Ue;break}xt=mt}}}var kt=F.alternate;if(kt!==null){var Ct=kt.child;if(Ct!==null){kt.child=null;do{var jr=Ct.sibling;Ct.sibling=null,Ct=jr}while(Ct!==null)}}xt=F}}if((F.subtreeFlags&2064)!==0&&U!==null)U.return=F,xt=U;else e:for(;xt!==null;){if(F=xt,(F.flags&2048)!==0)switch(F.tag){case 0:case 11:case 15:vb(9,F,F.return)}var Ce=F.sibling;if(Ce!==null){Ce.return=F.return,xt=Ce;break e}xt=F.return}}var ge=f.current;for(xt=ge;xt!==null;){U=xt;var Te=U.child;if((U.subtreeFlags&2064)!==0&&Te!==null)Te.return=U,xt=Te;else e:for(U=ge;xt!==null;){if(ne=xt,(ne.flags&2048)!==0)try{switch(ne.tag){case 0:case 11:case 15:pk(9,ne)}}catch($t){Or(ne,ne.return,$t)}if(ne===U){xt=null;break e}var Ye=ne.sibling;if(Ye!==null){Ye.return=ne.return,xt=Ye;break e}xt=ne.return}}if($n=E,mc(),eo&&typeof eo.onPostCommitFiberRoot=="function")try{eo.onPostCommitFiberRoot(sc,f)}catch{}C=!0}return C}finally{En=w,ao.transition=x}}return!1}function Zz(f,x,w){x=jm(w,x),x=mz(f,x,1),f=yc(f,x,1),x=Ba(),f!==null&&(yl(f,1,x),li(f,x))}function Or(f,x,w){if(f.tag===3)Zz(f,f,w);else for(;x!==null;){if(x.tag===3){Zz(x,f,w);break}else if(x.tag===1){var C=x.stateNode;if(typeof x.type.getDerivedStateFromError=="function"||typeof C.componentDidCatch=="function"&&(bc===null||!bc.has(C))){f=jm(w,f),f=gz(x,f,1),x=yc(x,f,1),f=Ba(),x!==null&&(yl(x,1,f),li(x,f));break}}x=x.return}}function Pae(f,x,w){var C=f.pingCache;C!==null&&C.delete(x),x=Ba(),f.pingedLanes|=f.suspendedLanes&w,Vs===f&&(na&w)===w&&(ks===4||ks===3&&(na&130023424)===na&&500>Bn()-M$?dp(f,0):O$|=w),li(f,x)}function Jz(f,x){x===0&&((f.mode&1)===0?x=1:(x=Im,Im<<=1,(Im&130023424)===0&&(Im=4194304)));var w=Ba();f=vu(f,x),f!==null&&(yl(f,x,w),li(f,w))}function zae(f){var x=f.memoizedState,w=0;x!==null&&(w=x.retryLane),Jz(f,w)}function Bae(f,x){var w=0;switch(f.tag){case 13:var C=f.stateNode,E=f.memoizedState;E!==null&&(w=E.retryLane);break;case 19:C=f.stateNode;break;default:throw Error(n(314))}C!==null&&C.delete(x),Jz(f,w)}var Qz;Qz=function(f,x,w){if(f!==null)if(f.memoizedProps!==x.pendingProps||si.current)ii=!0;else{if((f.lanes&w)===0&&(x.flags&128)===0)return ii=!1,Tae(f,x,w);ii=(f.flags&131072)!==0}else ii=!1,Ir&&(x.flags&1048576)!==0&&R4(x,Xw,x.index);switch(x.lanes=0,x.tag){case 2:var C=x.type;ck(f,x),f=x.pendingProps;var E=Lm(x,ma.current);Um(x,w),E=h$(null,x,C,f,E,w);var F=f$();return x.flags|=1,typeof E=="object"&&E!==null&&typeof E.render=="function"&&E.$$typeof===void 0?(x.tag=1,x.memoizedState=null,x.updateQueue=null,ai(C)?(F=!0,Hw(x)):F=!1,x.memoizedState=E.state!==null&&E.state!==void 0?E.state:null,i$(x),E.updater=lk,x.stateNode=E,E._reactInternals=x,v$(x,C,f,w),x=S$(null,x,C,!0,F,w)):(x.tag=0,Ir&&F&&YT(x),za(null,x,E,w),x=x.child),x;case 16:C=x.elementType;e:{switch(ck(f,x),f=x.pendingProps,E=C._init,C=E(C._payload),x.type=C,E=x.tag=Vae(C),f=Fo(C,f),E){case 0:x=I$(null,x,C,f,w);break e;case 1:x=Cz(null,x,C,f,w);break e;case 11:x=vz(null,x,C,f,w);break e;case 14:x=wz(null,x,C,Fo(C.type,f),w);break e}throw Error(n(306,C,""))}return x;case 0:return C=x.type,E=x.pendingProps,E=x.elementType===C?E:Fo(C,E),I$(f,x,C,E,w);case 1:return C=x.type,E=x.pendingProps,E=x.elementType===C?E:Fo(C,E),Cz(f,x,C,E,w);case 3:e:{if(Nz(x),f===null)throw Error(n(387));C=x.pendingProps,F=x.memoizedState,E=F.element,W4(f,x),tk(x,C,null,w);var U=x.memoizedState;if(C=U.element,F.isDehydrated)if(F={element:C,isDehydrated:!1,cache:U.cache,pendingSuspenseBoundaries:U.pendingSuspenseBoundaries,transitions:U.transitions},x.updateQueue.baseState=F,x.memoizedState=F,x.flags&256){E=jm(Error(n(423)),x),x=Tz(f,x,C,w,E);break e}else if(C!==E){E=jm(Error(n(424)),x),x=Tz(f,x,C,w,E);break e}else for(Mi=pc(x.stateNode.containerInfo.firstChild),Oi=x,Ir=!0,Do=null,w=z4(x,null,C,w),x.child=w;w;)w.flags=w.flags&-3|4096,w=w.sibling;else{if(Bm(),C===E){x=ku(f,x,w);break e}za(f,x,C,w)}x=x.child}return x;case 5:return G4(x),f===null&&QT(x),C=x.type,E=x.pendingProps,F=f!==null?f.memoizedProps:null,U=E.children,GT(C,E)?U=null:F!==null&&GT(C,F)&&(x.flags|=32),Sz(f,x),za(f,x,U,w),x.child;case 6:return f===null&&QT(x),null;case 13:return $z(f,x,w);case 4:return o$(x,x.stateNode.containerInfo),C=x.pendingProps,f===null?x.child=Wm(x,null,C,w):za(f,x,C,w),x.child;case 11:return C=x.type,E=x.pendingProps,E=x.elementType===C?E:Fo(C,E),vz(f,x,C,E,w);case 7:return za(f,x,x.pendingProps,w),x.child;case 8:return za(f,x,x.pendingProps.children,w),x.child;case 12:return za(f,x,x.pendingProps.children,w),x.child;case 10:e:{if(C=x.type._context,E=x.pendingProps,F=x.memoizedProps,U=E.value,pr(Jw,C._currentValue),C._currentValue=U,F!==null)if(Ro(F.value,U)){if(F.children===E.children&&!si.current){x=ku(f,x,w);break e}}else for(F=x.child,F!==null&&(F.return=x);F!==null;){var ne=F.dependencies;if(ne!==null){U=F.child;for(var de=ne.firstContext;de!==null;){if(de.context===C){if(F.tag===1){de=wu(-1,w&-w),de.tag=2;var Ee=F.updateQueue;if(Ee!==null){Ee=Ee.shared;var Ge=Ee.pending;Ge===null?de.next=de:(de.next=Ge.next,Ge.next=de),Ee.pending=de}}F.lanes|=w,de=F.alternate,de!==null&&(de.lanes|=w),s$(F.return,w,x),ne.lanes|=w;break}de=de.next}}else if(F.tag===10)U=F.type===x.type?null:F.child;else if(F.tag===18){if(U=F.return,U===null)throw Error(n(341));U.lanes|=w,ne=U.alternate,ne!==null&&(ne.lanes|=w),s$(U,w,x),U=F.sibling}else U=F.child;if(U!==null)U.return=F;else for(U=F;U!==null;){if(U===x){U=null;break}if(F=U.sibling,F!==null){F.return=U.return,U=F;break}U=U.return}F=U}za(f,x,E.children,w),x=x.child}return x;case 9:return E=x.type,C=x.pendingProps.children,Um(x,w),E=ro(E),C=C(E),x.flags|=1,za(f,x,C,w),x.child;case 14:return C=x.type,E=Fo(C,x.pendingProps),E=Fo(C.type,E),wz(f,x,C,E,w);case 15:return kz(f,x,x.type,x.pendingProps,w);case 17:return C=x.type,E=x.pendingProps,E=x.elementType===C?E:Fo(C,E),ck(f,x),x.tag=1,ai(C)?(f=!0,Hw(x)):f=!1,Um(x,w),hz(x,C,E),v$(x,C,E,w),S$(null,x,C,!0,f,w);case 19:return _z(f,x,w);case 22:return Iz(f,x,w)}throw Error(n(156,x.tag))};function eB(f,x){return Yd(f,x)}function Wae(f,x,w,C){this.tag=f,this.key=w,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=x,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=C,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function io(f,x,w,C){return new Wae(f,x,w,C)}function G$(f){return f=f.prototype,!(!f||!f.isReactComponent)}function Vae(f){if(typeof f=="function")return G$(f)?1:0;if(f!=null){if(f=f.$$typeof,f===_)return 11;if(f===W)return 14}return 2}function Ic(f,x){var w=f.alternate;return w===null?(w=io(f.tag,x,f.key,f.mode),w.elementType=f.elementType,w.type=f.type,w.stateNode=f.stateNode,w.alternate=f,f.alternate=w):(w.pendingProps=x,w.type=f.type,w.flags=0,w.subtreeFlags=0,w.deletions=null),w.flags=f.flags&14680064,w.childLanes=f.childLanes,w.lanes=f.lanes,w.child=f.child,w.memoizedProps=f.memoizedProps,w.memoizedState=f.memoizedState,w.updateQueue=f.updateQueue,x=f.dependencies,w.dependencies=x===null?null:{lanes:x.lanes,firstContext:x.firstContext},w.sibling=f.sibling,w.index=f.index,w.ref=f.ref,w}function wk(f,x,w,C,E,F){var U=2;if(C=f,typeof f=="function")G$(f)&&(U=1);else if(typeof f=="string")U=5;else e:switch(f){case T:return hp(w.children,E,F,x);case A:U=8,E|=8;break;case R:return f=io(12,w,x,E|2),f.elementType=R,f.lanes=F,f;case L:return f=io(13,w,x,E),f.elementType=L,f.lanes=F,f;case z:return f=io(19,w,x,E),f.elementType=z,f.lanes=F,f;case q:return kk(w,E,F,x);default:if(typeof f=="object"&&f!==null)switch(f.$$typeof){case D:U=10;break e;case $:U=9;break e;case _:U=11;break e;case W:U=14;break e;case G:U=16,C=null;break e}throw Error(n(130,f==null?f:typeof f,""))}return x=io(U,w,x,E),x.elementType=f,x.type=C,x.lanes=F,x}function hp(f,x,w,C){return f=io(7,f,C,x),f.lanes=w,f}function kk(f,x,w,C){return f=io(22,f,C,x),f.elementType=q,f.lanes=w,f.stateNode={isHidden:!1},f}function j$(f,x,w){return f=io(6,f,null,x),f.lanes=w,f}function H$(f,x,w){return x=io(4,f.children!==null?f.children:[],f.key,x),x.lanes=w,x.stateNode={containerInfo:f.containerInfo,pendingChildren:null,implementation:f.implementation},x}function Uae(f,x,w,C,E){this.tag=x,this.containerInfo=f,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Sm(0),this.expirationTimes=Sm(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Sm(0),this.identifierPrefix=C,this.onRecoverableError=E,this.mutableSourceEagerHydrationData=null}function q$(f,x,w,C,E,F,U,ne,de){return f=new Uae(f,x,w,ne,de),x===1?(x=1,F===!0&&(x|=8)):x=0,F=io(3,null,null,x),f.current=F,F.stateNode=f,F.memoizedState={element:C,isDehydrated:w,cache:null,transitions:null,pendingSuspenseBoundaries:null},i$(F),f}function Gae(f,x,w){var C=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:N,key:C==null?null:""+C,children:f,containerInfo:x,implementation:w}}function tB(f){if(!f)return fc;f=f._reactInternals;e:{if(zs(f)!==f||f.tag!==1)throw Error(n(170));var x=f;do{switch(x.tag){case 3:x=x.stateNode.context;break e;case 1:if(ai(x.type)){x=x.stateNode.__reactInternalMemoizedMergedChildContext;break e}}x=x.return}while(x!==null);throw Error(n(171))}if(f.tag===1){var w=f.type;if(ai(w))return E4(f,w,x)}return x}function nB(f,x,w,C,E,F,U,ne,de){return f=q$(w,C,!0,f,E,F,U,ne,de),f.context=tB(null),w=f.current,C=Ba(),E=wc(w),F=wu(C,E),F.callback=x??null,yc(w,F,E),f.current.lanes=E,yl(f,E,C),li(f,C),f}function Ik(f,x,w,C){var E=x.current,F=Ba(),U=wc(E);return w=tB(w),x.context===null?x.context=w:x.pendingContext=w,x=wu(F,U),x.payload={element:f},C=C===void 0?null:C,C!==null&&(x.callback=C),f=yc(E,x,U),f!==null&&(Lo(f,E,U,F),ek(f,E,U)),U}function Sk(f){if(f=f.current,!f.child)return null;switch(f.child.tag){case 5:return f.child.stateNode;default:return f.child.stateNode}}function rB(f,x){if(f=f.memoizedState,f!==null&&f.dehydrated!==null){var w=f.retryLane;f.retryLane=w!==0&&w<x?w:x}}function K$(f,x){rB(f,x),(f=f.alternate)&&rB(f,x)}function jae(){return null}var sB=typeof reportError=="function"?reportError:function(f){console.error(f)};function X$(f){this._internalRoot=f}Ck.prototype.render=X$.prototype.render=function(f){var x=this._internalRoot;if(x===null)throw Error(n(409));Ik(f,x,null,null)},Ck.prototype.unmount=X$.prototype.unmount=function(){var f=this._internalRoot;if(f!==null){this._internalRoot=null;var x=f.containerInfo;cp(function(){Ik(null,f,null,null)}),x[gu]=null}};function Ck(f){this._internalRoot=f}Ck.prototype.unstable_scheduleHydration=function(f){if(f){var x=Qd();f={blockedOn:null,target:f,priority:x};for(var w=0;w<je.length&&x!==0&&x<je[w].priority;w++);je.splice(w,0,f),w===0&&Nt(f)}};function Y$(f){return!(!f||f.nodeType!==1&&f.nodeType!==9&&f.nodeType!==11)}function Nk(f){return!(!f||f.nodeType!==1&&f.nodeType!==9&&f.nodeType!==11&&(f.nodeType!==8||f.nodeValue!==" react-mount-point-unstable "))}function aB(){}function Hae(f,x,w,C,E){if(E){if(typeof C=="function"){var F=C;C=function(){var Ee=Sk(U);F.call(Ee)}}var U=nB(x,C,f,0,null,!1,!1,"",aB);return f._reactRootContainer=U,f[gu]=U.current,ob(f.nodeType===8?f.parentNode:f),cp(),U}for(;E=f.lastChild;)f.removeChild(E);if(typeof C=="function"){var ne=C;C=function(){var Ee=Sk(de);ne.call(Ee)}}var de=q$(f,0,!1,null,null,!1,!1,"",aB);return f._reactRootContainer=de,f[gu]=de.current,ob(f.nodeType===8?f.parentNode:f),cp(function(){Ik(x,de,w,C)}),de}function Tk(f,x,w,C,E){var F=w._reactRootContainer;if(F){var U=F;if(typeof E=="function"){var ne=E;E=function(){var de=Sk(U);ne.call(de)}}Ik(x,U,f,E)}else U=Hae(w,x,f,E,C);return Sk(U)}Jx=function(f){switch(f.tag){case 3:var x=f.stateNode;if(x.current.memoizedState.isDehydrated){var w=ac(x.pendingLanes);w!==0&&(Cm(x,w|1),li(x,Bn()),($n&6)===0&&(Km=Bn()+500,mc()))}break;case 13:cp(function(){var C=vu(f,1);if(C!==null){var E=Ba();Lo(C,f,1,E)}}),K$(f,1)}},Tm=function(f){if(f.tag===13){var x=vu(f,134217728);if(x!==null){var w=Ba();Lo(x,f,134217728,w)}K$(f,134217728)}},$m=function(f){if(f.tag===13){var x=wc(f),w=vu(f,x);if(w!==null){var C=Ba();Lo(w,f,x,C)}K$(f,x)}},Qd=function(){return En},ep=function(f,x){var w=En;try{return En=f,x()}finally{En=w}},ns=function(f,x,w){switch(x){case"input":if(ot(f,w),x=w.name,w.type==="radio"&&x!=null){for(w=f;w.parentNode;)w=w.parentNode;for(w=w.querySelectorAll("input[name="+JSON.stringify(""+x)+'][type="radio"]'),x=0;x<w.length;x++){var C=w[x];if(C!==f&&C.form===f.form){var E=Gw(C);if(!E)throw Error(n(90));Ze(C),ot(C,E)}}}break;case"textarea":Ve(f,w);break;case"select":x=w.value,x!=null&&dn(f,!!w.multiple,x,!1)}},ye=W$,Me=cp;var qae={usingClientEntryPoint:!1,Events:[cb,Om,Gw,qn,ss,W$]},Sb={findFiberByHostInstance:np,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},Kae={bundleType:Sb.bundleType,version:Sb.version,rendererPackageName:Sb.rendererPackageName,rendererConfig:Sb.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:I.ReactCurrentDispatcher,findHostInstanceByFiber:function(f){return f=Kd(f),f===null?null:f.stateNode},findFiberByHostInstance:Sb.findFiberByHostInstance||jae,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var $k=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!$k.isDisabled&&$k.supportsFiber)try{sc=$k.inject(Kae),eo=$k}catch{}}return ui.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=qae,ui.createPortal=function(f,x){var w=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!Y$(x))throw Error(n(200));return Gae(f,x,null,w)},ui.createRoot=function(f,x){if(!Y$(f))throw Error(n(299));var w=!1,C="",E=sB;return x!=null&&(x.unstable_strictMode===!0&&(w=!0),x.identifierPrefix!==void 0&&(C=x.identifierPrefix),x.onRecoverableError!==void 0&&(E=x.onRecoverableError)),x=q$(f,1,!1,null,null,w,!1,C,E),f[gu]=x.current,ob(f.nodeType===8?f.parentNode:f),new X$(x)},ui.findDOMNode=function(f){if(f==null)return null;if(f.nodeType===1)return f;var x=f._reactInternals;if(x===void 0)throw typeof f.render=="function"?Error(n(188)):(f=Object.keys(f).join(","),Error(n(268,f)));return f=Kd(x),f=f===null?null:f.stateNode,f},ui.flushSync=function(f){return cp(f)},ui.hydrate=function(f,x,w){if(!Nk(x))throw Error(n(200));return Tk(null,f,x,!0,w)},ui.hydrateRoot=function(f,x,w){if(!Y$(f))throw Error(n(405));var C=w!=null&&w.hydratedSources||null,E=!1,F="",U=sB;if(w!=null&&(w.unstable_strictMode===!0&&(E=!0),w.identifierPrefix!==void 0&&(F=w.identifierPrefix),w.onRecoverableError!==void 0&&(U=w.onRecoverableError)),x=nB(x,null,f,1,w??null,E,!1,F,U),f[gu]=x.current,ob(f),C)for(f=0;f<C.length;f++)w=C[f],E=w._getVersion,E=E(w._source),x.mutableSourceEagerHydrationData==null?x.mutableSourceEagerHydrationData=[w,E]:x.mutableSourceEagerHydrationData.push(w,E);return new Ck(x)},ui.render=function(f,x,w){if(!Nk(x))throw Error(n(200));return Tk(null,f,x,!1,w)},ui.unmountComponentAtNode=function(f){if(!Nk(f))throw Error(n(40));return f._reactRootContainer?(cp(function(){Tk(null,null,f,!1,function(){f._reactRootContainer=null,f[gu]=null})}),!0):!1},ui.unstable_batchedUpdates=W$,ui.unstable_renderSubtreeIntoContainer=function(f,x,w,C){if(!Nk(w))throw Error(n(200));if(f==null||f._reactInternals===void 0)throw Error(n(38));return Tk(f,x,w,!1,C)},ui.version="18.3.1-next-f1338f8080-20240426",ui}var hB;function sie(){if(hB)return Q$.exports;hB=1;function e(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}return e(),Q$.exports=rie(),Q$.exports}var fB;function aie(){if(fB)return Ek;fB=1;var e=sie();return Ek.createRoot=e.createRoot,Ek.hydrateRoot=e.hydrateRoot,Ek}var iie=aie();const oie=ty(iie);var Nb={},mB;function lie(){if(mB)return Nb;mB=1,Object.defineProperty(Nb,"__esModule",{value:!0}),Nb.parse=i,Nb.serialize=u;const e=/^[\u0021-\u003A\u003C\u003E-\u007E]+$/,t=/^[\u0021-\u003A\u003C-\u007E]*$/,n=/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,r=/^[\u0020-\u003A\u003D-\u007E]*$/,s=Object.prototype.toString,a=(()=>{const p=function(){};return p.prototype=Object.create(null),p})();function i(p,h){const m=new a,g=p.length;if(g<2)return m;const y=(h==null?void 0:h.decode)||c;let b=0;do{const v=p.indexOf("=",b);if(v===-1)break;const k=p.indexOf(";",b),I=k===-1?g:k;if(v>I){b=p.lastIndexOf(";",v-1)+1;continue}const S=o(p,b,v),N=l(p,v,S),T=p.slice(S,N);if(m[T]===void 0){let A=o(p,v+1,I),R=l(p,I,A);const D=y(p.slice(A,R));m[T]=D}b=I+1}while(b<g);return m}function o(p,h,m){do{const g=p.charCodeAt(h);if(g!==32&&g!==9)return h}while(++h<m);return m}function l(p,h,m){for(;h>m;){const g=p.charCodeAt(--h);if(g!==32&&g!==9)return h+1}return m}function u(p,h,m){const g=(m==null?void 0:m.encode)||encodeURIComponent;if(!e.test(p))throw new TypeError(`argument name is invalid: ${p}`);const y=g(h);if(!t.test(y))throw new TypeError(`argument val is invalid: ${h}`);let b=p+"="+y;if(!m)return b;if(m.maxAge!==void 0){if(!Number.isInteger(m.maxAge))throw new TypeError(`option maxAge is invalid: ${m.maxAge}`);b+="; Max-Age="+m.maxAge}if(m.domain){if(!n.test(m.domain))throw new TypeError(`option domain is invalid: ${m.domain}`);b+="; Domain="+m.domain}if(m.path){if(!r.test(m.path))throw new TypeError(`option path is invalid: ${m.path}`);b+="; Path="+m.path}if(m.expires){if(!d(m.expires)||!Number.isFinite(m.expires.valueOf()))throw new TypeError(`option expires is invalid: ${m.expires}`);b+="; Expires="+m.expires.toUTCString()}if(m.httpOnly&&(b+="; HttpOnly"),m.secure&&(b+="; Secure"),m.partitioned&&(b+="; Partitioned"),m.priority)switch(typeof m.priority=="string"?m.priority.toLowerCase():void 0){case"low":b+="; Priority=Low";break;case"medium":b+="; Priority=Medium";break;case"high":b+="; Priority=High";break;default:throw new TypeError(`option priority is invalid: ${m.priority}`)}if(m.sameSite)switch(typeof m.sameSite=="string"?m.sameSite.toLowerCase():m.sameSite){case!0:case"strict":b+="; SameSite=Strict";break;case"lax":b+="; SameSite=Lax";break;case"none":b+="; SameSite=None";break;default:throw new TypeError(`option sameSite is invalid: ${m.sameSite}`)}return b}function c(p){if(p.indexOf("%")===-1)return p;try{return decodeURIComponent(p)}catch{return p}}function d(p){return s.call(p)==="[object Date]"}return Nb}lie();var gB="popstate";function uie(e={}){function t(r,s){let{pathname:a,search:i,hash:o}=r.location;return a_("",{pathname:a,search:i,hash:o},s.state&&s.state.usr||null,s.state&&s.state.key||"default")}function n(r,s){return typeof s=="string"?s:uv(s)}return die(t,n,null,e)}function $r(e,t){if(e===!1||e===null||typeof e>"u")throw new Error(t)}function tl(e,t){if(!e){typeof console<"u"&&console.warn(t);try{throw new Error(t)}catch{}}}function cie(){return Math.random().toString(36).substring(2,10)}function yB(e,t){return{usr:e.state,key:e.key,idx:t}}function a_(e,t,n=null,r){return{pathname:typeof e=="string"?e:e.pathname,search:"",hash:"",...typeof t=="string"?ny(t):t,state:n,key:t&&t.key||r||cie()}}function uv({pathname:e="/",search:t="",hash:n=""}){return t&&t!=="?"&&(e+=t.charAt(0)==="?"?t:"?"+t),n&&n!=="#"&&(e+=n.charAt(0)==="#"?n:"#"+n),e}function ny(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substring(n),e=e.substring(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substring(r),e=e.substring(0,r)),e&&(t.pathname=e)}return t}function die(e,t,n,r={}){let{window:s=document.defaultView,v5Compat:a=!1}=r,i=s.history,o="POP",l=null,u=c();u==null&&(u=0,i.replaceState({...i.state,idx:u},""));function c(){return(i.state||{idx:null}).idx}function d(){o="POP";let y=c(),b=y==null?null:y-u;u=y,l&&l({action:o,location:g.location,delta:b})}function p(y,b){o="PUSH";let v=a_(g.location,y,b);u=c()+1;let k=yB(v,u),I=g.createHref(v);try{i.pushState(k,"",I)}catch(S){if(S instanceof DOMException&&S.name==="DataCloneError")throw S;s.location.assign(I)}a&&l&&l({action:o,location:g.location,delta:1})}function h(y,b){o="REPLACE";let v=a_(g.location,y,b);u=c();let k=yB(v,u),I=g.createHref(v);i.replaceState(k,"",I),a&&l&&l({action:o,location:g.location,delta:0})}function m(y){return pie(y)}let g={get action(){return o},get location(){return e(s,i)},listen(y){if(l)throw new Error("A history only accepts one active listener");return s.addEventListener(gB,d),l=y,()=>{s.removeEventListener(gB,d),l=null}},createHref(y){return t(s,y)},createURL:m,encodeLocation(y){let b=m(y);return{pathname:b.pathname,search:b.search,hash:b.hash}},push:p,replace:h,go(y){return i.go(y)}};return g}function pie(e,t=!1){let n="http://localhost";typeof window<"u"&&(n=window.location.origin!=="null"?window.location.origin:window.location.href),$r(n,"No window.location.(origin|href) available to create URL");let r=typeof e=="string"?e:uv(e);return r=r.replace(/ $/,"%20"),!t&&r.startsWith("//")&&(r=n+r),new URL(r,n)}function J6(e,t,n="/"){return hie(e,t,n,!1)}function hie(e,t,n,r){let s=typeof t=="string"?ny(t):t,a=Ou(s.pathname||"/",n);if(a==null)return null;let i=Q6(e);fie(i);let o=null;for(let l=0;o==null&&l<i.length;++l){let u=Cie(a);o=Iie(i[l],u,r)}return o}function Q6(e,t=[],n=[],r=""){let s=(a,i,o)=>{let l={relativePath:o===void 0?a.path||"":o,caseSensitive:a.caseSensitive===!0,childrenIndex:i,route:a};l.relativePath.startsWith("/")&&($r(l.relativePath.startsWith(r),`Absolute route path "${l.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),l.relativePath=l.relativePath.slice(r.length));let u=_u([r,l.relativePath]),c=n.concat(l);a.children&&a.children.length>0&&($r(a.index!==!0,`Index routes must not have child routes. Please remove all child routes from route path "${u}".`),Q6(a.children,t,c,u)),!(a.path==null&&!a.index)&&t.push({path:u,score:wie(u,a.index),routesMeta:c})};return e.forEach((a,i)=>{var o;if(a.path===""||!((o=a.path)!=null&&o.includes("?")))s(a,i);else for(let l of eG(a.path))s(a,i,l)}),t}function eG(e){let t=e.split("/");if(t.length===0)return[];let[n,...r]=t,s=n.endsWith("?"),a=n.replace(/\?$/,"");if(r.length===0)return s?[a,""]:[a];let i=eG(r.join("/")),o=[];return o.push(...i.map(l=>l===""?a:[a,l].join("/"))),s&&o.push(...i),o.map(l=>e.startsWith("/")&&l===""?"/":l)}function fie(e){e.sort((t,n)=>t.score!==n.score?n.score-t.score:kie(t.routesMeta.map(r=>r.childrenIndex),n.routesMeta.map(r=>r.childrenIndex)))}var mie=/^:[\w-]+$/,gie=3,yie=2,xie=1,bie=10,vie=-2,xB=e=>e==="*";function wie(e,t){let n=e.split("/"),r=n.length;return n.some(xB)&&(r+=vie),t&&(r+=yie),n.filter(s=>!xB(s)).reduce((s,a)=>s+(mie.test(a)?gie:a===""?xie:bie),r)}function kie(e,t){return e.length===t.length&&e.slice(0,-1).every((r,s)=>r===t[s])?e[e.length-1]-t[t.length-1]:0}function Iie(e,t,n=!1){let{routesMeta:r}=e,s={},a="/",i=[];for(let o=0;o<r.length;++o){let l=r[o],u=o===r.length-1,c=a==="/"?t:t.slice(a.length)||"/",d=F2({path:l.relativePath,caseSensitive:l.caseSensitive,end:u},c),p=l.route;if(!d&&u&&n&&!r[r.length-1].route.index&&(d=F2({path:l.relativePath,caseSensitive:l.caseSensitive,end:!1},c)),!d)return null;Object.assign(s,d.params),i.push({params:s,pathname:_u([a,d.pathname]),pathnameBase:Eie(_u([a,d.pathnameBase])),route:p}),d.pathnameBase!=="/"&&(a=_u([a,d.pathnameBase]))}return i}function F2(e,t){typeof e=="string"&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=Sie(e.path,e.caseSensitive,e.end),s=t.match(n);if(!s)return null;let a=s[0],i=a.replace(/(.)\/+$/,"$1"),o=s.slice(1);return{params:r.reduce((u,{paramName:c,isOptional:d},p)=>{if(c==="*"){let m=o[p]||"";i=a.slice(0,a.length-m.length).replace(/(.)\/+$/,"$1")}const h=o[p];return d&&!h?u[c]=void 0:u[c]=(h||"").replace(/%2F/g,"/"),u},{}),pathname:a,pathnameBase:i,pattern:e}}function Sie(e,t=!1,n=!0){tl(e==="*"||!e.endsWith("*")||e.endsWith("/*"),`Route path "${e}" will be treated as if it were "${e.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/,"/*")}".`);let r=[],s="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(i,o,l)=>(r.push({paramName:o,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)"));return e.endsWith("*")?(r.push({paramName:"*"}),s+=e==="*"||e==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?s+="\\/*$":e!==""&&e!=="/"&&(s+="(?:(?=\\/|$))"),[new RegExp(s,t?void 0:"i"),r]}function Cie(e){try{return e.split("/").map(t=>decodeURIComponent(t).replace(/\//g,"%2F")).join("/")}catch(t){return tl(!1,`The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`),e}}function Ou(e,t){if(t==="/")return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&r!=="/"?null:e.slice(n)||"/"}function Nie(e,t="/"){let{pathname:n,search:r="",hash:s=""}=typeof e=="string"?ny(e):e;return{pathname:n?n.startsWith("/")?n:Tie(n,t):t,search:_ie(r),hash:Aie(s)}}function Tie(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach(s=>{s===".."?n.length>1&&n.pop():s!=="."&&n.push(s)}),n.length>1?n.join("/"):"/"}function nE(e,t,n,r){return`Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(r)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function $ie(e){return e.filter((t,n)=>n===0||t.route.path&&t.route.path.length>0)}function IR(e){let t=$ie(e);return t.map((n,r)=>r===t.length-1?n.pathname:n.pathnameBase)}function SR(e,t,n,r=!1){let s;typeof e=="string"?s=ny(e):(s={...e},$r(!s.pathname||!s.pathname.includes("?"),nE("?","pathname","search",s)),$r(!s.pathname||!s.pathname.includes("#"),nE("#","pathname","hash",s)),$r(!s.search||!s.search.includes("#"),nE("#","search","hash",s)));let a=e===""||s.pathname==="",i=a?"/":s.pathname,o;if(i==null)o=n;else{let d=t.length-1;if(!r&&i.startsWith("..")){let p=i.split("/");for(;p[0]==="..";)p.shift(),d-=1;s.pathname=p.join("/")}o=d>=0?t[d]:"/"}let l=Nie(s,o),u=i&&i!=="/"&&i.endsWith("/"),c=(a||i===".")&&n.endsWith("/");return!l.pathname.endsWith("/")&&(u||c)&&(l.pathname+="/"),l}var _u=e=>e.join("/").replace(/\/\/+/g,"/"),Eie=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),_ie=e=>!e||e==="?"?"":e.startsWith("?")?e:"?"+e,Aie=e=>!e||e==="#"?"":e.startsWith("#")?e:"#"+e;function Rie(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.internal=="boolean"&&"data"in e}var tG=["POST","PUT","PATCH","DELETE"];new Set(tG);var Die=["GET",...tG];new Set(Die);var ry=ee.createContext(null);ry.displayName="DataRouter";var JI=ee.createContext(null);JI.displayName="DataRouterState";var nG=ee.createContext({isTransitioning:!1});nG.displayName="ViewTransition";var Fie=ee.createContext(new Map);Fie.displayName="Fetchers";var Oie=ee.createContext(null);Oie.displayName="Await";var pl=ee.createContext(null);pl.displayName="Navigation";var jv=ee.createContext(null);jv.displayName="Location";var iu=ee.createContext({outlet:null,matches:[],isDataRoute:!1});iu.displayName="Route";var CR=ee.createContext(null);CR.displayName="RouteError";function Mie(e,{relative:t}={}){$r(sy(),"useHref() may be used only in the context of a <Router> component.");let{basename:n,navigator:r}=ee.useContext(pl),{hash:s,pathname:a,search:i}=Hv(e,{relative:t}),o=a;return n!=="/"&&(o=a==="/"?n:_u([n,a])),r.createHref({pathname:o,search:i,hash:s})}function sy(){return ee.useContext(jv)!=null}function Uu(){return $r(sy(),"useLocation() may be used only in the context of a <Router> component."),ee.useContext(jv).location}var rG="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function sG(e){ee.useContext(pl).static||ee.useLayoutEffect(e)}function yd(){let{isDataRoute:e}=ee.useContext(iu);return e?Xie():Lie()}function Lie(){$r(sy(),"useNavigate() may be used only in the context of a <Router> component.");let e=ee.useContext(ry),{basename:t,navigator:n}=ee.useContext(pl),{matches:r}=ee.useContext(iu),{pathname:s}=Uu(),a=JSON.stringify(IR(r)),i=ee.useRef(!1);return sG(()=>{i.current=!0}),ee.useCallback((l,u={})=>{if(tl(i.current,rG),!i.current)return;if(typeof l=="number"){n.go(l);return}let c=SR(l,JSON.parse(a),s,u.relative==="path");e==null&&t!=="/"&&(c.pathname=c.pathname==="/"?t:_u([t,c.pathname])),(u.replace?n.replace:n.push)(c,u.state,u)},[t,n,a,s,e])}ee.createContext(null);function Hv(e,{relative:t}={}){let{matches:n}=ee.useContext(iu),{pathname:r}=Uu(),s=JSON.stringify(IR(n));return ee.useMemo(()=>SR(e,JSON.parse(s),r,t==="path"),[e,s,r,t])}function Pie(e,t){return aG(e,t)}function aG(e,t,n,r){var b;$r(sy(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:s}=ee.useContext(pl),{matches:a}=ee.useContext(iu),i=a[a.length-1],o=i?i.params:{},l=i?i.pathname:"/",u=i?i.pathnameBase:"/",c=i&&i.route;{let v=c&&c.path||"";iG(l,!c||v.endsWith("*")||v.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${l}" (under <Route path="${v}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${v}"> to <Route path="${v==="/"?"*":`${v}/*`}">.`)}let d=Uu(),p;if(t){let v=typeof t=="string"?ny(t):t;$r(u==="/"||((b=v.pathname)==null?void 0:b.startsWith(u)),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${u}" but pathname "${v.pathname}" was given in the \`location\` prop.`),p=v}else p=d;let h=p.pathname||"/",m=h;if(u!=="/"){let v=u.replace(/^\//,"").split("/");m="/"+h.replace(/^\//,"").split("/").slice(v.length).join("/")}let g=J6(e,{pathname:m});tl(c||g!=null,`No routes matched location "${p.pathname}${p.search}${p.hash}" `),tl(g==null||g[g.length-1].route.element!==void 0||g[g.length-1].route.Component!==void 0||g[g.length-1].route.lazy!==void 0,`Matched leaf route at location "${p.pathname}${p.search}${p.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let y=Uie(g&&g.map(v=>Object.assign({},v,{params:Object.assign({},o,v.params),pathname:_u([u,s.encodeLocation?s.encodeLocation(v.pathname).pathname:v.pathname]),pathnameBase:v.pathnameBase==="/"?u:_u([u,s.encodeLocation?s.encodeLocation(v.pathnameBase).pathname:v.pathnameBase])})),a,n,r);return t&&y?ee.createElement(jv.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",...p},navigationType:"POP"}},y):y}function zie(){let e=Kie(),t=Rie(e)?`${e.status} ${e.statusText}`:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,r="rgba(200,200,200, 0.5)",s={padding:"0.5rem",backgroundColor:r},a={padding:"2px 4px",backgroundColor:r},i=null;return console.error("Error handled by React Router default ErrorBoundary:",e),i=ee.createElement(ee.Fragment,null,ee.createElement("p",null," Hey developer "),ee.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",ee.createElement("code",{style:a},"ErrorBoundary")," or"," ",ee.createElement("code",{style:a},"errorElement")," prop on your route.")),ee.createElement(ee.Fragment,null,ee.createElement("h2",null,"Unexpected Application Error!"),ee.createElement("h3",{style:{fontStyle:"italic"}},t),n?ee.createElement("pre",{style:s},n):null,i)}var Bie=ee.createElement(zie,null),Wie=class extends ee.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||t.revalidation!=="idle"&&e.revalidation==="idle"?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:e.error!==void 0?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return this.state.error!==void 0?ee.createElement(iu.Provider,{value:this.props.routeContext},ee.createElement(CR.Provider,{value:this.state.error,children:this.props.component})):this.props.children}};function Vie({routeContext:e,match:t,children:n}){let r=ee.useContext(ry);return r&&r.static&&r.staticContext&&(t.route.errorElement||t.route.ErrorBoundary)&&(r.staticContext._deepestRenderedBoundaryId=t.route.id),ee.createElement(iu.Provider,{value:e},n)}function Uie(e,t=[],n=null,r=null){if(e==null){if(!n)return null;if(n.errors)e=n.matches;else if(t.length===0&&!n.initialized&&n.matches.length>0)e=n.matches;else return null}let s=e,a=n==null?void 0:n.errors;if(a!=null){let l=s.findIndex(u=>u.route.id&&(a==null?void 0:a[u.route.id])!==void 0);$r(l>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(a).join(",")}`),s=s.slice(0,Math.min(s.length,l+1))}let i=!1,o=-1;if(n)for(let l=0;l<s.length;l++){let u=s[l];if((u.route.HydrateFallback||u.route.hydrateFallbackElement)&&(o=l),u.route.id){let{loaderData:c,errors:d}=n,p=u.route.loader&&!c.hasOwnProperty(u.route.id)&&(!d||d[u.route.id]===void 0);if(u.route.lazy||p){i=!0,o>=0?s=s.slice(0,o+1):s=[s[0]];break}}}return s.reduceRight((l,u,c)=>{let d,p=!1,h=null,m=null;n&&(d=a&&u.route.id?a[u.route.id]:void 0,h=u.route.errorElement||Bie,i&&(o<0&&c===0?(iG("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),p=!0,m=null):o===c&&(p=!0,m=u.route.hydrateFallbackElement||null)));let g=t.concat(s.slice(0,c+1)),y=()=>{let b;return d?b=h:p?b=m:u.route.Component?b=ee.createElement(u.route.Component,null):u.route.element?b=u.route.element:b=l,ee.createElement(Vie,{match:u,routeContext:{outlet:l,matches:g,isDataRoute:n!=null},children:b})};return n&&(u.route.ErrorBoundary||u.route.errorElement||c===0)?ee.createElement(Wie,{location:n.location,revalidation:n.revalidation,component:h,error:d,children:y(),routeContext:{outlet:null,matches:g,isDataRoute:!0}}):y()},null)}function NR(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function Gie(e){let t=ee.useContext(ry);return $r(t,NR(e)),t}function jie(e){let t=ee.useContext(JI);return $r(t,NR(e)),t}function Hie(e){let t=ee.useContext(iu);return $r(t,NR(e)),t}function TR(e){let t=Hie(e),n=t.matches[t.matches.length-1];return $r(n.route.id,`${e} can only be used on routes that contain a unique "id"`),n.route.id}function qie(){return TR("useRouteId")}function Kie(){var r;let e=ee.useContext(CR),t=jie("useRouteError"),n=TR("useRouteError");return e!==void 0?e:(r=t.errors)==null?void 0:r[n]}function Xie(){let{router:e}=Gie("useNavigate"),t=TR("useNavigate"),n=ee.useRef(!1);return sG(()=>{n.current=!0}),ee.useCallback(async(s,a={})=>{tl(n.current,rG),n.current&&(typeof s=="number"?e.navigate(s):await e.navigate(s,{fromRouteId:t,...a}))},[e,t])}var bB={};function iG(e,t,n){!t&&!bB[e]&&(bB[e]=!0,tl(!1,n))}ee.memo(Yie);function Yie({routes:e,future:t,state:n}){return aG(e,void 0,n,t)}function i_({to:e,replace:t,state:n,relative:r}){$r(sy(),"<Navigate> may be used only in the context of a <Router> component.");let{static:s}=ee.useContext(pl);tl(!s,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");let{matches:a}=ee.useContext(iu),{pathname:i}=Uu(),o=yd(),l=SR(e,IR(a),i,r==="path"),u=JSON.stringify(l);return ee.useEffect(()=>{o(JSON.parse(u),{replace:t,state:n,relative:r})},[o,u,r,t,n]),null}function Bo(e){$r(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function Zie({basename:e="/",children:t=null,location:n,navigationType:r="POP",navigator:s,static:a=!1}){$r(!sy(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let i=e.replace(/^\/*/,"/"),o=ee.useMemo(()=>({basename:i,navigator:s,static:a,future:{}}),[i,s,a]);typeof n=="string"&&(n=ny(n));let{pathname:l="/",search:u="",hash:c="",state:d=null,key:p="default"}=n,h=ee.useMemo(()=>{let m=Ou(l,i);return m==null?null:{location:{pathname:m,search:u,hash:c,state:d,key:p},navigationType:r}},[i,l,u,c,d,p,r]);return tl(h!=null,`<Router basename="${i}"> is not able to match the URL "${l}${u}${c}" because it does not start with the basename, so the <Router> won't render anything.`),h==null?null:ee.createElement(pl.Provider,{value:o},ee.createElement(jv.Provider,{children:t,value:h}))}function Jie({children:e,location:t}){return Pie(o_(e),t)}function o_(e,t=[]){let n=[];return ee.Children.forEach(e,(r,s)=>{if(!ee.isValidElement(r))return;let a=[...t,s];if(r.type===ee.Fragment){n.push.apply(n,o_(r.props.children,a));return}$r(r.type===Bo,`[${typeof r.type=="string"?r.type:r.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),$r(!r.props.index||!r.props.children,"An index route cannot have child routes.");let i={id:r.props.id||a.join("-"),caseSensitive:r.props.caseSensitive,element:r.props.element,Component:r.props.Component,index:r.props.index,path:r.props.path,loader:r.props.loader,action:r.props.action,hydrateFallbackElement:r.props.hydrateFallbackElement,HydrateFallback:r.props.HydrateFallback,errorElement:r.props.errorElement,ErrorBoundary:r.props.ErrorBoundary,hasErrorBoundary:r.props.hasErrorBoundary===!0||r.props.ErrorBoundary!=null||r.props.errorElement!=null,shouldRevalidate:r.props.shouldRevalidate,handle:r.props.handle,lazy:r.props.lazy};r.props.children&&(i.children=o_(r.props.children,a)),n.push(i)}),n}var d2="get",p2="application/x-www-form-urlencoded";function QI(e){return e!=null&&typeof e.tagName=="string"}function Qie(e){return QI(e)&&e.tagName.toLowerCase()==="button"}function eoe(e){return QI(e)&&e.tagName.toLowerCase()==="form"}function toe(e){return QI(e)&&e.tagName.toLowerCase()==="input"}function noe(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}function roe(e,t){return e.button===0&&(!t||t==="_self")&&!noe(e)}var _k=null;function soe(){if(_k===null)try{new FormData(document.createElement("form"),0),_k=!1}catch{_k=!0}return _k}var aoe=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function rE(e){return e!=null&&!aoe.has(e)?(tl(!1,`"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${p2}"`),null):e}function ioe(e,t){let n,r,s,a,i;if(eoe(e)){let o=e.getAttribute("action");r=o?Ou(o,t):null,n=e.getAttribute("method")||d2,s=rE(e.getAttribute("enctype"))||p2,a=new FormData(e)}else if(Qie(e)||toe(e)&&(e.type==="submit"||e.type==="image")){let o=e.form;if(o==null)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let l=e.getAttribute("formaction")||o.getAttribute("action");if(r=l?Ou(l,t):null,n=e.getAttribute("formmethod")||o.getAttribute("method")||d2,s=rE(e.getAttribute("formenctype"))||rE(o.getAttribute("enctype"))||p2,a=new FormData(o,e),!soe()){let{name:u,type:c,value:d}=e;if(c==="image"){let p=u?`${u}.`:"";a.append(`${p}x`,"0"),a.append(`${p}y`,"0")}else u&&a.append(u,d)}}else{if(QI(e))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');n=d2,r=null,s=p2,i=e}return a&&s==="text/plain"&&(i=a,a=void 0),{action:r,method:n.toLowerCase(),encType:s,formData:a,body:i}}function $R(e,t){if(e===!1||e===null||typeof e>"u")throw new Error(t)}async function ooe(e,t){if(e.id in t)return t[e.id];try{let n=await import(e.module);return t[e.id]=n,n}catch(n){return console.error(`Error loading route module \`${e.module}\`, reloading page...`),console.error(n),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise(()=>{})}}function loe(e){return e==null?!1:e.href==null?e.rel==="preload"&&typeof e.imageSrcSet=="string"&&typeof e.imageSizes=="string":typeof e.rel=="string"&&typeof e.href=="string"}async function uoe(e,t,n){let r=await Promise.all(e.map(async s=>{let a=t.routes[s.route.id];if(a){let i=await ooe(a,n);return i.links?i.links():[]}return[]}));return hoe(r.flat(1).filter(loe).filter(s=>s.rel==="stylesheet"||s.rel==="preload").map(s=>s.rel==="stylesheet"?{...s,rel:"prefetch",as:"style"}:{...s,rel:"prefetch"}))}function vB(e,t,n,r,s,a){let i=(l,u)=>n[u]?l.route.id!==n[u].route.id:!0,o=(l,u)=>{var c;return n[u].pathname!==l.pathname||((c=n[u].route.path)==null?void 0:c.endsWith("*"))&&n[u].params["*"]!==l.params["*"]};return a==="assets"?t.filter((l,u)=>i(l,u)||o(l,u)):a==="data"?t.filter((l,u)=>{var d;let c=r.routes[l.route.id];if(!c||!c.hasLoader)return!1;if(i(l,u)||o(l,u))return!0;if(l.route.shouldRevalidate){let p=l.route.shouldRevalidate({currentUrl:new URL(s.pathname+s.search+s.hash,window.origin),currentParams:((d=n[0])==null?void 0:d.params)||{},nextUrl:new URL(e,window.origin),nextParams:l.params,defaultShouldRevalidate:!0});if(typeof p=="boolean")return p}return!0}):[]}function coe(e,t,{includeHydrateFallback:n}={}){return doe(e.map(r=>{let s=t.routes[r.route.id];if(!s)return[];let a=[s.module];return s.clientActionModule&&(a=a.concat(s.clientActionModule)),s.clientLoaderModule&&(a=a.concat(s.clientLoaderModule)),n&&s.hydrateFallbackModule&&(a=a.concat(s.hydrateFallbackModule)),s.imports&&(a=a.concat(s.imports)),a}).flat(1))}function doe(e){return[...new Set(e)]}function poe(e){let t={},n=Object.keys(e).sort();for(let r of n)t[r]=e[r];return t}function hoe(e,t){let n=new Set;return new Set(t),e.reduce((r,s)=>{let a=JSON.stringify(poe(s));return n.has(a)||(n.add(a),r.push({key:a,link:s})),r},[])}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");var foe=new Set([100,101,204,205]);function moe(e,t){let n=typeof e=="string"?new URL(e,typeof window>"u"?"server://singlefetch/":window.location.origin):e;return n.pathname==="/"?n.pathname="_root.data":t&&Ou(n.pathname,t)==="/"?n.pathname=`${t.replace(/\/$/,"")}/_root.data`:n.pathname=`${n.pathname.replace(/\/$/,"")}.data`,n}function oG(){let e=ee.useContext(ry);return $R(e,"You must render this element inside a <DataRouterContext.Provider> element"),e}function goe(){let e=ee.useContext(JI);return $R(e,"You must render this element inside a <DataRouterStateContext.Provider> element"),e}var ER=ee.createContext(void 0);ER.displayName="FrameworkContext";function lG(){let e=ee.useContext(ER);return $R(e,"You must render this element inside a <HydratedRouter> element"),e}function yoe(e,t){let n=ee.useContext(ER),[r,s]=ee.useState(!1),[a,i]=ee.useState(!1),{onFocus:o,onBlur:l,onMouseEnter:u,onMouseLeave:c,onTouchStart:d}=t,p=ee.useRef(null);ee.useEffect(()=>{if(e==="render"&&i(!0),e==="viewport"){let g=b=>{b.forEach(v=>{i(v.isIntersecting)})},y=new IntersectionObserver(g,{threshold:.5});return p.current&&y.observe(p.current),()=>{y.disconnect()}}},[e]),ee.useEffect(()=>{if(r){let g=setTimeout(()=>{i(!0)},100);return()=>{clearTimeout(g)}}},[r]);let h=()=>{s(!0)},m=()=>{s(!1),i(!1)};return n?e!=="intent"?[a,p,{}]:[a,p,{onFocus:Tb(o,h),onBlur:Tb(l,m),onMouseEnter:Tb(u,h),onMouseLeave:Tb(c,m),onTouchStart:Tb(d,h)}]:[!1,p,{}]}function Tb(e,t){return n=>{e&&e(n),n.defaultPrevented||t(n)}}function xoe({page:e,...t}){let{router:n}=oG(),r=ee.useMemo(()=>J6(n.routes,e,n.basename),[n.routes,e,n.basename]);return r?ee.createElement(voe,{page:e,matches:r,...t}):null}function boe(e){let{manifest:t,routeModules:n}=lG(),[r,s]=ee.useState([]);return ee.useEffect(()=>{let a=!1;return uoe(e,t,n).then(i=>{a||s(i)}),()=>{a=!0}},[e,t,n]),r}function voe({page:e,matches:t,...n}){let r=Uu(),{manifest:s,routeModules:a}=lG(),{basename:i}=oG(),{loaderData:o,matches:l}=goe(),u=ee.useMemo(()=>vB(e,t,l,s,r,"data"),[e,t,l,s,r]),c=ee.useMemo(()=>vB(e,t,l,s,r,"assets"),[e,t,l,s,r]),d=ee.useMemo(()=>{if(e===r.pathname+r.search+r.hash)return[];let m=new Set,g=!1;if(t.forEach(b=>{var k;let v=s.routes[b.route.id];!v||!v.hasLoader||(!u.some(I=>I.route.id===b.route.id)&&b.route.id in o&&((k=a[b.route.id])!=null&&k.shouldRevalidate)||v.hasClientLoader?g=!0:m.add(b.route.id))}),m.size===0)return[];let y=moe(e,i);return g&&m.size>0&&y.searchParams.set("_routes",t.filter(b=>m.has(b.route.id)).map(b=>b.route.id).join(",")),[y.pathname+y.search]},[i,o,r,s,u,t,e,a]),p=ee.useMemo(()=>coe(c,s),[c,s]),h=boe(c);return ee.createElement(ee.Fragment,null,d.map(m=>ee.createElement("link",{key:m,rel:"prefetch",as:"fetch",href:m,...n})),p.map(m=>ee.createElement("link",{key:m,rel:"modulepreload",href:m,...n})),h.map(({key:m,link:g})=>ee.createElement("link",{key:m,...g})))}function woe(...e){return t=>{e.forEach(n=>{typeof n=="function"?n(t):n!=null&&(n.current=t)})}}var uG=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";try{uG&&(window.__reactRouterVersion="7.6.1")}catch{}function koe({basename:e,children:t,window:n}){let r=ee.useRef();r.current==null&&(r.current=uie({window:n,v5Compat:!0}));let s=r.current,[a,i]=ee.useState({action:s.action,location:s.location}),o=ee.useCallback(l=>{ee.startTransition(()=>i(l))},[i]);return ee.useLayoutEffect(()=>s.listen(o),[s,o]),ee.createElement(Zie,{basename:e,children:t,location:a.location,navigationType:a.action,navigator:s})}var cG=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,dG=ee.forwardRef(function({onClick:t,discover:n="render",prefetch:r="none",relative:s,reloadDocument:a,replace:i,state:o,target:l,to:u,preventScrollReset:c,viewTransition:d,...p},h){let{basename:m}=ee.useContext(pl),g=typeof u=="string"&&cG.test(u),y,b=!1;if(typeof u=="string"&&g&&(y=u,uG))try{let R=new URL(window.location.href),D=u.startsWith("//")?new URL(R.protocol+u):new URL(u),$=Ou(D.pathname,m);D.origin===R.origin&&$!=null?u=$+D.search+D.hash:b=!0}catch{tl(!1,`<Link to="${u}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}let v=Mie(u,{relative:s}),[k,I,S]=yoe(r,p),N=Noe(u,{replace:i,state:o,target:l,preventScrollReset:c,relative:s,viewTransition:d});function T(R){t&&t(R),R.defaultPrevented||N(R)}let A=ee.createElement("a",{...p,...S,href:y||v,onClick:b||a?t:T,ref:woe(h,I),target:l,"data-discover":!g&&n==="render"?"true":void 0});return k&&!g?ee.createElement(ee.Fragment,null,A,ee.createElement(xoe,{page:v})):A});dG.displayName="Link";var Ioe=ee.forwardRef(function({"aria-current":t="page",caseSensitive:n=!1,className:r="",end:s=!1,style:a,to:i,viewTransition:o,children:l,...u},c){let d=Hv(i,{relative:u.relative}),p=Uu(),h=ee.useContext(JI),{navigator:m,basename:g}=ee.useContext(pl),y=h!=null&&Aoe(d)&&o===!0,b=m.encodeLocation?m.encodeLocation(d).pathname:d.pathname,v=p.pathname,k=h&&h.navigation&&h.navigation.location?h.navigation.location.pathname:null;n||(v=v.toLowerCase(),k=k?k.toLowerCase():null,b=b.toLowerCase()),k&&g&&(k=Ou(k,g)||k);const I=b!=="/"&&b.endsWith("/")?b.length-1:b.length;let S=v===b||!s&&v.startsWith(b)&&v.charAt(I)==="/",N=k!=null&&(k===b||!s&&k.startsWith(b)&&k.charAt(b.length)==="/"),T={isActive:S,isPending:N,isTransitioning:y},A=S?t:void 0,R;typeof r=="function"?R=r(T):R=[r,S?"active":null,N?"pending":null,y?"transitioning":null].filter(Boolean).join(" ");let D=typeof a=="function"?a(T):a;return ee.createElement(dG,{...u,"aria-current":A,className:R,ref:c,style:D,to:i,viewTransition:o},typeof l=="function"?l(T):l)});Ioe.displayName="NavLink";var Soe=ee.forwardRef(({discover:e="render",fetcherKey:t,navigate:n,reloadDocument:r,replace:s,state:a,method:i=d2,action:o,onSubmit:l,relative:u,preventScrollReset:c,viewTransition:d,...p},h)=>{let m=Eoe(),g=_oe(o,{relative:u}),y=i.toLowerCase()==="get"?"get":"post",b=typeof o=="string"&&cG.test(o),v=k=>{if(l&&l(k),k.defaultPrevented)return;k.preventDefault();let I=k.nativeEvent.submitter,S=(I==null?void 0:I.getAttribute("formmethod"))||i;m(I||k.currentTarget,{fetcherKey:t,method:S,navigate:n,replace:s,state:a,relative:u,preventScrollReset:c,viewTransition:d})};return ee.createElement("form",{ref:h,method:y,action:g,onSubmit:r?l:v,...p,"data-discover":!b&&e==="render"?"true":void 0})});Soe.displayName="Form";function Coe(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function pG(e){let t=ee.useContext(ry);return $r(t,Coe(e)),t}function Noe(e,{target:t,replace:n,state:r,preventScrollReset:s,relative:a,viewTransition:i}={}){let o=yd(),l=Uu(),u=Hv(e,{relative:a});return ee.useCallback(c=>{if(roe(c,t)){c.preventDefault();let d=n!==void 0?n:uv(l)===uv(u);o(e,{replace:d,state:r,preventScrollReset:s,relative:a,viewTransition:i})}},[l,o,u,n,r,t,e,s,a,i])}var Toe=0,$oe=()=>`__${String(++Toe)}__`;function Eoe(){let{router:e}=pG("useSubmit"),{basename:t}=ee.useContext(pl),n=qie();return ee.useCallback(async(r,s={})=>{let{action:a,method:i,encType:o,formData:l,body:u}=ioe(r,t);if(s.navigate===!1){let c=s.fetcherKey||$oe();await e.fetch(c,n,s.action||a,{preventScrollReset:s.preventScrollReset,formData:l,body:u,formMethod:s.method||i,formEncType:s.encType||o,flushSync:s.flushSync})}else await e.navigate(s.action||a,{preventScrollReset:s.preventScrollReset,formData:l,body:u,formMethod:s.method||i,formEncType:s.encType||o,replace:s.replace,state:s.state,fromRouteId:n,flushSync:s.flushSync,viewTransition:s.viewTransition})},[e,t,n])}function _oe(e,{relative:t}={}){let{basename:n}=ee.useContext(pl),r=ee.useContext(iu);$r(r,"useFormAction must be used inside a RouteContext");let[s]=r.matches.slice(-1),a={...Hv(e||".",{relative:t})},i=Uu();if(e==null){a.search=i.search;let o=new URLSearchParams(a.search),l=o.getAll("index");if(l.some(c=>c==="")){o.delete("index"),l.filter(d=>d).forEach(d=>o.append("index",d));let c=o.toString();a.search=c?`?${c}`:""}}return(!e||e===".")&&s.route.index&&(a.search=a.search?a.search.replace(/^\?/,"?index&"):"?index"),n!=="/"&&(a.pathname=a.pathname==="/"?n:_u([n,a.pathname])),uv(a)}function Aoe(e,t={}){let n=ee.useContext(nG);$r(n!=null,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:r}=pG("useViewTransitionState"),s=Hv(e,{relative:t.relative});if(!n.isTransitioning)return!1;let a=Ou(n.currentLocation.pathname,r)||n.currentLocation.pathname,i=Ou(n.nextLocation.pathname,r)||n.nextLocation.pathname;return F2(s.pathname,i)!=null||F2(s.pathname,a)!=null}[...foe];function hG(e){var t,n,r="";if(typeof e=="string"||typeof e=="number")r+=e;else if(typeof e=="object")if(Array.isArray(e)){var s=e.length;for(t=0;t<s;t++)e[t]&&(n=hG(e[t]))&&(r&&(r+=" "),r+=n)}else for(n in e)e[n]&&(r&&(r+=" "),r+=n);return r}function Lp(){for(var e,t,n=0,r="",s=arguments.length;n<s;n++)(e=arguments[n])&&(t=hG(e))&&(r&&(r+=" "),r+=t);return r}function Roe(e){if(typeof document>"u")return;let t=document.head||document.getElementsByTagName("head")[0],n=document.createElement("style");n.type="text/css",t.firstChild?t.insertBefore(n,t.firstChild):t.appendChild(n),n.styleSheet?n.styleSheet.cssText=e:n.appendChild(document.createTextNode(e))}Roe(`:root{--toastify-color-light: #fff;--toastify-color-dark: #121212;--toastify-color-info: #3498db;--toastify-color-success: #07bc0c;--toastify-color-warning: #f1c40f;--toastify-color-error: hsl(6, 78%, 57%);--toastify-color-transparent: rgba(255, 255, 255, .7);--toastify-icon-color-info: var(--toastify-color-info);--toastify-icon-color-success: var(--toastify-color-success);--toastify-icon-color-warning: var(--toastify-color-warning);--toastify-icon-color-error: var(--toastify-color-error);--toastify-container-width: fit-content;--toastify-toast-width: 320px;--toastify-toast-offset: 16px;--toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));--toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));--toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));--toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));--toastify-toast-background: #fff;--toastify-toast-padding: 14px;--toastify-toast-min-height: 64px;--toastify-toast-max-height: 800px;--toastify-toast-bd-radius: 6px;--toastify-toast-shadow: 0px 4px 12px rgba(0, 0, 0, .1);--toastify-font-family: sans-serif;--toastify-z-index: 9999;--toastify-text-color-light: #757575;--toastify-text-color-dark: #fff;--toastify-text-color-info: #fff;--toastify-text-color-success: #fff;--toastify-text-color-warning: #fff;--toastify-text-color-error: #fff;--toastify-spinner-color: #616161;--toastify-spinner-color-empty-area: #e0e0e0;--toastify-color-progress-light: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);--toastify-color-progress-dark: #bb86fc;--toastify-color-progress-info: var(--toastify-color-info);--toastify-color-progress-success: var(--toastify-color-success);--toastify-color-progress-warning: var(--toastify-color-warning);--toastify-color-progress-error: var(--toastify-color-error);--toastify-color-progress-bgo: .2}.Toastify__toast-container{z-index:var(--toastify-z-index);-webkit-transform:translate3d(0,0,var(--toastify-z-index));position:fixed;width:var(--toastify-container-width);box-sizing:border-box;color:#fff;display:flex;flex-direction:column}.Toastify__toast-container--top-left{top:var(--toastify-toast-top);left:var(--toastify-toast-left)}.Toastify__toast-container--top-center{top:var(--toastify-toast-top);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--top-right{top:var(--toastify-toast-top);right:var(--toastify-toast-right);align-items:end}.Toastify__toast-container--bottom-left{bottom:var(--toastify-toast-bottom);left:var(--toastify-toast-left)}.Toastify__toast-container--bottom-center{bottom:var(--toastify-toast-bottom);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--bottom-right{bottom:var(--toastify-toast-bottom);right:var(--toastify-toast-right);align-items:end}.Toastify__toast{--y: 0;position:relative;touch-action:none;width:var(--toastify-toast-width);min-height:var(--toastify-toast-min-height);box-sizing:border-box;margin-bottom:1rem;padding:var(--toastify-toast-padding);border-radius:var(--toastify-toast-bd-radius);box-shadow:var(--toastify-toast-shadow);max-height:var(--toastify-toast-max-height);font-family:var(--toastify-font-family);z-index:0;display:flex;flex:1 auto;align-items:center;word-break:break-word}@media only screen and (max-width: 480px){.Toastify__toast-container{width:100vw;left:env(safe-area-inset-left);margin:0}.Toastify__toast-container--top-left,.Toastify__toast-container--top-center,.Toastify__toast-container--top-right{top:env(safe-area-inset-top);transform:translate(0)}.Toastify__toast-container--bottom-left,.Toastify__toast-container--bottom-center,.Toastify__toast-container--bottom-right{bottom:env(safe-area-inset-bottom);transform:translate(0)}.Toastify__toast-container--rtl{right:env(safe-area-inset-right);left:initial}.Toastify__toast{--toastify-toast-width: 100%;margin-bottom:0;border-radius:0}}.Toastify__toast-container[data-stacked=true]{width:var(--toastify-toast-width)}.Toastify__toast--stacked{position:absolute;width:100%;transform:translate3d(0,var(--y),0) scale(var(--s));transition:transform .3s}.Toastify__toast--stacked[data-collapsed] .Toastify__toast-body,.Toastify__toast--stacked[data-collapsed] .Toastify__close-button{transition:opacity .1s}.Toastify__toast--stacked[data-collapsed=false]{overflow:visible}.Toastify__toast--stacked[data-collapsed=true]:not(:last-child)>*{opacity:0}.Toastify__toast--stacked:after{content:"";position:absolute;left:0;right:0;height:calc(var(--g) * 1px);bottom:100%}.Toastify__toast--stacked[data-pos=top]{top:0}.Toastify__toast--stacked[data-pos=bot]{bottom:0}.Toastify__toast--stacked[data-pos=bot].Toastify__toast--stacked:before{transform-origin:top}.Toastify__toast--stacked[data-pos=top].Toastify__toast--stacked:before{transform-origin:bottom}.Toastify__toast--stacked:before{content:"";position:absolute;left:0;right:0;bottom:0;height:100%;transform:scaleY(3);z-index:-1}.Toastify__toast--rtl{direction:rtl}.Toastify__toast--close-on-click{cursor:pointer}.Toastify__toast-icon{margin-inline-end:10px;width:22px;flex-shrink:0;display:flex}.Toastify--animate{animation-fill-mode:both;animation-duration:.5s}.Toastify--animate-icon{animation-fill-mode:both;animation-duration:.3s}.Toastify__toast-theme--dark{background:var(--toastify-color-dark);color:var(--toastify-text-color-dark)}.Toastify__toast-theme--light,.Toastify__toast-theme--colored.Toastify__toast--default{background:var(--toastify-color-light);color:var(--toastify-text-color-light)}.Toastify__toast-theme--colored.Toastify__toast--info{color:var(--toastify-text-color-info);background:var(--toastify-color-info)}.Toastify__toast-theme--colored.Toastify__toast--success{color:var(--toastify-text-color-success);background:var(--toastify-color-success)}.Toastify__toast-theme--colored.Toastify__toast--warning{color:var(--toastify-text-color-warning);background:var(--toastify-color-warning)}.Toastify__toast-theme--colored.Toastify__toast--error{color:var(--toastify-text-color-error);background:var(--toastify-color-error)}.Toastify__progress-bar-theme--light{background:var(--toastify-color-progress-light)}.Toastify__progress-bar-theme--dark{background:var(--toastify-color-progress-dark)}.Toastify__progress-bar--info{background:var(--toastify-color-progress-info)}.Toastify__progress-bar--success{background:var(--toastify-color-progress-success)}.Toastify__progress-bar--warning{background:var(--toastify-color-progress-warning)}.Toastify__progress-bar--error{background:var(--toastify-color-progress-error)}.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error{background:var(--toastify-color-transparent)}.Toastify__close-button{color:#fff;position:absolute;top:6px;right:6px;background:transparent;outline:none;border:none;padding:0;cursor:pointer;opacity:.7;transition:.3s ease;z-index:1}.Toastify__toast--rtl .Toastify__close-button{left:6px;right:unset}.Toastify__close-button--light{color:#000;opacity:.3}.Toastify__close-button>svg{fill:currentColor;height:16px;width:14px}.Toastify__close-button:hover,.Toastify__close-button:focus{opacity:1}@keyframes Toastify__trackProgress{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Toastify__progress-bar{position:absolute;bottom:0;left:0;width:100%;height:100%;z-index:1;opacity:.7;transform-origin:left}.Toastify__progress-bar--animated{animation:Toastify__trackProgress linear 1 forwards}.Toastify__progress-bar--controlled{transition:transform .2s}.Toastify__progress-bar--rtl{right:0;left:initial;transform-origin:right;border-bottom-left-radius:initial}.Toastify__progress-bar--wrp{position:absolute;overflow:hidden;bottom:0;left:0;width:100%;height:5px;border-bottom-left-radius:var(--toastify-toast-bd-radius);border-bottom-right-radius:var(--toastify-toast-bd-radius)}.Toastify__progress-bar--wrp[data-hidden=true]{opacity:0}.Toastify__progress-bar--bg{opacity:var(--toastify-color-progress-bgo);width:100%;height:100%}.Toastify__spinner{width:20px;height:20px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--toastify-spinner-color-empty-area);border-right-color:var(--toastify-spinner-color);animation:Toastify__spin .65s linear infinite}@keyframes Toastify__bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutRight{20%{opacity:1;transform:translate3d(-20px,var(--y),0)}to{opacity:0;transform:translate3d(2000px,var(--y),0)}}@keyframes Toastify__bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutLeft{20%{opacity:1;transform:translate3d(20px,var(--y),0)}to{opacity:0;transform:translate3d(-2000px,var(--y),0)}}@keyframes Toastify__bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes Toastify__bounceOutUp{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes Toastify__bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes Toastify__bounceOutDown{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Toastify__bounce-enter--top-left,.Toastify__bounce-enter--bottom-left{animation-name:Toastify__bounceInLeft}.Toastify__bounce-enter--top-right,.Toastify__bounce-enter--bottom-right{animation-name:Toastify__bounceInRight}.Toastify__bounce-enter--top-center{animation-name:Toastify__bounceInDown}.Toastify__bounce-enter--bottom-center{animation-name:Toastify__bounceInUp}.Toastify__bounce-exit--top-left,.Toastify__bounce-exit--bottom-left{animation-name:Toastify__bounceOutLeft}.Toastify__bounce-exit--top-right,.Toastify__bounce-exit--bottom-right{animation-name:Toastify__bounceOutRight}.Toastify__bounce-exit--top-center{animation-name:Toastify__bounceOutUp}.Toastify__bounce-exit--bottom-center{animation-name:Toastify__bounceOutDown}@keyframes Toastify__zoomIn{0%{opacity:0;transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes Toastify__zoomOut{0%{opacity:1}50%{opacity:0;transform:translate3d(0,var(--y),0) scale3d(.3,.3,.3)}to{opacity:0}}.Toastify__zoom-enter{animation-name:Toastify__zoomIn}.Toastify__zoom-exit{animation-name:Toastify__zoomOut}@keyframes Toastify__flipIn{0%{transform:perspective(400px) rotateX(90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotateX(-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotateX(10deg);opacity:1}80%{transform:perspective(400px) rotateX(-5deg)}to{transform:perspective(400px)}}@keyframes Toastify__flipOut{0%{transform:translate3d(0,var(--y),0) perspective(400px)}30%{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(-20deg);opacity:1}to{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(90deg);opacity:0}}.Toastify__flip-enter{animation-name:Toastify__flipIn}.Toastify__flip-exit{animation-name:Toastify__flipOut}@keyframes Toastify__slideInRight{0%{transform:translate3d(110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInLeft{0%{transform:translate3d(-110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInUp{0%{transform:translate3d(0,110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInDown{0%{transform:translate3d(0,-110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideOutRight{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(110%,var(--y),0)}}@keyframes Toastify__slideOutLeft{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(-110%,var(--y),0)}}@keyframes Toastify__slideOutDown{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,500px,0)}}@keyframes Toastify__slideOutUp{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,-500px,0)}}.Toastify__slide-enter--top-left,.Toastify__slide-enter--bottom-left{animation-name:Toastify__slideInLeft}.Toastify__slide-enter--top-right,.Toastify__slide-enter--bottom-right{animation-name:Toastify__slideInRight}.Toastify__slide-enter--top-center{animation-name:Toastify__slideInDown}.Toastify__slide-enter--bottom-center{animation-name:Toastify__slideInUp}.Toastify__slide-exit--top-left,.Toastify__slide-exit--bottom-left{animation-name:Toastify__slideOutLeft;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-right,.Toastify__slide-exit--bottom-right{animation-name:Toastify__slideOutRight;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-center{animation-name:Toastify__slideOutUp;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--bottom-center{animation-name:Toastify__slideOutDown;animation-timing-function:ease-in;animation-duration:.3s}@keyframes Toastify__spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}
`);var qv=e=>typeof e=="number"&&!isNaN(e),Kp=e=>typeof e=="string",Mu=e=>typeof e=="function",Doe=e=>Kp(e)||qv(e),l_=e=>Kp(e)||Mu(e)?e:null,Foe=(e,t)=>e===!1||qv(e)&&e>0?e:t,u_=e=>ee.isValidElement(e)||Kp(e)||Mu(e)||qv(e);function Ooe(e,t,n=300){let{scrollHeight:r,style:s}=e;requestAnimationFrame(()=>{s.minHeight="initial",s.height=r+"px",s.transition=`all ${n}ms`,requestAnimationFrame(()=>{s.height="0",s.padding="0",s.margin="0",setTimeout(t,n)})})}function Moe({enter:e,exit:t,appendPosition:n=!1,collapse:r=!0,collapseDuration:s=300}){return function({children:a,position:i,preventExitTransition:o,done:l,nodeRef:u,isIn:c,playToast:d}){let p=n?`${e}--${i}`:e,h=n?`${t}--${i}`:t,m=ee.useRef(0);return ee.useLayoutEffect(()=>{let g=u.current,y=p.split(" "),b=v=>{v.target===u.current&&(d(),g.removeEventListener("animationend",b),g.removeEventListener("animationcancel",b),m.current===0&&v.type!=="animationcancel"&&g.classList.remove(...y))};g.classList.add(...y),g.addEventListener("animationend",b),g.addEventListener("animationcancel",b)},[]),ee.useEffect(()=>{let g=u.current,y=()=>{g.removeEventListener("animationend",y),r?Ooe(g,l,s):l()};c||(o?y():(m.current=1,g.className+=` ${h}`,g.addEventListener("animationend",y)))},[c]),Lt.createElement(Lt.Fragment,null,a)}}function wB(e,t){return{content:fG(e.content,e.props),containerId:e.props.containerId,id:e.props.toastId,theme:e.props.theme,type:e.props.type,data:e.props.data||{},isLoading:e.props.isLoading,icon:e.props.icon,reason:e.removalReason,status:t}}function fG(e,t,n=!1){return ee.isValidElement(e)&&!Kp(e.type)?ee.cloneElement(e,{closeToast:t.closeToast,toastProps:t,data:t.data,isPaused:n}):Mu(e)?e({closeToast:t.closeToast,toastProps:t,data:t.data,isPaused:n}):e}function Loe({closeToast:e,theme:t,ariaLabel:n="close"}){return Lt.createElement("button",{className:`Toastify__close-button Toastify__close-button--${t}`,type:"button",onClick:r=>{r.stopPropagation(),e(!0)},"aria-label":n},Lt.createElement("svg",{"aria-hidden":"true",viewBox:"0 0 14 16"},Lt.createElement("path",{fillRule:"evenodd",d:"M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"})))}function Poe({delay:e,isRunning:t,closeToast:n,type:r="default",hide:s,className:a,controlledProgress:i,progress:o,rtl:l,isIn:u,theme:c}){let d=s||i&&o===0,p={animationDuration:`${e}ms`,animationPlayState:t?"running":"paused"};i&&(p.transform=`scaleX(${o})`);let h=Lp("Toastify__progress-bar",i?"Toastify__progress-bar--controlled":"Toastify__progress-bar--animated",`Toastify__progress-bar-theme--${c}`,`Toastify__progress-bar--${r}`,{"Toastify__progress-bar--rtl":l}),m=Mu(a)?a({rtl:l,type:r,defaultClassName:h}):Lp(h,a),g={[i&&o>=1?"onTransitionEnd":"onAnimationEnd"]:i&&o<1?null:()=>{u&&n()}};return Lt.createElement("div",{className:"Toastify__progress-bar--wrp","data-hidden":d},Lt.createElement("div",{className:`Toastify__progress-bar--bg Toastify__progress-bar-theme--${c} Toastify__progress-bar--${r}`}),Lt.createElement("div",{role:"progressbar","aria-hidden":d?"true":"false","aria-label":"notification timer",className:m,style:p,...g}))}var zoe=1,mG=()=>`${zoe++}`;function Boe(e,t,n){let r=1,s=0,a=[],i=[],o=t,l=new Map,u=new Set,c=v=>(u.add(v),()=>u.delete(v)),d=()=>{i=Array.from(l.values()),u.forEach(v=>v())},p=({containerId:v,toastId:k,updateId:I})=>{let S=v?v!==e:e!==1,N=l.has(k)&&I==null;return S||N},h=(v,k)=>{l.forEach(I=>{var S;(k==null||k===I.props.toastId)&&((S=I.toggle)==null||S.call(I,v))})},m=v=>{var k,I;(I=(k=v.props)==null?void 0:k.onClose)==null||I.call(k,v.removalReason),v.isActive=!1},g=v=>{if(v==null)l.forEach(m);else{let k=l.get(v);k&&m(k)}d()},y=()=>{s-=a.length,a=[]},b=v=>{var k,I;let{toastId:S,updateId:N}=v.props,T=N==null;v.staleId&&l.delete(v.staleId),v.isActive=!0,l.set(S,v),d(),n(wB(v,T?"added":"updated")),T&&((I=(k=v.props).onOpen)==null||I.call(k))};return{id:e,props:o,observe:c,toggle:h,removeToast:g,toasts:l,clearQueue:y,buildToast:(v,k)=>{if(p(k))return;let{toastId:I,updateId:S,data:N,staleId:T,delay:A}=k,R=S==null;R&&s++;let D={...o,style:o.toastStyle,key:r++,...Object.fromEntries(Object.entries(k).filter(([_,L])=>L!=null)),toastId:I,updateId:S,data:N,isIn:!1,className:l_(k.className||o.toastClassName),progressClassName:l_(k.progressClassName||o.progressClassName),autoClose:k.isLoading?!1:Foe(k.autoClose,o.autoClose),closeToast(_){l.get(I).removalReason=_,g(I)},deleteToast(){let _=l.get(I);if(_!=null){if(n(wB(_,"removed")),l.delete(I),s--,s<0&&(s=0),a.length>0){b(a.shift());return}d()}}};D.closeButton=o.closeButton,k.closeButton===!1||u_(k.closeButton)?D.closeButton=k.closeButton:k.closeButton===!0&&(D.closeButton=u_(o.closeButton)?o.closeButton:!0);let $={content:v,props:D,staleId:T};o.limit&&o.limit>0&&s>o.limit&&R?a.push($):qv(A)?setTimeout(()=>{b($)},A):b($)},setProps(v){o=v},setToggle:(v,k)=>{let I=l.get(v);I&&(I.toggle=k)},isToastActive:v=>{var k;return(k=l.get(v))==null?void 0:k.isActive},getSnapshot:()=>i}}var ja=new Map,cv=[],c_=new Set,Woe=e=>c_.forEach(t=>t(e)),gG=()=>ja.size>0;function Voe(){cv.forEach(e=>xG(e.content,e.options)),cv=[]}var Uoe=(e,{containerId:t})=>{var n;return(n=ja.get(t||1))==null?void 0:n.toasts.get(e)};function yG(e,t){var n;if(t)return!!((n=ja.get(t))!=null&&n.isToastActive(e));let r=!1;return ja.forEach(s=>{s.isToastActive(e)&&(r=!0)}),r}function Goe(e){if(!gG()){cv=cv.filter(t=>e!=null&&t.options.toastId!==e);return}if(e==null||Doe(e))ja.forEach(t=>{t.removeToast(e)});else if(e&&("containerId"in e||"id"in e)){let t=ja.get(e.containerId);t?t.removeToast(e.id):ja.forEach(n=>{n.removeToast(e.id)})}}var joe=(e={})=>{ja.forEach(t=>{t.props.limit&&(!e.containerId||t.id===e.containerId)&&t.clearQueue()})};function xG(e,t){u_(e)&&(gG()||cv.push({content:e,options:t}),ja.forEach(n=>{n.buildToast(e,t)}))}function Hoe(e){var t;(t=ja.get(e.containerId||1))==null||t.setToggle(e.id,e.fn)}function bG(e,t){ja.forEach(n=>{(t==null||!(t!=null&&t.containerId)||(t==null?void 0:t.containerId)===n.id)&&n.toggle(e,t==null?void 0:t.id)})}function qoe(e){let t=e.containerId||1;return{subscribe(n){let r=Boe(t,e,Woe);ja.set(t,r);let s=r.observe(n);return Voe(),()=>{s(),ja.delete(t)}},setProps(n){var r;(r=ja.get(t))==null||r.setProps(n)},getSnapshot(){var n;return(n=ja.get(t))==null?void 0:n.getSnapshot()}}}function Koe(e){return c_.add(e),()=>{c_.delete(e)}}function Xoe(e){return e&&(Kp(e.toastId)||qv(e.toastId))?e.toastId:mG()}function Kv(e,t){return xG(e,t),t.toastId}function eS(e,t){return{...t,type:t&&t.type||e,toastId:Xoe(t)}}function tS(e){return(t,n)=>Kv(t,eS(e,n))}function xn(e,t){return Kv(e,eS("default",t))}xn.loading=(e,t)=>Kv(e,eS("default",{isLoading:!0,autoClose:!1,closeOnClick:!1,closeButton:!1,draggable:!1,...t}));function Yoe(e,{pending:t,error:n,success:r},s){let a;t&&(a=Kp(t)?xn.loading(t,s):xn.loading(t.render,{...s,...t}));let i={isLoading:null,autoClose:null,closeOnClick:null,closeButton:null,draggable:null},o=(u,c,d)=>{if(c==null){xn.dismiss(a);return}let p={type:u,...i,...s,data:d},h=Kp(c)?{render:c}:c;return a?xn.update(a,{...p,...h}):xn(h.render,{...p,...h}),d},l=Mu(e)?e():e;return l.then(u=>o("success",r,u)).catch(u=>o("error",n,u)),l}xn.promise=Yoe;xn.success=tS("success");xn.info=tS("info");xn.error=tS("error");xn.warning=tS("warning");xn.warn=xn.warning;xn.dark=(e,t)=>Kv(e,eS("default",{theme:"dark",...t}));function Zoe(e){Goe(e)}xn.dismiss=Zoe;xn.clearWaitingQueue=joe;xn.isActive=yG;xn.update=(e,t={})=>{let n=Uoe(e,t);if(n){let{props:r,content:s}=n,a={delay:100,...r,...t,toastId:t.toastId||e,updateId:mG()};a.toastId!==e&&(a.staleId=e);let i=a.render||s;delete a.render,Kv(i,a)}};xn.done=e=>{xn.update(e,{progress:1})};xn.onChange=Koe;xn.play=e=>bG(!0,e);xn.pause=e=>bG(!1,e);function Joe(e){var t;let{subscribe:n,getSnapshot:r,setProps:s}=ee.useRef(qoe(e)).current;s(e);let a=(t=ee.useSyncExternalStore(n,r,r))==null?void 0:t.slice();function i(o){if(!a)return[];let l=new Map;return e.newestOnTop&&a.reverse(),a.forEach(u=>{let{position:c}=u.props;l.has(c)||l.set(c,[]),l.get(c).push(u)}),Array.from(l,u=>o(u[0],u[1]))}return{getToastToRender:i,isToastActive:yG,count:a==null?void 0:a.length}}function Qoe(e){let[t,n]=ee.useState(!1),[r,s]=ee.useState(!1),a=ee.useRef(null),i=ee.useRef({start:0,delta:0,removalDistance:0,canCloseOnClick:!0,canDrag:!1,didMove:!1}).current,{autoClose:o,pauseOnHover:l,closeToast:u,onClick:c,closeOnClick:d}=e;Hoe({id:e.toastId,containerId:e.containerId,fn:n}),ee.useEffect(()=>{if(e.pauseOnFocusLoss)return p(),()=>{h()}},[e.pauseOnFocusLoss]);function p(){document.hasFocus()||b(),window.addEventListener("focus",y),window.addEventListener("blur",b)}function h(){window.removeEventListener("focus",y),window.removeEventListener("blur",b)}function m(T){if(e.draggable===!0||e.draggable===T.pointerType){v();let A=a.current;i.canCloseOnClick=!0,i.canDrag=!0,A.style.transition="none",e.draggableDirection==="x"?(i.start=T.clientX,i.removalDistance=A.offsetWidth*(e.draggablePercent/100)):(i.start=T.clientY,i.removalDistance=A.offsetHeight*(e.draggablePercent===80?e.draggablePercent*1.5:e.draggablePercent)/100)}}function g(T){let{top:A,bottom:R,left:D,right:$}=a.current.getBoundingClientRect();T.nativeEvent.type!=="touchend"&&e.pauseOnHover&&T.clientX>=D&&T.clientX<=$&&T.clientY>=A&&T.clientY<=R?b():y()}function y(){n(!0)}function b(){n(!1)}function v(){i.didMove=!1,document.addEventListener("pointermove",I),document.addEventListener("pointerup",S)}function k(){document.removeEventListener("pointermove",I),document.removeEventListener("pointerup",S)}function I(T){let A=a.current;if(i.canDrag&&A){i.didMove=!0,t&&b(),e.draggableDirection==="x"?i.delta=T.clientX-i.start:i.delta=T.clientY-i.start,i.start!==T.clientX&&(i.canCloseOnClick=!1);let R=e.draggableDirection==="x"?`${i.delta}px, var(--y)`:`0, calc(${i.delta}px + var(--y))`;A.style.transform=`translate3d(${R},0)`,A.style.opacity=`${1-Math.abs(i.delta/i.removalDistance)}`}}function S(){k();let T=a.current;if(i.canDrag&&i.didMove&&T){if(i.canDrag=!1,Math.abs(i.delta)>i.removalDistance){s(!0),e.closeToast(!0),e.collapseAll();return}T.style.transition="transform 0.2s, opacity 0.2s",T.style.removeProperty("transform"),T.style.removeProperty("opacity")}}let N={onPointerDown:m,onPointerUp:g};return o&&l&&(N.onMouseEnter=b,e.stacked||(N.onMouseLeave=y)),d&&(N.onClick=T=>{c&&c(T),i.canCloseOnClick&&u(!0)}),{playToast:y,pauseToast:b,isRunning:t,preventExitTransition:r,toastRef:a,eventHandlers:N}}var ele=typeof window<"u"?ee.useLayoutEffect:ee.useEffect,nS=({theme:e,type:t,isLoading:n,...r})=>Lt.createElement("svg",{viewBox:"0 0 24 24",width:"100%",height:"100%",fill:e==="colored"?"currentColor":`var(--toastify-icon-color-${t})`,...r});function tle(e){return Lt.createElement(nS,{...e},Lt.createElement("path",{d:"M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"}))}function nle(e){return Lt.createElement(nS,{...e},Lt.createElement("path",{d:"M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"}))}function rle(e){return Lt.createElement(nS,{...e},Lt.createElement("path",{d:"M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"}))}function sle(e){return Lt.createElement(nS,{...e},Lt.createElement("path",{d:"M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"}))}function ale(){return Lt.createElement("div",{className:"Toastify__spinner"})}var d_={info:nle,warning:tle,success:rle,error:sle,spinner:ale},ile=e=>e in d_;function ole({theme:e,type:t,isLoading:n,icon:r}){let s=null,a={theme:e,type:t};return r===!1||(Mu(r)?s=r({...a,isLoading:n}):ee.isValidElement(r)?s=ee.cloneElement(r,a):n?s=d_.spinner():ile(t)&&(s=d_[t](a))),s}var lle=e=>{let{isRunning:t,preventExitTransition:n,toastRef:r,eventHandlers:s,playToast:a}=Qoe(e),{closeButton:i,children:o,autoClose:l,onClick:u,type:c,hideProgressBar:d,closeToast:p,transition:h,position:m,className:g,style:y,progressClassName:b,updateId:v,role:k,progress:I,rtl:S,toastId:N,deleteToast:T,isIn:A,isLoading:R,closeOnClick:D,theme:$,ariaLabel:_}=e,L=Lp("Toastify__toast",`Toastify__toast-theme--${$}`,`Toastify__toast--${c}`,{"Toastify__toast--rtl":S},{"Toastify__toast--close-on-click":D}),z=Mu(g)?g({rtl:S,position:m,type:c,defaultClassName:L}):Lp(L,g),W=ole(e),G=!!I||!l,q={closeToast:p,type:c,theme:$},B=null;return i===!1||(Mu(i)?B=i(q):ee.isValidElement(i)?B=ee.cloneElement(i,q):B=Loe(q)),Lt.createElement(h,{isIn:A,done:T,position:m,preventExitTransition:n,nodeRef:r,playToast:a},Lt.createElement("div",{id:N,tabIndex:0,onClick:u,"data-in":A,className:z,...s,style:y,ref:r,...A&&{role:k,"aria-label":_}},W!=null&&Lt.createElement("div",{className:Lp("Toastify__toast-icon",{"Toastify--animate-icon Toastify__zoom-enter":!R})},W),fG(o,e,!t),B,!e.customProgressBar&&Lt.createElement(Poe,{...v&&!G?{key:`p-${v}`}:{},rtl:S,theme:$,delay:l,isRunning:t,isIn:A,closeToast:p,hide:d,type:c,className:b,controlledProgress:G,progress:I||0})))},ule=(e,t=!1)=>({enter:`Toastify--animate Toastify__${e}-enter`,exit:`Toastify--animate Toastify__${e}-exit`,appendPosition:t}),cle=Moe(ule("bounce",!0)),dle={position:"top-right",transition:cle,autoClose:5e3,closeButton:!0,pauseOnHover:!0,pauseOnFocusLoss:!0,draggable:"touch",draggablePercent:80,draggableDirection:"x",role:"alert",theme:"light","aria-label":"Notifications Alt+T",hotKeys:e=>e.altKey&&e.code==="KeyT"};function _R(e){let t={...dle,...e},n=e.stacked,[r,s]=ee.useState(!0),a=ee.useRef(null),{getToastToRender:i,isToastActive:o,count:l}=Joe(t),{className:u,style:c,rtl:d,containerId:p,hotKeys:h}=t;function m(y){let b=Lp("Toastify__toast-container",`Toastify__toast-container--${y}`,{"Toastify__toast-container--rtl":d});return Mu(u)?u({position:y,rtl:d,defaultClassName:b}):Lp(b,l_(u))}function g(){n&&(s(!0),xn.play())}return ele(()=>{var y;if(n){let b=a.current.querySelectorAll('[data-in="true"]'),v=12,k=(y=t.position)==null?void 0:y.includes("top"),I=0,S=0;Array.from(b).reverse().forEach((N,T)=>{let A=N;A.classList.add("Toastify__toast--stacked"),T>0&&(A.dataset.collapsed=`${r}`),A.dataset.pos||(A.dataset.pos=k?"top":"bot");let R=I*(r?.2:1)+(r?0:v*T);A.style.setProperty("--y",`${k?R:R*-1}px`),A.style.setProperty("--g",`${v}`),A.style.setProperty("--s",`${1-(r?S:0)}`),I+=A.offsetHeight,S+=.025})}},[r,l,n]),ee.useEffect(()=>{function y(b){var v;let k=a.current;h(b)&&((v=k.querySelector('[tabIndex="0"]'))==null||v.focus(),s(!1),xn.pause()),b.key==="Escape"&&(document.activeElement===k||k!=null&&k.contains(document.activeElement))&&(s(!0),xn.play())}return document.addEventListener("keydown",y),()=>{document.removeEventListener("keydown",y)}},[h]),Lt.createElement("section",{ref:a,className:"Toastify",id:p,onMouseEnter:()=>{n&&(s(!1),xn.pause())},onMouseLeave:g,"aria-live":"polite","aria-atomic":"false","aria-relevant":"additions text","aria-label":t["aria-label"]},i((y,b)=>{let v=b.length?{...c}:{...c,pointerEvents:"none"};return Lt.createElement("div",{tabIndex:-1,className:m(y),"data-stacked":n,style:v,key:`c-${y}`},b.map(({content:k,props:I})=>Lt.createElement(lle,{...I,stacked:n,collapseAll:g,isIn:o(I.toastId,I.containerId),key:`t-${I.key}`},k)))}))}var vG={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},kB=Lt.createContext&&Lt.createContext(vG),ple=["attr","size","title"];function hle(e,t){if(e==null)return{};var n=fle(e,t),r,s;if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)r=a[s],!(t.indexOf(r)>=0)&&Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}function fle(e,t){if(e==null)return{};var n={};for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r)){if(t.indexOf(r)>=0)continue;n[r]=e[r]}return n}function O2(){return O2=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},O2.apply(this,arguments)}function IB(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable})),n.push.apply(n,r)}return n}function M2(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?IB(Object(n),!0).forEach(function(r){mle(e,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):IB(Object(n)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))})}return e}function mle(e,t,n){return t=gle(t),t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function gle(e){var t=yle(e,"string");return typeof t=="symbol"?t:t+""}function yle(e,t){if(typeof e!="object"||!e)return e;var n=e[Symbol.toPrimitive];if(n!==void 0){var r=n.call(e,t);if(typeof r!="object")return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(e)}function wG(e){return e&&e.map((t,n)=>Lt.createElement(t.tag,M2({key:n},t.attr),wG(t.child)))}function cr(e){return t=>Lt.createElement(xle,O2({attr:M2({},e.attr)},t),wG(e.child))}function xle(e){var t=n=>{var{attr:r,size:s,title:a}=e,i=hle(e,ple),o=s||n.size||"1em",l;return n.className&&(l=n.className),e.className&&(l=(l?l+" ":"")+e.className),Lt.createElement("svg",O2({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},n.attr,r,i,{className:l,style:M2(M2({color:e.color||n.color},n.style),e.style),height:o,width:o,xmlns:"http://www.w3.org/2000/svg"}),a&&Lt.createElement("title",null,a),e.children)};return kB!==void 0?Lt.createElement(kB.Consumer,null,n=>t(n)):t(vG)}function ble(e){return cr({attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"},child:[]}]})(e)}function vle(e){return cr({attr:{viewBox:"0 0 496 512"},child:[{tag:"path",attr:{d:"M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"},child:[]}]})(e)}function wle(e){return cr({attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"},child:[]}]})(e)}function kle(e){return cr({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"},child:[]}]})(e)}function kG(e){return cr({attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z"},child:[]}]})(e)}function IG(e){return cr({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"},child:[]}]})(e)}function SB(e){return cr({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"},child:[]}]})(e)}function Ile(e){return cr({attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4zM393.4 288H328v112c0 8.8-7.2 16-16 16h-48c-8.8 0-16-7.2-16-16V288h-65.4c-14.3 0-21.4-17.2-11.3-27.3l105.4-105.4c6.2-6.2 16.4-6.2 22.6 0l105.4 105.4c10.1 10.1 2.9 27.3-11.3 27.3z"},child:[]}]})(e)}function Sle(e){return cr({attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M528 0H48C21.5 0 0 21.5 0 48v320c0 26.5 21.5 48 48 48h192l-16 48h-72c-13.3 0-24 10.7-24 24s10.7 24 24 24h272c13.3 0 24-10.7 24-24s-10.7-24-24-24h-72l-16-48h192c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zm-16 352H64V64h448v288z"},child:[]}]})(e)}function Cle(e){return cr({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"},child:[]}]})(e)}function sE(e){return cr({attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"},child:[]}]})(e)}function SG(e){return cr({attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M400 224h-24v-72C376 68.2 307.8 0 224 0S72 68.2 72 152v72H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zm-104 0H152v-72c0-39.7 32.3-72 72-72s72 32.3 72 72v72z"},child:[]}]})(e)}function Nle(e){return cr({attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z"},child:[]}]})(e)}function Tle(e){return cr({attr:{viewBox:"0 0 320 512"},child:[{tag:"path",attr:{d:"M272 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h224c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM160 480c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm112-108c0 6.6-5.4 12-12 12H60c-6.6 0-12-5.4-12-12V60c0-6.6 5.4-12 12-12h200c6.6 0 12 5.4 12 12v312z"},child:[]}]})(e)}function $le(e){return cr({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M493.4 24.6l-104-24c-11.3-2.6-22.9 3.3-27.5 13.9l-48 112c-4.2 9.8-1.4 21.3 6.9 28l60.6 49.6c-36 76.7-98.9 140.5-177.2 177.2l-49.6-60.6c-6.8-8.3-18.2-11.1-28-6.9l-112 48C3.9 366.5-2 378.1.6 389.4l24 104C27.1 504.2 36.7 512 48 512c256.1 0 464-207.5 464-464 0-11.2-7.7-20.9-18.6-23.4z"},child:[]}]})(e)}function Ele(e){return cr({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"},child:[]}]})(e)}function AR(e){return cr({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M466.5 83.7l-192-80a48.15 48.15 0 0 0-36.9 0l-192 80C27.7 91.1 16 108.6 16 128c0 198.5 114.5 335.7 221.5 380.3 11.8 4.9 25.1 4.9 36.9 0C360.1 472.6 496 349.3 496 128c0-19.4-11.7-36.9-29.5-44.3zM256.1 446.3l-.1-381 175.9 73.3c-3.3 151.4-82.1 261.1-175.8 307.7z"},child:[]}]})(e)}function CG(e){return cr({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"},child:[]}]})(e)}function NG(e){return cr({attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"},child:[]}]})(e)}function CB(e){return cr({attr:{viewBox:"0 0 352 512"},child:[{tag:"path",attr:{d:"M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"},child:[]}]})(e)}function TG(e){return cr({attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M624 208h-64v-64c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v64h-64c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h64v64c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16v-64h64c8.8 0 16-7.2 16-16v-32c0-8.8-7.2-16-16-16zm-400 48c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"},child:[]}]})(e)}function _le(e){return cr({attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M622.3 271.1l-115.2-45c-4.1-1.6-12.6-3.7-22.2 0l-115.2 45c-10.7 4.2-17.7 14-17.7 24.9 0 111.6 68.7 188.8 132.9 213.9 9.6 3.7 18 1.6 22.2 0C558.4 489.9 640 420.5 640 296c0-10.9-7-20.7-17.7-24.9zM496 462.4V273.3l95.5 37.3c-5.6 87.1-60.9 135.4-95.5 151.8zM224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm96 40c0-2.5.8-4.8 1.1-7.2-2.5-.1-4.9-.8-7.5-.8h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c6.8 0 13.3-1.5 19.2-4-54-42.9-99.2-116.7-99.2-212z"},child:[]}]})(e)}const Ale="modulepreload",Rle=function(e){return"/E-CORP/"+e},NB={},Dle=function(t,n,r){let s=Promise.resolve();if(n&&n.length>0){let i=function(u){return Promise.all(u.map(c=>Promise.resolve(c).then(d=>({status:"fulfilled",value:d}),d=>({status:"rejected",reason:d}))))};document.getElementsByTagName("link");const o=document.querySelector("meta[property=csp-nonce]"),l=(o==null?void 0:o.nonce)||(o==null?void 0:o.getAttribute("nonce"));s=i(n.map(u=>{if(u=Rle(u),u in NB)return;NB[u]=!0;const c=u.endsWith(".css"),d=c?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${u}"]${d}`))return;const p=document.createElement("link");if(p.rel=c?"stylesheet":Ale,c||(p.as="script"),p.crossOrigin="",p.href=u,l&&p.setAttribute("nonce",l),document.head.appendChild(p),c)return new Promise((h,m)=>{p.addEventListener("load",h),p.addEventListener("error",()=>m(new Error(`Unable to preload CSS for ${u}`)))})}))}function a(i){const o=new Event("vite:preloadError",{cancelable:!0});if(o.payload=i,window.dispatchEvent(o),!o.defaultPrevented)throw i}return s.then(i=>{for(const o of i||[])o.status==="rejected"&&a(o.reason);return t().catch(a)})};function L2(){return L2=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)({}).hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},L2.apply(null,arguments)}function Fle(e,t){if(e==null)return{};var n={};for(var r in e)if({}.hasOwnProperty.call(e,r)){if(t.indexOf(r)!==-1)continue;n[r]=e[r]}return n}function Ole(e){ee.useEffect(e,[])}var Mle=["id","volume","playbackRate","soundEnabled","interrupt","onload"];function ra(e,t){var n=t===void 0?{}:t,r=n.volume,s=r===void 0?1:r,a=n.playbackRate,i=a===void 0?1:a,o=n.soundEnabled,l=o===void 0?!0:o,u=n.interrupt,c=u===void 0?!1:u,d=n.onload,p=Fle(n,Mle),h=Lt.useRef(null),m=Lt.useRef(!1),g=Lt.useState(null),y=g[0],b=g[1],v=Lt.useState(null),k=v[0],I=v[1],S=function(){typeof d=="function"&&d.call(this),m.current&&b(this.duration()*1e3),I(this)};Ole(function(){return Dle(()=>import("./howler-DjLYG1-Q.js").then(D=>D.h),[]).then(function(D){if(!m.current){var $;h.current=($=D.Howl)!==null&&$!==void 0?$:D.default.Howl,m.current=!0,new h.current(L2({src:Array.isArray(e)?e:[e],volume:s,rate:i,onload:S},p))}}),function(){m.current=!1}}),Lt.useEffect(function(){h.current&&k&&I(new h.current(L2({src:Array.isArray(e)?e:[e],volume:s,onload:S},p)))},[JSON.stringify(e)]),Lt.useEffect(function(){k&&(k.volume(s),p.sprite||k.rate(i))},[k,s,i]);var N=Lt.useCallback(function(D){typeof D>"u"&&(D={}),!(!k||!l&&!D.forceSoundEnabled)&&(c&&k.stop(),D.playbackRate&&k.rate(D.playbackRate),k.play(D.id))},[k,l,c]),T=Lt.useCallback(function(D){k&&k.stop(D)},[k]),A=Lt.useCallback(function(D){k&&k.pause(D)},[k]),R=[N,{sound:k,stop:T,pause:A,duration:y}];return R}const Gu="/E-CORP/assets/hover-pytfdnFE.mp3",xd="/E-CORP/assets/click-7Sr8gXe-.mp3",Lle=()=>{const[e]=ra(Gu,{volume:.5});return J.jsx("div",{className:"footer-wrapper",children:J.jsx("footer",{className:"cyber-footer",children:J.jsxs("div",{className:"footer-grid",children:[J.jsxs("div",{className:"footer-section",children:[J.jsx("h4",{children:"Connect With Us"}),J.jsxs("div",{className:"social-icons",children:[J.jsx("a",{href:"#",onMouseEnter:()=>e(),children:J.jsx(vle,{})}),J.jsx("a",{href:"#",onMouseEnter:()=>e(),children:J.jsx(wle,{})}),J.jsx("a",{href:"#",onMouseEnter:()=>e(),children:J.jsx(kle,{})}),J.jsx("a",{href:"#",onMouseEnter:()=>e(),children:J.jsx(ble,{})})]})]}),J.jsxs("div",{className:"footer-section",children:[J.jsx("h4",{children:"Contact Us"}),J.jsxs("div",{className:"contact-info",children:[J.jsxs("div",{className:"contact-item",children:[J.jsx(Cle,{}),J.jsx("span",{children:"contact@ecorp.security"})]}),J.jsxs("div",{className:"contact-item",children:[J.jsx($le,{}),J.jsx("span",{children:"+1 (234) 567-890"})]}),J.jsxs("div",{className:"contact-item",children:[J.jsx(Nle,{}),J.jsx("span",{children:"Tech City, TC 12345"})]})]})]}),J.jsxs("div",{className:"footer-section",children:[J.jsx("h4",{children:"Quick Links"}),J.jsxs("div",{className:"quick-links",children:[J.jsx("a",{href:"#",onMouseEnter:()=>e(),children:"About"}),J.jsx("a",{href:"#",onMouseEnter:()=>e(),children:"Services"}),J.jsx("a",{href:"#",onMouseEnter:()=>e(),children:"Privacy"}),J.jsx("a",{href:"#",onMouseEnter:()=>e(),children:"Terms"})]})]})]})})})},bd=()=>{const e=ee.useRef(null),t=ee.useRef([]);return ee.useEffect(()=>{const n=e.current,r=n.getContext("2d");let s;const a=()=>{n.width=window.innerWidth,n.height=window.innerHeight};a(),window.addEventListener("resize",a),(()=>{t.current=[];for(let l=0;l<200;l++)t.current.push({x:Math.random()*n.width,y:Math.random()*n.height,size:Math.random()*1.5+.5,speedX:(Math.random()-.5)*.4,speedY:(Math.random()-.5)*.4,angle:Math.random()*Math.PI*2,angleSpeed:(Math.random()-.5)*.002,color:`hsl(${Math.random()*20}, 100%, 50%)`})})();const o=()=>{r.fillStyle="rgba(0, 0, 0, 0.05)",r.fillRect(0,0,n.width,n.height),t.current.forEach(l=>{l.angle+=l.angleSpeed,l.x+=l.speedX+Math.cos(l.angle)*.3,l.y+=l.speedY+Math.sin(l.angle)*.3,l.x<0&&(l.x=n.width),l.x>n.width&&(l.x=0),l.y<0&&(l.y=n.height),l.y>n.height&&(l.y=0),r.beginPath(),r.arc(l.x,l.y,l.size,0,Math.PI*2),r.fillStyle=l.color,r.fill()}),s=requestAnimationFrame(o)};return o(),()=>{window.removeEventListener("resize",a),cancelAnimationFrame(s)}},[]),J.jsx("canvas",{ref:e,style:{position:"fixed",top:0,left:0,width:"100%",height:"100%",zIndex:0,background:"#000000",pointerEvents:"none"}})},Ple=()=>{const e=yd(),[t]=ra(Gu,{volume:3.9}),[n]=ra(xd,{volume:3.9}),r=()=>{n(),e("/login")};return J.jsxs("div",{className:"home-container",children:[J.jsx(bd,{}),J.jsxs("main",{className:"main-content",children:[J.jsxs("div",{className:"title-container",children:[J.jsx("h1",{children:"SECURE YOUR DIGITAL WORLD WITH"}),J.jsx("h1",{children:"E-CORP"})]}),J.jsxs("section",{className:"hero-section",children:[J.jsx("p",{className:"hero-description",children:"Advanced security tools powered by AI to protect your online presence. From email protection to secure browsing, we've got you covered."}),J.jsx("div",{className:"cta-section",children:J.jsxs("button",{className:"cyber-logout",onClick:r,onMouseEnter:()=>t(),children:[J.jsx("div",{className:"card-overlay"}),"Get Started"]})})]}),J.jsx("section",{className:"features-grid",children:[{icon:J.jsx(AR,{className:"feature-icon"}),title:"Advanced Protection",description:"AI-powered security analysis for real-time threat detection"},{icon:J.jsx(SG,{className:"feature-icon"}),title:"Secure Browsing",description:"Safe browsing with phishing and malware protection"},{icon:J.jsx(_le,{className:"feature-icon"}),title:"Email Security",description:"Spam detection and email content analysis"}].map((s,a)=>J.jsxs("div",{className:"cyber-card",onMouseEnter:()=>t(),children:[J.jsx("div",{className:"card-overlay"}),s.icon,J.jsx("h3",{children:s.title}),J.jsx("p",{children:s.description})]},a))})]}),J.jsx(Lle,{})]})},zle="6.14.3";function TB(e,t,n){for(let r in t){let s=t[r];Object.defineProperty(e,r,{enumerable:!0,value:s,writable:!1})}}function cg(e,t){if(e==null)return"null";if(t==null&&(t=new Set),typeof e=="object"){if(t.has(e))return"[Circular]";t.add(e)}if(Array.isArray(e))return"[ "+e.map(n=>cg(n,t)).join(", ")+" ]";if(e instanceof Uint8Array){const n="0123456789abcdef";let r="0x";for(let s=0;s<e.length;s++)r+=n[e[s]>>4],r+=n[e[s]&15];return r}if(typeof e=="object"&&typeof e.toJSON=="function")return cg(e.toJSON(),t);switch(typeof e){case"boolean":case"number":case"symbol":return e.toString();case"bigint":return BigInt(e).toString();case"string":return JSON.stringify(e);case"object":{const n=Object.keys(e);return n.sort(),"{ "+n.map(r=>`${cg(r,t)}: ${cg(e[r],t)}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"}function Ble(e,t,n){let r=e;{const a=[];if(n){if("message"in n||"code"in n||"name"in n)throw new Error(`value will overwrite populated values: ${cg(n)}`);for(const i in n){if(i==="shortMessage")continue;const o=n[i];a.push(i+"="+cg(o))}}a.push(`code=${t}`),a.push(`version=${zle}`),a.length&&(e+=" ("+a.join(", ")+")")}let s;switch(t){case"INVALID_ARGUMENT":s=new TypeError(e);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":s=new RangeError(e);break;default:s=new Error(e)}return TB(s,{code:t}),n&&Object.assign(s,n),s.shortMessage==null&&TB(s,{shortMessage:r}),s}function Wle(e,t,n,r){if(!e)throw Ble(t,n,r)}function p_(e,t,n,r){Wle(e,t,"INVALID_ARGUMENT",{argument:n,value:r})}["NFD","NFC","NFKD","NFKC"].reduce((e,t)=>{try{if("test".normalize(t)!=="test")throw new Error("bad");if(t==="NFD"&&"".normalize("NFD")!=="e")throw new Error("broken");e.push(t)}catch{}return e},[]);function Vle(e,t,n){if(e instanceof Uint8Array)return e;if(typeof e=="string"&&e.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){const r=new Uint8Array((e.length-2)/2);let s=2;for(let a=0;a<r.length;a++)r[a]=parseInt(e.substring(s,s+2),16),s+=2;return r}p_(!1,"invalid BytesLike value",t||"value",e)}function $G(e,t){return Vle(e,t)}const $B="0123456789abcdef";function Ule(e){const t=$G(e);let n="0x";for(let r=0;r<t.length;r++){const s=t[r];n+=$B[(s&240)>>4]+$B[s&15]}return n}function Gle(e,t){p_(typeof e=="string","invalid string value","str",e);let n=[];for(let r=0;r<e.length;r++){const s=e.charCodeAt(r);if(s<128)n.push(s);else if(s<2048)n.push(s>>6|192),n.push(s&63|128);else if((s&64512)==55296){r++;const a=e.charCodeAt(r);p_(r<e.length&&(a&64512)===56320,"invalid surrogate pair","str",e);const i=65536+((s&1023)<<10)+(a&1023);n.push(i>>18|240),n.push(i>>12&63|128),n.push(i>>6&63|128),n.push(i&63|128)}else n.push(s>>12|224),n.push(s>>6&63|128),n.push(s&63|128)}return new Uint8Array(n)}function EB(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function EG(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function _B(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function jle(e,t){EG(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Hle=e=>e instanceof Uint8Array,qle=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),Kle=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Kle)throw new Error("Non little-endian hardware is not supported");function Xle(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function _G(e){if(typeof e=="string"&&(e=Xle(e)),!Hle(e))throw new Error(`expected Uint8Array, got ${typeof e}`);return e}class Yle{clone(){return this._cloneInto()}}function Zle(e){const t=r=>e().update(_G(r)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}const Ak=BigInt(2**32-1),AB=BigInt(32);function Jle(e,t=!1){return t?{h:Number(e&Ak),l:Number(e>>AB&Ak)}:{h:Number(e>>AB&Ak)|0,l:Number(e&Ak)|0}}function Qle(e,t=!1){let n=new Uint32Array(e.length),r=new Uint32Array(e.length);for(let s=0;s<e.length;s++){const{h:a,l:i}=Jle(e[s],t);[n[s],r[s]]=[a,i]}return[n,r]}const eue=(e,t,n)=>e<<n|t>>>32-n,tue=(e,t,n)=>t<<n|e>>>32-n,nue=(e,t,n)=>t<<n-32|e>>>64-n,rue=(e,t,n)=>e<<n-32|t>>>64-n,[AG,RG,DG]=[[],[],[]],sue=BigInt(0),$b=BigInt(1),aue=BigInt(2),iue=BigInt(7),oue=BigInt(256),lue=BigInt(113);for(let e=0,t=$b,n=1,r=0;e<24;e++){[n,r]=[r,(2*n+3*r)%5],AG.push(2*(5*r+n)),RG.push((e+1)*(e+2)/2%64);let s=sue;for(let a=0;a<7;a++)t=(t<<$b^(t>>iue)*lue)%oue,t&aue&&(s^=$b<<($b<<BigInt(a))-$b);DG.push(s)}const[uue,cue]=Qle(DG,!0),RB=(e,t,n)=>n>32?nue(e,t,n):eue(e,t,n),DB=(e,t,n)=>n>32?rue(e,t,n):tue(e,t,n);function due(e,t=24){const n=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let i=0;i<10;i++)n[i]=e[i]^e[i+10]^e[i+20]^e[i+30]^e[i+40];for(let i=0;i<10;i+=2){const o=(i+8)%10,l=(i+2)%10,u=n[l],c=n[l+1],d=RB(u,c,1)^n[o],p=DB(u,c,1)^n[o+1];for(let h=0;h<50;h+=10)e[i+h]^=d,e[i+h+1]^=p}let s=e[2],a=e[3];for(let i=0;i<24;i++){const o=RG[i],l=RB(s,a,o),u=DB(s,a,o),c=AG[i];s=e[c],a=e[c+1],e[c]=l,e[c+1]=u}for(let i=0;i<50;i+=10){for(let o=0;o<10;o++)n[o]=e[i+o];for(let o=0;o<10;o++)e[i+o]^=~n[(o+2)%10]&n[(o+4)%10]}e[0]^=uue[r],e[1]^=cue[r]}n.fill(0)}class RR extends Yle{constructor(t,n,r,s=!1,a=24){if(super(),this.blockLen=t,this.suffix=n,this.outputLen=r,this.enableXOF=s,this.rounds=a,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,EB(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=qle(this.state)}keccak(){due(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){_B(this);const{blockLen:n,state:r}=this;t=_G(t);const s=t.length;for(let a=0;a<s;){const i=Math.min(n-this.pos,s-a);for(let o=0;o<i;o++)r[this.pos++]^=t[a++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:r,blockLen:s}=this;t[r]^=n,(n&128)!==0&&r===s-1&&this.keccak(),t[s-1]^=128,this.keccak()}writeInto(t){_B(this,!1),EG(t),this.finish();const n=this.state,{blockLen:r}=this;for(let s=0,a=t.length;s<a;){this.posOut>=r&&this.keccak();const i=Math.min(r-this.posOut,a-s);t.set(n.subarray(this.posOut,this.posOut+i),s),this.posOut+=i,s+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return EB(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(jle(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:n,suffix:r,outputLen:s,rounds:a,enableXOF:i}=this;return t||(t=new RR(n,r,s,i,a)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=a,t.suffix=r,t.outputLen=s,t.enableXOF=i,t.destroyed=this.destroyed,t}}const pue=(e,t,n)=>Zle(()=>new RR(t,e,n)),hue=pue(1,136,256/8);let FG=!1;const OG=function(e){return hue(e)};let MG=OG;function Xv(e){const t=$G(e,"data");return Ule(MG(t))}Xv._=OG;Xv.lock=function(){FG=!0};Xv.register=function(e){if(FG)throw new TypeError("keccak256 is locked");MG=e};Object.freeze(Xv);const LG=e=>{try{const t=Gle(e.toString());return{proof:Xv(t),success:!0}}catch(t){return console.error("Error generating proof:",t),{proof:null,success:!1,error:t.message}}},Ig=Math.min,Pp=Math.max,P2=Math.round,Rk=Math.floor,Wl=e=>({x:e,y:e}),fue={left:"right",right:"left",bottom:"top",top:"bottom"},mue={start:"end",end:"start"};function h_(e,t,n){return Pp(e,Ig(t,n))}function Yv(e,t){return typeof e=="function"?e(t):e}function Xp(e){return e.split("-")[0]}function Zv(e){return e.split("-")[1]}function PG(e){return e==="x"?"y":"x"}function DR(e){return e==="y"?"height":"width"}function zp(e){return["top","bottom"].includes(Xp(e))?"y":"x"}function FR(e){return PG(zp(e))}function gue(e,t,n){n===void 0&&(n=!1);const r=Zv(e),s=FR(e),a=DR(s);let i=s==="x"?r===(n?"end":"start")?"right":"left":r==="start"?"bottom":"top";return t.reference[a]>t.floating[a]&&(i=z2(i)),[i,z2(i)]}function yue(e){const t=z2(e);return[f_(e),t,f_(t)]}function f_(e){return e.replace(/start|end/g,t=>mue[t])}function xue(e,t,n){const r=["left","right"],s=["right","left"],a=["top","bottom"],i=["bottom","top"];switch(e){case"top":case"bottom":return n?t?s:r:t?r:s;case"left":case"right":return t?a:i;default:return[]}}function bue(e,t,n,r){const s=Zv(e);let a=xue(Xp(e),n==="start",r);return s&&(a=a.map(i=>i+"-"+s),t&&(a=a.concat(a.map(f_)))),a}function z2(e){return e.replace(/left|right|bottom|top/g,t=>fue[t])}function vue(e){return{top:0,right:0,bottom:0,left:0,...e}}function zG(e){return typeof e!="number"?vue(e):{top:e,right:e,bottom:e,left:e}}function B2(e){const{x:t,y:n,width:r,height:s}=e;return{width:r,height:s,top:n,left:t,right:t+r,bottom:n+s,x:t,y:n}}function FB(e,t,n){let{reference:r,floating:s}=e;const a=zp(t),i=FR(t),o=DR(i),l=Xp(t),u=a==="y",c=r.x+r.width/2-s.width/2,d=r.y+r.height/2-s.height/2,p=r[o]/2-s[o]/2;let h;switch(l){case"top":h={x:c,y:r.y-s.height};break;case"bottom":h={x:c,y:r.y+r.height};break;case"right":h={x:r.x+r.width,y:d};break;case"left":h={x:r.x-s.width,y:d};break;default:h={x:r.x,y:r.y}}switch(Zv(t)){case"start":h[i]-=p*(n&&u?-1:1);break;case"end":h[i]+=p*(n&&u?-1:1);break}return h}const wue=async(e,t,n)=>{const{placement:r="bottom",strategy:s="absolute",middleware:a=[],platform:i}=n,o=a.filter(Boolean),l=await(i.isRTL==null?void 0:i.isRTL(t));let u=await i.getElementRects({reference:e,floating:t,strategy:s}),{x:c,y:d}=FB(u,r,l),p=r,h={},m=0;for(let g=0;g<o.length;g++){const{name:y,fn:b}=o[g],{x:v,y:k,data:I,reset:S}=await b({x:c,y:d,initialPlacement:r,placement:p,strategy:s,middlewareData:h,rects:u,platform:i,elements:{reference:e,floating:t}});c=v??c,d=k??d,h={...h,[y]:{...h[y],...I}},S&&m<=50&&(m++,typeof S=="object"&&(S.placement&&(p=S.placement),S.rects&&(u=S.rects===!0?await i.getElementRects({reference:e,floating:t,strategy:s}):S.rects),{x:c,y:d}=FB(u,p,l)),g=-1)}return{x:c,y:d,placement:p,strategy:s,middlewareData:h}};async function BG(e,t){var n;t===void 0&&(t={});const{x:r,y:s,platform:a,rects:i,elements:o,strategy:l}=e,{boundary:u="clippingAncestors",rootBoundary:c="viewport",elementContext:d="floating",altBoundary:p=!1,padding:h=0}=Yv(t,e),m=zG(h),y=o[p?d==="floating"?"reference":"floating":d],b=B2(await a.getClippingRect({element:(n=await(a.isElement==null?void 0:a.isElement(y)))==null||n?y:y.contextElement||await(a.getDocumentElement==null?void 0:a.getDocumentElement(o.floating)),boundary:u,rootBoundary:c,strategy:l})),v=d==="floating"?{x:r,y:s,width:i.floating.width,height:i.floating.height}:i.reference,k=await(a.getOffsetParent==null?void 0:a.getOffsetParent(o.floating)),I=await(a.isElement==null?void 0:a.isElement(k))?await(a.getScale==null?void 0:a.getScale(k))||{x:1,y:1}:{x:1,y:1},S=B2(a.convertOffsetParentRelativeRectToViewportRelativeRect?await a.convertOffsetParentRelativeRectToViewportRelativeRect({elements:o,rect:v,offsetParent:k,strategy:l}):v);return{top:(b.top-S.top+m.top)/I.y,bottom:(S.bottom-b.bottom+m.bottom)/I.y,left:(b.left-S.left+m.left)/I.x,right:(S.right-b.right+m.right)/I.x}}const kue=e=>({name:"arrow",options:e,async fn(t){const{x:n,y:r,placement:s,rects:a,platform:i,elements:o,middlewareData:l}=t,{element:u,padding:c=0}=Yv(e,t)||{};if(u==null)return{};const d=zG(c),p={x:n,y:r},h=FR(s),m=DR(h),g=await i.getDimensions(u),y=h==="y",b=y?"top":"left",v=y?"bottom":"right",k=y?"clientHeight":"clientWidth",I=a.reference[m]+a.reference[h]-p[h]-a.floating[m],S=p[h]-a.reference[h],N=await(i.getOffsetParent==null?void 0:i.getOffsetParent(u));let T=N?N[k]:0;(!T||!await(i.isElement==null?void 0:i.isElement(N)))&&(T=o.floating[k]||a.floating[m]);const A=I/2-S/2,R=T/2-g[m]/2-1,D=Ig(d[b],R),$=Ig(d[v],R),_=D,L=T-g[m]-$,z=T/2-g[m]/2+A,W=h_(_,z,L),G=!l.arrow&&Zv(s)!=null&&z!==W&&a.reference[m]/2-(z<_?D:$)-g[m]/2<0,q=G?z<_?z-_:z-L:0;return{[h]:p[h]+q,data:{[h]:W,centerOffset:z-W-q,...G&&{alignmentOffset:q}},reset:G}}}),Iue=function(e){return e===void 0&&(e={}),{name:"flip",options:e,async fn(t){var n,r;const{placement:s,middlewareData:a,rects:i,initialPlacement:o,platform:l,elements:u}=t,{mainAxis:c=!0,crossAxis:d=!0,fallbackPlacements:p,fallbackStrategy:h="bestFit",fallbackAxisSideDirection:m="none",flipAlignment:g=!0,...y}=Yv(e,t);if((n=a.arrow)!=null&&n.alignmentOffset)return{};const b=Xp(s),v=zp(o),k=Xp(o)===o,I=await(l.isRTL==null?void 0:l.isRTL(u.floating)),S=p||(k||!g?[z2(o)]:yue(o)),N=m!=="none";!p&&N&&S.push(...bue(o,g,m,I));const T=[o,...S],A=await BG(t,y),R=[];let D=((r=a.flip)==null?void 0:r.overflows)||[];if(c&&R.push(A[b]),d){const W=gue(s,i,I);R.push(A[W[0]],A[W[1]])}if(D=[...D,{placement:s,overflows:R}],!R.every(W=>W<=0)){var $,_;const W=((($=a.flip)==null?void 0:$.index)||0)+1,G=T[W];if(G){var L;const B=d==="alignment"?v!==zp(G):!1,j=((L=D[0])==null?void 0:L.overflows[0])>0;if(!B||j)return{data:{index:W,overflows:D},reset:{placement:G}}}let q=(_=D.filter(B=>B.overflows[0]<=0).sort((B,j)=>B.overflows[1]-j.overflows[1])[0])==null?void 0:_.placement;if(!q)switch(h){case"bestFit":{var z;const B=(z=D.filter(j=>{if(N){const H=zp(j.placement);return H===v||H==="y"}return!0}).map(j=>[j.placement,j.overflows.filter(H=>H>0).reduce((H,P)=>H+P,0)]).sort((j,H)=>j[1]-H[1])[0])==null?void 0:z[0];B&&(q=B);break}case"initialPlacement":q=o;break}if(s!==q)return{reset:{placement:q}}}return{}}}};async function Sue(e,t){const{placement:n,platform:r,elements:s}=e,a=await(r.isRTL==null?void 0:r.isRTL(s.floating)),i=Xp(n),o=Zv(n),l=zp(n)==="y",u=["left","top"].includes(i)?-1:1,c=a&&l?-1:1,d=Yv(t,e);let{mainAxis:p,crossAxis:h,alignmentAxis:m}=typeof d=="number"?{mainAxis:d,crossAxis:0,alignmentAxis:null}:{mainAxis:d.mainAxis||0,crossAxis:d.crossAxis||0,alignmentAxis:d.alignmentAxis};return o&&typeof m=="number"&&(h=o==="end"?m*-1:m),l?{x:h*c,y:p*u}:{x:p*u,y:h*c}}const Cue=function(e){return e===void 0&&(e=0),{name:"offset",options:e,async fn(t){var n,r;const{x:s,y:a,placement:i,middlewareData:o}=t,l=await Sue(t,e);return i===((n=o.offset)==null?void 0:n.placement)&&(r=o.arrow)!=null&&r.alignmentOffset?{}:{x:s+l.x,y:a+l.y,data:{...l,placement:i}}}}},Nue=function(e){return e===void 0&&(e={}),{name:"shift",options:e,async fn(t){const{x:n,y:r,placement:s}=t,{mainAxis:a=!0,crossAxis:i=!1,limiter:o={fn:y=>{let{x:b,y:v}=y;return{x:b,y:v}}},...l}=Yv(e,t),u={x:n,y:r},c=await BG(t,l),d=zp(Xp(s)),p=PG(d);let h=u[p],m=u[d];if(a){const y=p==="y"?"top":"left",b=p==="y"?"bottom":"right",v=h+c[y],k=h-c[b];h=h_(v,h,k)}if(i){const y=d==="y"?"top":"left",b=d==="y"?"bottom":"right",v=m+c[y],k=m-c[b];m=h_(v,m,k)}const g=o.fn({...t,[p]:h,[d]:m});return{...g,data:{x:g.x-n,y:g.y-r,enabled:{[p]:a,[d]:i}}}}}};function rS(){return typeof window<"u"}function ay(e){return WG(e)?(e.nodeName||"").toLowerCase():"#document"}function Gi(e){var t;return(e==null||(t=e.ownerDocument)==null?void 0:t.defaultView)||window}function ou(e){var t;return(t=(WG(e)?e.ownerDocument:e.document)||window.document)==null?void 0:t.documentElement}function WG(e){return rS()?e instanceof Node||e instanceof Gi(e).Node:!1}function nl(e){return rS()?e instanceof Element||e instanceof Gi(e).Element:!1}function Yl(e){return rS()?e instanceof HTMLElement||e instanceof Gi(e).HTMLElement:!1}function OB(e){return!rS()||typeof ShadowRoot>"u"?!1:e instanceof ShadowRoot||e instanceof Gi(e).ShadowRoot}function Jv(e){const{overflow:t,overflowX:n,overflowY:r,display:s}=rl(e);return/auto|scroll|overlay|hidden|clip/.test(t+r+n)&&!["inline","contents"].includes(s)}function Tue(e){return["table","td","th"].includes(ay(e))}function sS(e){return[":popover-open",":modal"].some(t=>{try{return e.matches(t)}catch{return!1}})}function OR(e){const t=MR(),n=nl(e)?rl(e):e;return["transform","translate","scale","rotate","perspective"].some(r=>n[r]?n[r]!=="none":!1)||(n.containerType?n.containerType!=="normal":!1)||!t&&(n.backdropFilter?n.backdropFilter!=="none":!1)||!t&&(n.filter?n.filter!=="none":!1)||["transform","translate","scale","rotate","perspective","filter"].some(r=>(n.willChange||"").includes(r))||["paint","layout","strict","content"].some(r=>(n.contain||"").includes(r))}function $ue(e){let t=Xc(e);for(;Yl(t)&&!Sg(t);){if(OR(t))return t;if(sS(t))return null;t=Xc(t)}return null}function MR(){return typeof CSS>"u"||!CSS.supports?!1:CSS.supports("-webkit-backdrop-filter","none")}function Sg(e){return["html","body","#document"].includes(ay(e))}function rl(e){return Gi(e).getComputedStyle(e)}function aS(e){return nl(e)?{scrollLeft:e.scrollLeft,scrollTop:e.scrollTop}:{scrollLeft:e.scrollX,scrollTop:e.scrollY}}function Xc(e){if(ay(e)==="html")return e;const t=e.assignedSlot||e.parentNode||OB(e)&&e.host||ou(e);return OB(t)?t.host:t}function VG(e){const t=Xc(e);return Sg(t)?e.ownerDocument?e.ownerDocument.body:e.body:Yl(t)&&Jv(t)?t:VG(t)}function dv(e,t,n){var r;t===void 0&&(t=[]),n===void 0&&(n=!0);const s=VG(e),a=s===((r=e.ownerDocument)==null?void 0:r.body),i=Gi(s);if(a){const o=m_(i);return t.concat(i,i.visualViewport||[],Jv(s)?s:[],o&&n?dv(o):[])}return t.concat(s,dv(s,[],n))}function m_(e){return e.parent&&Object.getPrototypeOf(e.parent)?e.frameElement:null}function UG(e){const t=rl(e);let n=parseFloat(t.width)||0,r=parseFloat(t.height)||0;const s=Yl(e),a=s?e.offsetWidth:n,i=s?e.offsetHeight:r,o=P2(n)!==a||P2(r)!==i;return o&&(n=a,r=i),{width:n,height:r,$:o}}function LR(e){return nl(e)?e:e.contextElement}function pg(e){const t=LR(e);if(!Yl(t))return Wl(1);const n=t.getBoundingClientRect(),{width:r,height:s,$:a}=UG(t);let i=(a?P2(n.width):n.width)/r,o=(a?P2(n.height):n.height)/s;return(!i||!Number.isFinite(i))&&(i=1),(!o||!Number.isFinite(o))&&(o=1),{x:i,y:o}}const Eue=Wl(0);function GG(e){const t=Gi(e);return!MR()||!t.visualViewport?Eue:{x:t.visualViewport.offsetLeft,y:t.visualViewport.offsetTop}}function _ue(e,t,n){return t===void 0&&(t=!1),!n||t&&n!==Gi(e)?!1:t}function Yp(e,t,n,r){t===void 0&&(t=!1),n===void 0&&(n=!1);const s=e.getBoundingClientRect(),a=LR(e);let i=Wl(1);t&&(r?nl(r)&&(i=pg(r)):i=pg(e));const o=_ue(a,n,r)?GG(a):Wl(0);let l=(s.left+o.x)/i.x,u=(s.top+o.y)/i.y,c=s.width/i.x,d=s.height/i.y;if(a){const p=Gi(a),h=r&&nl(r)?Gi(r):r;let m=p,g=m_(m);for(;g&&r&&h!==m;){const y=pg(g),b=g.getBoundingClientRect(),v=rl(g),k=b.left+(g.clientLeft+parseFloat(v.paddingLeft))*y.x,I=b.top+(g.clientTop+parseFloat(v.paddingTop))*y.y;l*=y.x,u*=y.y,c*=y.x,d*=y.y,l+=k,u+=I,m=Gi(g),g=m_(m)}}return B2({width:c,height:d,x:l,y:u})}function PR(e,t){const n=aS(e).scrollLeft;return t?t.left+n:Yp(ou(e)).left+n}function jG(e,t,n){n===void 0&&(n=!1);const r=e.getBoundingClientRect(),s=r.left+t.scrollLeft-(n?0:PR(e,r)),a=r.top+t.scrollTop;return{x:s,y:a}}function Aue(e){let{elements:t,rect:n,offsetParent:r,strategy:s}=e;const a=s==="fixed",i=ou(r),o=t?sS(t.floating):!1;if(r===i||o&&a)return n;let l={scrollLeft:0,scrollTop:0},u=Wl(1);const c=Wl(0),d=Yl(r);if((d||!d&&!a)&&((ay(r)!=="body"||Jv(i))&&(l=aS(r)),Yl(r))){const h=Yp(r);u=pg(r),c.x=h.x+r.clientLeft,c.y=h.y+r.clientTop}const p=i&&!d&&!a?jG(i,l,!0):Wl(0);return{width:n.width*u.x,height:n.height*u.y,x:n.x*u.x-l.scrollLeft*u.x+c.x+p.x,y:n.y*u.y-l.scrollTop*u.y+c.y+p.y}}function Rue(e){return Array.from(e.getClientRects())}function Due(e){const t=ou(e),n=aS(e),r=e.ownerDocument.body,s=Pp(t.scrollWidth,t.clientWidth,r.scrollWidth,r.clientWidth),a=Pp(t.scrollHeight,t.clientHeight,r.scrollHeight,r.clientHeight);let i=-n.scrollLeft+PR(e);const o=-n.scrollTop;return rl(r).direction==="rtl"&&(i+=Pp(t.clientWidth,r.clientWidth)-s),{width:s,height:a,x:i,y:o}}function Fue(e,t){const n=Gi(e),r=ou(e),s=n.visualViewport;let a=r.clientWidth,i=r.clientHeight,o=0,l=0;if(s){a=s.width,i=s.height;const u=MR();(!u||u&&t==="fixed")&&(o=s.offsetLeft,l=s.offsetTop)}return{width:a,height:i,x:o,y:l}}function Oue(e,t){const n=Yp(e,!0,t==="fixed"),r=n.top+e.clientTop,s=n.left+e.clientLeft,a=Yl(e)?pg(e):Wl(1),i=e.clientWidth*a.x,o=e.clientHeight*a.y,l=s*a.x,u=r*a.y;return{width:i,height:o,x:l,y:u}}function MB(e,t,n){let r;if(t==="viewport")r=Fue(e,n);else if(t==="document")r=Due(ou(e));else if(nl(t))r=Oue(t,n);else{const s=GG(e);r={x:t.x-s.x,y:t.y-s.y,width:t.width,height:t.height}}return B2(r)}function HG(e,t){const n=Xc(e);return n===t||!nl(n)||Sg(n)?!1:rl(n).position==="fixed"||HG(n,t)}function Mue(e,t){const n=t.get(e);if(n)return n;let r=dv(e,[],!1).filter(o=>nl(o)&&ay(o)!=="body"),s=null;const a=rl(e).position==="fixed";let i=a?Xc(e):e;for(;nl(i)&&!Sg(i);){const o=rl(i),l=OR(i);!l&&o.position==="fixed"&&(s=null),(a?!l&&!s:!l&&o.position==="static"&&!!s&&["absolute","fixed"].includes(s.position)||Jv(i)&&!l&&HG(e,i))?r=r.filter(c=>c!==i):s=o,i=Xc(i)}return t.set(e,r),r}function Lue(e){let{element:t,boundary:n,rootBoundary:r,strategy:s}=e;const i=[...n==="clippingAncestors"?sS(t)?[]:Mue(t,this._c):[].concat(n),r],o=i[0],l=i.reduce((u,c)=>{const d=MB(t,c,s);return u.top=Pp(d.top,u.top),u.right=Ig(d.right,u.right),u.bottom=Ig(d.bottom,u.bottom),u.left=Pp(d.left,u.left),u},MB(t,o,s));return{width:l.right-l.left,height:l.bottom-l.top,x:l.left,y:l.top}}function Pue(e){const{width:t,height:n}=UG(e);return{width:t,height:n}}function zue(e,t,n){const r=Yl(t),s=ou(t),a=n==="fixed",i=Yp(e,!0,a,t);let o={scrollLeft:0,scrollTop:0};const l=Wl(0);function u(){l.x=PR(s)}if(r||!r&&!a)if((ay(t)!=="body"||Jv(s))&&(o=aS(t)),r){const h=Yp(t,!0,a,t);l.x=h.x+t.clientLeft,l.y=h.y+t.clientTop}else s&&u();a&&!r&&s&&u();const c=s&&!r&&!a?jG(s,o):Wl(0),d=i.left+o.scrollLeft-l.x-c.x,p=i.top+o.scrollTop-l.y-c.y;return{x:d,y:p,width:i.width,height:i.height}}function aE(e){return rl(e).position==="static"}function LB(e,t){if(!Yl(e)||rl(e).position==="fixed")return null;if(t)return t(e);let n=e.offsetParent;return ou(e)===n&&(n=n.ownerDocument.body),n}function qG(e,t){const n=Gi(e);if(sS(e))return n;if(!Yl(e)){let s=Xc(e);for(;s&&!Sg(s);){if(nl(s)&&!aE(s))return s;s=Xc(s)}return n}let r=LB(e,t);for(;r&&Tue(r)&&aE(r);)r=LB(r,t);return r&&Sg(r)&&aE(r)&&!OR(r)?n:r||$ue(e)||n}const Bue=async function(e){const t=this.getOffsetParent||qG,n=this.getDimensions,r=await n(e.floating);return{reference:zue(e.reference,await t(e.floating),e.strategy),floating:{x:0,y:0,width:r.width,height:r.height}}};function Wue(e){return rl(e).direction==="rtl"}const Vue={convertOffsetParentRelativeRectToViewportRelativeRect:Aue,getDocumentElement:ou,getClippingRect:Lue,getOffsetParent:qG,getElementRects:Bue,getClientRects:Rue,getDimensions:Pue,getScale:pg,isElement:nl,isRTL:Wue};function KG(e,t){return e.x===t.x&&e.y===t.y&&e.width===t.width&&e.height===t.height}function Uue(e,t){let n=null,r;const s=ou(e);function a(){var o;clearTimeout(r),(o=n)==null||o.disconnect(),n=null}function i(o,l){o===void 0&&(o=!1),l===void 0&&(l=1),a();const u=e.getBoundingClientRect(),{left:c,top:d,width:p,height:h}=u;if(o||t(),!p||!h)return;const m=Rk(d),g=Rk(s.clientWidth-(c+p)),y=Rk(s.clientHeight-(d+h)),b=Rk(c),k={rootMargin:-m+"px "+-g+"px "+-y+"px "+-b+"px",threshold:Pp(0,Ig(1,l))||1};let I=!0;function S(N){const T=N[0].intersectionRatio;if(T!==l){if(!I)return i();T?i(!1,T):r=setTimeout(()=>{i(!1,1e-7)},1e3)}T===1&&!KG(u,e.getBoundingClientRect())&&i(),I=!1}try{n=new IntersectionObserver(S,{...k,root:s.ownerDocument})}catch{n=new IntersectionObserver(S,k)}n.observe(e)}return i(!0),a}function Gue(e,t,n,r){r===void 0&&(r={});const{ancestorScroll:s=!0,ancestorResize:a=!0,elementResize:i=typeof ResizeObserver=="function",layoutShift:o=typeof IntersectionObserver=="function",animationFrame:l=!1}=r,u=LR(e),c=s||a?[...u?dv(u):[],...dv(t)]:[];c.forEach(b=>{s&&b.addEventListener("scroll",n,{passive:!0}),a&&b.addEventListener("resize",n)});const d=u&&o?Uue(u,n):null;let p=-1,h=null;i&&(h=new ResizeObserver(b=>{let[v]=b;v&&v.target===u&&h&&(h.unobserve(t),cancelAnimationFrame(p),p=requestAnimationFrame(()=>{var k;(k=h)==null||k.observe(t)})),n()}),u&&!l&&h.observe(u),h.observe(t));let m,g=l?Yp(e):null;l&&y();function y(){const b=Yp(e);g&&!KG(g,b)&&n(),g=b,m=requestAnimationFrame(y)}return n(),()=>{var b;c.forEach(v=>{s&&v.removeEventListener("scroll",n),a&&v.removeEventListener("resize",n)}),d==null||d(),(b=h)==null||b.disconnect(),h=null,l&&cancelAnimationFrame(m)}}const jue=Cue,Hue=Nue,que=Iue,Kue=kue,PB=(e,t,n)=>{const r=new Map,s={platform:Vue,...n},a={...s.platform,_c:r};return wue(e,t,{...s,platform:a})};var iE={exports:{}};/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/var zB;function Xue(){return zB||(zB=1,function(e){(function(){var t={}.hasOwnProperty;function n(){for(var a="",i=0;i<arguments.length;i++){var o=arguments[i];o&&(a=s(a,r(o)))}return a}function r(a){if(typeof a=="string"||typeof a=="number")return a;if(typeof a!="object")return"";if(Array.isArray(a))return n.apply(null,a);if(a.toString!==Object.prototype.toString&&!a.toString.toString().includes("[native code]"))return a.toString();var i="";for(var o in a)t.call(a,o)&&a[o]&&(i=s(i,o));return i}function s(a,i){return i?a?a+" "+i:a+i:a}e.exports?(n.default=n,e.exports=n):window.classNames=n})()}(iE)),iE.exports}var Yue=Xue();const g_=ty(Yue);var BB={};const Zue="react-tooltip-core-styles",Jue="react-tooltip-base-styles",WB={core:!1,base:!1};function VB({css:e,id:t=Jue,type:n="base",ref:r}){var s,a;if(!e||typeof document>"u"||WB[n]||n==="core"&&typeof process<"u"&&(!((s=process==null?void 0:BB)===null||s===void 0)&&s.REACT_TOOLTIP_DISABLE_CORE_STYLES)||n!=="base"&&typeof process<"u"&&(!((a=process==null?void 0:BB)===null||a===void 0)&&a.REACT_TOOLTIP_DISABLE_BASE_STYLES))return;n==="core"&&(t=Zue),r||(r={});const{insertAt:i}=r;if(document.getElementById(t))return;const o=document.head||document.getElementsByTagName("head")[0],l=document.createElement("style");l.id=t,l.type="text/css",i==="top"&&o.firstChild?o.insertBefore(l,o.firstChild):o.appendChild(l),l.styleSheet?l.styleSheet.cssText=e:l.appendChild(document.createTextNode(e)),WB[n]=!0}const UB=async({elementReference:e=null,tooltipReference:t=null,tooltipArrowReference:n=null,place:r="top",offset:s=10,strategy:a="absolute",middlewares:i=[jue(Number(s)),que({fallbackAxisSideDirection:"start"}),Hue({padding:5})],border:o})=>{if(!e)return{tooltipStyles:{},tooltipArrowStyles:{},place:r};if(t===null)return{tooltipStyles:{},tooltipArrowStyles:{},place:r};const l=i;return n?(l.push(Kue({element:n,padding:5})),PB(e,t,{placement:r,strategy:a,middleware:l}).then(({x:u,y:c,placement:d,middlewareData:p})=>{var h,m;const g={left:`${u}px`,top:`${c}px`,border:o},{x:y,y:b}=(h=p.arrow)!==null&&h!==void 0?h:{x:0,y:0},v=(m={top:"bottom",right:"left",bottom:"top",left:"right"}[d.split("-")[0]])!==null&&m!==void 0?m:"bottom",k=o&&{borderBottom:o,borderRight:o};let I=0;if(o){const S=`${o}`.match(/(\d+)px/);I=S!=null&&S[1]?Number(S[1]):1}return{tooltipStyles:g,tooltipArrowStyles:{left:y!=null?`${y}px`:"",top:b!=null?`${b}px`:"",right:"",bottom:"",...k,[v]:`-${4+I}px`},place:d}})):PB(e,t,{placement:"bottom",strategy:a,middleware:l}).then(({x:u,y:c,placement:d})=>({tooltipStyles:{left:`${u}px`,top:`${c}px`},tooltipArrowStyles:{},place:d}))},GB=(e,t)=>!("CSS"in window&&"supports"in window.CSS)||window.CSS.supports(e,t),jB=(e,t,n)=>{let r=null;const s=function(...a){const i=()=>{r=null};!r&&(e.apply(this,a),r=setTimeout(i,t))};return s.cancel=()=>{r&&(clearTimeout(r),r=null)},s},HB=e=>e!==null&&!Array.isArray(e)&&typeof e=="object",y_=(e,t)=>{if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t))return e.length===t.length&&e.every((s,a)=>y_(s,t[a]));if(Array.isArray(e)!==Array.isArray(t))return!1;if(!HB(e)||!HB(t))return e===t;const n=Object.keys(e),r=Object.keys(t);return n.length===r.length&&n.every(s=>y_(e[s],t[s]))},Que=e=>{if(!(e instanceof HTMLElement||e instanceof SVGElement))return!1;const t=getComputedStyle(e);return["overflow","overflow-x","overflow-y"].some(n=>{const r=t.getPropertyValue(n);return r==="auto"||r==="scroll"})},qB=e=>{if(!e)return null;let t=e.parentElement;for(;t;){if(Que(t))return t;t=t.parentElement}return document.scrollingElement||document.documentElement},ece=typeof window<"u"?ee.useLayoutEffect:ee.useEffect,oo=e=>{e.current&&(clearTimeout(e.current),e.current=null)},tce="DEFAULT_TOOLTIP_ID",nce={anchorRefs:new Set,activeAnchor:{current:null},attach:()=>{},detach:()=>{},setActiveAnchor:()=>{}},rce=ee.createContext({getTooltipData:()=>nce});function XG(e=tce){return ee.useContext(rce).getTooltipData(e)}var Ym={tooltip:"core-styles-module_tooltip__3vRRp",fixed:"core-styles-module_fixed__pcSol",arrow:"core-styles-module_arrow__cvMwQ",noArrow:"core-styles-module_noArrow__xock6",clickable:"core-styles-module_clickable__ZuTTB",show:"core-styles-module_show__Nt9eE",closing:"core-styles-module_closing__sGnxF"},oE={tooltip:"styles-module_tooltip__mnnfp",arrow:"styles-module_arrow__K0L3T",dark:"styles-module_dark__xNqje",light:"styles-module_light__Z6W-X",success:"styles-module_success__A2AKt",warning:"styles-module_warning__SCK0X",error:"styles-module_error__JvumD",info:"styles-module_info__BWdHW"};const sce=({forwardRef:e,id:t,className:n,classNameArrow:r,variant:s="dark",anchorId:a,anchorSelect:i,place:o="top",offset:l=10,events:u=["hover"],openOnClick:c=!1,positionStrategy:d="absolute",middlewares:p,wrapper:h,delayShow:m=0,delayHide:g=0,float:y=!1,hidden:b=!1,noArrow:v=!1,clickable:k=!1,closeOnEsc:I=!1,closeOnScroll:S=!1,closeOnResize:N=!1,openEvents:T,closeEvents:A,globalCloseEvents:R,imperativeModeOnly:D,style:$,position:_,afterShow:L,afterHide:z,disableTooltip:W,content:G,contentWrapperRef:q,isOpen:B,defaultIsOpen:j=!1,setIsOpen:H,activeAnchor:P,setActiveAnchor:X,border:Q,opacity:re,arrowColor:le,role:ke="tooltip"})=>{var Ne;const we=ee.useRef(null),_e=ee.useRef(null),Le=ee.useRef(null),Be=ee.useRef(null),Ze=ee.useRef(null),[ut,ft]=ee.useState({tooltipStyles:{},tooltipArrowStyles:{},place:o}),[et,Qe]=ee.useState(!1),[ot,gt]=ee.useState(!1),[At,Et]=ee.useState(null),dn=ee.useRef(!1),Xt=ee.useRef(null),{anchorRefs:In,setActiveAnchor:Ve}=XG(t),tt=ee.useRef(!1),[Rt,Dt]=ee.useState([]),Ut=ee.useRef(!1),Pn=c||u.includes("click"),dr=Pn||(T==null?void 0:T.click)||(T==null?void 0:T.dblclick)||(T==null?void 0:T.mousedown),zn=T?{...T}:{mouseover:!0,focus:!0,mouseenter:!1,click:!1,dblclick:!1,mousedown:!1};!T&&Pn&&Object.assign(zn,{mouseenter:!1,focus:!1,mouseover:!1,click:!0});const Gr=A?{...A}:{mouseout:!0,blur:!0,mouseleave:!1,click:!1,dblclick:!1,mouseup:!1};!A&&Pn&&Object.assign(Gr,{mouseleave:!1,blur:!1,mouseout:!1});const Sn=R?{...R}:{escape:I||!1,scroll:S||!1,resize:N||!1,clickOutsideAnchor:dr||!1};D&&(Object.assign(zn,{mouseover:!1,focus:!1,mouseenter:!1,click:!1,dblclick:!1,mousedown:!1}),Object.assign(Gr,{mouseout:!1,blur:!1,mouseleave:!1,click:!1,dblclick:!1,mouseup:!1}),Object.assign(Sn,{escape:!1,scroll:!1,resize:!1,clickOutsideAnchor:!1})),ece(()=>(Ut.current=!0,()=>{Ut.current=!1}),[]);const pn=We=>{Ut.current&&(We&&gt(!0),setTimeout(()=>{Ut.current&&(H==null||H(We),B===void 0&&Qe(We))},10))};ee.useEffect(()=>{if(B===void 0)return()=>null;B&&gt(!0);const We=setTimeout(()=>{Qe(B)},10);return()=>{clearTimeout(We)}},[B]),ee.useEffect(()=>{if(et!==dn.current)if(oo(Ze),dn.current=et,et)L==null||L();else{const We=(it=>{const Xe=it.match(/^([\d.]+)(ms|s)$/);if(!Xe)return 0;const[,bt,Yt]=Xe;return Number(bt)*(Yt==="ms"?1:1e3)})(getComputedStyle(document.body).getPropertyValue("--rt-transition-show-delay"));Ze.current=setTimeout(()=>{gt(!1),Et(null),z==null||z()},We+25)}},[et]);const Fn=We=>{ft(it=>y_(it,We)?it:We)},Ls=(We=m)=>{oo(Le),ot?pn(!0):Le.current=setTimeout(()=>{pn(!0)},We)},vs=(We=g)=>{oo(Be),Be.current=setTimeout(()=>{tt.current||pn(!1)},We)},Ps=We=>{var it;if(!We)return;const Xe=(it=We.currentTarget)!==null&&it!==void 0?it:We.target;if(!(Xe!=null&&Xe.isConnected))return X(null),void Ve({current:null});m?Ls():pn(!0),X(Xe),Ve({current:Xe}),oo(Be)},Qs=()=>{k?vs(g||100):g?vs():pn(!1),oo(Le)},ns=({x:We,y:it})=>{var Xe;const bt={getBoundingClientRect:()=>({x:We,y:it,width:0,height:0,top:it,left:We,right:We,bottom:it})};UB({place:(Xe=At==null?void 0:At.place)!==null&&Xe!==void 0?Xe:o,offset:l,elementReference:bt,tooltipReference:we.current,tooltipArrowReference:_e.current,strategy:d,middlewares:p,border:Q}).then(Yt=>{Fn(Yt)})},rs=We=>{if(!We)return;const it=We,Xe={x:it.clientX,y:it.clientY};ns(Xe),Xt.current=Xe},ea=We=>{var it;if(!et)return;const Xe=We.target;Xe.isConnected&&(!((it=we.current)===null||it===void 0)&&it.contains(Xe)||[document.querySelector(`[id='${a}']`),...Rt].some(bt=>bt==null?void 0:bt.contains(Xe))||(pn(!1),oo(Le)))},Pa=jB(Ps,50),qn=jB(Qs,50),ss=We=>{qn.cancel(),Pa(We)},ye=()=>{Pa.cancel(),qn()},Me=ee.useCallback(()=>{var We,it;const Xe=(We=At==null?void 0:At.position)!==null&&We!==void 0?We:_;Xe?ns(Xe):y?Xt.current&&ns(Xt.current):P!=null&&P.isConnected&&UB({place:(it=At==null?void 0:At.place)!==null&&it!==void 0?it:o,offset:l,elementReference:P,tooltipReference:we.current,tooltipArrowReference:_e.current,strategy:d,middlewares:p,border:Q}).then(bt=>{Ut.current&&Fn(bt)})},[et,P,G,$,o,At==null?void 0:At.place,l,d,_,At==null?void 0:At.position,y]);ee.useEffect(()=>{var We,it;const Xe=new Set(In);Rt.forEach(fn=>{W!=null&&W(fn)||Xe.add({current:fn})});const bt=document.querySelector(`[id='${a}']`);bt&&!(W!=null&&W(bt))&&Xe.add({current:bt});const Yt=()=>{pn(!1)},Kn=qB(P),fr=qB(we.current);Sn.scroll&&(window.addEventListener("scroll",Yt),Kn==null||Kn.addEventListener("scroll",Yt),fr==null||fr.addEventListener("scroll",Yt));let kr=null;Sn.resize?window.addEventListener("resize",Yt):P&&we.current&&(kr=Gue(P,we.current,Me,{ancestorResize:!0,elementResize:!0,layoutShift:!0}));const as=fn=>{fn.key==="Escape"&&pn(!1)};Sn.escape&&window.addEventListener("keydown",as),Sn.clickOutsideAnchor&&window.addEventListener("click",ea);const On=[],mr=fn=>!!(fn!=null&&fn.target&&(P!=null&&P.contains(fn.target))),zs=fn=>{et&&mr(fn)||Ps(fn)},hu=fn=>{et&&mr(fn)&&Qs()},qd=["mouseover","mouseout","mouseenter","mouseleave","focus","blur"],rc=["click","dblclick","mousedown","mouseup"];Object.entries(zn).forEach(([fn,_i])=>{_i&&(qd.includes(fn)?On.push({event:fn,listener:ss}):rc.includes(fn)&&On.push({event:fn,listener:zs}))}),Object.entries(Gr).forEach(([fn,_i])=>{_i&&(qd.includes(fn)?On.push({event:fn,listener:ye}):rc.includes(fn)&&On.push({event:fn,listener:hu}))}),y&&On.push({event:"pointermove",listener:rs});const Kd=()=>{tt.current=!0},Xd=()=>{tt.current=!1,Qs()},Yd=k&&(Gr.mouseout||Gr.mouseleave);return Yd&&((We=we.current)===null||We===void 0||We.addEventListener("mouseover",Kd),(it=we.current)===null||it===void 0||it.addEventListener("mouseout",Xd)),On.forEach(({event:fn,listener:_i})=>{Xe.forEach(Zd=>{var Bn;(Bn=Zd.current)===null||Bn===void 0||Bn.addEventListener(fn,_i)})}),()=>{var fn,_i;Sn.scroll&&(window.removeEventListener("scroll",Yt),Kn==null||Kn.removeEventListener("scroll",Yt),fr==null||fr.removeEventListener("scroll",Yt)),Sn.resize?window.removeEventListener("resize",Yt):kr==null||kr(),Sn.clickOutsideAnchor&&window.removeEventListener("click",ea),Sn.escape&&window.removeEventListener("keydown",as),Yd&&((fn=we.current)===null||fn===void 0||fn.removeEventListener("mouseover",Kd),(_i=we.current)===null||_i===void 0||_i.removeEventListener("mouseout",Xd)),On.forEach(({event:Zd,listener:Bn})=>{Xe.forEach(Yx=>{var _o;(_o=Yx.current)===null||_o===void 0||_o.removeEventListener(Zd,Bn)})})}},[P,Me,ot,In,Rt,T,A,R,Pn,m,g]),ee.useEffect(()=>{var We,it;let Xe=(it=(We=At==null?void 0:At.anchorSelect)!==null&&We!==void 0?We:i)!==null&&it!==void 0?it:"";!Xe&&t&&(Xe=`[data-tooltip-id='${t.replace(/'/g,"\\'")}']`);const bt=new MutationObserver(Yt=>{const Kn=[],fr=[];Yt.forEach(kr=>{if(kr.type==="attributes"&&kr.attributeName==="data-tooltip-id"&&(kr.target.getAttribute("data-tooltip-id")===t?Kn.push(kr.target):kr.oldValue===t&&fr.push(kr.target)),kr.type==="childList"){if(P){const as=[...kr.removedNodes].filter(On=>On.nodeType===1);if(Xe)try{fr.push(...as.filter(On=>On.matches(Xe))),fr.push(...as.flatMap(On=>[...On.querySelectorAll(Xe)]))}catch{}as.some(On=>{var mr;return!!(!((mr=On==null?void 0:On.contains)===null||mr===void 0)&&mr.call(On,P))&&(gt(!1),pn(!1),X(null),oo(Le),oo(Be),!0)})}if(Xe)try{const as=[...kr.addedNodes].filter(On=>On.nodeType===1);Kn.push(...as.filter(On=>On.matches(Xe))),Kn.push(...as.flatMap(On=>[...On.querySelectorAll(Xe)]))}catch{}}}),(Kn.length||fr.length)&&Dt(kr=>[...kr.filter(as=>!fr.includes(as)),...Kn])});return bt.observe(document.body,{childList:!0,subtree:!0,attributes:!0,attributeFilter:["data-tooltip-id"],attributeOldValue:!0}),()=>{bt.disconnect()}},[t,i,At==null?void 0:At.anchorSelect,P]),ee.useEffect(()=>{Me()},[Me]),ee.useEffect(()=>{if(!(q!=null&&q.current))return()=>null;const We=new ResizeObserver(()=>{setTimeout(()=>Me())});return We.observe(q.current),()=>{We.disconnect()}},[G,q==null?void 0:q.current]),ee.useEffect(()=>{var We;const it=document.querySelector(`[id='${a}']`),Xe=[...Rt,it];P&&Xe.includes(P)||X((We=Rt[0])!==null&&We!==void 0?We:it)},[a,Rt,P]),ee.useEffect(()=>(j&&pn(!0),()=>{oo(Le),oo(Be)}),[]),ee.useEffect(()=>{var We;let it=(We=At==null?void 0:At.anchorSelect)!==null&&We!==void 0?We:i;if(!it&&t&&(it=`[data-tooltip-id='${t.replace(/'/g,"\\'")}']`),it)try{const Xe=Array.from(document.querySelectorAll(it));Dt(Xe)}catch{Dt([])}},[t,i,At==null?void 0:At.anchorSelect]),ee.useEffect(()=>{Le.current&&(oo(Le),Ls(m))},[m]);const dt=(Ne=At==null?void 0:At.content)!==null&&Ne!==void 0?Ne:G,Je=et&&Object.keys(ut.tooltipStyles).length>0;return ee.useImperativeHandle(e,()=>({open:We=>{if(We!=null&&We.anchorSelect)try{document.querySelector(We.anchorSelect)}catch{return void console.warn(`[react-tooltip] "${We.anchorSelect}" is not a valid CSS selector`)}Et(We??null),We!=null&&We.delay?Ls(We.delay):pn(!0)},close:We=>{We!=null&&We.delay?vs(We.delay):pn(!1)},activeAnchor:P,place:ut.place,isOpen:!!(ot&&!b&&dt&&Je)})),ot&&!b&&dt?Lt.createElement(h,{id:t,role:ke,className:g_("react-tooltip",Ym.tooltip,oE.tooltip,oE[s],n,`react-tooltip__place-${ut.place}`,Ym[Je?"show":"closing"],Je?"react-tooltip__show":"react-tooltip__closing",d==="fixed"&&Ym.fixed,k&&Ym.clickable),onTransitionEnd:We=>{oo(Ze),et||We.propertyName!=="opacity"||(gt(!1),Et(null),z==null||z())},style:{...$,...ut.tooltipStyles,opacity:re!==void 0&&Je?re:void 0},ref:we},dt,Lt.createElement(h,{className:g_("react-tooltip-arrow",Ym.arrow,oE.arrow,r,v&&Ym.noArrow),style:{...ut.tooltipArrowStyles,background:le?`linear-gradient(to right bottom, transparent 50%, ${le} 50%)`:void 0},ref:_e})):null},ace=({content:e})=>Lt.createElement("span",{dangerouslySetInnerHTML:{__html:e}});Lt.forwardRef(({id:e,anchorId:t,anchorSelect:n,content:r,html:s,render:a,className:i,classNameArrow:o,variant:l="dark",place:u="top",offset:c=10,wrapper:d="div",children:p=null,events:h=["hover"],openOnClick:m=!1,positionStrategy:g="absolute",middlewares:y,delayShow:b=0,delayHide:v=0,float:k=!1,hidden:I=!1,noArrow:S=!1,clickable:N=!1,closeOnEsc:T=!1,closeOnScroll:A=!1,closeOnResize:R=!1,openEvents:D,closeEvents:$,globalCloseEvents:_,imperativeModeOnly:L=!1,style:z,position:W,isOpen:G,defaultIsOpen:q=!1,disableStyleInjection:B=!1,border:j,opacity:H,arrowColor:P,setIsOpen:X,afterShow:Q,afterHide:re,disableTooltip:le,role:ke="tooltip"},Ne)=>{const[we,_e]=ee.useState(r),[Le,Be]=ee.useState(s),[Ze,ut]=ee.useState(u),[ft,et]=ee.useState(l),[Qe,ot]=ee.useState(c),[gt,At]=ee.useState(b),[Et,dn]=ee.useState(v),[Xt,In]=ee.useState(k),[Ve,tt]=ee.useState(I),[Rt,Dt]=ee.useState(d),[Ut,Pn]=ee.useState(h),[dr,zn]=ee.useState(g),[Gr,Sn]=ee.useState(null),[pn,Fn]=ee.useState(null),Ls=ee.useRef(B),{anchorRefs:vs,activeAnchor:Ps}=XG(e),Qs=qn=>qn==null?void 0:qn.getAttributeNames().reduce((ss,ye)=>{var Me;return ye.startsWith("data-tooltip-")&&(ss[ye.replace(/^data-tooltip-/,"")]=(Me=qn==null?void 0:qn.getAttribute(ye))!==null&&Me!==void 0?Me:null),ss},{}),ns=qn=>{const ss={place:ye=>{var Me;ut((Me=ye)!==null&&Me!==void 0?Me:u)},content:ye=>{_e(ye??r)},html:ye=>{Be(ye??s)},variant:ye=>{var Me;et((Me=ye)!==null&&Me!==void 0?Me:l)},offset:ye=>{ot(ye===null?c:Number(ye))},wrapper:ye=>{var Me;Dt((Me=ye)!==null&&Me!==void 0?Me:d)},events:ye=>{const Me=ye==null?void 0:ye.split(" ");Pn(Me??h)},"position-strategy":ye=>{var Me;zn((Me=ye)!==null&&Me!==void 0?Me:g)},"delay-show":ye=>{At(ye===null?b:Number(ye))},"delay-hide":ye=>{dn(ye===null?v:Number(ye))},float:ye=>{In(ye===null?k:ye==="true")},hidden:ye=>{tt(ye===null?I:ye==="true")},"class-name":ye=>{Sn(ye)}};Object.values(ss).forEach(ye=>ye(null)),Object.entries(qn).forEach(([ye,Me])=>{var dt;(dt=ss[ye])===null||dt===void 0||dt.call(ss,Me)})};ee.useEffect(()=>{_e(r)},[r]),ee.useEffect(()=>{Be(s)},[s]),ee.useEffect(()=>{ut(u)},[u]),ee.useEffect(()=>{et(l)},[l]),ee.useEffect(()=>{ot(c)},[c]),ee.useEffect(()=>{At(b)},[b]),ee.useEffect(()=>{dn(v)},[v]),ee.useEffect(()=>{In(k)},[k]),ee.useEffect(()=>{tt(I)},[I]),ee.useEffect(()=>{zn(g)},[g]),ee.useEffect(()=>{Ls.current!==B&&console.warn("[react-tooltip] Do not change `disableStyleInjection` dynamically.")},[B]),ee.useEffect(()=>{typeof window<"u"&&window.dispatchEvent(new CustomEvent("react-tooltip-inject-styles",{detail:{disableCore:B==="core",disableBase:B}}))},[]),ee.useEffect(()=>{var qn;const ss=new Set(vs);let ye=n;if(!ye&&e&&(ye=`[data-tooltip-id='${e.replace(/'/g,"\\'")}']`),ye)try{document.querySelectorAll(ye).forEach(it=>{ss.add({current:it})})}catch{console.warn(`[react-tooltip] "${ye}" is not a valid CSS selector`)}const Me=document.querySelector(`[id='${t}']`);if(Me&&ss.add({current:Me}),!ss.size)return()=>null;const dt=(qn=pn??Me)!==null&&qn!==void 0?qn:Ps.current,Je=new MutationObserver(it=>{it.forEach(Xe=>{var bt;if(!dt||Xe.type!=="attributes"||!(!((bt=Xe.attributeName)===null||bt===void 0)&&bt.startsWith("data-tooltip-")))return;const Yt=Qs(dt);ns(Yt)})}),We={attributes:!0,childList:!1,subtree:!1};if(dt){const it=Qs(dt);ns(it),Je.observe(dt,We)}return()=>{Je.disconnect()}},[vs,Ps,pn,t,n]),ee.useEffect(()=>{z!=null&&z.border&&console.warn("[react-tooltip] Do not set `style.border`. Use `border` prop instead."),j&&!GB("border",`${j}`)&&console.warn(`[react-tooltip] "${j}" is not a valid \`border\`.`),z!=null&&z.opacity&&console.warn("[react-tooltip] Do not set `style.opacity`. Use `opacity` prop instead."),H&&!GB("opacity",`${H}`)&&console.warn(`[react-tooltip] "${H}" is not a valid \`opacity\`.`)},[]);let rs=p;const ea=ee.useRef(null);if(a){const qn=a({content:(pn==null?void 0:pn.getAttribute("data-tooltip-content"))||we||null,activeAnchor:pn});rs=qn?Lt.createElement("div",{ref:ea,className:"react-tooltip-content-wrapper"},qn):null}else we&&(rs=we);Le&&(rs=Lt.createElement(ace,{content:Le}));const Pa={forwardRef:Ne,id:e,anchorId:t,anchorSelect:n,className:g_(i,Gr),classNameArrow:o,content:rs,contentWrapperRef:ea,place:Ze,variant:ft,offset:Qe,wrapper:Rt,events:Ut,openOnClick:m,positionStrategy:dr,middlewares:y,delayShow:gt,delayHide:Et,float:Xt,hidden:Ve,noArrow:S,clickable:N,closeOnEsc:T,closeOnScroll:A,closeOnResize:R,openEvents:D,closeEvents:$,globalCloseEvents:_,imperativeModeOnly:L,style:z,position:W,isOpen:G,defaultIsOpen:q,border:j,opacity:H,arrowColor:P,setIsOpen:X,afterShow:Q,afterHide:re,disableTooltip:le,activeAnchor:pn,setActiveAnchor:qn=>Fn(qn),role:ke};return Lt.createElement(sce,{...Pa})});typeof window<"u"&&window.addEventListener("react-tooltip-inject-styles",e=>{e.detail.disableCore||VB({css:":root{--rt-color-white:#fff;--rt-color-dark:#222;--rt-color-success:#8dc572;--rt-color-error:#be6464;--rt-color-warning:#f0ad4e;--rt-color-info:#337ab7;--rt-opacity:0.9;--rt-transition-show-delay:0.15s;--rt-transition-closing-delay:0.15s}.core-styles-module_tooltip__3vRRp{position:absolute;top:0;left:0;pointer-events:none;opacity:0;will-change:opacity}.core-styles-module_fixed__pcSol{position:fixed}.core-styles-module_arrow__cvMwQ{position:absolute;background:inherit}.core-styles-module_noArrow__xock6{display:none}.core-styles-module_clickable__ZuTTB{pointer-events:auto}.core-styles-module_show__Nt9eE{opacity:var(--rt-opacity);transition:opacity var(--rt-transition-show-delay)ease-out}.core-styles-module_closing__sGnxF{opacity:0;transition:opacity var(--rt-transition-closing-delay)ease-in}",type:"core"}),e.detail.disableBase||VB({css:`
.styles-module_tooltip__mnnfp{padding:8px 16px;border-radius:3px;font-size:90%;width:max-content}.styles-module_arrow__K0L3T{width:8px;height:8px}[class*='react-tooltip__place-top']>.styles-module_arrow__K0L3T{transform:rotate(45deg)}[class*='react-tooltip__place-right']>.styles-module_arrow__K0L3T{transform:rotate(135deg)}[class*='react-tooltip__place-bottom']>.styles-module_arrow__K0L3T{transform:rotate(225deg)}[class*='react-tooltip__place-left']>.styles-module_arrow__K0L3T{transform:rotate(315deg)}.styles-module_dark__xNqje{background:var(--rt-color-dark);color:var(--rt-color-white)}.styles-module_light__Z6W-X{background-color:var(--rt-color-white);color:var(--rt-color-dark)}.styles-module_success__A2AKt{background-color:var(--rt-color-success);color:var(--rt-color-white)}.styles-module_warning__SCK0X{background-color:var(--rt-color-warning);color:var(--rt-color-white)}.styles-module_error__JvumD{background-color:var(--rt-color-error);color:var(--rt-color-white)}.styles-module_info__BWdHW{background-color:var(--rt-color-info);color:var(--rt-color-white)}`,type:"base"})});const ice=({setIsAuthenticated:e})=>{const t=yd(),[n,r]=ee.useState({username:"",pin:""}),[s,a]=ee.useState(!1),[i]=ra(Gu,{volume:3.9}),[o]=ra(xd,{volume:3.9}),l=async c=>{c.preventDefault(),o(),a(!0);try{const{proof:d}=LG(n.pin),p=await fetch("http://localhost:5000/api/auth/login",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:n.username.trim(),proof:d})}),h=await p.json();if(!p.ok){xn.error(h.message||"Invalid credentials",{hideProgressBar:!0,closeButton:!1,autoClose:2e3});return}h.success&&(localStorage.setItem("token",h.token),localStorage.setItem("isAuthenticated","true"),e(!0),xn.success("Login successful!",{hideProgressBar:!0,closeButton:!1,autoClose:200,pauseOnHover:!1,draggable:!1,onClose:()=>t("/dashboard")}))}catch(d){console.error("Login error:",d),xn.error("Login failed. Please try again.",{hideProgressBar:!0,closeButton:!1,autoClose:2e3})}finally{a(!1)}},u=(c,d)=>{if(d){const p=d.getBoundingClientRect(),h=(c.clientX-p.left)/p.width*100,m=(c.clientY-p.top)/p.height*100;d.style.setProperty("--mouse-x",`${h}%`),d.style.setProperty("--mouse-y",`${m}%`)}};return J.jsxs("div",{className:"login-container",children:[J.jsx(_R,{position:"top-right",hideProgressBar:!0,newestOnTop:!1,closeOnClick:!1,rtl:!1,pauseOnFocusLoss:!1,draggable:!1,pauseOnHover:!1,closeButton:!1,theme:"dark"}),J.jsx(bd,{}),J.jsx("div",{className:"login-content",children:J.jsxs("div",{className:"login-box",children:[J.jsx("h2",{className:"login-title",children:"SECURE LOGIN"}),J.jsxs("form",{onSubmit:l,className:"login-form",children:[J.jsx("div",{className:"form-group",children:J.jsx("input",{type:"text",name:"username",value:n.username,onChange:c=>r({...n,username:c.target.value}),placeholder:"Username",required:!0,className:"auth-input",onMouseEnter:()=>i()})}),J.jsx("div",{className:"form-group",children:J.jsx("input",{type:"password",name:"pin",value:n.pin,onChange:c=>r({...n,pin:c.target.value}),placeholder:"PIN",required:!0,className:"auth-input",onMouseEnter:()=>i()})}),J.jsxs("div",{className:"button-container",children:[J.jsxs("button",{type:"submit",disabled:s,className:"auth-button",onMouseEnter:()=>i(),onMouseMove:c=>u(c,c.currentTarget),children:[J.jsx(SG,{}),J.jsx("span",{children:s?"Authenticating...":"Login"})]}),J.jsxs("button",{type:"button",className:"auth-button",onClick:()=>{o(),t("/register")},onMouseEnter:()=>i(),onMouseMove:c=>u(c,c.currentTarget),children:[J.jsx(TG,{}),J.jsx("span",{children:"Register"})]})]})]})]})})]})},oce=()=>{const e=yd(),[t,n]=ee.useState({username:"",pin:""}),[r,s]=ee.useState(!1),[a]=ra(Gu,{volume:3.9}),[i]=ra(xd,{volume:3.9}),o=async u=>{if(u.preventDefault(),i(),!t.username||!t.pin){xn.error("All fields are required",{hideProgressBar:!0,closeButton:!1,autoClose:2e3});return}if(!/^\d{4}$/.test(t.pin)){xn.error("PIN must be exactly 4 digits",{hideProgressBar:!0,closeButton:!1,autoClose:2e3});return}s(!0);try{const{proof:c}=LG(t.pin),d=await fetch("http://localhost:5000/api/auth/register",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:t.username.trim(),proof:c})}),p=await d.json();if(!d.ok){xn.error(p.message||"Registration failed",{hideProgressBar:!0,closeButton:!1,autoClose:2e3});return}p.success&&xn.success("Registration successful!",{hideProgressBar:!0,closeButton:!1,autoClose:200,pauseOnHover:!1,draggable:!1,onClose:()=>e("/login")})}catch(c){console.error("Registration error:",c),xn.error(c.message||"Registration failed. Please try again.",{hideProgressBar:!0,closeButton:!1,autoClose:2e3})}finally{s(!1)}},l=(u,c)=>{const d=c.getBoundingClientRect(),p=u.clientX-d.left,h=u.clientY-d.top;c.style.setProperty("--x",`${p}px`),c.style.setProperty("--y",`${h}px`)};return J.jsxs("div",{className:"register-container",style:{position:"relative"},children:[J.jsx(_R,{position:"top-right",hideProgressBar:!0,newestOnTop:!1,closeOnClick:!1,rtl:!1,pauseOnFocusLoss:!1,draggable:!1,pauseOnHover:!1,closeButton:!1,theme:"dark"}),J.jsx(bd,{}),J.jsx("div",{className:"login-content",children:J.jsxs("div",{className:"login-box",children:[J.jsx("h2",{className:"login-title",children:"SECURE REGISTER"}),J.jsxs("form",{onSubmit:o,className:"login-form",children:[J.jsx("div",{className:"form-group",children:J.jsx("input",{type:"text",placeholder:"Choose a username",value:t.username,onChange:u=>n({...t,username:u.target.value}),required:!0,disabled:r,minLength:3,maxLength:20,className:"auth-input",onMouseEnter:()=>a()})}),J.jsx("div",{className:"form-group",children:J.jsx("input",{type:"password",placeholder:"Enter 4-digit PIN",value:t.pin,onChange:u=>n({...t,pin:u.target.value}),required:!0,disabled:r,pattern:"[0-9]{4}",maxLength:"4",className:"auth-input",title:"Please enter a 4-digit PIN",onMouseEnter:()=>a()})}),J.jsxs("div",{className:"button-container",children:[J.jsxs("button",{type:"submit",disabled:r,className:"auth-button",onMouseEnter:()=>a(),onMouseMove:u=>l(u,u.currentTarget),children:[J.jsx(TG,{}),J.jsx("span",{children:r?"Creating Account...":"Register"})]}),J.jsxs("button",{type:"button",className:"auth-button",onClick:()=>{i(),e("/login")},onMouseEnter:()=>a(),onMouseMove:u=>l(u,u.currentTarget),children:[J.jsx(kG,{}),J.jsx("span",{children:"Back to Login"})]})]})]})]})})]})};function lce(e){return cr({attr:{viewBox:"0 0 24 24",fill:"currentColor"},child:[{tag:"path",attr:{d:"M22 11.9996C21.1643 11.3719 20.1256 11 19 11C16.581 11 14.5633 12.7178 14.1 15H13V21H3C2.44772 21 2 20.5523 2 20V4C2 3.44772 2.44772 3 3 3H21C21.5523 3 22 3.44772 22 4V11.9996ZM12.0606 11.6829L5.64722 6.2377L4.35278 7.7623L12.0731 14.3171L19.6544 7.75616L18.3456 6.24384L12.0606 11.6829ZM22 17H23V22H15V17H16V16C16 14.3431 17.3431 13 19 13C20.6569 13 22 14.3431 22 16V17ZM20 17V16C20 15.4477 19.5523 15 19 15C18.4477 15 18 15.4477 18 16V17H20Z"},child:[]}]})(e)}function uce(e){return cr({attr:{viewBox:"0 0 24 24",fill:"currentColor"},child:[{tag:"path",attr:{d:"M19.7134 9.12811L19.4668 9.69379C19.2864 10.1079 18.7136 10.1079 18.5331 9.69379L18.2866 9.12811C17.8471 8.11947 17.0555 7.31641 16.0677 6.87708L15.308 6.53922C14.8973 6.35653 14.8973 5.75881 15.308 5.57612L16.0252 5.25714C17.0384 4.80651 17.8442 3.97373 18.2761 2.93083L18.5293 2.31953C18.7058 1.89349 19.2942 1.89349 19.4706 2.31953L19.7238 2.93083C20.1558 3.97373 20.9616 4.80651 21.9748 5.25714L22.6919 5.57612C23.1027 5.75881 23.1027 6.35653 22.6919 6.53922L21.9323 6.87708C20.9445 7.31641 20.1529 8.11947 19.7134 9.12811ZM6 5C4.89543 5 4 5.89543 4 7V17C4 18.1046 4.89543 19 6 19H18C19.1046 19 20 18.1046 20 17V12H22V17C22 19.2091 20.2091 21 18 21H6C3.79086 21 2 19.2091 2 17V7C2 4.79086 3.79086 3 6 3H13V5H6Z"},child:[]}]})(e)}function cce(e){return cr({attr:{viewBox:"0 0 24 24",fill:"currentColor"},child:[{tag:"path",attr:{d:"M20 3C20.5523 3 21 3.44772 21 4V5.757L19 7.757V5H5V13.1L9 9.1005L13.328 13.429L12.0012 14.7562L11.995 18.995L16.2414 19.0012L17.571 17.671L18.8995 19H19V16.242L21 14.242V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20ZM21.7782 7.80761L23.1924 9.22183L15.4142 17L13.9979 16.9979L14 15.5858L21.7782 7.80761ZM15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7Z"},child:[]}]})(e)}function dce(e){return cr({attr:{viewBox:"0 0 24 24",fill:"currentColor"},child:[{tag:"path",attr:{d:"M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM17 16L22 12L17 8V11H9V13H17V16Z"},child:[]}]})(e)}function pce(e){return cr({attr:{viewBox:"0 0 24 24",fill:"currentColor"},child:[{tag:"path",attr:{d:"M12 1L20.2169 2.82598C20.6745 2.92766 21 3.33347 21 3.80217V13.7889C21 15.795 19.9974 17.6684 18.3282 18.7812L12 23L5.6718 18.7812C4.00261 17.6684 3 15.795 3 13.7889V3.80217C3 3.33347 3.32553 2.92766 3.78307 2.82598L12 1ZM12 7C10.8954 7 10 7.89543 10 9C10 9.74025 10.4022 10.3866 10.9999 10.7324L11 15H13L13.0011 10.7318C13.5983 10.3858 14 9.73984 14 9C14 7.89543 13.1046 7 12 7Z"},child:[]}]})(e)}function iS(e,t,n,r){return new(n||(n=Promise))(function(s,a){function i(u){try{l(r.next(u))}catch(c){a(c)}}function o(u){try{l(r.throw(u))}catch(c){a(c)}}function l(u){var c;u.done?s(u.value):(c=u.value,c instanceof n?c:new n(function(d){d(c)})).then(i,o)}l((r=r.apply(e,[])).next())})}function Wc(e,t){var n,r,s,a,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function o(l){return function(u){return function(c){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return i.label++,{value:c[1],done:!1};case 5:i.label++,r=c[1],c=[0];continue;case 7:c=i.ops.pop(),i.trys.pop();continue;default:if(s=i.trys,!((s=s.length>0&&s[s.length-1])||c[0]!==6&&c[0]!==2)){i=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){i.label=c[1];break}if(c[0]===6&&i.label<s[1]){i.label=s[1],s=c;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(c);break}s[2]&&i.ops.pop(),i.trys.pop();continue}c=t.call(e,i)}catch(d){c=[6,d],r=0}finally{n=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([l,u])}}}function x_(e){var t=typeof Symbol=="function"&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&typeof e.length=="number")return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function qo(e,t){var n=typeof Symbol=="function"&&e[Symbol.iterator];if(!n)return e;var r,s,a=n.call(e),i=[];try{for(;(t===void 0||t-- >0)&&!(r=a.next()).done;)i.push(r.value)}catch(o){s={error:o}}finally{try{r&&!r.done&&(n=a.return)&&n.call(a)}finally{if(s)throw s.error}}return i}function Ll(e,t,n){if(arguments.length===2)for(var r,s=0,a=t.length;s<a;s++)!r&&s in t||(r||(r=Array.prototype.slice.call(t,0,s)),r[s]=t[s]);return e.concat(r||Array.prototype.slice.call(t))}function KB(e,t,n,r,s){for(var a=[],i=5;i<arguments.length;i++)a[i-5]=arguments[i];return iS(this,void 0,void 0,function(){var o,l,u,c,d,p;return Wc(this,function(h){switch(h.label){case 0:h.trys.push([0,12,13,14]),o=x_(a),l=o.next(),h.label=1;case 1:if(l.done)return[3,11];switch(u=l.value,typeof u){case"string":return[3,2];case"number":return[3,4];case"function":return[3,6]}return[3,8];case 2:return[4,hce(e,t,u,n,r,s)];case 3:return h.sent(),[3,10];case 4:return[4,YG(u)];case 5:return h.sent(),[3,10];case 6:return[4,u.apply(void 0,Ll([e,t,n,r,s],qo(a),!1))];case 7:return h.sent(),[3,10];case 8:return[4,u];case 9:h.sent(),h.label=10;case 10:return l=o.next(),[3,1];case 11:return[3,14];case 12:return c=h.sent(),d={error:c},[3,14];case 13:try{l&&!l.done&&(p=o.return)&&p.call(o)}finally{if(d)throw d.error}return[7];case 14:return[2]}})})}function hce(e,t,n,r,s,a){return iS(this,void 0,void 0,function(){var i,o;return Wc(this,function(l){switch(l.label){case 0:return i=e.textContent||"",o=function(u,c){var d=qo(c).slice(0);return Ll(Ll([],qo(u),!1),[NaN],!1).findIndex(function(p,h){return d[h]!==p})}(i,n),[4,fce(e,Ll(Ll([],qo(gce(i,t,o)),!1),qo(mce(n,t,o)),!1),r,s,a)];case 1:return l.sent(),[2]}})})}function YG(e){return iS(this,void 0,void 0,function(){return Wc(this,function(t){switch(t.label){case 0:return[4,new Promise(function(n){return setTimeout(n,e)})];case 1:return t.sent(),[2]}})})}function fce(e,t,n,r,s){return iS(this,void 0,void 0,function(){var a,i,o,l,u,c,d,p,h,m,g,y,b;return Wc(this,function(v){switch(v.label){case 0:if(a=t,s){for(i=0,o=1;o<t.length;o++)if(l=qo([t[o-1],t[o]],2),u=l[0],(c=l[1]).length>u.length||c===""){i=o;break}a=t.slice(i,t.length)}v.label=1;case 1:v.trys.push([1,6,7,8]),d=x_(function(k){var I,S,N,T,A,R,D;return Wc(this,function($){switch($.label){case 0:I=function(_){return Wc(this,function(L){switch(L.label){case 0:return[4,{op:function(z){return requestAnimationFrame(function(){return z.textContent=_})},opCode:function(z){var W=z.textContent||"";return _===""||W.length>_.length?"DELETE":"WRITING"}}];case 1:return L.sent(),[2]}})},$.label=1;case 1:$.trys.push([1,6,7,8]),S=x_(k),N=S.next(),$.label=2;case 2:return N.done?[3,5]:(T=N.value,[5,I(T)]);case 3:$.sent(),$.label=4;case 4:return N=S.next(),[3,2];case 5:return[3,8];case 6:return A=$.sent(),R={error:A},[3,8];case 7:try{N&&!N.done&&(D=S.return)&&D.call(S)}finally{if(R)throw R.error}return[7];case 8:return[2]}})}(a)),p=d.next(),v.label=2;case 2:return p.done?[3,5]:(h=p.value,m=h.opCode(e)==="WRITING"?n+n*(Math.random()-.5):r+r*(Math.random()-.5),h.op(e),[4,YG(m)]);case 3:v.sent(),v.label=4;case 4:return p=d.next(),[3,2];case 5:return[3,8];case 6:return g=v.sent(),y={error:g},[3,8];case 7:try{p&&!p.done&&(b=d.return)&&b.call(d)}finally{if(y)throw y.error}return[7];case 8:return[2]}})})}function mce(e,t,n){var r,s;return n===void 0&&(n=0),Wc(this,function(a){switch(a.label){case 0:r=t(e),s=r.length,a.label=1;case 1:return n<s?[4,r.slice(0,++n).join("")]:[3,3];case 2:return a.sent(),[3,1];case 3:return[2]}})}function gce(e,t,n){var r,s;return n===void 0&&(n=0),Wc(this,function(a){switch(a.label){case 0:r=t(e),s=r.length,a.label=1;case 1:return s>n?[4,r.slice(0,--s).join("")]:[3,3];case 2:return a.sent(),[3,1];case 3:return[2]}})}var yce="index-module_type__E-SaG";(function(e,t){t===void 0&&(t={});var n=t.insertAt;if(typeof document<"u"){var r=document.head||document.getElementsByTagName("head")[0],s=document.createElement("style");s.type="text/css",n==="top"&&r.firstChild?r.insertBefore(s,r.firstChild):r.appendChild(s),s.styleSheet?s.styleSheet.cssText=e:s.appendChild(document.createTextNode(e))}})(`.index-module_type__E-SaG::after {
  content: '|';
  animation: index-module_cursor__PQg0P 1.1s infinite step-start;
}

@keyframes index-module_cursor__PQg0P {
  50% {
    opacity: 0;
  }
}
`);var xce=ee.memo(ee.forwardRef(function(e,t){var n=e.sequence,r=e.repeat,s=e.className,a=e.speed,i=a===void 0?40:a,o=e.deletionSpeed,l=e.omitDeletionAnimation,u=l!==void 0&&l,c=e.preRenderFirstString,d=c!==void 0&&c,p=e.wrapper,h=p===void 0?"span":p,m=e.splitter,g=m===void 0?function(H){return Ll([],qo(H),!1)}:m,y=e.cursor,b=y===void 0||y,v=e.style,k=function(H,P){var X={};for(var Q in H)Object.prototype.hasOwnProperty.call(H,Q)&&P.indexOf(Q)<0&&(X[Q]=H[Q]);if(H!=null&&typeof Object.getOwnPropertySymbols=="function"){var re=0;for(Q=Object.getOwnPropertySymbols(H);re<Q.length;re++)P.indexOf(Q[re])<0&&Object.prototype.propertyIsEnumerable.call(H,Q[re])&&(X[Q[re]]=H[Q[re]])}return X}(e,["sequence","repeat","className","speed","deletionSpeed","omitDeletionAnimation","preRenderFirstString","wrapper","splitter","cursor","style"]),I=k["aria-label"],S=k["aria-hidden"],N=k.role;o||(o=i);var T=new Array(2).fill(40);[i,o].forEach(function(H,P){switch(typeof H){case"number":T[P]=Math.abs(H-100);break;case"object":var X=H.type,Q=H.value;if(typeof Q!="number")break;X==="keyStrokeDelayInMs"&&(T[P]=Q)}});var A,R,D,$,_,L,z=T[0],W=T[1],G=function(H,P){P===void 0&&(P=null);var X=ee.useRef(P);return ee.useEffect(function(){H&&(typeof H=="function"?H(X.current):H.current=X.current)},[H]),X}(t),q=yce;A=s?"".concat(b?q+" ":"").concat(s):b?q:"",R=ee.useRef(function(){var H,P=n;r===1/0?H=KB:typeof r=="number"&&(P=Array(1+r).fill(n).flat());var X=H?Ll(Ll([],qo(P),!1),[H],!1):Ll([],qo(P),!1);return KB.apply(void 0,Ll([G.current,g,z,W,u],qo(X),!1)),function(){G.current}}),D=ee.useRef(),$=ee.useRef(!1),_=ee.useRef(!1),L=qo(ee.useState(0),2)[1],$.current&&(_.current=!0),ee.useEffect(function(){return $.current||(D.current=R.current(),$.current=!0),L(function(H){return H+1}),function(){_.current&&D.current&&D.current()}},[]);var B=h,j=d?n.find(function(H){return typeof H=="string"})||"":null;return Lt.createElement(B,{"aria-hidden":S,"aria-label":I,role:N,style:v,className:A,children:I?Lt.createElement("span",{"aria-hidden":"true",ref:G,children:j}):j,ref:I?void 0:G})}),function(e,t){return!0});const bce=()=>{const e=yd(),[t]=ra(Gu,{volume:3.9}),[n]=ra(xd,{volume:3.9}),[r,s]=ee.useState(null),a=ee.useRef(null),i=[{icon:J.jsx(uce,{}),title:"Deepfake Detection",description:"Advanced AI-powered detection of manipulated images and videos",path:"/detect",color:"#6366f1"},{icon:J.jsx(pce,{}),title:"Safe Browsing",description:"Check websites for potential security threats",path:"/safe-browsing",color:"#ec4899"},{icon:J.jsx(lce,{}),title:"Email Scanner",description:"Analyze emails for spam and phishing attempts",path:"/emailscanner",color:"#14b8a6"},{icon:J.jsx(cce,{}),title:"Steganography",description:"Detect hidden content in images",path:"/steganography",color:"#f59e0b"}];ee.useEffect(()=>{const d=localStorage.getItem("token"),p=localStorage.getItem("isAuthenticated");(!d||p!=="true")&&e("/login",{replace:!0})},[e]);const o=()=>{localStorage.removeItem("token"),localStorage.removeItem("userEmail"),localStorage.removeItem("userName"),localStorage.removeItem("isAuthenticated"),localStorage.removeItem("authType"),localStorage.removeItem("loginTime"),e("/login",{replace:!0})};ee.useEffect(()=>{const p=setInterval(()=>{const h=document.querySelector(".floating-particles"),m=document.createElement("div");m.className="particle";const g=Math.random()*4+2;m.style.width=`${g}px`,m.style.height=`${g}px`,m.style.setProperty("--random-x",Math.random()),m.style.setProperty("--random-y",Math.random()*-1),m.style.left=`${Math.random()*100}vw`,m.style.top="100vh",h.appendChild(m),m.addEventListener("animationend",()=>m.remove())},200);return()=>clearInterval(p)},[]),ee.useEffect(()=>{const d=p=>{const h=document.querySelectorAll(".particle");p.clientX/window.innerWidth,p.clientY/window.innerHeight,h.forEach(m=>{const g=m.getBoundingClientRect(),y=g.left+g.width/2,b=g.top+g.height/2,v=p.clientX-y,k=p.clientY-b,I=Math.sqrt(v*v+k*k);if(I<300){const S=Math.atan2(k,v),N=(300-I)/300,T=Math.cos(S)*N*50,A=Math.sin(S)*N*50;m.style.transform=`translate(${-T}px, ${-A}px)`}else m.style.transform=""})};return window.addEventListener("mousemove",d),()=>window.removeEventListener("mousemove",d)},[]),ee.useEffect(()=>{let d=0,p=!1,h=null;const m=()=>{if(d+=(window.scrollY-d)*.1,a.current&&(a.current.style.transform=`translate3d(0, ${-d}px, 0)`),Math.abs(window.scrollY-d)<.1){p=!1,cancelAnimationFrame(h);return}h=requestAnimationFrame(m)},g=()=>{p||(p=!0,h=requestAnimationFrame(m))};return window.addEventListener("scroll",g),()=>{window.removeEventListener("scroll",g),cancelAnimationFrame(h)}},[]);const[l,u]=ee.useState(!1);ee.useEffect(()=>(u(!0),()=>u(!1)),[]);const c=d=>{const p=d.currentTarget.getBoundingClientRect(),h=(d.clientX-p.left)/p.width*100,m=(d.clientY-p.top)/p.height*100;d.currentTarget.style.setProperty("--mouse-x",`${h}%`),d.currentTarget.style.setProperty("--mouse-y",`${m}%`)};return J.jsxs("div",{className:"dashboard-new",children:[J.jsx(bd,{}),J.jsx("div",{className:"cyber-grid",children:J.jsxs("div",{className:"split-layout",children:[J.jsx("div",{className:"tools-section",children:J.jsx("div",{className:"cyber-tools",children:i.map((d,p)=>J.jsxs("div",{className:"cyber-card",onMouseMove:h=>c(h),onMouseEnter:()=>t(),onClick:()=>{n(),e(d.path)},children:[J.jsx("div",{className:"card-overlay"}),J.jsxs("div",{className:"card-content",children:[J.jsx("div",{className:"icon-container",children:d.icon}),J.jsx("h2",{children:d.title}),J.jsx("p",{children:d.description})]})]},d.title))})}),J.jsxs("div",{className:"info-section",children:[J.jsx("img",{src:"/ECorp.png",alt:"E-CORP",className:"company-logo"}),J.jsxs("div",{className:"company-description",children:[J.jsx(xce,{sequence:["Advanced Threat Detection",1e3,"Comprehensive Security",1e3,"Enterprise Protection",1e3],wrapper:"p",speed:50,className:"typing-text",repeat:1/0}),J.jsxs("div",{className:"static-text-container",children:[J.jsx("p",{className:"static-text",children:"Pioneering the future of cybersecurity with cutting-edge detection."}),J.jsx("p",{className:"static-text",children:"Our advanced AI-powered tools provide real-time threat prevention."}),J.jsx("p",{className:"static-text",children:"Protecting digital assets with next-generation security solutions."})]}),J.jsxs("button",{className:"cyber-logout",onClick:o,onMouseEnter:()=>t(),onMouseMove:d=>c(d),children:[J.jsx("div",{className:"card-overlay"}),J.jsx(dce,{}),J.jsx("span",{children:"Exit"})]})]})]})]})})]})};function ZG(e,t){return function(){return e.apply(t,arguments)}}const{toString:vce}=Object.prototype,{getPrototypeOf:zR}=Object,{iterator:oS,toStringTag:JG}=Symbol,lS=(e=>t=>{const n=vce.call(t);return e[n]||(e[n]=n.slice(8,-1).toLowerCase())})(Object.create(null)),hl=e=>(e=e.toLowerCase(),t=>lS(t)===e),uS=e=>t=>typeof t===e,{isArray:iy}=Array,pv=uS("undefined");function wce(e){return e!==null&&!pv(e)&&e.constructor!==null&&!pv(e.constructor)&&bi(e.constructor.isBuffer)&&e.constructor.isBuffer(e)}const QG=hl("ArrayBuffer");function kce(e){let t;return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?t=ArrayBuffer.isView(e):t=e&&e.buffer&&QG(e.buffer),t}const Ice=uS("string"),bi=uS("function"),e5=uS("number"),cS=e=>e!==null&&typeof e=="object",Sce=e=>e===!0||e===!1,h2=e=>{if(lS(e)!=="object")return!1;const t=zR(e);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(JG in e)&&!(oS in e)},Cce=hl("Date"),Nce=hl("File"),Tce=hl("Blob"),$ce=hl("FileList"),Ece=e=>cS(e)&&bi(e.pipe),_ce=e=>{let t;return e&&(typeof FormData=="function"&&e instanceof FormData||bi(e.append)&&((t=lS(e))==="formdata"||t==="object"&&bi(e.toString)&&e.toString()==="[object FormData]"))},Ace=hl("URLSearchParams"),[Rce,Dce,Fce,Oce]=["ReadableStream","Request","Response","Headers"].map(hl),Mce=e=>e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");function Qv(e,t,{allOwnKeys:n=!1}={}){if(e===null||typeof e>"u")return;let r,s;if(typeof e!="object"&&(e=[e]),iy(e))for(r=0,s=e.length;r<s;r++)t.call(null,e[r],r,e);else{const a=n?Object.getOwnPropertyNames(e):Object.keys(e),i=a.length;let o;for(r=0;r<i;r++)o=a[r],t.call(null,e[o],o,e)}}function t5(e,t){t=t.toLowerCase();const n=Object.keys(e);let r=n.length,s;for(;r-- >0;)if(s=n[r],t===s.toLowerCase())return s;return null}const Rp=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:global,n5=e=>!pv(e)&&e!==Rp;function b_(){const{caseless:e}=n5(this)&&this||{},t={},n=(r,s)=>{const a=e&&t5(t,s)||s;h2(t[a])&&h2(r)?t[a]=b_(t[a],r):h2(r)?t[a]=b_({},r):iy(r)?t[a]=r.slice():t[a]=r};for(let r=0,s=arguments.length;r<s;r++)arguments[r]&&Qv(arguments[r],n);return t}const Lce=(e,t,n,{allOwnKeys:r}={})=>(Qv(t,(s,a)=>{n&&bi(s)?e[a]=ZG(s,n):e[a]=s},{allOwnKeys:r}),e),Pce=e=>(e.charCodeAt(0)===65279&&(e=e.slice(1)),e),zce=(e,t,n,r)=>{e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},Bce=(e,t,n,r)=>{let s,a,i;const o={};if(t=t||{},e==null)return t;do{for(s=Object.getOwnPropertyNames(e),a=s.length;a-- >0;)i=s[a],(!r||r(i,e,t))&&!o[i]&&(t[i]=e[i],o[i]=!0);e=n!==!1&&zR(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},Wce=(e,t,n)=>{e=String(e),(n===void 0||n>e.length)&&(n=e.length),n-=t.length;const r=e.indexOf(t,n);return r!==-1&&r===n},Vce=e=>{if(!e)return null;if(iy(e))return e;let t=e.length;if(!e5(t))return null;const n=new Array(t);for(;t-- >0;)n[t]=e[t];return n},Uce=(e=>t=>e&&t instanceof e)(typeof Uint8Array<"u"&&zR(Uint8Array)),Gce=(e,t)=>{const r=(e&&e[oS]).call(e);let s;for(;(s=r.next())&&!s.done;){const a=s.value;t.call(e,a[0],a[1])}},jce=(e,t)=>{let n;const r=[];for(;(n=e.exec(t))!==null;)r.push(n);return r},Hce=hl("HTMLFormElement"),qce=e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,function(n,r,s){return r.toUpperCase()+s}),XB=(({hasOwnProperty:e})=>(t,n)=>e.call(t,n))(Object.prototype),Kce=hl("RegExp"),r5=(e,t)=>{const n=Object.getOwnPropertyDescriptors(e),r={};Qv(n,(s,a)=>{let i;(i=t(s,a,e))!==!1&&(r[a]=i||s)}),Object.defineProperties(e,r)},Xce=e=>{r5(e,(t,n)=>{if(bi(e)&&["arguments","caller","callee"].indexOf(n)!==-1)return!1;const r=e[n];if(bi(r)){if(t.enumerable=!1,"writable"in t){t.writable=!1;return}t.set||(t.set=()=>{throw Error("Can not rewrite read-only method '"+n+"'")})}})},Yce=(e,t)=>{const n={},r=s=>{s.forEach(a=>{n[a]=!0})};return iy(e)?r(e):r(String(e).split(t)),n},Zce=()=>{},Jce=(e,t)=>e!=null&&Number.isFinite(e=+e)?e:t;function Qce(e){return!!(e&&bi(e.append)&&e[JG]==="FormData"&&e[oS])}const ede=e=>{const t=new Array(10),n=(r,s)=>{if(cS(r)){if(t.indexOf(r)>=0)return;if(!("toJSON"in r)){t[s]=r;const a=iy(r)?[]:{};return Qv(r,(i,o)=>{const l=n(i,s+1);!pv(l)&&(a[o]=l)}),t[s]=void 0,a}}return r};return n(e,0)},tde=hl("AsyncFunction"),nde=e=>e&&(cS(e)||bi(e))&&bi(e.then)&&bi(e.catch),s5=((e,t)=>e?setImmediate:t?((n,r)=>(Rp.addEventListener("message",({source:s,data:a})=>{s===Rp&&a===n&&r.length&&r.shift()()},!1),s=>{r.push(s),Rp.postMessage(n,"*")}))(`axios@${Math.random()}`,[]):n=>setTimeout(n))(typeof setImmediate=="function",bi(Rp.postMessage)),rde=typeof queueMicrotask<"u"?queueMicrotask.bind(Rp):typeof process<"u"&&process.nextTick||s5,sde=e=>e!=null&&bi(e[oS]),Fe={isArray:iy,isArrayBuffer:QG,isBuffer:wce,isFormData:_ce,isArrayBufferView:kce,isString:Ice,isNumber:e5,isBoolean:Sce,isObject:cS,isPlainObject:h2,isReadableStream:Rce,isRequest:Dce,isResponse:Fce,isHeaders:Oce,isUndefined:pv,isDate:Cce,isFile:Nce,isBlob:Tce,isRegExp:Kce,isFunction:bi,isStream:Ece,isURLSearchParams:Ace,isTypedArray:Uce,isFileList:$ce,forEach:Qv,merge:b_,extend:Lce,trim:Mce,stripBOM:Pce,inherits:zce,toFlatObject:Bce,kindOf:lS,kindOfTest:hl,endsWith:Wce,toArray:Vce,forEachEntry:Gce,matchAll:jce,isHTMLForm:Hce,hasOwnProperty:XB,hasOwnProp:XB,reduceDescriptors:r5,freezeMethods:Xce,toObjectSet:Yce,toCamelCase:qce,noop:Zce,toFiniteNumber:Jce,findKey:t5,global:Rp,isContextDefined:n5,isSpecCompliantForm:Qce,toJSONObject:ede,isAsyncFn:tde,isThenable:nde,setImmediate:s5,asap:rde,isIterable:sde};function nn(e,t,n,r,s){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack,this.message=e,this.name="AxiosError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),s&&(this.response=s,this.status=s.status?s.status:null)}Fe.inherits(nn,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:Fe.toJSONObject(this.config),code:this.code,status:this.status}}});const a5=nn.prototype,i5={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach(e=>{i5[e]={value:e}});Object.defineProperties(nn,i5);Object.defineProperty(a5,"isAxiosError",{value:!0});nn.from=(e,t,n,r,s,a)=>{const i=Object.create(a5);return Fe.toFlatObject(e,i,function(l){return l!==Error.prototype},o=>o!=="isAxiosError"),nn.call(i,e.message,t,n,r,s),i.cause=e,i.name=e.name,a&&Object.assign(i,a),i};const ade=null;function v_(e){return Fe.isPlainObject(e)||Fe.isArray(e)}function o5(e){return Fe.endsWith(e,"[]")?e.slice(0,-2):e}function YB(e,t,n){return e?e.concat(t).map(function(s,a){return s=o5(s),!n&&a?"["+s+"]":s}).join(n?".":""):t}function ide(e){return Fe.isArray(e)&&!e.some(v_)}const ode=Fe.toFlatObject(Fe,{},null,function(t){return/^is[A-Z]/.test(t)});function dS(e,t,n){if(!Fe.isObject(e))throw new TypeError("target must be an object");t=t||new FormData,n=Fe.toFlatObject(n,{metaTokens:!0,dots:!1,indexes:!1},!1,function(g,y){return!Fe.isUndefined(y[g])});const r=n.metaTokens,s=n.visitor||c,a=n.dots,i=n.indexes,l=(n.Blob||typeof Blob<"u"&&Blob)&&Fe.isSpecCompliantForm(t);if(!Fe.isFunction(s))throw new TypeError("visitor must be a function");function u(m){if(m===null)return"";if(Fe.isDate(m))return m.toISOString();if(!l&&Fe.isBlob(m))throw new nn("Blob is not supported. Use a Buffer instead.");return Fe.isArrayBuffer(m)||Fe.isTypedArray(m)?l&&typeof Blob=="function"?new Blob([m]):Buffer.from(m):m}function c(m,g,y){let b=m;if(m&&!y&&typeof m=="object"){if(Fe.endsWith(g,"{}"))g=r?g:g.slice(0,-2),m=JSON.stringify(m);else if(Fe.isArray(m)&&ide(m)||(Fe.isFileList(m)||Fe.endsWith(g,"[]"))&&(b=Fe.toArray(m)))return g=o5(g),b.forEach(function(k,I){!(Fe.isUndefined(k)||k===null)&&t.append(i===!0?YB([g],I,a):i===null?g:g+"[]",u(k))}),!1}return v_(m)?!0:(t.append(YB(y,g,a),u(m)),!1)}const d=[],p=Object.assign(ode,{defaultVisitor:c,convertValue:u,isVisitable:v_});function h(m,g){if(!Fe.isUndefined(m)){if(d.indexOf(m)!==-1)throw Error("Circular reference detected in "+g.join("."));d.push(m),Fe.forEach(m,function(b,v){(!(Fe.isUndefined(b)||b===null)&&s.call(t,b,Fe.isString(v)?v.trim():v,g,p))===!0&&h(b,g?g.concat(v):[v])}),d.pop()}}if(!Fe.isObject(e))throw new TypeError("data must be an object");return h(e),t}function ZB(e){const t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,function(r){return t[r]})}function BR(e,t){this._pairs=[],e&&dS(e,this,t)}const l5=BR.prototype;l5.append=function(t,n){this._pairs.push([t,n])};l5.toString=function(t){const n=t?function(r){return t.call(this,r,ZB)}:ZB;return this._pairs.map(function(s){return n(s[0])+"="+n(s[1])},"").join("&")};function lde(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function u5(e,t,n){if(!t)return e;const r=n&&n.encode||lde;Fe.isFunction(n)&&(n={serialize:n});const s=n&&n.serialize;let a;if(s?a=s(t,n):a=Fe.isURLSearchParams(t)?t.toString():new BR(t,n).toString(r),a){const i=e.indexOf("#");i!==-1&&(e=e.slice(0,i)),e+=(e.indexOf("?")===-1?"?":"&")+a}return e}class JB{constructor(){this.handlers=[]}use(t,n,r){return this.handlers.push({fulfilled:t,rejected:n,synchronous:r?r.synchronous:!1,runWhen:r?r.runWhen:null}),this.handlers.length-1}eject(t){this.handlers[t]&&(this.handlers[t]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(t){Fe.forEach(this.handlers,function(r){r!==null&&t(r)})}}const c5={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},ude=typeof URLSearchParams<"u"?URLSearchParams:BR,cde=typeof FormData<"u"?FormData:null,dde=typeof Blob<"u"?Blob:null,pde={isBrowser:!0,classes:{URLSearchParams:ude,FormData:cde,Blob:dde},protocols:["http","https","file","blob","url","data"]},WR=typeof window<"u"&&typeof document<"u",w_=typeof navigator=="object"&&navigator||void 0,hde=WR&&(!w_||["ReactNative","NativeScript","NS"].indexOf(w_.product)<0),fde=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&typeof self.importScripts=="function",mde=WR&&window.location.href||"http://localhost",gde=Object.freeze(Object.defineProperty({__proto__:null,hasBrowserEnv:WR,hasStandardBrowserEnv:hde,hasStandardBrowserWebWorkerEnv:fde,navigator:w_,origin:mde},Symbol.toStringTag,{value:"Module"})),Ia={...gde,...pde};function yde(e,t){return dS(e,new Ia.classes.URLSearchParams,Object.assign({visitor:function(n,r,s,a){return Ia.isNode&&Fe.isBuffer(n)?(this.append(r,n.toString("base64")),!1):a.defaultVisitor.apply(this,arguments)}},t))}function xde(e){return Fe.matchAll(/\w+|\[(\w*)]/g,e).map(t=>t[0]==="[]"?"":t[1]||t[0])}function bde(e){const t={},n=Object.keys(e);let r;const s=n.length;let a;for(r=0;r<s;r++)a=n[r],t[a]=e[a];return t}function d5(e){function t(n,r,s,a){let i=n[a++];if(i==="__proto__")return!0;const o=Number.isFinite(+i),l=a>=n.length;return i=!i&&Fe.isArray(s)?s.length:i,l?(Fe.hasOwnProp(s,i)?s[i]=[s[i],r]:s[i]=r,!o):((!s[i]||!Fe.isObject(s[i]))&&(s[i]=[]),t(n,r,s[i],a)&&Fe.isArray(s[i])&&(s[i]=bde(s[i])),!o)}if(Fe.isFormData(e)&&Fe.isFunction(e.entries)){const n={};return Fe.forEachEntry(e,(r,s)=>{t(xde(r),s,n,0)}),n}return null}function vde(e,t,n){if(Fe.isString(e))try{return(t||JSON.parse)(e),Fe.trim(e)}catch(r){if(r.name!=="SyntaxError")throw r}return(n||JSON.stringify)(e)}const e0={transitional:c5,adapter:["xhr","http","fetch"],transformRequest:[function(t,n){const r=n.getContentType()||"",s=r.indexOf("application/json")>-1,a=Fe.isObject(t);if(a&&Fe.isHTMLForm(t)&&(t=new FormData(t)),Fe.isFormData(t))return s?JSON.stringify(d5(t)):t;if(Fe.isArrayBuffer(t)||Fe.isBuffer(t)||Fe.isStream(t)||Fe.isFile(t)||Fe.isBlob(t)||Fe.isReadableStream(t))return t;if(Fe.isArrayBufferView(t))return t.buffer;if(Fe.isURLSearchParams(t))return n.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),t.toString();let o;if(a){if(r.indexOf("application/x-www-form-urlencoded")>-1)return yde(t,this.formSerializer).toString();if((o=Fe.isFileList(t))||r.indexOf("multipart/form-data")>-1){const l=this.env&&this.env.FormData;return dS(o?{"files[]":t}:t,l&&new l,this.formSerializer)}}return a||s?(n.setContentType("application/json",!1),vde(t)):t}],transformResponse:[function(t){const n=this.transitional||e0.transitional,r=n&&n.forcedJSONParsing,s=this.responseType==="json";if(Fe.isResponse(t)||Fe.isReadableStream(t))return t;if(t&&Fe.isString(t)&&(r&&!this.responseType||s)){const i=!(n&&n.silentJSONParsing)&&s;try{return JSON.parse(t)}catch(o){if(i)throw o.name==="SyntaxError"?nn.from(o,nn.ERR_BAD_RESPONSE,this,null,this.response):o}}return t}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:Ia.classes.FormData,Blob:Ia.classes.Blob},validateStatus:function(t){return t>=200&&t<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};Fe.forEach(["delete","get","head","post","put","patch"],e=>{e0.headers[e]={}});const wde=Fe.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),kde=e=>{const t={};let n,r,s;return e&&e.split(`
`).forEach(function(i){s=i.indexOf(":"),n=i.substring(0,s).trim().toLowerCase(),r=i.substring(s+1).trim(),!(!n||t[n]&&wde[n])&&(n==="set-cookie"?t[n]?t[n].push(r):t[n]=[r]:t[n]=t[n]?t[n]+", "+r:r)}),t},QB=Symbol("internals");function Eb(e){return e&&String(e).trim().toLowerCase()}function f2(e){return e===!1||e==null?e:Fe.isArray(e)?e.map(f2):String(e)}function Ide(e){const t=Object.create(null),n=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let r;for(;r=n.exec(e);)t[r[1]]=r[2];return t}const Sde=e=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());function lE(e,t,n,r,s){if(Fe.isFunction(r))return r.call(this,t,n);if(s&&(t=n),!!Fe.isString(t)){if(Fe.isString(r))return t.indexOf(r)!==-1;if(Fe.isRegExp(r))return r.test(t)}}function Cde(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(t,n,r)=>n.toUpperCase()+r)}function Nde(e,t){const n=Fe.toCamelCase(" "+t);["get","set","has"].forEach(r=>{Object.defineProperty(e,r+n,{value:function(s,a,i){return this[r].call(this,t,s,a,i)},configurable:!0})})}let vi=class{constructor(t){t&&this.set(t)}set(t,n,r){const s=this;function a(o,l,u){const c=Eb(l);if(!c)throw new Error("header name must be a non-empty string");const d=Fe.findKey(s,c);(!d||s[d]===void 0||u===!0||u===void 0&&s[d]!==!1)&&(s[d||l]=f2(o))}const i=(o,l)=>Fe.forEach(o,(u,c)=>a(u,c,l));if(Fe.isPlainObject(t)||t instanceof this.constructor)i(t,n);else if(Fe.isString(t)&&(t=t.trim())&&!Sde(t))i(kde(t),n);else if(Fe.isObject(t)&&Fe.isIterable(t)){let o={},l,u;for(const c of t){if(!Fe.isArray(c))throw TypeError("Object iterator must return a key-value pair");o[u=c[0]]=(l=o[u])?Fe.isArray(l)?[...l,c[1]]:[l,c[1]]:c[1]}i(o,n)}else t!=null&&a(n,t,r);return this}get(t,n){if(t=Eb(t),t){const r=Fe.findKey(this,t);if(r){const s=this[r];if(!n)return s;if(n===!0)return Ide(s);if(Fe.isFunction(n))return n.call(this,s,r);if(Fe.isRegExp(n))return n.exec(s);throw new TypeError("parser must be boolean|regexp|function")}}}has(t,n){if(t=Eb(t),t){const r=Fe.findKey(this,t);return!!(r&&this[r]!==void 0&&(!n||lE(this,this[r],r,n)))}return!1}delete(t,n){const r=this;let s=!1;function a(i){if(i=Eb(i),i){const o=Fe.findKey(r,i);o&&(!n||lE(r,r[o],o,n))&&(delete r[o],s=!0)}}return Fe.isArray(t)?t.forEach(a):a(t),s}clear(t){const n=Object.keys(this);let r=n.length,s=!1;for(;r--;){const a=n[r];(!t||lE(this,this[a],a,t,!0))&&(delete this[a],s=!0)}return s}normalize(t){const n=this,r={};return Fe.forEach(this,(s,a)=>{const i=Fe.findKey(r,a);if(i){n[i]=f2(s),delete n[a];return}const o=t?Cde(a):String(a).trim();o!==a&&delete n[a],n[o]=f2(s),r[o]=!0}),this}concat(...t){return this.constructor.concat(this,...t)}toJSON(t){const n=Object.create(null);return Fe.forEach(this,(r,s)=>{r!=null&&r!==!1&&(n[s]=t&&Fe.isArray(r)?r.join(", "):r)}),n}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map(([t,n])=>t+": "+n).join(`
`)}getSetCookie(){return this.get("set-cookie")||[]}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(t){return t instanceof this?t:new this(t)}static concat(t,...n){const r=new this(t);return n.forEach(s=>r.set(s)),r}static accessor(t){const r=(this[QB]=this[QB]={accessors:{}}).accessors,s=this.prototype;function a(i){const o=Eb(i);r[o]||(Nde(s,i),r[o]=!0)}return Fe.isArray(t)?t.forEach(a):a(t),this}};vi.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]);Fe.reduceDescriptors(vi.prototype,({value:e},t)=>{let n=t[0].toUpperCase()+t.slice(1);return{get:()=>e,set(r){this[n]=r}}});Fe.freezeMethods(vi);function uE(e,t){const n=this||e0,r=t||n,s=vi.from(r.headers);let a=r.data;return Fe.forEach(e,function(o){a=o.call(n,a,s.normalize(),t?t.status:void 0)}),s.normalize(),a}function p5(e){return!!(e&&e.__CANCEL__)}function oy(e,t,n){nn.call(this,e??"canceled",nn.ERR_CANCELED,t,n),this.name="CanceledError"}Fe.inherits(oy,nn,{__CANCEL__:!0});function h5(e,t,n){const r=n.config.validateStatus;!n.status||!r||r(n.status)?e(n):t(new nn("Request failed with status code "+n.status,[nn.ERR_BAD_REQUEST,nn.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n))}function Tde(e){const t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}function $de(e,t){e=e||10;const n=new Array(e),r=new Array(e);let s=0,a=0,i;return t=t!==void 0?t:1e3,function(l){const u=Date.now(),c=r[a];i||(i=u),n[s]=l,r[s]=u;let d=a,p=0;for(;d!==s;)p+=n[d++],d=d%e;if(s=(s+1)%e,s===a&&(a=(a+1)%e),u-i<t)return;const h=c&&u-c;return h?Math.round(p*1e3/h):void 0}}function Ede(e,t){let n=0,r=1e3/t,s,a;const i=(u,c=Date.now())=>{n=c,s=null,a&&(clearTimeout(a),a=null),e.apply(null,u)};return[(...u)=>{const c=Date.now(),d=c-n;d>=r?i(u,c):(s=u,a||(a=setTimeout(()=>{a=null,i(s)},r-d)))},()=>s&&i(s)]}const W2=(e,t,n=3)=>{let r=0;const s=$de(50,250);return Ede(a=>{const i=a.loaded,o=a.lengthComputable?a.total:void 0,l=i-r,u=s(l),c=i<=o;r=i;const d={loaded:i,total:o,progress:o?i/o:void 0,bytes:l,rate:u||void 0,estimated:u&&o&&c?(o-i)/u:void 0,event:a,lengthComputable:o!=null,[t?"download":"upload"]:!0};e(d)},n)},eW=(e,t)=>{const n=e!=null;return[r=>t[0]({lengthComputable:n,total:e,loaded:r}),t[1]]},tW=e=>(...t)=>Fe.asap(()=>e(...t)),_de=Ia.hasStandardBrowserEnv?((e,t)=>n=>(n=new URL(n,Ia.origin),e.protocol===n.protocol&&e.host===n.host&&(t||e.port===n.port)))(new URL(Ia.origin),Ia.navigator&&/(msie|trident)/i.test(Ia.navigator.userAgent)):()=>!0,Ade=Ia.hasStandardBrowserEnv?{write(e,t,n,r,s,a){const i=[e+"="+encodeURIComponent(t)];Fe.isNumber(n)&&i.push("expires="+new Date(n).toGMTString()),Fe.isString(r)&&i.push("path="+r),Fe.isString(s)&&i.push("domain="+s),a===!0&&i.push("secure"),document.cookie=i.join("; ")},read(e){const t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove(e){this.write(e,"",Date.now()-864e5)}}:{write(){},read(){return null},remove(){}};function Rde(e){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)}function Dde(e,t){return t?e.replace(/\/?\/$/,"")+"/"+t.replace(/^\/+/,""):e}function f5(e,t,n){let r=!Rde(t);return e&&(r||n==!1)?Dde(e,t):t}const nW=e=>e instanceof vi?{...e}:e;function Zp(e,t){t=t||{};const n={};function r(u,c,d,p){return Fe.isPlainObject(u)&&Fe.isPlainObject(c)?Fe.merge.call({caseless:p},u,c):Fe.isPlainObject(c)?Fe.merge({},c):Fe.isArray(c)?c.slice():c}function s(u,c,d,p){if(Fe.isUndefined(c)){if(!Fe.isUndefined(u))return r(void 0,u,d,p)}else return r(u,c,d,p)}function a(u,c){if(!Fe.isUndefined(c))return r(void 0,c)}function i(u,c){if(Fe.isUndefined(c)){if(!Fe.isUndefined(u))return r(void 0,u)}else return r(void 0,c)}function o(u,c,d){if(d in t)return r(u,c);if(d in e)return r(void 0,u)}const l={url:a,method:a,data:a,baseURL:i,transformRequest:i,transformResponse:i,paramsSerializer:i,timeout:i,timeoutMessage:i,withCredentials:i,withXSRFToken:i,adapter:i,responseType:i,xsrfCookieName:i,xsrfHeaderName:i,onUploadProgress:i,onDownloadProgress:i,decompress:i,maxContentLength:i,maxBodyLength:i,beforeRedirect:i,transport:i,httpAgent:i,httpsAgent:i,cancelToken:i,socketPath:i,responseEncoding:i,validateStatus:o,headers:(u,c,d)=>s(nW(u),nW(c),d,!0)};return Fe.forEach(Object.keys(Object.assign({},e,t)),function(c){const d=l[c]||s,p=d(e[c],t[c],c);Fe.isUndefined(p)&&d!==o||(n[c]=p)}),n}const m5=e=>{const t=Zp({},e);let{data:n,withXSRFToken:r,xsrfHeaderName:s,xsrfCookieName:a,headers:i,auth:o}=t;t.headers=i=vi.from(i),t.url=u5(f5(t.baseURL,t.url,t.allowAbsoluteUrls),e.params,e.paramsSerializer),o&&i.set("Authorization","Basic "+btoa((o.username||"")+":"+(o.password?unescape(encodeURIComponent(o.password)):"")));let l;if(Fe.isFormData(n)){if(Ia.hasStandardBrowserEnv||Ia.hasStandardBrowserWebWorkerEnv)i.setContentType(void 0);else if((l=i.getContentType())!==!1){const[u,...c]=l?l.split(";").map(d=>d.trim()).filter(Boolean):[];i.setContentType([u||"multipart/form-data",...c].join("; "))}}if(Ia.hasStandardBrowserEnv&&(r&&Fe.isFunction(r)&&(r=r(t)),r||r!==!1&&_de(t.url))){const u=s&&a&&Ade.read(a);u&&i.set(s,u)}return t},Fde=typeof XMLHttpRequest<"u",Ode=Fde&&function(e){return new Promise(function(n,r){const s=m5(e);let a=s.data;const i=vi.from(s.headers).normalize();let{responseType:o,onUploadProgress:l,onDownloadProgress:u}=s,c,d,p,h,m;function g(){h&&h(),m&&m(),s.cancelToken&&s.cancelToken.unsubscribe(c),s.signal&&s.signal.removeEventListener("abort",c)}let y=new XMLHttpRequest;y.open(s.method.toUpperCase(),s.url,!0),y.timeout=s.timeout;function b(){if(!y)return;const k=vi.from("getAllResponseHeaders"in y&&y.getAllResponseHeaders()),S={data:!o||o==="text"||o==="json"?y.responseText:y.response,status:y.status,statusText:y.statusText,headers:k,config:e,request:y};h5(function(T){n(T),g()},function(T){r(T),g()},S),y=null}"onloadend"in y?y.onloadend=b:y.onreadystatechange=function(){!y||y.readyState!==4||y.status===0&&!(y.responseURL&&y.responseURL.indexOf("file:")===0)||setTimeout(b)},y.onabort=function(){y&&(r(new nn("Request aborted",nn.ECONNABORTED,e,y)),y=null)},y.onerror=function(){r(new nn("Network Error",nn.ERR_NETWORK,e,y)),y=null},y.ontimeout=function(){let I=s.timeout?"timeout of "+s.timeout+"ms exceeded":"timeout exceeded";const S=s.transitional||c5;s.timeoutErrorMessage&&(I=s.timeoutErrorMessage),r(new nn(I,S.clarifyTimeoutError?nn.ETIMEDOUT:nn.ECONNABORTED,e,y)),y=null},a===void 0&&i.setContentType(null),"setRequestHeader"in y&&Fe.forEach(i.toJSON(),function(I,S){y.setRequestHeader(S,I)}),Fe.isUndefined(s.withCredentials)||(y.withCredentials=!!s.withCredentials),o&&o!=="json"&&(y.responseType=s.responseType),u&&([p,m]=W2(u,!0),y.addEventListener("progress",p)),l&&y.upload&&([d,h]=W2(l),y.upload.addEventListener("progress",d),y.upload.addEventListener("loadend",h)),(s.cancelToken||s.signal)&&(c=k=>{y&&(r(!k||k.type?new oy(null,e,y):k),y.abort(),y=null)},s.cancelToken&&s.cancelToken.subscribe(c),s.signal&&(s.signal.aborted?c():s.signal.addEventListener("abort",c)));const v=Tde(s.url);if(v&&Ia.protocols.indexOf(v)===-1){r(new nn("Unsupported protocol "+v+":",nn.ERR_BAD_REQUEST,e));return}y.send(a||null)})},Mde=(e,t)=>{const{length:n}=e=e?e.filter(Boolean):[];if(t||n){let r=new AbortController,s;const a=function(u){if(!s){s=!0,o();const c=u instanceof Error?u:this.reason;r.abort(c instanceof nn?c:new oy(c instanceof Error?c.message:c))}};let i=t&&setTimeout(()=>{i=null,a(new nn(`timeout ${t} of ms exceeded`,nn.ETIMEDOUT))},t);const o=()=>{e&&(i&&clearTimeout(i),i=null,e.forEach(u=>{u.unsubscribe?u.unsubscribe(a):u.removeEventListener("abort",a)}),e=null)};e.forEach(u=>u.addEventListener("abort",a));const{signal:l}=r;return l.unsubscribe=()=>Fe.asap(o),l}},Lde=function*(e,t){let n=e.byteLength;if(n<t){yield e;return}let r=0,s;for(;r<n;)s=r+t,yield e.slice(r,s),r=s},Pde=async function*(e,t){for await(const n of zde(e))yield*Lde(n,t)},zde=async function*(e){if(e[Symbol.asyncIterator]){yield*e;return}const t=e.getReader();try{for(;;){const{done:n,value:r}=await t.read();if(n)break;yield r}}finally{await t.cancel()}},rW=(e,t,n,r)=>{const s=Pde(e,t);let a=0,i,o=l=>{i||(i=!0,r&&r(l))};return new ReadableStream({async pull(l){try{const{done:u,value:c}=await s.next();if(u){o(),l.close();return}let d=c.byteLength;if(n){let p=a+=d;n(p)}l.enqueue(new Uint8Array(c))}catch(u){throw o(u),u}},cancel(l){return o(l),s.return()}},{highWaterMark:2})},pS=typeof fetch=="function"&&typeof Request=="function"&&typeof Response=="function",g5=pS&&typeof ReadableStream=="function",Bde=pS&&(typeof TextEncoder=="function"?(e=>t=>e.encode(t))(new TextEncoder):async e=>new Uint8Array(await new Response(e).arrayBuffer())),y5=(e,...t)=>{try{return!!e(...t)}catch{return!1}},Wde=g5&&y5(()=>{let e=!1;const t=new Request(Ia.origin,{body:new ReadableStream,method:"POST",get duplex(){return e=!0,"half"}}).headers.has("Content-Type");return e&&!t}),sW=64*1024,k_=g5&&y5(()=>Fe.isReadableStream(new Response("").body)),V2={stream:k_&&(e=>e.body)};pS&&(e=>{["text","arrayBuffer","blob","formData","stream"].forEach(t=>{!V2[t]&&(V2[t]=Fe.isFunction(e[t])?n=>n[t]():(n,r)=>{throw new nn(`Response type '${t}' is not supported`,nn.ERR_NOT_SUPPORT,r)})})})(new Response);const Vde=async e=>{if(e==null)return 0;if(Fe.isBlob(e))return e.size;if(Fe.isSpecCompliantForm(e))return(await new Request(Ia.origin,{method:"POST",body:e}).arrayBuffer()).byteLength;if(Fe.isArrayBufferView(e)||Fe.isArrayBuffer(e))return e.byteLength;if(Fe.isURLSearchParams(e)&&(e=e+""),Fe.isString(e))return(await Bde(e)).byteLength},Ude=async(e,t)=>{const n=Fe.toFiniteNumber(e.getContentLength());return n??Vde(t)},Gde=pS&&(async e=>{let{url:t,method:n,data:r,signal:s,cancelToken:a,timeout:i,onDownloadProgress:o,onUploadProgress:l,responseType:u,headers:c,withCredentials:d="same-origin",fetchOptions:p}=m5(e);u=u?(u+"").toLowerCase():"text";let h=Mde([s,a&&a.toAbortSignal()],i),m;const g=h&&h.unsubscribe&&(()=>{h.unsubscribe()});let y;try{if(l&&Wde&&n!=="get"&&n!=="head"&&(y=await Ude(c,r))!==0){let S=new Request(t,{method:"POST",body:r,duplex:"half"}),N;if(Fe.isFormData(r)&&(N=S.headers.get("content-type"))&&c.setContentType(N),S.body){const[T,A]=eW(y,W2(tW(l)));r=rW(S.body,sW,T,A)}}Fe.isString(d)||(d=d?"include":"omit");const b="credentials"in Request.prototype;m=new Request(t,{...p,signal:h,method:n.toUpperCase(),headers:c.normalize().toJSON(),body:r,duplex:"half",credentials:b?d:void 0});let v=await fetch(m);const k=k_&&(u==="stream"||u==="response");if(k_&&(o||k&&g)){const S={};["status","statusText","headers"].forEach(R=>{S[R]=v[R]});const N=Fe.toFiniteNumber(v.headers.get("content-length")),[T,A]=o&&eW(N,W2(tW(o),!0))||[];v=new Response(rW(v.body,sW,T,()=>{A&&A(),g&&g()}),S)}u=u||"text";let I=await V2[Fe.findKey(V2,u)||"text"](v,e);return!k&&g&&g(),await new Promise((S,N)=>{h5(S,N,{data:I,headers:vi.from(v.headers),status:v.status,statusText:v.statusText,config:e,request:m})})}catch(b){throw g&&g(),b&&b.name==="TypeError"&&/Load failed|fetch/i.test(b.message)?Object.assign(new nn("Network Error",nn.ERR_NETWORK,e,m),{cause:b.cause||b}):nn.from(b,b&&b.code,e,m)}}),I_={http:ade,xhr:Ode,fetch:Gde};Fe.forEach(I_,(e,t)=>{if(e){try{Object.defineProperty(e,"name",{value:t})}catch{}Object.defineProperty(e,"adapterName",{value:t})}});const aW=e=>`- ${e}`,jde=e=>Fe.isFunction(e)||e===null||e===!1,x5={getAdapter:e=>{e=Fe.isArray(e)?e:[e];const{length:t}=e;let n,r;const s={};for(let a=0;a<t;a++){n=e[a];let i;if(r=n,!jde(n)&&(r=I_[(i=String(n)).toLowerCase()],r===void 0))throw new nn(`Unknown adapter '${i}'`);if(r)break;s[i||"#"+a]=r}if(!r){const a=Object.entries(s).map(([o,l])=>`adapter ${o} `+(l===!1?"is not supported by the environment":"is not available in the build"));let i=t?a.length>1?`since :
`+a.map(aW).join(`
`):" "+aW(a[0]):"as no adapter specified";throw new nn("There is no suitable adapter to dispatch the request "+i,"ERR_NOT_SUPPORT")}return r},adapters:I_};function cE(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new oy(null,e)}function iW(e){return cE(e),e.headers=vi.from(e.headers),e.data=uE.call(e,e.transformRequest),["post","put","patch"].indexOf(e.method)!==-1&&e.headers.setContentType("application/x-www-form-urlencoded",!1),x5.getAdapter(e.adapter||e0.adapter)(e).then(function(r){return cE(e),r.data=uE.call(e,e.transformResponse,r),r.headers=vi.from(r.headers),r},function(r){return p5(r)||(cE(e),r&&r.response&&(r.response.data=uE.call(e,e.transformResponse,r.response),r.response.headers=vi.from(r.response.headers))),Promise.reject(r)})}const b5="1.9.0",hS={};["object","boolean","number","function","string","symbol"].forEach((e,t)=>{hS[e]=function(r){return typeof r===e||"a"+(t<1?"n ":" ")+e}});const oW={};hS.transitional=function(t,n,r){function s(a,i){return"[Axios v"+b5+"] Transitional option '"+a+"'"+i+(r?". "+r:"")}return(a,i,o)=>{if(t===!1)throw new nn(s(i," has been removed"+(n?" in "+n:"")),nn.ERR_DEPRECATED);return n&&!oW[i]&&(oW[i]=!0,console.warn(s(i," has been deprecated since v"+n+" and will be removed in the near future"))),t?t(a,i,o):!0}};hS.spelling=function(t){return(n,r)=>(console.warn(`${r} is likely a misspelling of ${t}`),!0)};function Hde(e,t,n){if(typeof e!="object")throw new nn("options must be an object",nn.ERR_BAD_OPTION_VALUE);const r=Object.keys(e);let s=r.length;for(;s-- >0;){const a=r[s],i=t[a];if(i){const o=e[a],l=o===void 0||i(o,a,e);if(l!==!0)throw new nn("option "+a+" must be "+l,nn.ERR_BAD_OPTION_VALUE);continue}if(n!==!0)throw new nn("Unknown option "+a,nn.ERR_BAD_OPTION)}}const m2={assertOptions:Hde,validators:hS},Il=m2.validators;let Bp=class{constructor(t){this.defaults=t||{},this.interceptors={request:new JB,response:new JB}}async request(t,n){try{return await this._request(t,n)}catch(r){if(r instanceof Error){let s={};Error.captureStackTrace?Error.captureStackTrace(s):s=new Error;const a=s.stack?s.stack.replace(/^.+\n/,""):"";try{r.stack?a&&!String(r.stack).endsWith(a.replace(/^.+\n.+\n/,""))&&(r.stack+=`
`+a):r.stack=a}catch{}}throw r}}_request(t,n){typeof t=="string"?(n=n||{},n.url=t):n=t||{},n=Zp(this.defaults,n);const{transitional:r,paramsSerializer:s,headers:a}=n;r!==void 0&&m2.assertOptions(r,{silentJSONParsing:Il.transitional(Il.boolean),forcedJSONParsing:Il.transitional(Il.boolean),clarifyTimeoutError:Il.transitional(Il.boolean)},!1),s!=null&&(Fe.isFunction(s)?n.paramsSerializer={serialize:s}:m2.assertOptions(s,{encode:Il.function,serialize:Il.function},!0)),n.allowAbsoluteUrls!==void 0||(this.defaults.allowAbsoluteUrls!==void 0?n.allowAbsoluteUrls=this.defaults.allowAbsoluteUrls:n.allowAbsoluteUrls=!0),m2.assertOptions(n,{baseUrl:Il.spelling("baseURL"),withXsrfToken:Il.spelling("withXSRFToken")},!0),n.method=(n.method||this.defaults.method||"get").toLowerCase();let i=a&&Fe.merge(a.common,a[n.method]);a&&Fe.forEach(["delete","get","head","post","put","patch","common"],m=>{delete a[m]}),n.headers=vi.concat(i,a);const o=[];let l=!0;this.interceptors.request.forEach(function(g){typeof g.runWhen=="function"&&g.runWhen(n)===!1||(l=l&&g.synchronous,o.unshift(g.fulfilled,g.rejected))});const u=[];this.interceptors.response.forEach(function(g){u.push(g.fulfilled,g.rejected)});let c,d=0,p;if(!l){const m=[iW.bind(this),void 0];for(m.unshift.apply(m,o),m.push.apply(m,u),p=m.length,c=Promise.resolve(n);d<p;)c=c.then(m[d++],m[d++]);return c}p=o.length;let h=n;for(d=0;d<p;){const m=o[d++],g=o[d++];try{h=m(h)}catch(y){g.call(this,y);break}}try{c=iW.call(this,h)}catch(m){return Promise.reject(m)}for(d=0,p=u.length;d<p;)c=c.then(u[d++],u[d++]);return c}getUri(t){t=Zp(this.defaults,t);const n=f5(t.baseURL,t.url,t.allowAbsoluteUrls);return u5(n,t.params,t.paramsSerializer)}};Fe.forEach(["delete","get","head","options"],function(t){Bp.prototype[t]=function(n,r){return this.request(Zp(r||{},{method:t,url:n,data:(r||{}).data}))}});Fe.forEach(["post","put","patch"],function(t){function n(r){return function(a,i,o){return this.request(Zp(o||{},{method:t,headers:r?{"Content-Type":"multipart/form-data"}:{},url:a,data:i}))}}Bp.prototype[t]=n(),Bp.prototype[t+"Form"]=n(!0)});let qde=class v5{constructor(t){if(typeof t!="function")throw new TypeError("executor must be a function.");let n;this.promise=new Promise(function(a){n=a});const r=this;this.promise.then(s=>{if(!r._listeners)return;let a=r._listeners.length;for(;a-- >0;)r._listeners[a](s);r._listeners=null}),this.promise.then=s=>{let a;const i=new Promise(o=>{r.subscribe(o),a=o}).then(s);return i.cancel=function(){r.unsubscribe(a)},i},t(function(a,i,o){r.reason||(r.reason=new oy(a,i,o),n(r.reason))})}throwIfRequested(){if(this.reason)throw this.reason}subscribe(t){if(this.reason){t(this.reason);return}this._listeners?this._listeners.push(t):this._listeners=[t]}unsubscribe(t){if(!this._listeners)return;const n=this._listeners.indexOf(t);n!==-1&&this._listeners.splice(n,1)}toAbortSignal(){const t=new AbortController,n=r=>{t.abort(r)};return this.subscribe(n),t.signal.unsubscribe=()=>this.unsubscribe(n),t.signal}static source(){let t;return{token:new v5(function(s){t=s}),cancel:t}}};function Kde(e){return function(n){return e.apply(null,n)}}function Xde(e){return Fe.isObject(e)&&e.isAxiosError===!0}const S_={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(S_).forEach(([e,t])=>{S_[t]=e});function w5(e){const t=new Bp(e),n=ZG(Bp.prototype.request,t);return Fe.extend(n,Bp.prototype,t,{allOwnKeys:!0}),Fe.extend(n,t,null,{allOwnKeys:!0}),n.create=function(s){return w5(Zp(e,s))},n}const Zr=w5(e0);Zr.Axios=Bp;Zr.CanceledError=oy;Zr.CancelToken=qde;Zr.isCancel=p5;Zr.VERSION=b5;Zr.toFormData=dS;Zr.AxiosError=nn;Zr.Cancel=Zr.CanceledError;Zr.all=function(t){return Promise.all(t)};Zr.spread=Kde;Zr.isAxiosError=Xde;Zr.mergeConfig=Zp;Zr.AxiosHeaders=vi;Zr.formToJSON=e=>d5(Fe.isHTMLForm(e)?new FormData(e):e);Zr.getAdapter=x5.getAdapter;Zr.HttpStatusCode=S_;Zr.default=Zr;const{Axios:l1t,AxiosError:u1t,CanceledError:c1t,isCancel:d1t,CancelToken:p1t,VERSION:h1t,all:f1t,Cancel:m1t,isAxiosError:g1t,spread:y1t,toFormData:x1t,AxiosHeaders:b1t,HttpStatusCode:v1t,formToJSON:w1t,getAdapter:k1t,mergeConfig:I1t}=Zr,lW={safe:{primary:"#10B981",background:"rgba(16, 185, 129, 0.1)",text:"#ffffff"},dangerous:{primary:"#EF4444",background:"rgba(239, 68, 68, 0.1)",text:"#ffffff"},suspicious:{primary:"#F59E0B",background:"rgba(245, 158, 11, 0.1)",text:"#ffffff"},unreachable:{primary:"#6B7280",background:"rgba(107, 114, 128, 0.1)",text:"#ffffff"}},Yde=()=>{const[e,t]=ee.useState(""),[n,r]=ee.useState(!1),[s,a]=ee.useState(null),[i,o]=ee.useState(""),[l]=ra(Gu,{volume:3.9}),[u]=ra(xd,{volume:3.9}),c=async h=>{try{const m=await fetch(h,{method:"HEAD",mode:"no-cors",timeout:5e3});return!0}catch(m){return console.error("Reachability check failed:",m),!1}},d=async h=>{const m=h.toLowerCase().includes("malware")||h.toLowerCase().includes("phishing")||h.toLowerCase().includes("scam"),g=h.toLowerCase().startsWith("https://");return{hasSecurityIssues:m,hasWeakProtocol:!g,score:g?m?30:90:60}},p=async h=>{h.preventDefault(),u(),r(!0),o(""),a(null);try{if(!e.match(/^https?:\/\/.+/))throw new Error("Please enter a valid URL including http:// or https://");if(!await c(e)){a({status:"unreachable",message:"Website Unreachable",details:["The website could not be reached","The server might be down","The domain might not exist","The connection might be blocked"],score:0});return}const g=await d(e);g.hasSecurityIssues?a({status:"dangerous",message:"Security Threats Detected",details:["Potential security risks found","Suspicious content detected",g.hasWeakProtocol?"Insecure protocol (HTTP)":null,"Exercise extreme caution"].filter(Boolean),score:g.score}):a({status:g.hasWeakProtocol?"suspicious":"safe",message:g.hasWeakProtocol?"Exercise Caution - Insecure Protocol":"Website Appears Safe",details:[g.hasWeakProtocol?"Site uses insecure HTTP protocol":"Site uses secure HTTPS protocol","No immediate security threats detected",g.hasWeakProtocol?"Data sent to this site is not encrypted":"Connection is encrypted"],score:g.score})}catch(m){o(m.message||"Failed to analyze URL"),console.error("Analysis error:",m)}finally{r(!1)}};return J.jsxs("div",{className:"auth-container",children:[J.jsx(bd,{}),J.jsx("div",{className:"detector-content",children:J.jsxs("div",{className:"detector-box",children:[J.jsxs("div",{className:"header-section",children:[J.jsx("h2",{className:"login-title",children:"WEBSITE SECURITY CHECK"}),J.jsx("p",{className:"auth-subtitle",children:"Enter a website URL to analyze security threats"})]}),J.jsxs("div",{className:"scan-card",children:[J.jsx("form",{onSubmit:p,className:"scan-form",children:J.jsxs("div",{className:"input-wrapper",children:[J.jsx("input",{type:"url",value:e,onChange:h=>t(h.target.value),placeholder:"Enter website URL (e.g., https://example.com)",className:"auth-input",required:!0,onMouseEnter:()=>l()}),J.jsx("button",{type:"submit",className:"auth-button",disabled:n,onMouseEnter:()=>l(),children:n?J.jsxs(J.Fragment,{children:[J.jsx(CG,{className:"icon-spin"}),J.jsx("span",{children:"Scanning..."})]}):J.jsxs(J.Fragment,{children:[J.jsx(AR,{}),J.jsx("span",{children:"Check Security"})]})})]})}),i&&J.jsxs("div",{className:"error-alert",children:[J.jsx(CB,{className:"error-icon"}),J.jsx("p",{children:i})]}),s&&J.jsxs("div",{className:`result-section ${s.status}`,style:{"--status-color":lW[s.status].primary,"--status-bg":lW[s.status].background},children:[J.jsxs("div",{className:"result-header",children:[s.status==="safe"&&J.jsx(SB,{className:"result-icon"}),s.status==="dangerous"&&J.jsx(sE,{className:"result-icon"}),s.status==="unreachable"&&J.jsx(CB,{className:"result-icon"}),J.jsx("h2",{children:s.message})]}),J.jsxs("div",{className:"score-section",children:[J.jsx("div",{className:"score-label",children:"Security Score"}),J.jsx("div",{className:"score-bar",children:J.jsx("div",{className:"score-fill",style:{width:`${s.score}%`}})}),J.jsxs("div",{className:"score-value",children:[s.score,"%"]})]}),s.details&&s.details.length>0&&J.jsxs("div",{className:"details-section",children:[J.jsx("h3",{children:"Analysis Details"}),J.jsx("ul",{className:"details-list",children:s.details.map((h,m)=>J.jsx("li",{children:h},m))})]}),s.status!=="unreachable"&&J.jsxs("button",{className:"action-button",onClick:()=>window.open(e,"_blank","noopener,noreferrer"),children:[s.status==="safe"&&J.jsxs(J.Fragment,{children:[J.jsx(SB,{})," Visit Website"]}),s.status==="dangerous"&&J.jsxs(J.Fragment,{children:[J.jsx(sE,{})," View Details"]}),s.status==="suspicious"&&J.jsxs(J.Fragment,{children:[J.jsx(sE,{})," Proceed with Caution"]})]})]})]})]})})]})},Zde=()=>{const e=yd(),[t,n]=ee.useState(null),[r,s]=ee.useState(!1),a=ee.useRef(null),[i,o]=ee.useState(null),[l,u]=ee.useState(!1),[c]=ra(Gu,{volume:3.9}),[d]=ra(xd,{volume:3.9}),p=g=>{let y="",b=[];for(let v=0;v<g.data.length;v+=4)y+=g.data[v]&1;for(let v=0;v<y.length;v+=8){let k=y.substr(v,8),I=parseInt(k,2);if(I===0||I>127)break;b.push(I)}return String.fromCharCode(...b)},h=g=>{const y=g.target.files[0];o(y),u(!1)},m=async()=>{if(d(),!i){alert("Please select an image file first");return}s(!0),u(!1);try{const g=a.current,y=g.getContext("2d"),b=new Image;b.onload=()=>{g.width=b.width,g.height=b.height,y.drawImage(b,0,0);const v=y.getImageData(0,0,g.width,g.height),I=p(v).length>0;n({isMalicious:I,message:I?"Malicious Content Detected":"Image is Safe",details:I?"Hidden text content was detected in this image. The file may be compromised.":"No hidden content detected in this image"}),u(!0),s(!1)},b.src=URL.createObjectURL(i)}catch(g){console.error("Scan error:",g),s(!1)}};return J.jsxs("div",{className:"auth-container",children:[J.jsx(bd,{}),J.jsx("div",{className:"detector-content",children:J.jsxs("div",{className:"detector-box",children:[J.jsxs("div",{className:"header-section",children:[J.jsx("h2",{className:"login-title",children:"STEGANOGRAPHY SCANNER"}),J.jsx("p",{className:"auth-subtitle",children:"Check images for hidden malicious content"})]}),J.jsxs("div",{className:"scan-interface",children:[J.jsxs("div",{className:"file-input-container",children:[J.jsx("input",{type:"file",id:"imageUploader",className:"file-input",accept:"image/*",onChange:h,onMouseEnter:()=>c()}),i&&J.jsxs("p",{className:"selected-file",children:["Selected: ",i.name]})]}),J.jsxs("div",{className:"button-container",children:[J.jsxs("button",{onClick:m,className:"auth-button",disabled:!i||r,onMouseEnter:()=>c(),children:[J.jsx(Ele,{}),J.jsx("span",{children:r?"Scanning...":"Scan Image"})]}),J.jsxs("button",{onClick:()=>{d(),e("/dashboard")},className:"auth-button",onMouseEnter:()=>c(),children:[J.jsx(kG,{}),J.jsx("span",{children:"Back to Dashboard"})]})]}),l&&t&&J.jsx("div",{className:"results-section",children:J.jsxs("div",{className:`analysis-card ${t.isMalicious?"danger":"safe"}`,children:[J.jsx("div",{className:"result-header",children:J.jsx("h3",{className:"result-title",children:"SCAN RESULTS"})}),J.jsxs("div",{className:"status-indicator",children:[J.jsx("span",{className:"status-icon",children:t.isMalicious?J.jsx(NG,{color:"#ef4444",size:24}):J.jsx(IG,{color:"#10b981",size:24})}),J.jsxs("div",{className:"result-content",children:[J.jsx("h4",{className:`status-message ${t.isMalicious?"danger":"safe"}`,children:t.message}),J.jsx("p",{className:"status-details",children:t.details})]})]})]})})]}),J.jsx("canvas",{ref:a,style:{display:"none"}})]})})]})},Jde="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",Qde="https://openrouter.ai/api/v1/chat/completions",epe={role:"system",content:"You are a cybersecurity expert assistant. Provide precise and technically accurate responses about phishing, malware, spam, ransomware, social engineering, and other cyber threats. Be concise but clear and do not include unnecessary information."};function tpe(){yd();const[e,t]=ee.useState([]),[n,r]=ee.useState(""),[s,a]=ee.useState(!1),i=ee.useRef(null),o=ee.useRef(null),[l]=ra(Gu,{volume:3.9}),[u]=ra(xd,{volume:3.9}),c=()=>{i.current&&i.current.scrollIntoView({behavior:"smooth"})},d=m=>{r(m.target.value),o.current.style.height="auto",o.current.style.height=o.current.scrollHeight+"px"},p=m=>{m.key==="Enter"&&!m.shiftKey&&(m.preventDefault(),h())},h=async()=>{const m=n.trim();if(!(!m||s)){t(g=>[...g,{text:m,isUser:!0},{text:"Analyzing cybersecurity patterns...",isUser:!1,loading:!0}]),r(""),a(!0);try{const g={model:"deepseek/deepseek-chat-v3-0324:free",messages:[epe,{role:"user",content:m}]},b=await(await fetch(Qde,{method:"POST",headers:{Authorization:`Bearer ${Jde}`,"Content-Type":"application/json","HTTP-Referer":"http://localhost","X-Title":"Cyber Chat"},body:JSON.stringify(g)})).json();t(v=>{const k=v.filter(I=>!I.loading);return b&&b.choices&&b.choices.length>0?[...k,{text:b.choices[0].message.content,isUser:!1}]:[...k,{text:" Threat intel unavailable. Try again later.",isUser:!1}]})}catch(g){t(y=>[...y.filter(v=>!v.loading),{text:" Cyber link disrupted. Check console for logs.",isUser:!1}]),console.error(g)}finally{a(!1),setTimeout(c,100)}}};return Lt.useEffect(()=>{c()},[e]),J.jsxs("div",{className:"auth-container",children:[J.jsx(bd,{}),J.jsx("div",{className:"detector-content",children:J.jsxs("div",{className:"detector-box",children:[J.jsxs("div",{className:"header-section",children:[J.jsx("h2",{className:"login-title",children:"EMAIL SECURITY SCANNER"}),J.jsx("p",{className:"auth-subtitle",children:"Analyze emails for spam, phishing attempts, and malicious content"})]}),J.jsxs("div",{className:"chat-interface",children:[J.jsxs("div",{className:"chat-messages",id:"chatMessages",children:[e.map((m,g)=>J.jsx("div",{className:`message ${m.isUser?"user-message":"bot-message"} ${m.loading?"loading":""}`,children:m.text},g)),J.jsx("div",{ref:i})]}),J.jsxs("div",{className:"input-container",children:[J.jsx("textarea",{id:"userInput",ref:o,placeholder:"Paste email content to analyze for threats...",rows:1,value:n,onChange:d,onKeyPress:p,disabled:s,className:"auth-input",onMouseEnter:()=>l(),autoFocus:!0}),J.jsxs("button",{onClick:h,disabled:s||!n.trim(),className:"auth-button",onMouseEnter:()=>l(),children:[J.jsx(AR,{}),J.jsx("span",{children:s?"Analyzing...":"Analyze"})]})]})]})]})})]})}var dE={exports:{}},pE,uW;function npe(){if(uW)return pE;uW=1;var e="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";return pE=e,pE}var hE,cW;function rpe(){if(cW)return hE;cW=1;var e=npe();function t(){}function n(){}return n.resetWarningCache=t,hE=function(){function r(i,o,l,u,c,d){if(d!==e){var p=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw p.name="Invariant Violation",p}}r.isRequired=r;function s(){return r}var a={array:r,bigint:r,bool:r,func:r,number:r,object:r,string:r,symbol:r,any:r,arrayOf:s,element:r,elementType:r,instanceOf:s,node:r,objectOf:s,oneOf:s,oneOfType:s,shape:s,exact:s,checkPropTypes:n,resetWarningCache:t};return a.PropTypes=a,a},hE}var dW;function spe(){return dW||(dW=1,dE.exports=rpe()()),dE.exports}var ape=spe();const Mn=ty(ape);function Rh(e,t,n,r){function s(a){return a instanceof n?a:new n(function(i){i(a)})}return new(n||(n=Promise))(function(a,i){function o(c){try{u(r.next(c))}catch(d){i(d)}}function l(c){try{u(r.throw(c))}catch(d){i(d)}}function u(c){c.done?a(c.value):s(c.value).then(o,l)}u((r=r.apply(e,t||[])).next())})}const ipe=new Map([["1km","application/vnd.1000minds.decision-model+xml"],["3dml","text/vnd.in3d.3dml"],["3ds","image/x-3ds"],["3g2","video/3gpp2"],["3gp","video/3gp"],["3gpp","video/3gpp"],["3mf","model/3mf"],["7z","application/x-7z-compressed"],["7zip","application/x-7z-compressed"],["123","application/vnd.lotus-1-2-3"],["aab","application/x-authorware-bin"],["aac","audio/x-acc"],["aam","application/x-authorware-map"],["aas","application/x-authorware-seg"],["abw","application/x-abiword"],["ac","application/vnd.nokia.n-gage.ac+xml"],["ac3","audio/ac3"],["acc","application/vnd.americandynamics.acc"],["ace","application/x-ace-compressed"],["acu","application/vnd.acucobol"],["acutc","application/vnd.acucorp"],["adp","audio/adpcm"],["aep","application/vnd.audiograph"],["afm","application/x-font-type1"],["afp","application/vnd.ibm.modcap"],["ahead","application/vnd.ahead.space"],["ai","application/pdf"],["aif","audio/x-aiff"],["aifc","audio/x-aiff"],["aiff","audio/x-aiff"],["air","application/vnd.adobe.air-application-installer-package+zip"],["ait","application/vnd.dvb.ait"],["ami","application/vnd.amiga.ami"],["amr","audio/amr"],["apk","application/vnd.android.package-archive"],["apng","image/apng"],["appcache","text/cache-manifest"],["application","application/x-ms-application"],["apr","application/vnd.lotus-approach"],["arc","application/x-freearc"],["arj","application/x-arj"],["asc","application/pgp-signature"],["asf","video/x-ms-asf"],["asm","text/x-asm"],["aso","application/vnd.accpac.simply.aso"],["asx","video/x-ms-asf"],["atc","application/vnd.acucorp"],["atom","application/atom+xml"],["atomcat","application/atomcat+xml"],["atomdeleted","application/atomdeleted+xml"],["atomsvc","application/atomsvc+xml"],["atx","application/vnd.antix.game-component"],["au","audio/x-au"],["avi","video/x-msvideo"],["avif","image/avif"],["aw","application/applixware"],["azf","application/vnd.airzip.filesecure.azf"],["azs","application/vnd.airzip.filesecure.azs"],["azv","image/vnd.airzip.accelerator.azv"],["azw","application/vnd.amazon.ebook"],["b16","image/vnd.pco.b16"],["bat","application/x-msdownload"],["bcpio","application/x-bcpio"],["bdf","application/x-font-bdf"],["bdm","application/vnd.syncml.dm+wbxml"],["bdoc","application/x-bdoc"],["bed","application/vnd.realvnc.bed"],["bh2","application/vnd.fujitsu.oasysprs"],["bin","application/octet-stream"],["blb","application/x-blorb"],["blorb","application/x-blorb"],["bmi","application/vnd.bmi"],["bmml","application/vnd.balsamiq.bmml+xml"],["bmp","image/bmp"],["book","application/vnd.framemaker"],["box","application/vnd.previewsystems.box"],["boz","application/x-bzip2"],["bpk","application/octet-stream"],["bpmn","application/octet-stream"],["bsp","model/vnd.valve.source.compiled-map"],["btif","image/prs.btif"],["buffer","application/octet-stream"],["bz","application/x-bzip"],["bz2","application/x-bzip2"],["c","text/x-c"],["c4d","application/vnd.clonk.c4group"],["c4f","application/vnd.clonk.c4group"],["c4g","application/vnd.clonk.c4group"],["c4p","application/vnd.clonk.c4group"],["c4u","application/vnd.clonk.c4group"],["c11amc","application/vnd.cluetrust.cartomobile-config"],["c11amz","application/vnd.cluetrust.cartomobile-config-pkg"],["cab","application/vnd.ms-cab-compressed"],["caf","audio/x-caf"],["cap","application/vnd.tcpdump.pcap"],["car","application/vnd.curl.car"],["cat","application/vnd.ms-pki.seccat"],["cb7","application/x-cbr"],["cba","application/x-cbr"],["cbr","application/x-cbr"],["cbt","application/x-cbr"],["cbz","application/x-cbr"],["cc","text/x-c"],["cco","application/x-cocoa"],["cct","application/x-director"],["ccxml","application/ccxml+xml"],["cdbcmsg","application/vnd.contact.cmsg"],["cda","application/x-cdf"],["cdf","application/x-netcdf"],["cdfx","application/cdfx+xml"],["cdkey","application/vnd.mediastation.cdkey"],["cdmia","application/cdmi-capability"],["cdmic","application/cdmi-container"],["cdmid","application/cdmi-domain"],["cdmio","application/cdmi-object"],["cdmiq","application/cdmi-queue"],["cdr","application/cdr"],["cdx","chemical/x-cdx"],["cdxml","application/vnd.chemdraw+xml"],["cdy","application/vnd.cinderella"],["cer","application/pkix-cert"],["cfs","application/x-cfs-compressed"],["cgm","image/cgm"],["chat","application/x-chat"],["chm","application/vnd.ms-htmlhelp"],["chrt","application/vnd.kde.kchart"],["cif","chemical/x-cif"],["cii","application/vnd.anser-web-certificate-issue-initiation"],["cil","application/vnd.ms-artgalry"],["cjs","application/node"],["cla","application/vnd.claymore"],["class","application/octet-stream"],["clkk","application/vnd.crick.clicker.keyboard"],["clkp","application/vnd.crick.clicker.palette"],["clkt","application/vnd.crick.clicker.template"],["clkw","application/vnd.crick.clicker.wordbank"],["clkx","application/vnd.crick.clicker"],["clp","application/x-msclip"],["cmc","application/vnd.cosmocaller"],["cmdf","chemical/x-cmdf"],["cml","chemical/x-cml"],["cmp","application/vnd.yellowriver-custom-menu"],["cmx","image/x-cmx"],["cod","application/vnd.rim.cod"],["coffee","text/coffeescript"],["com","application/x-msdownload"],["conf","text/plain"],["cpio","application/x-cpio"],["cpp","text/x-c"],["cpt","application/mac-compactpro"],["crd","application/x-mscardfile"],["crl","application/pkix-crl"],["crt","application/x-x509-ca-cert"],["crx","application/x-chrome-extension"],["cryptonote","application/vnd.rig.cryptonote"],["csh","application/x-csh"],["csl","application/vnd.citationstyles.style+xml"],["csml","chemical/x-csml"],["csp","application/vnd.commonspace"],["csr","application/octet-stream"],["css","text/css"],["cst","application/x-director"],["csv","text/csv"],["cu","application/cu-seeme"],["curl","text/vnd.curl"],["cww","application/prs.cww"],["cxt","application/x-director"],["cxx","text/x-c"],["dae","model/vnd.collada+xml"],["daf","application/vnd.mobius.daf"],["dart","application/vnd.dart"],["dataless","application/vnd.fdsn.seed"],["davmount","application/davmount+xml"],["dbf","application/vnd.dbf"],["dbk","application/docbook+xml"],["dcr","application/x-director"],["dcurl","text/vnd.curl.dcurl"],["dd2","application/vnd.oma.dd2+xml"],["ddd","application/vnd.fujixerox.ddd"],["ddf","application/vnd.syncml.dmddf+xml"],["dds","image/vnd.ms-dds"],["deb","application/x-debian-package"],["def","text/plain"],["deploy","application/octet-stream"],["der","application/x-x509-ca-cert"],["dfac","application/vnd.dreamfactory"],["dgc","application/x-dgc-compressed"],["dic","text/x-c"],["dir","application/x-director"],["dis","application/vnd.mobius.dis"],["disposition-notification","message/disposition-notification"],["dist","application/octet-stream"],["distz","application/octet-stream"],["djv","image/vnd.djvu"],["djvu","image/vnd.djvu"],["dll","application/octet-stream"],["dmg","application/x-apple-diskimage"],["dmn","application/octet-stream"],["dmp","application/vnd.tcpdump.pcap"],["dms","application/octet-stream"],["dna","application/vnd.dna"],["doc","application/msword"],["docm","application/vnd.ms-word.template.macroEnabled.12"],["docx","application/vnd.openxmlformats-officedocument.wordprocessingml.document"],["dot","application/msword"],["dotm","application/vnd.ms-word.template.macroEnabled.12"],["dotx","application/vnd.openxmlformats-officedocument.wordprocessingml.template"],["dp","application/vnd.osgi.dp"],["dpg","application/vnd.dpgraph"],["dra","audio/vnd.dra"],["drle","image/dicom-rle"],["dsc","text/prs.lines.tag"],["dssc","application/dssc+der"],["dtb","application/x-dtbook+xml"],["dtd","application/xml-dtd"],["dts","audio/vnd.dts"],["dtshd","audio/vnd.dts.hd"],["dump","application/octet-stream"],["dvb","video/vnd.dvb.file"],["dvi","application/x-dvi"],["dwd","application/atsc-dwd+xml"],["dwf","model/vnd.dwf"],["dwg","image/vnd.dwg"],["dxf","image/vnd.dxf"],["dxp","application/vnd.spotfire.dxp"],["dxr","application/x-director"],["ear","application/java-archive"],["ecelp4800","audio/vnd.nuera.ecelp4800"],["ecelp7470","audio/vnd.nuera.ecelp7470"],["ecelp9600","audio/vnd.nuera.ecelp9600"],["ecma","application/ecmascript"],["edm","application/vnd.novadigm.edm"],["edx","application/vnd.novadigm.edx"],["efif","application/vnd.picsel"],["ei6","application/vnd.pg.osasli"],["elc","application/octet-stream"],["emf","image/emf"],["eml","message/rfc822"],["emma","application/emma+xml"],["emotionml","application/emotionml+xml"],["emz","application/x-msmetafile"],["eol","audio/vnd.digital-winds"],["eot","application/vnd.ms-fontobject"],["eps","application/postscript"],["epub","application/epub+zip"],["es","application/ecmascript"],["es3","application/vnd.eszigno3+xml"],["esa","application/vnd.osgi.subsystem"],["esf","application/vnd.epson.esf"],["et3","application/vnd.eszigno3+xml"],["etx","text/x-setext"],["eva","application/x-eva"],["evy","application/x-envoy"],["exe","application/octet-stream"],["exi","application/exi"],["exp","application/express"],["exr","image/aces"],["ext","application/vnd.novadigm.ext"],["ez","application/andrew-inset"],["ez2","application/vnd.ezpix-album"],["ez3","application/vnd.ezpix-package"],["f","text/x-fortran"],["f4v","video/mp4"],["f77","text/x-fortran"],["f90","text/x-fortran"],["fbs","image/vnd.fastbidsheet"],["fcdt","application/vnd.adobe.formscentral.fcdt"],["fcs","application/vnd.isac.fcs"],["fdf","application/vnd.fdf"],["fdt","application/fdt+xml"],["fe_launch","application/vnd.denovo.fcselayout-link"],["fg5","application/vnd.fujitsu.oasysgp"],["fgd","application/x-director"],["fh","image/x-freehand"],["fh4","image/x-freehand"],["fh5","image/x-freehand"],["fh7","image/x-freehand"],["fhc","image/x-freehand"],["fig","application/x-xfig"],["fits","image/fits"],["flac","audio/x-flac"],["fli","video/x-fli"],["flo","application/vnd.micrografx.flo"],["flv","video/x-flv"],["flw","application/vnd.kde.kivio"],["flx","text/vnd.fmi.flexstor"],["fly","text/vnd.fly"],["fm","application/vnd.framemaker"],["fnc","application/vnd.frogans.fnc"],["fo","application/vnd.software602.filler.form+xml"],["for","text/x-fortran"],["fpx","image/vnd.fpx"],["frame","application/vnd.framemaker"],["fsc","application/vnd.fsc.weblaunch"],["fst","image/vnd.fst"],["ftc","application/vnd.fluxtime.clip"],["fti","application/vnd.anser-web-funds-transfer-initiation"],["fvt","video/vnd.fvt"],["fxp","application/vnd.adobe.fxp"],["fxpl","application/vnd.adobe.fxp"],["fzs","application/vnd.fuzzysheet"],["g2w","application/vnd.geoplan"],["g3","image/g3fax"],["g3w","application/vnd.geospace"],["gac","application/vnd.groove-account"],["gam","application/x-tads"],["gbr","application/rpki-ghostbusters"],["gca","application/x-gca-compressed"],["gdl","model/vnd.gdl"],["gdoc","application/vnd.google-apps.document"],["geo","application/vnd.dynageo"],["geojson","application/geo+json"],["gex","application/vnd.geometry-explorer"],["ggb","application/vnd.geogebra.file"],["ggt","application/vnd.geogebra.tool"],["ghf","application/vnd.groove-help"],["gif","image/gif"],["gim","application/vnd.groove-identity-message"],["glb","model/gltf-binary"],["gltf","model/gltf+json"],["gml","application/gml+xml"],["gmx","application/vnd.gmx"],["gnumeric","application/x-gnumeric"],["gpg","application/gpg-keys"],["gph","application/vnd.flographit"],["gpx","application/gpx+xml"],["gqf","application/vnd.grafeq"],["gqs","application/vnd.grafeq"],["gram","application/srgs"],["gramps","application/x-gramps-xml"],["gre","application/vnd.geometry-explorer"],["grv","application/vnd.groove-injector"],["grxml","application/srgs+xml"],["gsf","application/x-font-ghostscript"],["gsheet","application/vnd.google-apps.spreadsheet"],["gslides","application/vnd.google-apps.presentation"],["gtar","application/x-gtar"],["gtm","application/vnd.groove-tool-message"],["gtw","model/vnd.gtw"],["gv","text/vnd.graphviz"],["gxf","application/gxf"],["gxt","application/vnd.geonext"],["gz","application/gzip"],["gzip","application/gzip"],["h","text/x-c"],["h261","video/h261"],["h263","video/h263"],["h264","video/h264"],["hal","application/vnd.hal+xml"],["hbci","application/vnd.hbci"],["hbs","text/x-handlebars-template"],["hdd","application/x-virtualbox-hdd"],["hdf","application/x-hdf"],["heic","image/heic"],["heics","image/heic-sequence"],["heif","image/heif"],["heifs","image/heif-sequence"],["hej2","image/hej2k"],["held","application/atsc-held+xml"],["hh","text/x-c"],["hjson","application/hjson"],["hlp","application/winhlp"],["hpgl","application/vnd.hp-hpgl"],["hpid","application/vnd.hp-hpid"],["hps","application/vnd.hp-hps"],["hqx","application/mac-binhex40"],["hsj2","image/hsj2"],["htc","text/x-component"],["htke","application/vnd.kenameaapp"],["htm","text/html"],["html","text/html"],["hvd","application/vnd.yamaha.hv-dic"],["hvp","application/vnd.yamaha.hv-voice"],["hvs","application/vnd.yamaha.hv-script"],["i2g","application/vnd.intergeo"],["icc","application/vnd.iccprofile"],["ice","x-conference/x-cooltalk"],["icm","application/vnd.iccprofile"],["ico","image/x-icon"],["ics","text/calendar"],["ief","image/ief"],["ifb","text/calendar"],["ifm","application/vnd.shana.informed.formdata"],["iges","model/iges"],["igl","application/vnd.igloader"],["igm","application/vnd.insors.igm"],["igs","model/iges"],["igx","application/vnd.micrografx.igx"],["iif","application/vnd.shana.informed.interchange"],["img","application/octet-stream"],["imp","application/vnd.accpac.simply.imp"],["ims","application/vnd.ms-ims"],["in","text/plain"],["ini","text/plain"],["ink","application/inkml+xml"],["inkml","application/inkml+xml"],["install","application/x-install-instructions"],["iota","application/vnd.astraea-software.iota"],["ipfix","application/ipfix"],["ipk","application/vnd.shana.informed.package"],["irm","application/vnd.ibm.rights-management"],["irp","application/vnd.irepository.package+xml"],["iso","application/x-iso9660-image"],["itp","application/vnd.shana.informed.formtemplate"],["its","application/its+xml"],["ivp","application/vnd.immervision-ivp"],["ivu","application/vnd.immervision-ivu"],["jad","text/vnd.sun.j2me.app-descriptor"],["jade","text/jade"],["jam","application/vnd.jam"],["jar","application/java-archive"],["jardiff","application/x-java-archive-diff"],["java","text/x-java-source"],["jhc","image/jphc"],["jisp","application/vnd.jisp"],["jls","image/jls"],["jlt","application/vnd.hp-jlyt"],["jng","image/x-jng"],["jnlp","application/x-java-jnlp-file"],["joda","application/vnd.joost.joda-archive"],["jp2","image/jp2"],["jpe","image/jpeg"],["jpeg","image/jpeg"],["jpf","image/jpx"],["jpg","image/jpeg"],["jpg2","image/jp2"],["jpgm","video/jpm"],["jpgv","video/jpeg"],["jph","image/jph"],["jpm","video/jpm"],["jpx","image/jpx"],["js","application/javascript"],["json","application/json"],["json5","application/json5"],["jsonld","application/ld+json"],["jsonl","application/jsonl"],["jsonml","application/jsonml+json"],["jsx","text/jsx"],["jxr","image/jxr"],["jxra","image/jxra"],["jxrs","image/jxrs"],["jxs","image/jxs"],["jxsc","image/jxsc"],["jxsi","image/jxsi"],["jxss","image/jxss"],["kar","audio/midi"],["karbon","application/vnd.kde.karbon"],["kdb","application/octet-stream"],["kdbx","application/x-keepass2"],["key","application/x-iwork-keynote-sffkey"],["kfo","application/vnd.kde.kformula"],["kia","application/vnd.kidspiration"],["kml","application/vnd.google-earth.kml+xml"],["kmz","application/vnd.google-earth.kmz"],["kne","application/vnd.kinar"],["knp","application/vnd.kinar"],["kon","application/vnd.kde.kontour"],["kpr","application/vnd.kde.kpresenter"],["kpt","application/vnd.kde.kpresenter"],["kpxx","application/vnd.ds-keypoint"],["ksp","application/vnd.kde.kspread"],["ktr","application/vnd.kahootz"],["ktx","image/ktx"],["ktx2","image/ktx2"],["ktz","application/vnd.kahootz"],["kwd","application/vnd.kde.kword"],["kwt","application/vnd.kde.kword"],["lasxml","application/vnd.las.las+xml"],["latex","application/x-latex"],["lbd","application/vnd.llamagraphics.life-balance.desktop"],["lbe","application/vnd.llamagraphics.life-balance.exchange+xml"],["les","application/vnd.hhe.lesson-player"],["less","text/less"],["lgr","application/lgr+xml"],["lha","application/octet-stream"],["link66","application/vnd.route66.link66+xml"],["list","text/plain"],["list3820","application/vnd.ibm.modcap"],["listafp","application/vnd.ibm.modcap"],["litcoffee","text/coffeescript"],["lnk","application/x-ms-shortcut"],["log","text/plain"],["lostxml","application/lost+xml"],["lrf","application/octet-stream"],["lrm","application/vnd.ms-lrm"],["ltf","application/vnd.frogans.ltf"],["lua","text/x-lua"],["luac","application/x-lua-bytecode"],["lvp","audio/vnd.lucent.voice"],["lwp","application/vnd.lotus-wordpro"],["lzh","application/octet-stream"],["m1v","video/mpeg"],["m2a","audio/mpeg"],["m2v","video/mpeg"],["m3a","audio/mpeg"],["m3u","text/plain"],["m3u8","application/vnd.apple.mpegurl"],["m4a","audio/x-m4a"],["m4p","application/mp4"],["m4s","video/iso.segment"],["m4u","application/vnd.mpegurl"],["m4v","video/x-m4v"],["m13","application/x-msmediaview"],["m14","application/x-msmediaview"],["m21","application/mp21"],["ma","application/mathematica"],["mads","application/mads+xml"],["maei","application/mmt-aei+xml"],["mag","application/vnd.ecowin.chart"],["maker","application/vnd.framemaker"],["man","text/troff"],["manifest","text/cache-manifest"],["map","application/json"],["mar","application/octet-stream"],["markdown","text/markdown"],["mathml","application/mathml+xml"],["mb","application/mathematica"],["mbk","application/vnd.mobius.mbk"],["mbox","application/mbox"],["mc1","application/vnd.medcalcdata"],["mcd","application/vnd.mcd"],["mcurl","text/vnd.curl.mcurl"],["md","text/markdown"],["mdb","application/x-msaccess"],["mdi","image/vnd.ms-modi"],["mdx","text/mdx"],["me","text/troff"],["mesh","model/mesh"],["meta4","application/metalink4+xml"],["metalink","application/metalink+xml"],["mets","application/mets+xml"],["mfm","application/vnd.mfmp"],["mft","application/rpki-manifest"],["mgp","application/vnd.osgeo.mapguide.package"],["mgz","application/vnd.proteus.magazine"],["mid","audio/midi"],["midi","audio/midi"],["mie","application/x-mie"],["mif","application/vnd.mif"],["mime","message/rfc822"],["mj2","video/mj2"],["mjp2","video/mj2"],["mjs","application/javascript"],["mk3d","video/x-matroska"],["mka","audio/x-matroska"],["mkd","text/x-markdown"],["mks","video/x-matroska"],["mkv","video/x-matroska"],["mlp","application/vnd.dolby.mlp"],["mmd","application/vnd.chipnuts.karaoke-mmd"],["mmf","application/vnd.smaf"],["mml","text/mathml"],["mmr","image/vnd.fujixerox.edmics-mmr"],["mng","video/x-mng"],["mny","application/x-msmoney"],["mobi","application/x-mobipocket-ebook"],["mods","application/mods+xml"],["mov","video/quicktime"],["movie","video/x-sgi-movie"],["mp2","audio/mpeg"],["mp2a","audio/mpeg"],["mp3","audio/mpeg"],["mp4","video/mp4"],["mp4a","audio/mp4"],["mp4s","application/mp4"],["mp4v","video/mp4"],["mp21","application/mp21"],["mpc","application/vnd.mophun.certificate"],["mpd","application/dash+xml"],["mpe","video/mpeg"],["mpeg","video/mpeg"],["mpg","video/mpeg"],["mpg4","video/mp4"],["mpga","audio/mpeg"],["mpkg","application/vnd.apple.installer+xml"],["mpm","application/vnd.blueice.multipass"],["mpn","application/vnd.mophun.application"],["mpp","application/vnd.ms-project"],["mpt","application/vnd.ms-project"],["mpy","application/vnd.ibm.minipay"],["mqy","application/vnd.mobius.mqy"],["mrc","application/marc"],["mrcx","application/marcxml+xml"],["ms","text/troff"],["mscml","application/mediaservercontrol+xml"],["mseed","application/vnd.fdsn.mseed"],["mseq","application/vnd.mseq"],["msf","application/vnd.epson.msf"],["msg","application/vnd.ms-outlook"],["msh","model/mesh"],["msi","application/x-msdownload"],["msl","application/vnd.mobius.msl"],["msm","application/octet-stream"],["msp","application/octet-stream"],["msty","application/vnd.muvee.style"],["mtl","model/mtl"],["mts","model/vnd.mts"],["mus","application/vnd.musician"],["musd","application/mmt-usd+xml"],["musicxml","application/vnd.recordare.musicxml+xml"],["mvb","application/x-msmediaview"],["mvt","application/vnd.mapbox-vector-tile"],["mwf","application/vnd.mfer"],["mxf","application/mxf"],["mxl","application/vnd.recordare.musicxml"],["mxmf","audio/mobile-xmf"],["mxml","application/xv+xml"],["mxs","application/vnd.triscape.mxs"],["mxu","video/vnd.mpegurl"],["n-gage","application/vnd.nokia.n-gage.symbian.install"],["n3","text/n3"],["nb","application/mathematica"],["nbp","application/vnd.wolfram.player"],["nc","application/x-netcdf"],["ncx","application/x-dtbncx+xml"],["nfo","text/x-nfo"],["ngdat","application/vnd.nokia.n-gage.data"],["nitf","application/vnd.nitf"],["nlu","application/vnd.neurolanguage.nlu"],["nml","application/vnd.enliven"],["nnd","application/vnd.noblenet-directory"],["nns","application/vnd.noblenet-sealer"],["nnw","application/vnd.noblenet-web"],["npx","image/vnd.net-fpx"],["nq","application/n-quads"],["nsc","application/x-conference"],["nsf","application/vnd.lotus-notes"],["nt","application/n-triples"],["ntf","application/vnd.nitf"],["numbers","application/x-iwork-numbers-sffnumbers"],["nzb","application/x-nzb"],["oa2","application/vnd.fujitsu.oasys2"],["oa3","application/vnd.fujitsu.oasys3"],["oas","application/vnd.fujitsu.oasys"],["obd","application/x-msbinder"],["obgx","application/vnd.openblox.game+xml"],["obj","model/obj"],["oda","application/oda"],["odb","application/vnd.oasis.opendocument.database"],["odc","application/vnd.oasis.opendocument.chart"],["odf","application/vnd.oasis.opendocument.formula"],["odft","application/vnd.oasis.opendocument.formula-template"],["odg","application/vnd.oasis.opendocument.graphics"],["odi","application/vnd.oasis.opendocument.image"],["odm","application/vnd.oasis.opendocument.text-master"],["odp","application/vnd.oasis.opendocument.presentation"],["ods","application/vnd.oasis.opendocument.spreadsheet"],["odt","application/vnd.oasis.opendocument.text"],["oga","audio/ogg"],["ogex","model/vnd.opengex"],["ogg","audio/ogg"],["ogv","video/ogg"],["ogx","application/ogg"],["omdoc","application/omdoc+xml"],["onepkg","application/onenote"],["onetmp","application/onenote"],["onetoc","application/onenote"],["onetoc2","application/onenote"],["opf","application/oebps-package+xml"],["opml","text/x-opml"],["oprc","application/vnd.palm"],["opus","audio/ogg"],["org","text/x-org"],["osf","application/vnd.yamaha.openscoreformat"],["osfpvg","application/vnd.yamaha.openscoreformat.osfpvg+xml"],["osm","application/vnd.openstreetmap.data+xml"],["otc","application/vnd.oasis.opendocument.chart-template"],["otf","font/otf"],["otg","application/vnd.oasis.opendocument.graphics-template"],["oth","application/vnd.oasis.opendocument.text-web"],["oti","application/vnd.oasis.opendocument.image-template"],["otp","application/vnd.oasis.opendocument.presentation-template"],["ots","application/vnd.oasis.opendocument.spreadsheet-template"],["ott","application/vnd.oasis.opendocument.text-template"],["ova","application/x-virtualbox-ova"],["ovf","application/x-virtualbox-ovf"],["owl","application/rdf+xml"],["oxps","application/oxps"],["oxt","application/vnd.openofficeorg.extension"],["p","text/x-pascal"],["p7a","application/x-pkcs7-signature"],["p7b","application/x-pkcs7-certificates"],["p7c","application/pkcs7-mime"],["p7m","application/pkcs7-mime"],["p7r","application/x-pkcs7-certreqresp"],["p7s","application/pkcs7-signature"],["p8","application/pkcs8"],["p10","application/x-pkcs10"],["p12","application/x-pkcs12"],["pac","application/x-ns-proxy-autoconfig"],["pages","application/x-iwork-pages-sffpages"],["pas","text/x-pascal"],["paw","application/vnd.pawaafile"],["pbd","application/vnd.powerbuilder6"],["pbm","image/x-portable-bitmap"],["pcap","application/vnd.tcpdump.pcap"],["pcf","application/x-font-pcf"],["pcl","application/vnd.hp-pcl"],["pclxl","application/vnd.hp-pclxl"],["pct","image/x-pict"],["pcurl","application/vnd.curl.pcurl"],["pcx","image/x-pcx"],["pdb","application/x-pilot"],["pde","text/x-processing"],["pdf","application/pdf"],["pem","application/x-x509-user-cert"],["pfa","application/x-font-type1"],["pfb","application/x-font-type1"],["pfm","application/x-font-type1"],["pfr","application/font-tdpfr"],["pfx","application/x-pkcs12"],["pgm","image/x-portable-graymap"],["pgn","application/x-chess-pgn"],["pgp","application/pgp"],["php","application/x-httpd-php"],["php3","application/x-httpd-php"],["php4","application/x-httpd-php"],["phps","application/x-httpd-php-source"],["phtml","application/x-httpd-php"],["pic","image/x-pict"],["pkg","application/octet-stream"],["pki","application/pkixcmp"],["pkipath","application/pkix-pkipath"],["pkpass","application/vnd.apple.pkpass"],["pl","application/x-perl"],["plb","application/vnd.3gpp.pic-bw-large"],["plc","application/vnd.mobius.plc"],["plf","application/vnd.pocketlearn"],["pls","application/pls+xml"],["pm","application/x-perl"],["pml","application/vnd.ctc-posml"],["png","image/png"],["pnm","image/x-portable-anymap"],["portpkg","application/vnd.macports.portpkg"],["pot","application/vnd.ms-powerpoint"],["potm","application/vnd.ms-powerpoint.presentation.macroEnabled.12"],["potx","application/vnd.openxmlformats-officedocument.presentationml.template"],["ppa","application/vnd.ms-powerpoint"],["ppam","application/vnd.ms-powerpoint.addin.macroEnabled.12"],["ppd","application/vnd.cups-ppd"],["ppm","image/x-portable-pixmap"],["pps","application/vnd.ms-powerpoint"],["ppsm","application/vnd.ms-powerpoint.slideshow.macroEnabled.12"],["ppsx","application/vnd.openxmlformats-officedocument.presentationml.slideshow"],["ppt","application/powerpoint"],["pptm","application/vnd.ms-powerpoint.presentation.macroEnabled.12"],["pptx","application/vnd.openxmlformats-officedocument.presentationml.presentation"],["pqa","application/vnd.palm"],["prc","application/x-pilot"],["pre","application/vnd.lotus-freelance"],["prf","application/pics-rules"],["provx","application/provenance+xml"],["ps","application/postscript"],["psb","application/vnd.3gpp.pic-bw-small"],["psd","application/x-photoshop"],["psf","application/x-font-linux-psf"],["pskcxml","application/pskc+xml"],["pti","image/prs.pti"],["ptid","application/vnd.pvi.ptid1"],["pub","application/x-mspublisher"],["pvb","application/vnd.3gpp.pic-bw-var"],["pwn","application/vnd.3m.post-it-notes"],["pya","audio/vnd.ms-playready.media.pya"],["pyv","video/vnd.ms-playready.media.pyv"],["qam","application/vnd.epson.quickanime"],["qbo","application/vnd.intu.qbo"],["qfx","application/vnd.intu.qfx"],["qps","application/vnd.publishare-delta-tree"],["qt","video/quicktime"],["qwd","application/vnd.quark.quarkxpress"],["qwt","application/vnd.quark.quarkxpress"],["qxb","application/vnd.quark.quarkxpress"],["qxd","application/vnd.quark.quarkxpress"],["qxl","application/vnd.quark.quarkxpress"],["qxt","application/vnd.quark.quarkxpress"],["ra","audio/x-realaudio"],["ram","audio/x-pn-realaudio"],["raml","application/raml+yaml"],["rapd","application/route-apd+xml"],["rar","application/x-rar"],["ras","image/x-cmu-raster"],["rcprofile","application/vnd.ipunplugged.rcprofile"],["rdf","application/rdf+xml"],["rdz","application/vnd.data-vision.rdz"],["relo","application/p2p-overlay+xml"],["rep","application/vnd.businessobjects"],["res","application/x-dtbresource+xml"],["rgb","image/x-rgb"],["rif","application/reginfo+xml"],["rip","audio/vnd.rip"],["ris","application/x-research-info-systems"],["rl","application/resource-lists+xml"],["rlc","image/vnd.fujixerox.edmics-rlc"],["rld","application/resource-lists-diff+xml"],["rm","audio/x-pn-realaudio"],["rmi","audio/midi"],["rmp","audio/x-pn-realaudio-plugin"],["rms","application/vnd.jcp.javame.midlet-rms"],["rmvb","application/vnd.rn-realmedia-vbr"],["rnc","application/relax-ng-compact-syntax"],["rng","application/xml"],["roa","application/rpki-roa"],["roff","text/troff"],["rp9","application/vnd.cloanto.rp9"],["rpm","audio/x-pn-realaudio-plugin"],["rpss","application/vnd.nokia.radio-presets"],["rpst","application/vnd.nokia.radio-preset"],["rq","application/sparql-query"],["rs","application/rls-services+xml"],["rsa","application/x-pkcs7"],["rsat","application/atsc-rsat+xml"],["rsd","application/rsd+xml"],["rsheet","application/urc-ressheet+xml"],["rss","application/rss+xml"],["rtf","text/rtf"],["rtx","text/richtext"],["run","application/x-makeself"],["rusd","application/route-usd+xml"],["rv","video/vnd.rn-realvideo"],["s","text/x-asm"],["s3m","audio/s3m"],["saf","application/vnd.yamaha.smaf-audio"],["sass","text/x-sass"],["sbml","application/sbml+xml"],["sc","application/vnd.ibm.secure-container"],["scd","application/x-msschedule"],["scm","application/vnd.lotus-screencam"],["scq","application/scvp-cv-request"],["scs","application/scvp-cv-response"],["scss","text/x-scss"],["scurl","text/vnd.curl.scurl"],["sda","application/vnd.stardivision.draw"],["sdc","application/vnd.stardivision.calc"],["sdd","application/vnd.stardivision.impress"],["sdkd","application/vnd.solent.sdkm+xml"],["sdkm","application/vnd.solent.sdkm+xml"],["sdp","application/sdp"],["sdw","application/vnd.stardivision.writer"],["sea","application/octet-stream"],["see","application/vnd.seemail"],["seed","application/vnd.fdsn.seed"],["sema","application/vnd.sema"],["semd","application/vnd.semd"],["semf","application/vnd.semf"],["senmlx","application/senml+xml"],["sensmlx","application/sensml+xml"],["ser","application/java-serialized-object"],["setpay","application/set-payment-initiation"],["setreg","application/set-registration-initiation"],["sfd-hdstx","application/vnd.hydrostatix.sof-data"],["sfs","application/vnd.spotfire.sfs"],["sfv","text/x-sfv"],["sgi","image/sgi"],["sgl","application/vnd.stardivision.writer-global"],["sgm","text/sgml"],["sgml","text/sgml"],["sh","application/x-sh"],["shar","application/x-shar"],["shex","text/shex"],["shf","application/shf+xml"],["shtml","text/html"],["sid","image/x-mrsid-image"],["sieve","application/sieve"],["sig","application/pgp-signature"],["sil","audio/silk"],["silo","model/mesh"],["sis","application/vnd.symbian.install"],["sisx","application/vnd.symbian.install"],["sit","application/x-stuffit"],["sitx","application/x-stuffitx"],["siv","application/sieve"],["skd","application/vnd.koan"],["skm","application/vnd.koan"],["skp","application/vnd.koan"],["skt","application/vnd.koan"],["sldm","application/vnd.ms-powerpoint.slide.macroenabled.12"],["sldx","application/vnd.openxmlformats-officedocument.presentationml.slide"],["slim","text/slim"],["slm","text/slim"],["sls","application/route-s-tsid+xml"],["slt","application/vnd.epson.salt"],["sm","application/vnd.stepmania.stepchart"],["smf","application/vnd.stardivision.math"],["smi","application/smil"],["smil","application/smil"],["smv","video/x-smv"],["smzip","application/vnd.stepmania.package"],["snd","audio/basic"],["snf","application/x-font-snf"],["so","application/octet-stream"],["spc","application/x-pkcs7-certificates"],["spdx","text/spdx"],["spf","application/vnd.yamaha.smaf-phrase"],["spl","application/x-futuresplash"],["spot","text/vnd.in3d.spot"],["spp","application/scvp-vp-response"],["spq","application/scvp-vp-request"],["spx","audio/ogg"],["sql","application/x-sql"],["src","application/x-wais-source"],["srt","application/x-subrip"],["sru","application/sru+xml"],["srx","application/sparql-results+xml"],["ssdl","application/ssdl+xml"],["sse","application/vnd.kodak-descriptor"],["ssf","application/vnd.epson.ssf"],["ssml","application/ssml+xml"],["sst","application/octet-stream"],["st","application/vnd.sailingtracker.track"],["stc","application/vnd.sun.xml.calc.template"],["std","application/vnd.sun.xml.draw.template"],["stf","application/vnd.wt.stf"],["sti","application/vnd.sun.xml.impress.template"],["stk","application/hyperstudio"],["stl","model/stl"],["stpx","model/step+xml"],["stpxz","model/step-xml+zip"],["stpz","model/step+zip"],["str","application/vnd.pg.format"],["stw","application/vnd.sun.xml.writer.template"],["styl","text/stylus"],["stylus","text/stylus"],["sub","text/vnd.dvb.subtitle"],["sus","application/vnd.sus-calendar"],["susp","application/vnd.sus-calendar"],["sv4cpio","application/x-sv4cpio"],["sv4crc","application/x-sv4crc"],["svc","application/vnd.dvb.service"],["svd","application/vnd.svd"],["svg","image/svg+xml"],["svgz","image/svg+xml"],["swa","application/x-director"],["swf","application/x-shockwave-flash"],["swi","application/vnd.aristanetworks.swi"],["swidtag","application/swid+xml"],["sxc","application/vnd.sun.xml.calc"],["sxd","application/vnd.sun.xml.draw"],["sxg","application/vnd.sun.xml.writer.global"],["sxi","application/vnd.sun.xml.impress"],["sxm","application/vnd.sun.xml.math"],["sxw","application/vnd.sun.xml.writer"],["t","text/troff"],["t3","application/x-t3vm-image"],["t38","image/t38"],["taglet","application/vnd.mynfc"],["tao","application/vnd.tao.intent-module-archive"],["tap","image/vnd.tencent.tap"],["tar","application/x-tar"],["tcap","application/vnd.3gpp2.tcap"],["tcl","application/x-tcl"],["td","application/urc-targetdesc+xml"],["teacher","application/vnd.smart.teacher"],["tei","application/tei+xml"],["teicorpus","application/tei+xml"],["tex","application/x-tex"],["texi","application/x-texinfo"],["texinfo","application/x-texinfo"],["text","text/plain"],["tfi","application/thraud+xml"],["tfm","application/x-tex-tfm"],["tfx","image/tiff-fx"],["tga","image/x-tga"],["tgz","application/x-tar"],["thmx","application/vnd.ms-officetheme"],["tif","image/tiff"],["tiff","image/tiff"],["tk","application/x-tcl"],["tmo","application/vnd.tmobile-livetv"],["toml","application/toml"],["torrent","application/x-bittorrent"],["tpl","application/vnd.groove-tool-template"],["tpt","application/vnd.trid.tpt"],["tr","text/troff"],["tra","application/vnd.trueapp"],["trig","application/trig"],["trm","application/x-msterminal"],["ts","video/mp2t"],["tsd","application/timestamped-data"],["tsv","text/tab-separated-values"],["ttc","font/collection"],["ttf","font/ttf"],["ttl","text/turtle"],["ttml","application/ttml+xml"],["twd","application/vnd.simtech-mindmapper"],["twds","application/vnd.simtech-mindmapper"],["txd","application/vnd.genomatix.tuxedo"],["txf","application/vnd.mobius.txf"],["txt","text/plain"],["u8dsn","message/global-delivery-status"],["u8hdr","message/global-headers"],["u8mdn","message/global-disposition-notification"],["u8msg","message/global"],["u32","application/x-authorware-bin"],["ubj","application/ubjson"],["udeb","application/x-debian-package"],["ufd","application/vnd.ufdl"],["ufdl","application/vnd.ufdl"],["ulx","application/x-glulx"],["umj","application/vnd.umajin"],["unityweb","application/vnd.unity"],["uoml","application/vnd.uoml+xml"],["uri","text/uri-list"],["uris","text/uri-list"],["urls","text/uri-list"],["usdz","model/vnd.usdz+zip"],["ustar","application/x-ustar"],["utz","application/vnd.uiq.theme"],["uu","text/x-uuencode"],["uva","audio/vnd.dece.audio"],["uvd","application/vnd.dece.data"],["uvf","application/vnd.dece.data"],["uvg","image/vnd.dece.graphic"],["uvh","video/vnd.dece.hd"],["uvi","image/vnd.dece.graphic"],["uvm","video/vnd.dece.mobile"],["uvp","video/vnd.dece.pd"],["uvs","video/vnd.dece.sd"],["uvt","application/vnd.dece.ttml+xml"],["uvu","video/vnd.uvvu.mp4"],["uvv","video/vnd.dece.video"],["uvva","audio/vnd.dece.audio"],["uvvd","application/vnd.dece.data"],["uvvf","application/vnd.dece.data"],["uvvg","image/vnd.dece.graphic"],["uvvh","video/vnd.dece.hd"],["uvvi","image/vnd.dece.graphic"],["uvvm","video/vnd.dece.mobile"],["uvvp","video/vnd.dece.pd"],["uvvs","video/vnd.dece.sd"],["uvvt","application/vnd.dece.ttml+xml"],["uvvu","video/vnd.uvvu.mp4"],["uvvv","video/vnd.dece.video"],["uvvx","application/vnd.dece.unspecified"],["uvvz","application/vnd.dece.zip"],["uvx","application/vnd.dece.unspecified"],["uvz","application/vnd.dece.zip"],["vbox","application/x-virtualbox-vbox"],["vbox-extpack","application/x-virtualbox-vbox-extpack"],["vcard","text/vcard"],["vcd","application/x-cdlink"],["vcf","text/x-vcard"],["vcg","application/vnd.groove-vcard"],["vcs","text/x-vcalendar"],["vcx","application/vnd.vcx"],["vdi","application/x-virtualbox-vdi"],["vds","model/vnd.sap.vds"],["vhd","application/x-virtualbox-vhd"],["vis","application/vnd.visionary"],["viv","video/vnd.vivo"],["vlc","application/videolan"],["vmdk","application/x-virtualbox-vmdk"],["vob","video/x-ms-vob"],["vor","application/vnd.stardivision.writer"],["vox","application/x-authorware-bin"],["vrml","model/vrml"],["vsd","application/vnd.visio"],["vsf","application/vnd.vsf"],["vss","application/vnd.visio"],["vst","application/vnd.visio"],["vsw","application/vnd.visio"],["vtf","image/vnd.valve.source.texture"],["vtt","text/vtt"],["vtu","model/vnd.vtu"],["vxml","application/voicexml+xml"],["w3d","application/x-director"],["wad","application/x-doom"],["wadl","application/vnd.sun.wadl+xml"],["war","application/java-archive"],["wasm","application/wasm"],["wav","audio/x-wav"],["wax","audio/x-ms-wax"],["wbmp","image/vnd.wap.wbmp"],["wbs","application/vnd.criticaltools.wbs+xml"],["wbxml","application/wbxml"],["wcm","application/vnd.ms-works"],["wdb","application/vnd.ms-works"],["wdp","image/vnd.ms-photo"],["weba","audio/webm"],["webapp","application/x-web-app-manifest+json"],["webm","video/webm"],["webmanifest","application/manifest+json"],["webp","image/webp"],["wg","application/vnd.pmi.widget"],["wgt","application/widget"],["wks","application/vnd.ms-works"],["wm","video/x-ms-wm"],["wma","audio/x-ms-wma"],["wmd","application/x-ms-wmd"],["wmf","image/wmf"],["wml","text/vnd.wap.wml"],["wmlc","application/wmlc"],["wmls","text/vnd.wap.wmlscript"],["wmlsc","application/vnd.wap.wmlscriptc"],["wmv","video/x-ms-wmv"],["wmx","video/x-ms-wmx"],["wmz","application/x-msmetafile"],["woff","font/woff"],["woff2","font/woff2"],["word","application/msword"],["wpd","application/vnd.wordperfect"],["wpl","application/vnd.ms-wpl"],["wps","application/vnd.ms-works"],["wqd","application/vnd.wqd"],["wri","application/x-mswrite"],["wrl","model/vrml"],["wsc","message/vnd.wfa.wsc"],["wsdl","application/wsdl+xml"],["wspolicy","application/wspolicy+xml"],["wtb","application/vnd.webturbo"],["wvx","video/x-ms-wvx"],["x3d","model/x3d+xml"],["x3db","model/x3d+fastinfoset"],["x3dbz","model/x3d+binary"],["x3dv","model/x3d-vrml"],["x3dvz","model/x3d+vrml"],["x3dz","model/x3d+xml"],["x32","application/x-authorware-bin"],["x_b","model/vnd.parasolid.transmit.binary"],["x_t","model/vnd.parasolid.transmit.text"],["xaml","application/xaml+xml"],["xap","application/x-silverlight-app"],["xar","application/vnd.xara"],["xav","application/xcap-att+xml"],["xbap","application/x-ms-xbap"],["xbd","application/vnd.fujixerox.docuworks.binder"],["xbm","image/x-xbitmap"],["xca","application/xcap-caps+xml"],["xcs","application/calendar+xml"],["xdf","application/xcap-diff+xml"],["xdm","application/vnd.syncml.dm+xml"],["xdp","application/vnd.adobe.xdp+xml"],["xdssc","application/dssc+xml"],["xdw","application/vnd.fujixerox.docuworks"],["xel","application/xcap-el+xml"],["xenc","application/xenc+xml"],["xer","application/patch-ops-error+xml"],["xfdf","application/vnd.adobe.xfdf"],["xfdl","application/vnd.xfdl"],["xht","application/xhtml+xml"],["xhtml","application/xhtml+xml"],["xhvml","application/xv+xml"],["xif","image/vnd.xiff"],["xl","application/excel"],["xla","application/vnd.ms-excel"],["xlam","application/vnd.ms-excel.addin.macroEnabled.12"],["xlc","application/vnd.ms-excel"],["xlf","application/xliff+xml"],["xlm","application/vnd.ms-excel"],["xls","application/vnd.ms-excel"],["xlsb","application/vnd.ms-excel.sheet.binary.macroEnabled.12"],["xlsm","application/vnd.ms-excel.sheet.macroEnabled.12"],["xlsx","application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],["xlt","application/vnd.ms-excel"],["xltm","application/vnd.ms-excel.template.macroEnabled.12"],["xltx","application/vnd.openxmlformats-officedocument.spreadsheetml.template"],["xlw","application/vnd.ms-excel"],["xm","audio/xm"],["xml","application/xml"],["xns","application/xcap-ns+xml"],["xo","application/vnd.olpc-sugar"],["xop","application/xop+xml"],["xpi","application/x-xpinstall"],["xpl","application/xproc+xml"],["xpm","image/x-xpixmap"],["xpr","application/vnd.is-xpr"],["xps","application/vnd.ms-xpsdocument"],["xpw","application/vnd.intercon.formnet"],["xpx","application/vnd.intercon.formnet"],["xsd","application/xml"],["xsl","application/xml"],["xslt","application/xslt+xml"],["xsm","application/vnd.syncml+xml"],["xspf","application/xspf+xml"],["xul","application/vnd.mozilla.xul+xml"],["xvm","application/xv+xml"],["xvml","application/xv+xml"],["xwd","image/x-xwindowdump"],["xyz","chemical/x-xyz"],["xz","application/x-xz"],["yaml","text/yaml"],["yang","application/yang"],["yin","application/yin+xml"],["yml","text/yaml"],["ymp","text/x-suse-ymp"],["z","application/x-compress"],["z1","application/x-zmachine"],["z2","application/x-zmachine"],["z3","application/x-zmachine"],["z4","application/x-zmachine"],["z5","application/x-zmachine"],["z6","application/x-zmachine"],["z7","application/x-zmachine"],["z8","application/x-zmachine"],["zaz","application/vnd.zzazz.deck+xml"],["zip","application/zip"],["zir","application/vnd.zul"],["zirz","application/vnd.zul"],["zmm","application/vnd.handheld-entertainment+xml"],["zsh","text/x-scriptzsh"]]);function Cg(e,t,n){const r=ope(e),{webkitRelativePath:s}=e,a=typeof t=="string"?t:typeof s=="string"&&s.length>0?s:`./${e.name}`;return typeof r.path!="string"&&pW(r,"path",a),pW(r,"relativePath",a),r}function ope(e){const{name:t}=e;if(t&&t.lastIndexOf(".")!==-1&&!e.type){const r=t.split(".").pop().toLowerCase(),s=ipe.get(r);s&&Object.defineProperty(e,"type",{value:s,writable:!1,configurable:!1,enumerable:!0})}return e}function pW(e,t,n){Object.defineProperty(e,t,{value:n,writable:!1,configurable:!1,enumerable:!0})}const lpe=[".DS_Store","Thumbs.db"];function upe(e){return Rh(this,void 0,void 0,function*(){return U2(e)&&cpe(e.dataTransfer)?fpe(e.dataTransfer,e.type):dpe(e)?ppe(e):Array.isArray(e)&&e.every(t=>"getFile"in t&&typeof t.getFile=="function")?hpe(e):[]})}function cpe(e){return U2(e)}function dpe(e){return U2(e)&&U2(e.target)}function U2(e){return typeof e=="object"&&e!==null}function ppe(e){return C_(e.target.files).map(t=>Cg(t))}function hpe(e){return Rh(this,void 0,void 0,function*(){return(yield Promise.all(e.map(n=>n.getFile()))).map(n=>Cg(n))})}function fpe(e,t){return Rh(this,void 0,void 0,function*(){if(e.items){const n=C_(e.items).filter(s=>s.kind==="file");if(t!=="drop")return n;const r=yield Promise.all(n.map(mpe));return hW(k5(r))}return hW(C_(e.files).map(n=>Cg(n)))})}function hW(e){return e.filter(t=>lpe.indexOf(t.name)===-1)}function C_(e){if(e===null)return[];const t=[];for(let n=0;n<e.length;n++){const r=e[n];t.push(r)}return t}function mpe(e){if(typeof e.webkitGetAsEntry!="function")return fW(e);const t=e.webkitGetAsEntry();return t&&t.isDirectory?I5(t):fW(e,t)}function k5(e){return e.reduce((t,n)=>[...t,...Array.isArray(n)?k5(n):[n]],[])}function fW(e,t){return Rh(this,void 0,void 0,function*(){var n;if(globalThis.isSecureContext&&typeof e.getAsFileSystemHandle=="function"){const a=yield e.getAsFileSystemHandle();if(a===null)throw new Error(`${e} is not a File`);if(a!==void 0){const i=yield a.getFile();return i.handle=a,Cg(i)}}const r=e.getAsFile();if(!r)throw new Error(`${e} is not a File`);return Cg(r,(n=t==null?void 0:t.fullPath)!==null&&n!==void 0?n:void 0)})}function gpe(e){return Rh(this,void 0,void 0,function*(){return e.isDirectory?I5(e):ype(e)})}function I5(e){const t=e.createReader();return new Promise((n,r)=>{const s=[];function a(){t.readEntries(i=>Rh(this,void 0,void 0,function*(){if(i.length){const o=Promise.all(i.map(gpe));s.push(o),a()}else try{const o=yield Promise.all(s);n(o)}catch(o){r(o)}}),i=>{r(i)})}a()})}function ype(e){return Rh(this,void 0,void 0,function*(){return new Promise((t,n)=>{e.file(r=>{const s=Cg(r,e.fullPath);t(s)},r=>{n(r)})})})}var Dk={},mW;function xpe(){return mW||(mW=1,Dk.__esModule=!0,Dk.default=function(e,t){if(e&&t){var n=Array.isArray(t)?t:t.split(",");if(n.length===0)return!0;var r=e.name||"",s=(e.type||"").toLowerCase(),a=s.replace(/\/.*$/,"");return n.some(function(i){var o=i.trim().toLowerCase();return o.charAt(0)==="."?r.toLowerCase().endsWith(o):o.endsWith("/*")?a===o.replace(/\/.*$/,""):s===o})}return!0}),Dk}var bpe=xpe();const fE=ty(bpe);function gW(e){return kpe(e)||wpe(e)||C5(e)||vpe()}function vpe(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function wpe(e){if(typeof Symbol<"u"&&e[Symbol.iterator]!=null||e["@@iterator"]!=null)return Array.from(e)}function kpe(e){if(Array.isArray(e))return N_(e)}function yW(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable})),n.push.apply(n,r)}return n}function xW(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?yW(Object(n),!0).forEach(function(r){S5(e,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):yW(Object(n)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))})}return e}function S5(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function hv(e,t){return Cpe(e)||Spe(e,t)||C5(e,t)||Ipe()}function Ipe(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function C5(e,t){if(e){if(typeof e=="string")return N_(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);if(n==="Object"&&e.constructor&&(n=e.constructor.name),n==="Map"||n==="Set")return Array.from(e);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return N_(e,t)}}function N_(e,t){(t==null||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function Spe(e,t){var n=e==null?null:typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(n!=null){var r=[],s=!0,a=!1,i,o;try{for(n=n.call(e);!(s=(i=n.next()).done)&&(r.push(i.value),!(t&&r.length===t));s=!0);}catch(l){a=!0,o=l}finally{try{!s&&n.return!=null&&n.return()}finally{if(a)throw o}}return r}}function Cpe(e){if(Array.isArray(e))return e}var Npe=typeof fE=="function"?fE:fE.default,Tpe="file-invalid-type",$pe="file-too-large",Epe="file-too-small",_pe="too-many-files",Ape=function(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"",n=t.split(","),r=n.length>1?"one of ".concat(n.join(", ")):n[0];return{code:Tpe,message:"File type must be ".concat(r)}},bW=function(t){return{code:$pe,message:"File is larger than ".concat(t," ").concat(t===1?"byte":"bytes")}},vW=function(t){return{code:Epe,message:"File is smaller than ".concat(t," ").concat(t===1?"byte":"bytes")}},Rpe={code:_pe,message:"Too many files"};function N5(e,t){var n=e.type==="application/x-moz-file"||Npe(e,t);return[n,n?null:Ape(t)]}function T5(e,t,n){if(Ip(e.size))if(Ip(t)&&Ip(n)){if(e.size>n)return[!1,bW(n)];if(e.size<t)return[!1,vW(t)]}else{if(Ip(t)&&e.size<t)return[!1,vW(t)];if(Ip(n)&&e.size>n)return[!1,bW(n)]}return[!0,null]}function Ip(e){return e!=null}function Dpe(e){var t=e.files,n=e.accept,r=e.minSize,s=e.maxSize,a=e.multiple,i=e.maxFiles,o=e.validator;return!a&&t.length>1||a&&i>=1&&t.length>i?!1:t.every(function(l){var u=N5(l,n),c=hv(u,1),d=c[0],p=T5(l,r,s),h=hv(p,1),m=h[0],g=o?o(l):null;return d&&m&&!g})}function G2(e){return typeof e.isPropagationStopped=="function"?e.isPropagationStopped():typeof e.cancelBubble<"u"?e.cancelBubble:!1}function Fk(e){return e.dataTransfer?Array.prototype.some.call(e.dataTransfer.types,function(t){return t==="Files"||t==="application/x-moz-file"}):!!e.target&&!!e.target.files}function wW(e){e.preventDefault()}function Fpe(e){return e.indexOf("MSIE")!==-1||e.indexOf("Trident/")!==-1}function Ope(e){return e.indexOf("Edge/")!==-1}function Mpe(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:window.navigator.userAgent;return Fpe(e)||Ope(e)}function Sl(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(r){for(var s=arguments.length,a=new Array(s>1?s-1:0),i=1;i<s;i++)a[i-1]=arguments[i];return t.some(function(o){return!G2(r)&&o&&o.apply(void 0,[r].concat(a)),G2(r)})}}function Lpe(){return"showOpenFilePicker"in window}function Ppe(e){if(Ip(e)){var t=Object.entries(e).filter(function(n){var r=hv(n,2),s=r[0],a=r[1],i=!0;return $5(s)||(console.warn('Skipped "'.concat(s,'" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.')),i=!1),(!Array.isArray(a)||!a.every(E5))&&(console.warn('Skipped "'.concat(s,'" because an invalid file extension was provided.')),i=!1),i}).reduce(function(n,r){var s=hv(r,2),a=s[0],i=s[1];return xW(xW({},n),{},S5({},a,i))},{});return[{description:"Files",accept:t}]}return e}function zpe(e){if(Ip(e))return Object.entries(e).reduce(function(t,n){var r=hv(n,2),s=r[0],a=r[1];return[].concat(gW(t),[s],gW(a))},[]).filter(function(t){return $5(t)||E5(t)}).join(",")}function Bpe(e){return e instanceof DOMException&&(e.name==="AbortError"||e.code===e.ABORT_ERR)}function Wpe(e){return e instanceof DOMException&&(e.name==="SecurityError"||e.code===e.SECURITY_ERR)}function $5(e){return e==="audio/*"||e==="video/*"||e==="image/*"||e==="text/*"||e==="application/*"||/\w+\/[-+.\w]+/g.test(e)}function E5(e){return/^.*\.[\w]+$/.test(e)}var Vpe=["children"],Upe=["open"],Gpe=["refKey","role","onKeyDown","onFocus","onBlur","onClick","onDragEnter","onDragOver","onDragLeave","onDrop"],jpe=["refKey","onChange","onClick"];function Hpe(e){return Xpe(e)||Kpe(e)||_5(e)||qpe()}function qpe(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function Kpe(e){if(typeof Symbol<"u"&&e[Symbol.iterator]!=null||e["@@iterator"]!=null)return Array.from(e)}function Xpe(e){if(Array.isArray(e))return T_(e)}function mE(e,t){return Jpe(e)||Zpe(e,t)||_5(e,t)||Ype()}function Ype(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _5(e,t){if(e){if(typeof e=="string")return T_(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);if(n==="Object"&&e.constructor&&(n=e.constructor.name),n==="Map"||n==="Set")return Array.from(e);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return T_(e,t)}}function T_(e,t){(t==null||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function Zpe(e,t){var n=e==null?null:typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(n!=null){var r=[],s=!0,a=!1,i,o;try{for(n=n.call(e);!(s=(i=n.next()).done)&&(r.push(i.value),!(t&&r.length===t));s=!0);}catch(l){a=!0,o=l}finally{try{!s&&n.return!=null&&n.return()}finally{if(a)throw o}}return r}}function Jpe(e){if(Array.isArray(e))return e}function kW(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable})),n.push.apply(n,r)}return n}function Dr(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?kW(Object(n),!0).forEach(function(r){$_(e,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):kW(Object(n)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))})}return e}function $_(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function j2(e,t){if(e==null)return{};var n=Qpe(e,t),r,s;if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)r=a[s],!(t.indexOf(r)>=0)&&Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}function Qpe(e,t){if(e==null)return{};var n={},r=Object.keys(e),s,a;for(a=0;a<r.length;a++)s=r[a],!(t.indexOf(s)>=0)&&(n[s]=e[s]);return n}var VR=ee.forwardRef(function(e,t){var n=e.children,r=j2(e,Vpe),s=R5(r),a=s.open,i=j2(s,Upe);return ee.useImperativeHandle(t,function(){return{open:a}},[a]),Lt.createElement(ee.Fragment,null,n(Dr(Dr({},i),{},{open:a})))});VR.displayName="Dropzone";var A5={disabled:!1,getFilesFromEvent:upe,maxSize:1/0,minSize:0,multiple:!0,maxFiles:0,preventDropOnDocument:!0,noClick:!1,noKeyboard:!1,noDrag:!1,noDragEventsBubbling:!1,validator:null,useFsAccessApi:!1,autoFocus:!1};VR.defaultProps=A5;VR.propTypes={children:Mn.func,accept:Mn.objectOf(Mn.arrayOf(Mn.string)),multiple:Mn.bool,preventDropOnDocument:Mn.bool,noClick:Mn.bool,noKeyboard:Mn.bool,noDrag:Mn.bool,noDragEventsBubbling:Mn.bool,minSize:Mn.number,maxSize:Mn.number,maxFiles:Mn.number,disabled:Mn.bool,getFilesFromEvent:Mn.func,onFileDialogCancel:Mn.func,onFileDialogOpen:Mn.func,useFsAccessApi:Mn.bool,autoFocus:Mn.bool,onDragEnter:Mn.func,onDragLeave:Mn.func,onDragOver:Mn.func,onDrop:Mn.func,onDropAccepted:Mn.func,onDropRejected:Mn.func,onError:Mn.func,validator:Mn.func};var E_={isFocused:!1,isFileDialogActive:!1,isDragActive:!1,isDragAccept:!1,isDragReject:!1,acceptedFiles:[],fileRejections:[]};function R5(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},t=Dr(Dr({},A5),e),n=t.accept,r=t.disabled,s=t.getFilesFromEvent,a=t.maxSize,i=t.minSize,o=t.multiple,l=t.maxFiles,u=t.onDragEnter,c=t.onDragLeave,d=t.onDragOver,p=t.onDrop,h=t.onDropAccepted,m=t.onDropRejected,g=t.onFileDialogCancel,y=t.onFileDialogOpen,b=t.useFsAccessApi,v=t.autoFocus,k=t.preventDropOnDocument,I=t.noClick,S=t.noKeyboard,N=t.noDrag,T=t.noDragEventsBubbling,A=t.onError,R=t.validator,D=ee.useMemo(function(){return zpe(n)},[n]),$=ee.useMemo(function(){return Ppe(n)},[n]),_=ee.useMemo(function(){return typeof y=="function"?y:IW},[y]),L=ee.useMemo(function(){return typeof g=="function"?g:IW},[g]),z=ee.useRef(null),W=ee.useRef(null),G=ee.useReducer(ehe,E_),q=mE(G,2),B=q[0],j=q[1],H=B.isFocused,P=B.isFileDialogActive,X=ee.useRef(typeof window<"u"&&window.isSecureContext&&b&&Lpe()),Q=function(){!X.current&&P&&setTimeout(function(){if(W.current){var tt=W.current.files;tt.length||(j({type:"closeDialog"}),L())}},300)};ee.useEffect(function(){return window.addEventListener("focus",Q,!1),function(){window.removeEventListener("focus",Q,!1)}},[W,P,L,X]);var re=ee.useRef([]),le=function(tt){z.current&&z.current.contains(tt.target)||(tt.preventDefault(),re.current=[])};ee.useEffect(function(){return k&&(document.addEventListener("dragover",wW,!1),document.addEventListener("drop",le,!1)),function(){k&&(document.removeEventListener("dragover",wW),document.removeEventListener("drop",le))}},[z,k]),ee.useEffect(function(){return!r&&v&&z.current&&z.current.focus(),function(){}},[z,v,r]);var ke=ee.useCallback(function(Ve){A?A(Ve):console.error(Ve)},[A]),Ne=ee.useCallback(function(Ve){Ve.preventDefault(),Ve.persist(),Et(Ve),re.current=[].concat(Hpe(re.current),[Ve.target]),Fk(Ve)&&Promise.resolve(s(Ve)).then(function(tt){if(!(G2(Ve)&&!T)){var Rt=tt.length,Dt=Rt>0&&Dpe({files:tt,accept:D,minSize:i,maxSize:a,multiple:o,maxFiles:l,validator:R}),Ut=Rt>0&&!Dt;j({isDragAccept:Dt,isDragReject:Ut,isDragActive:!0,type:"setDraggedFiles"}),u&&u(Ve)}}).catch(function(tt){return ke(tt)})},[s,u,ke,T,D,i,a,o,l,R]),we=ee.useCallback(function(Ve){Ve.preventDefault(),Ve.persist(),Et(Ve);var tt=Fk(Ve);if(tt&&Ve.dataTransfer)try{Ve.dataTransfer.dropEffect="copy"}catch{}return tt&&d&&d(Ve),!1},[d,T]),_e=ee.useCallback(function(Ve){Ve.preventDefault(),Ve.persist(),Et(Ve);var tt=re.current.filter(function(Dt){return z.current&&z.current.contains(Dt)}),Rt=tt.indexOf(Ve.target);Rt!==-1&&tt.splice(Rt,1),re.current=tt,!(tt.length>0)&&(j({type:"setDraggedFiles",isDragActive:!1,isDragAccept:!1,isDragReject:!1}),Fk(Ve)&&c&&c(Ve))},[z,c,T]),Le=ee.useCallback(function(Ve,tt){var Rt=[],Dt=[];Ve.forEach(function(Ut){var Pn=N5(Ut,D),dr=mE(Pn,2),zn=dr[0],Gr=dr[1],Sn=T5(Ut,i,a),pn=mE(Sn,2),Fn=pn[0],Ls=pn[1],vs=R?R(Ut):null;if(zn&&Fn&&!vs)Rt.push(Ut);else{var Ps=[Gr,Ls];vs&&(Ps=Ps.concat(vs)),Dt.push({file:Ut,errors:Ps.filter(function(Qs){return Qs})})}}),(!o&&Rt.length>1||o&&l>=1&&Rt.length>l)&&(Rt.forEach(function(Ut){Dt.push({file:Ut,errors:[Rpe]})}),Rt.splice(0)),j({acceptedFiles:Rt,fileRejections:Dt,isDragReject:Dt.length>0,type:"setFiles"}),p&&p(Rt,Dt,tt),Dt.length>0&&m&&m(Dt,tt),Rt.length>0&&h&&h(Rt,tt)},[j,o,D,i,a,l,p,h,m,R]),Be=ee.useCallback(function(Ve){Ve.preventDefault(),Ve.persist(),Et(Ve),re.current=[],Fk(Ve)&&Promise.resolve(s(Ve)).then(function(tt){G2(Ve)&&!T||Le(tt,Ve)}).catch(function(tt){return ke(tt)}),j({type:"reset"})},[s,Le,ke,T]),Ze=ee.useCallback(function(){if(X.current){j({type:"openDialog"}),_();var Ve={multiple:o,types:$};window.showOpenFilePicker(Ve).then(function(tt){return s(tt)}).then(function(tt){Le(tt,null),j({type:"closeDialog"})}).catch(function(tt){Bpe(tt)?(L(tt),j({type:"closeDialog"})):Wpe(tt)?(X.current=!1,W.current?(W.current.value=null,W.current.click()):ke(new Error("Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."))):ke(tt)});return}W.current&&(j({type:"openDialog"}),_(),W.current.value=null,W.current.click())},[j,_,L,b,Le,ke,$,o]),ut=ee.useCallback(function(Ve){!z.current||!z.current.isEqualNode(Ve.target)||(Ve.key===" "||Ve.key==="Enter"||Ve.keyCode===32||Ve.keyCode===13)&&(Ve.preventDefault(),Ze())},[z,Ze]),ft=ee.useCallback(function(){j({type:"focus"})},[]),et=ee.useCallback(function(){j({type:"blur"})},[]),Qe=ee.useCallback(function(){I||(Mpe()?setTimeout(Ze,0):Ze())},[I,Ze]),ot=function(tt){return r?null:tt},gt=function(tt){return S?null:ot(tt)},At=function(tt){return N?null:ot(tt)},Et=function(tt){T&&tt.stopPropagation()},dn=ee.useMemo(function(){return function(){var Ve=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},tt=Ve.refKey,Rt=tt===void 0?"ref":tt,Dt=Ve.role,Ut=Ve.onKeyDown,Pn=Ve.onFocus,dr=Ve.onBlur,zn=Ve.onClick,Gr=Ve.onDragEnter,Sn=Ve.onDragOver,pn=Ve.onDragLeave,Fn=Ve.onDrop,Ls=j2(Ve,Gpe);return Dr(Dr($_({onKeyDown:gt(Sl(Ut,ut)),onFocus:gt(Sl(Pn,ft)),onBlur:gt(Sl(dr,et)),onClick:ot(Sl(zn,Qe)),onDragEnter:At(Sl(Gr,Ne)),onDragOver:At(Sl(Sn,we)),onDragLeave:At(Sl(pn,_e)),onDrop:At(Sl(Fn,Be)),role:typeof Dt=="string"&&Dt!==""?Dt:"presentation"},Rt,z),!r&&!S?{tabIndex:0}:{}),Ls)}},[z,ut,ft,et,Qe,Ne,we,_e,Be,S,N,r]),Xt=ee.useCallback(function(Ve){Ve.stopPropagation()},[]),In=ee.useMemo(function(){return function(){var Ve=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},tt=Ve.refKey,Rt=tt===void 0?"ref":tt,Dt=Ve.onChange,Ut=Ve.onClick,Pn=j2(Ve,jpe),dr=$_({accept:D,multiple:o,type:"file",style:{border:0,clip:"rect(0, 0, 0, 0)",clipPath:"inset(50%)",height:"1px",margin:"0 -1px -1px 0",overflow:"hidden",padding:0,position:"absolute",width:"1px",whiteSpace:"nowrap"},onChange:ot(Sl(Dt,Be)),onClick:ot(Sl(Ut,Xt)),tabIndex:-1},Rt,W);return Dr(Dr({},dr),Pn)}},[W,n,o,Be,r]);return Dr(Dr({},B),{},{isFocused:H&&!r,getRootProps:dn,getInputProps:In,rootRef:z,inputRef:W,open:ot(Ze)})}function ehe(e,t){switch(t.type){case"focus":return Dr(Dr({},e),{},{isFocused:!0});case"blur":return Dr(Dr({},e),{},{isFocused:!1});case"openDialog":return Dr(Dr({},E_),{},{isFileDialogActive:!0});case"closeDialog":return Dr(Dr({},e),{},{isFileDialogActive:!1});case"setDraggedFiles":return Dr(Dr({},e),{},{isDragActive:t.isDragActive,isDragAccept:t.isDragAccept,isDragReject:t.isDragReject});case"setFiles":return Dr(Dr({},e),{},{acceptedFiles:t.acceptedFiles,fileRejections:t.fileRejections,isDragReject:t.isDragReject});case"reset":return Dr({},E_);default:return e}}function IW(){}const the=({stage:e,progress:t})=>J.jsxs("div",{className:"loading-overlay",children:[J.jsx(CG,{className:"spinner"}),J.jsx("div",{className:"loading-text",children:e}),J.jsx("div",{className:"progress-bar",children:J.jsx("div",{className:"progress-fill",style:{width:`${t}%`}})})]});Mn.string.isRequired,Mn.number,Mn.string,Mn.bool;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nhe=1e-7,rhe=1e-4;class D5{constructor(t,n){this.backend=t,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,n){this.dataIdsCount++,this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class UR{refCount(t){return ci("refCount")}incRef(t){return ci("incRef")}timerAvailable(){return!0}time(t){return ci("time")}read(t){return ci("read")}readSync(t){return ci("readSync")}readToGPU(t,n){return ci("readToGPU")}numDataIds(){return ci("numDataIds")}disposeData(t,n){return ci("disposeData")}write(t,n,r){return ci("write")}move(t,n,r,s,a){return ci("move")}createTensorFromGPUData(t,n,r){return ci("createTensorFromGPUData")}memory(){return ci("memory")}floatPrecision(){return ci("floatPrecision")}epsilon(){return this.floatPrecision()===32?nhe:rhe}dispose(){return ci("dispose")}}function ci(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function she(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,sg(e,t,n)}function Jp(e,t,n){return Math.max(e,Math.min(t,n))}function GR(e){return e%2===0?e:e+1}function sg(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function ahe(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function Y(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function jR(e,t,n=""){Y(Dn(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function HR(e){Y(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Oe(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Dn(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Ng(e){return e%1===0}function __(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function hg(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function SW(e,t=s=>0,n,r){return new Promise((s,a)=>{let i=0;const o=()=>{if(e()){s();return}i++;const l=t(i);if(n!=null&&i>=n){a();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function F5(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(e[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function un(e,t){const n=t.length;return e=e==null?t.map((r,s)=>s):[].concat(e),Y(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),Y(e.every(r=>Ng(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function vd(e,t){const n=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||s?null:un(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(a!=null){if(a[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(a[i]==null||a[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function sa(e,t){return Mr(e,t)}function Mr(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function ihe(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function ohe(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function O5(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function H2(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function lhe(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function t0(e){return typeof e=="string"||e instanceof String}function uhe(e){return typeof e=="boolean"}function A_(e){return typeof e=="number"}function ly(e){return Array.isArray(e)?ly(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":A_(e)?"float32":t0(e)?"string":uhe(e)?"bool":"float32"}function R_(e){return!!(e&&e.constructor&&e.call&&e.apply)}function D_(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function _t(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function M5(e,t,n,r=!1){const s=new Array;if(t.length===1){const a=t[0]*(r?2:1);for(let i=0;i<a;i++)s[i]=n[e+i]}else{const a=t[0],i=t.slice(1),o=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<a;l++)s[l]=M5(e+l*o,i,n,r)}return s}function Xo(e,t,n=!1){if(e.length===0)return t[0];const r=e.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return M5(0,e,t,n)}function che(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function qR(e,t){const n=aa(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function aa(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function L5(e,t){const n=e.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return Xo(e,new Float32Array(n));if(t==="int32")return Xo(e,new Int32Array(n));if(t==="bool")return Xo(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function ju(e){e.forEach(t=>{Y(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function Vl(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function uy(e,t,n){if(t===0)return[];if(t===1)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function KR(e){return e&&e.then&&typeof e.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CW="tfjsflags";class dhe{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=phe,this.populateURLFlags()}setPlatform(t,n){this.platform!=null&&($e().getBool("IS_TEST")||$e().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,r){if(this.flagRegistry[t]={evaluationFn:n,setHook:r},this.urlFlags[t]!=null){const s=this.urlFlags[t];$e().getBool("IS_TEST")||$e().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if(KR(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);CW in t&&t[CW].split(",").forEach(r=>{const[s,a]=r.split(":");this.urlFlags[s]=fhe(s,a)})}}function phe(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(hhe(t,r[0],r[1]),r.join("="))),t}function hhe(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function fhe(e,t){const n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function $e(){return P5}let P5=null;function mhe(e){P5=e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gE;function z5(){if(gE==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");gE=e}return gE}function ghe(){const e=z5();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function XR(e,t){const n=ghe();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const fS="Abs",n0="Acos",r0="Acosh",cy="Add",YR="AddN",ZR="All",JR="Any",mS="ArgMax",gS="ArgMin",s0="Asin",a0="Asinh",i0="Atan",o0="Atanh",l0="Atan2",yS="AvgPool",QR="AvgPoolGrad",xS="AvgPool3D",eD="AvgPool3DGrad",bS="BatchMatMul",vS="BatchToSpaceND",tD="Bincount",nD="BitwiseAnd",yhe="BroadcastTo",B5="BroadcastArgs",u0="Cast",c0="Ceil",d0="ClipByValue",rD="Complex",wS="ComplexAbs",kS="Concat",IS="Conv2D",sD="Conv2DBackpropFilter",SS="Conv2DBackpropInput",CS="Conv3D",aD="Conv3DBackpropFilterV2",iD="Conv3DBackpropInputV2",p0="Cos",h0="Cosh",oD="Cumprod",NS="Cumsum",lD="CropAndResize",uD="DenseBincount",cD="DepthToSpace",TS="DepthwiseConv2dNative",dD="DepthwiseConv2dNativeBackpropFilter",pD="DepthwiseConv2dNativeBackpropInput",W5="Diag",$S="Dilation2D",F_="Dilation2DBackpropInput",O_="Dilation2DBackpropFilter",xhe="Draw",f0="RealDiv",hD="Einsum",m0="Elu",fD="EluGrad",g0="Erf",ES="Equal",y0="Exp",_S="ExpandDims",x0="Expm1",mD="FFT",gD="Fill",yD="FlipLeftRight",b0="Floor",v0="FloorDiv",AS="FusedBatchNorm",RS="GatherV2",V5="GatherNd",DS="Greater",w0="GreaterEqual",k0="Identity",xD="IFFT",bD="Imag",I0="IsFinite",S0="IsInf",C0="IsNan",FS="LeakyRelu",OS="Less",MS="LessEqual",U5="LinSpace",N0="Log",T0="Log1p",LS="LogicalAnd",PS="LogicalNot",zS="LogicalOr",bhe="LogSoftmax",BS="LRN",vD="LRNGrad",WS="Max",$0="Maximum",VS="MaxPool",wD="MaxPoolGrad",US="MaxPool3D",kD="MaxPool3DGrad",G5="MaxPoolWithArgmax",GS="Mean",jS="Min",E0="Minimum",HS="MirrorPad",_0="Mod",j5="Multinomial",A0="Multiply",qS="Neg",KS="NotEqual",ID="NonMaxSuppressionV3",SD="NonMaxSuppressionV4",CD="NonMaxSuppressionV5",XS="OnesLike",YS="OneHot",ZS="Pack",JS="PadV2",R0="Pow",QS="Prelu",eC="Prod",H5="RaggedGather",q5="RaggedRange",K5="RaggedTensorToTensor",ND="Range",TD="Real",D0="Reciprocal",F0="Relu",tC="Reshape",nC="ResizeNearestNeighbor",$D="ResizeNearestNeighborGrad",rC="ResizeBilinear",ED="ResizeBilinearGrad",O0="Relu6",sC="Reverse",M0="Round",L0="Rsqrt",X5="ScatterNd",Y5="TensorScatterUpdate",Z5="SearchSorted",aC="Select",P0="Selu",iC="Slice",z0="Sin",B0="Sinh",W0="Sign",V0="Sigmoid",U0="Softplus",G0="Sqrt",oC="Sum",lC="SpaceToBatchND",uC="SplitV",cC="Softmax",J5="SparseFillEmptyRows",Q5="SparseReshape",ej="SparseSegmentMean",tj="SparseSegmentSum",nj="SparseToDense",j0="SquaredDifference",_D="Square",AD="StaticRegexReplace",RD="StridedSlice",rj="StringNGrams",sj="StringSplit",aj="StringToHashBucketFast",H0="Sub",q0="Tan",K0="Tanh",X0="Tile",DD="TopK",FD="Transform",fg="Transpose",OD="Unique",dC="Unpack",pC="UnsortedSegmentSum",hC="ZerosLike",Y0="Step",M_="FromPixels",MD="RotateWithOffset",q2="_FusedMatMul",K2="FusedConv2D",ij="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pi(...e){$e().getBool("IS_TEST")||$e().getBool("PROD")||console.warn(...e)}function vhe(...e){$e().getBool("IS_TEST")||$e().getBool("PROD")||console.log(...e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X2=XR("kernelRegistry",()=>new Map),L_=XR("gradRegistry",()=>new Map);function P_(e,t){const n=lj(e,t);return X2.get(n)}function NW(e){return L_.get(e)}function TW(e){const t=X2.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function oj(e){const{kernelName:t,backendName:n}=e,r=lj(t,n);X2.has(r)&&Pi(`The kernel '${t}' for backend '${n}' is already registered`),X2.set(r,e)}function whe(e){const{kernelName:t}=e;L_.has(t)&&$e().getBool("DEBUG")&&Pi(`Overriding the gradient for '${t}'`),L_.set(t,e)}function lj(e,t){return`${t}_${e}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uj(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var yE,$W;function khe(){if($W)return yE;$W=1,yE=t;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(D,$,_){this.low=D|0,this.high=$|0,this.unsigned=!!_}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function n(D){return(D&&D.__isLong__)===!0}t.isLong=n;var r={},s={};function a(D,$){var _,L,z;return $?(D>>>=0,(z=0<=D&&D<256)&&(L=s[D],L)?L:(_=o(D,(D|0)<0?-1:0,!0),z&&(s[D]=_),_)):(D|=0,(z=-128<=D&&D<128)&&(L=r[D],L)?L:(_=o(D,D<0?-1:0,!1),z&&(r[D]=_),_))}t.fromInt=a;function i(D,$){if(isNaN(D))return $?v:b;if($){if(D<0)return v;if(D>=m)return T}else{if(D<=-9223372036854776e3)return A;if(D+1>=g)return N}return D<0?i(-D,$).neg():o(D%h|0,D/h|0,$)}t.fromNumber=i;function o(D,$,_){return new t(D,$,_)}t.fromBits=o;var l=Math.pow;function u(D,$,_){if(D.length===0)throw Error("empty string");if(D==="NaN"||D==="Infinity"||D==="+Infinity"||D==="-Infinity")return b;if(typeof $=="number"?(_=$,$=!1):$=!!$,_=_||10,_<2||36<_)throw RangeError("radix");var L;if((L=D.indexOf("-"))>0)throw Error("interior hyphen");if(L===0)return u(D.substring(1),$,_).neg();for(var z=i(l(_,8)),W=b,G=0;G<D.length;G+=8){var q=Math.min(8,D.length-G),B=parseInt(D.substring(G,G+q),_);if(q<8){var j=i(l(_,q));W=W.mul(j).add(i(B))}else W=W.mul(z),W=W.add(i(B))}return W.unsigned=$,W}t.fromString=u;function c(D,$){return typeof D=="number"?i(D,$):typeof D=="string"?u(D,$):o(D.low,D.high,typeof $=="boolean"?$:D.unsigned)}t.fromValue=c;var d=65536,p=1<<24,h=d*d,m=h*h,g=m/2,y=a(p),b=a(0);t.ZERO=b;var v=a(0,!0);t.UZERO=v;var k=a(1);t.ONE=k;var I=a(1,!0);t.UONE=I;var S=a(-1);t.NEG_ONE=S;var N=o(-1,2147483647,!1);t.MAX_VALUE=N;var T=o(-1,-1,!0);t.MAX_UNSIGNED_VALUE=T;var A=o(0,-2147483648,!1);t.MIN_VALUE=A;var R=t.prototype;return R.toInt=function(){return this.unsigned?this.low>>>0:this.low},R.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},R.toString=function($){if($=$||10,$<2||36<$)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(A)){var _=i($),L=this.div(_),z=L.mul(_).sub(this);return L.toString($)+z.toInt().toString($)}else return"-"+this.neg().toString($);for(var W=i(l($,6),this.unsigned),G=this,q="";;){var B=G.div(W),j=G.sub(B.mul(W)).toInt()>>>0,H=j.toString($);if(G=B,G.isZero())return H+q;for(;H.length<6;)H="0"+H;q=""+H+q}},R.getHighBits=function(){return this.high},R.getHighBitsUnsigned=function(){return this.high>>>0},R.getLowBits=function(){return this.low},R.getLowBitsUnsigned=function(){return this.low>>>0},R.getNumBitsAbs=function(){if(this.isNegative())return this.eq(A)?64:this.neg().getNumBitsAbs();for(var $=this.high!=0?this.high:this.low,_=31;_>0&&($&1<<_)==0;_--);return this.high!=0?_+33:_+1},R.isZero=function(){return this.high===0&&this.low===0},R.eqz=R.isZero,R.isNegative=function(){return!this.unsigned&&this.high<0},R.isPositive=function(){return this.unsigned||this.high>=0},R.isOdd=function(){return(this.low&1)===1},R.isEven=function(){return(this.low&1)===0},R.equals=function($){return n($)||($=c($)),this.unsigned!==$.unsigned&&this.high>>>31===1&&$.high>>>31===1?!1:this.high===$.high&&this.low===$.low},R.eq=R.equals,R.notEquals=function($){return!this.eq($)},R.neq=R.notEquals,R.ne=R.notEquals,R.lessThan=function($){return this.comp($)<0},R.lt=R.lessThan,R.lessThanOrEqual=function($){return this.comp($)<=0},R.lte=R.lessThanOrEqual,R.le=R.lessThanOrEqual,R.greaterThan=function($){return this.comp($)>0},R.gt=R.greaterThan,R.greaterThanOrEqual=function($){return this.comp($)>=0},R.gte=R.greaterThanOrEqual,R.ge=R.greaterThanOrEqual,R.compare=function($){if(n($)||($=c($)),this.eq($))return 0;var _=this.isNegative(),L=$.isNegative();return _&&!L?-1:!_&&L?1:this.unsigned?$.high>>>0>this.high>>>0||$.high===this.high&&$.low>>>0>this.low>>>0?-1:1:this.sub($).isNegative()?-1:1},R.comp=R.compare,R.negate=function(){return!this.unsigned&&this.eq(A)?A:this.not().add(k)},R.neg=R.negate,R.add=function($){n($)||($=c($));var _=this.high>>>16,L=this.high&65535,z=this.low>>>16,W=this.low&65535,G=$.high>>>16,q=$.high&65535,B=$.low>>>16,j=$.low&65535,H=0,P=0,X=0,Q=0;return Q+=W+j,X+=Q>>>16,Q&=65535,X+=z+B,P+=X>>>16,X&=65535,P+=L+q,H+=P>>>16,P&=65535,H+=_+G,H&=65535,o(X<<16|Q,H<<16|P,this.unsigned)},R.subtract=function($){return n($)||($=c($)),this.add($.neg())},R.sub=R.subtract,R.multiply=function($){if(this.isZero())return b;if(n($)||($=c($)),e){var _=e.mul(this.low,this.high,$.low,$.high);return o(_,e.get_high(),this.unsigned)}if($.isZero())return b;if(this.eq(A))return $.isOdd()?A:b;if($.eq(A))return this.isOdd()?A:b;if(this.isNegative())return $.isNegative()?this.neg().mul($.neg()):this.neg().mul($).neg();if($.isNegative())return this.mul($.neg()).neg();if(this.lt(y)&&$.lt(y))return i(this.toNumber()*$.toNumber(),this.unsigned);var L=this.high>>>16,z=this.high&65535,W=this.low>>>16,G=this.low&65535,q=$.high>>>16,B=$.high&65535,j=$.low>>>16,H=$.low&65535,P=0,X=0,Q=0,re=0;return re+=G*H,Q+=re>>>16,re&=65535,Q+=W*H,X+=Q>>>16,Q&=65535,Q+=G*j,X+=Q>>>16,Q&=65535,X+=z*H,P+=X>>>16,X&=65535,X+=W*j,P+=X>>>16,X&=65535,X+=G*B,P+=X>>>16,X&=65535,P+=L*H+z*j+W*B+G*q,P&=65535,o(Q<<16|re,P<<16|X,this.unsigned)},R.mul=R.multiply,R.divide=function($){if(n($)||($=c($)),$.isZero())throw Error("division by zero");if(e){if(!this.unsigned&&this.high===-2147483648&&$.low===-1&&$.high===-1)return this;var _=(this.unsigned?e.div_u:e.div_s)(this.low,this.high,$.low,$.high);return o(_,e.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?v:b;var L,z,W;if(this.unsigned){if($.unsigned||($=$.toUnsigned()),$.gt(this))return v;if($.gt(this.shru(1)))return I;W=v}else{if(this.eq(A)){if($.eq(k)||$.eq(S))return A;if($.eq(A))return k;var G=this.shr(1);return L=G.div($).shl(1),L.eq(b)?$.isNegative()?k:S:(z=this.sub($.mul(L)),W=L.add(z.div($)),W)}else if($.eq(A))return this.unsigned?v:b;if(this.isNegative())return $.isNegative()?this.neg().div($.neg()):this.neg().div($).neg();if($.isNegative())return this.div($.neg()).neg();W=b}for(z=this;z.gte($);){L=Math.max(1,Math.floor(z.toNumber()/$.toNumber()));for(var q=Math.ceil(Math.log(L)/Math.LN2),B=q<=48?1:l(2,q-48),j=i(L),H=j.mul($);H.isNegative()||H.gt(z);)L-=B,j=i(L,this.unsigned),H=j.mul($);j.isZero()&&(j=k),W=W.add(j),z=z.sub(H)}return W},R.div=R.divide,R.modulo=function($){if(n($)||($=c($)),e){var _=(this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,$.low,$.high);return o(_,e.get_high(),this.unsigned)}return this.sub(this.div($).mul($))},R.mod=R.modulo,R.rem=R.modulo,R.not=function(){return o(~this.low,~this.high,this.unsigned)},R.and=function($){return n($)||($=c($)),o(this.low&$.low,this.high&$.high,this.unsigned)},R.or=function($){return n($)||($=c($)),o(this.low|$.low,this.high|$.high,this.unsigned)},R.xor=function($){return n($)||($=c($)),o(this.low^$.low,this.high^$.high,this.unsigned)},R.shiftLeft=function($){return n($)&&($=$.toInt()),($&=63)===0?this:$<32?o(this.low<<$,this.high<<$|this.low>>>32-$,this.unsigned):o(0,this.low<<$-32,this.unsigned)},R.shl=R.shiftLeft,R.shiftRight=function($){return n($)&&($=$.toInt()),($&=63)===0?this:$<32?o(this.low>>>$|this.high<<32-$,this.high>>$,this.unsigned):o(this.high>>$-32,this.high>=0?0:-1,this.unsigned)},R.shr=R.shiftRight,R.shiftRightUnsigned=function($){if(n($)&&($=$.toInt()),$&=63,$===0)return this;var _=this.high;if($<32){var L=this.low;return o(L>>>$|_<<32-$,_>>>$,this.unsigned)}else return $===32?o(_,0,this.unsigned):o(_>>>$-32,0,this.unsigned)},R.shru=R.shiftRightUnsigned,R.shr_u=R.shiftRightUnsigned,R.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},R.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},R.toBytes=function($){return $?this.toBytesLE():this.toBytesBE()},R.toBytesLE=function(){var $=this.high,_=this.low;return[_&255,_>>>8&255,_>>>16&255,_>>>24,$&255,$>>>8&255,$>>>16&255,$>>>24]},R.toBytesBE=function(){var $=this.high,_=this.low;return[$>>>24,$>>>16&255,$>>>8&255,$&255,_>>>24,_>>>16&255,_>>>8&255,_&255]},t.fromBytes=function($,_,L){return L?t.fromBytesLE($,_):t.fromBytesBE($,_)},t.fromBytesLE=function($,_){return new t($[0]|$[1]<<8|$[2]<<16|$[3]<<24,$[4]|$[5]<<8|$[6]<<16|$[7]<<24,_)},t.fromBytesBE=function($,_){return new t($[4]<<24|$[5]<<16|$[6]<<8|$[7],$[0]<<24|$[1]<<16|$[2]<<8|$[3],_)},yE}var cj=khe();const dj=ty(cj),Ihe=Yae({__proto__:null,default:dj},[cj]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sp=dj||Ihe;function fC(e){return Sp.fromString(e,!0,16)}const pj=fC("c3a5c85c97cb3127"),bp=fC("b492b66fbe98f273"),wa=fC("9ae16a3b2f90404f");function z_(e){return e.xor(e.shru(47))}function hj(e,t,n){const r=e.slice(t,t+n);return Sp.fromBytes(Array.from(r),!0,!0)}function sr(e,t){return hj(e,t,8)}function EW(e,t){return hj(e,t,4)}function Cs(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Vc(e,t,n=fC("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function She(e,t,n,r,s,a){s=s.add(e),a=Cs(a.add(s).add(r),21);const i=s;return s=s.add(t),s=s.add(n),a=a.add(Cs(s,44)),[s.add(r),a.add(i)]}function Ok(e,t,n,r){return She(sr(e,t),sr(e,t+8),sr(e,t+16),sr(e,t+24),n,r)}function Che(e,t=e.length){if(t>=8){const n=wa.add(t*2),r=sr(e,0).add(wa),s=sr(e,t-8),a=Cs(s,37).mul(n).add(r),i=Cs(r,25).add(s).mul(n);return Vc(a,i,n)}if(t>=4){const n=wa.add(t*2),r=EW(e,0);return Vc(r.shl(3).add(t),EW(e,t-4),n)}if(t>0){const n=e[0],r=e[t>>1],s=e[t-1],a=n+(r<<8),i=t+(s<<2);return z_(wa.mul(a).xor(pj.mul(i))).mul(wa)}return wa}function Nhe(e,t=e.length){const n=wa.add(t*2),r=sr(e,0).mul(bp),s=sr(e,8),a=sr(e,t-8).mul(n),i=sr(e,t-16).mul(wa);return Vc(Cs(r.add(s),43).add(Cs(a,30)).add(i),r.add(Cs(s.add(wa),18)).add(a),n)}function The(e,t=e.length){const n=wa.add(t*2),r=sr(e,0).mul(wa),s=sr(e,8),a=sr(e,t-8).mul(n),i=sr(e,t-16).mul(wa),o=Cs(r.add(s),43).add(Cs(a,30)).add(i),l=Vc(o,r.add(Cs(s.add(wa),18)).add(a),n),u=sr(e,16).mul(n),c=sr(e,24),d=o.add(sr(e,t-32)).mul(n),p=l.add(sr(e,t-24)).mul(n);return Vc(Cs(u.add(c),43).add(Cs(d,30)).add(p),u.add(Cs(c.add(r),18)).add(d),n)}function $he(e,t=e.length){const n=Sp.fromNumber(81,!0);if(t<=32)return t<=16?Che(e,t):Nhe(e,t);if(t<=64)return The(e,t);let r=n,s=n.mul(bp).add(113),a=z_(s.mul(wa).add(113)).mul(wa),i=[Sp.UZERO,Sp.UZERO],o=[Sp.UZERO,Sp.UZERO];r=r.mul(wa).add(sr(e,0));let l=0;const u=(t-1>>6)*64,c=u+(t-1&63)-63;do r=Cs(r.add(s).add(i[0]).add(sr(e,l+8)),37).mul(bp),s=Cs(s.add(i[1]).add(sr(e,l+48)),42).mul(bp),r=r.xor(o[1]),s=s.add(i[0]).add(sr(e,l+40)),a=Cs(a.add(o[0]),33).mul(bp),i=Ok(e,l,i[1].mul(bp),r.add(o[0])),o=Ok(e,l+32,a.add(o[1]),s.add(sr(e,l+16))),[a,r]=[r,a],l+=64;while(l!==u);const d=bp.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Cs(r.add(s).add(i[0]).add(sr(e,l+8)),37).mul(d),s=Cs(s.add(i[1]).add(sr(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(sr(e,l+40))),a=Cs(a.add(o[0]),33).mul(d),i=Ok(e,l,i[1].mul(d),r.add(o[0])),o=Ok(e,l+32,a.add(o[1]),s.add(sr(e,l+16))),[a,r]=[r,a],Vc(Vc(i[0],o[0],d).add(z_(s).mul(pj)).add(a),Vc(i[1],o[1],d).add(r),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wd(e,t){return t==="string"?Uc(e):Dh([e],t)}function Ehe(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Dh(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Qp(e)),$e().getBool("DEBUG")&&ihe(e,t),Ehe(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){const n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function Wa(){return $e().platform.now()}function Uc(e,t="utf-8"){return t=t||"utf-8",$e().platform.encode(e,t)}function Yc(e,t="utf-8"){return t=t||"utf-8",$e().platform.decode(e,t)}function wo(e){return $e().platform.isTypedArray!=null?$e().platform.isTypedArray(e):uj(e)}function Qp(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||KR(e)||e==null||wo(e)&&n)t.push(e);else if(Array.isArray(e)||wo(e))for(let r=0;r<e.length;++r)Qp(e[r],t,n);else{let r=-1;for(const s of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Qp(e[s],t,n)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _he{constructor(t,n){this.backendTimer=t,this.logger=n,n==null&&(this.logger=new Rhe)}profileKernel(t,n,r){let s;const a=()=>{s=r()};let i;const o=Wa();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(a);else{a();for(const u of s)u.dataSync();i=Promise.resolve({kernelMs:Wa()-o})}if($e().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(d=>{Ahe(d,c.dtype,t)})}return{kernelName:t,outputs:s,inputs:n,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:n,outputs:r,timeMs:s,inputs:a,extraInfo:i}=t;r.forEach(o=>{Promise.all([o.data(),s,i]).then(l=>{this.logger.logKernelProfile(n,o,l[0],l[1],a,l[2])})})}}function Ahe(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){const s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class Rhe{logKernelProfile(t,n,r,s,a,i){const o=typeof s=="number"?hg(`${s}ms`,9):s.error,l=hg(t,25),u=n.rank,c=n.size,d=hg(n.shape.toString(),14);let p="";for(const h in a){const m=a[h];if(m!=null){const g=m.shape||n.shape,y=g.length;p+=`${h}: ${y}D ${y>0?g:""} `}}console.log(`%c${l}	%c${o}	%c${u}D ${d}	%c${c}	%c${p}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dhe(e,t,n){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){const u=e[l],c=u.inputs;for(const d in c){const p=c[d];let h=!1;for(let m=0;m<t.length;m++)if(r[p.id]){u.outputs.forEach(g=>r[g.id]=!0),h=!0,s[u.id]=!0;break}if(h)break}}const a={};a[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const u=e[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(a[u.outputs[d].id]){for(const p in c)a[c[p].id]=!0,i[u.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const u=e[l];if(s[u.id]&&i[u.id]){const c={};for(const p in u.inputs){const h=u.inputs[p];r[h.id]&&(c[p]=h)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,o.push(d)}}return o}function Fhe(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach(l=>{const u=e[l.id];u!=null?i.push(u):i.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const l in a.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const u=n(()=>o[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=a.inputs[l];if(!Dn(u.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=u;else{const d=e[c.id];e[c.id]=r(d,u),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _W=20,_b=3,xE=7;function Ohe(e,t,n,r){const s=_t(t),a=Mhe(e,t,n,s),i=t.length,o=g2(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join(`
`)),l.join(`
`)}function Mhe(e,t,n,r){const s=Oe(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l=n==="complex64"?Wb(e):e;if(o>1)for(let u=0;u<s/a;u++){const c=u*a;for(let d=0;d<a;d++)i[d]=Math.max(i[d],Bb(l[c+d],0,n).length)}return i}function Bb(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(xE))} + ${parseFloat(e[1].toFixed(xE))}j`:t0(e)?r=`'${e}'`:n==="bool"?r=fj(e):r=parseFloat(e.toFixed(xE)).toString(),hg(r,t)}function fj(e){return e===0?"false":"true"}function g2(e,t,n,r,s,a=!0){const i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){const g=Wb(e);return[Bb(g[0],0,n)]}return n==="bool"?[fj(e[0])]:[e[0].toString()]}if(l===1){if(o>_W){const y=_b*i;let b=Array.from(e.slice(0,y)),v=Array.from(e.slice((o-_b)*i,o*i));return n==="complex64"&&(b=Wb(b),v=Wb(v)),["["+b.map((k,I)=>Bb(k,s[I],n)).join(", ")+", ..., "+v.map((k,I)=>Bb(k,s[o-_b+I],n)).join(", ")+"]"]}return["["+(n==="complex64"?Wb(e):Array.from(e)).map((y,b)=>Bb(y,s[b],n)).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*i,p=[];if(o>_W){for(let g=0;g<_b;g++){const y=g*d,b=y+d;p.push(...g2(e.slice(y,b),u,n,c,s,!1))}p.push("...");for(let g=o-_b;g<o;g++){const y=g*d,b=y+d;p.push(...g2(e.slice(y,b),u,n,c,s,g===o-1))}}else for(let g=0;g<o;g++){const y=g*d,b=y+d;p.push(...g2(e.slice(y,b),u,n,c,s,g===o-1))}const h=l===2?",":"";p[0]="["+(o>0?p[0]+h:"");for(let g=1;g<p.length-1;g++)p[g]=" "+p[g]+h;let m=`,
`;for(let g=2;g<l;g++)m+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":m),p}function Wb(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ks{constructor(t,n,r){if(this.dtype=n,this.shape=t.slice(),this.size=Oe(t),r!=null){const s=r.length;Y(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Mr(n,this.size),this.strides=_t(t)}set(t,...n){n.length===0&&(n=[0]),Y(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(const s of t){if(s<0||s>=this.shape[n]){const a=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let r=0;r<t.length-1;++r)n+=this.strides[r]*t[r];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(t/this.strides[r]),t-=n[r]*this.strides[r];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return Go().makeTensor(this.values,this.shape,this.dtype)}}let Go=null,ag=null;function Lhe(e){Go=e}function Phe(e){ag=e}class os{constructor(t,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=Oe(t),this.strides=_t(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return ag.buffer(this.shape,this.dtype,t)}bufferSync(){return ag.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Xo(this.shape,t,this.dtype==="complex64")}arraySync(){return Xo(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Go().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map(r=>Yc(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Go().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Go().readSync(this.dataId);if(this.dtype==="string")try{return t.map(n=>Yc(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Go().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Go().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return ag.print(this,t)}clone(){return this.throwIfDisposed(),ag.clone(this)}toString(t=!1){const n=this.dataSync();return Ohe(n,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),ag.cast(this,t)}variable(t=!0,n,r){return this.throwIfDisposed(),Go().makeVariable(this,t,n,r)}}Object.defineProperty(os,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Re(){return XR("Tensor",()=>os)}Re();class Y2 extends os{constructor(t,n,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=n,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Dn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Go().disposeTensor(this),this.dataId=t.dataId,Go().incRef(this,null)}dispose(){Go().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Y2,Symbol.hasInstance,{value:e=>e instanceof os&&e.assign!=null&&e.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var AW;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(AW||(AW={}));var B_;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(B_||(B_={}));var W_;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(W_||(W_={}));var V_;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(V_||(V_={}));var U_;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(U_||(U_={}));const zhe={float32:V_,int32:B_,bool:W_,complex64:U_};function ki(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return zhe[e][t]}function LD(e){return ki(e,"int32")}function mj(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function gj(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pr(e,t){if(e.dtype===t.dtype)return[e,t];const n=ki(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function yj(e){const t=[];return xj(e,t,new Set),t}function xj(e,t,n){if(e==null)return;if(e instanceof os){t.push(e);return}if(!Bhe(e))return;const r=e;for(const s in r){const a=r[s];n.has(a)||(n.add(a),xj(a,t,n))}}function Bhe(e){return Array.isArray(e)||typeof e=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bE(e){return e.kernelName!=null}class RW{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Tg{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new RW}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const r=t[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(Pi(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(t);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new _he(this.backendInstance),!0}setupRegisteredKernels(){TW(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){TW(t).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[t])})}initializeBackend(t){const n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof UR)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,a=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Pi(`Initialization of backend ${t} failed`),Pi(i.stack||i.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return Pi(`Initialization of backend ${t} failed`),Pi(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const r=t[n],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const r=this.state.tensorInfo.get(n),s=r.backend,a=this.readSync(n),i=s.refCount(n);s.disposeData(n,!0),r.backend=t,t.move(n,a,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let r=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,n,r){t();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return Tg.nextTensorId++}nextVariableId(){return Tg.nextVariableId++}clone(t){const n=me.runKernel(k0,{x:t}),r={x:t},s=i=>({x:()=>{const o="float32",l={x:i},u={dtype:o};return me.runKernel(u0,l,u)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,a,{}),n}runKernel(t,n,r){if(this.backendName==null&&this.backend,!(P_(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){const s=this.backend.numDataIds();let a=0;r.forEach(l=>{a+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=s-n-a-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,r=[];const s=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const u=bE(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(bE(t)){const{kernelName:m,inputs:g,attrs:y}=t;this.backendName==null&&this.backend;const b=P_(m,this.backendName);Y(b!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),o=()=>{const v=this.backend.numDataIds();l=b.kernelFunc({inputs:g,attrs:y,backend:this.backend});const k=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,v,k);const I=k.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(s){const S=this.getTensorsForGradient(m,g,I);r=this.saveTensorsForBackwardMode(S)}return I}}else{const{forwardFunc:m}=t,g=y=>{s&&(r=y.map(b=>this.keep(this.clone(b))))};o=()=>{const y=this.backend.numDataIds();l=this.tidy(()=>m(this.backend,g));const b=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,b),b}}const{inputs:c,attrs:d}=t,p=bE(t)?null:t.backwardsFunc;let h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(h=this.profiler.profileKernel(u,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),n=h.outputs)}),s&&this.addTapeNode(u,c,n,p,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(m=>c[m]!=null?c[m].shape:null),outputShapes:n.map(m=>m.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(t,n,r){const s=NW(t);if(s!=null){const a=s.inputsToSave||[],i=s.outputsToSave||[];let o;s.saveAllInputs?(Y(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(u=>n[u])):o=a.map(u=>n[u]);const l=r.filter((u,c)=>i[c]);return o.concat(l)}return[]}makeTensor(t,n,r,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=t;r==="string"&&t0(t[0])&&(a=t.map(l=>Uc(l)));const i=s.write(a,n,r),o=new os(n,r,i,this.nextTensorId());if(this.trackTensor(o,s),r==="string"){const l=this.state.tensorInfo.get(i),u=lhe(a);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(t,n,r,s){r=r||"float32";const a={dataId:t,shape:n,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(t,n){const{dataId:r,shape:s,dtype:a}=t,i=new os(s,a,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));const a=new Y2(t,n,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*H2(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof Y2||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const r=t.size*H2(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,r,s,a,i){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:a},l=NW(t);l!=null&&(s=l.gradFunc),s!=null&&(o.gradient=u=>(u=u.map((c,d)=>{if(c==null){const p=r[d],h=aa(p.size,p.dtype);return this.makeTensor(h,p.shape,p.dtype)}return c}),s(u.length>1?u:u[0],a,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=yj(t),r=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const i=this.state.activeScope.track[a];!i.kept&&!r.has(i.id)&&i.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(t,n,r,s=!1){if(Y(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));Y(a instanceof os,()=>"The result y returned by f() must be a tensor.");const i=Dhe(this.state.activeTape,n,a);if(!s&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[a.id]=r??Whe(a.shape),Fhe(o,i,u=>this.tidy(u),Vhe);const l=n.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:a,grads:l}})}customGrad(t){return Y(R_(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{Y(n.every(o=>o instanceof os),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((o,l)=>{s[l]=o});const a=(o,l)=>(r=t(...n,l),Y(r.value instanceof os,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Y(R_(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(o,l)=>{const u=r.gradFunc(o,l),c=Array.isArray(u)?u:[u];Y(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Y(c.every(p=>p instanceof os),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return c.forEach((p,h)=>{d[h]=()=>p}),d};return this.runKernelFunc({forwardFunc:a,backwardsFunc:i,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){const n=Wa(),r=await this.backend.time(t);return r.wallMs=Wa()-n,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new RW;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Tg.nextTensorId=0;Tg.nextVariableId=0;function Whe(e){const t=qR(Oe(e),"float32");return me.makeTensor(t,e,"float32")}function bj(){const e=z5();if(e._tfengine==null){const t=new dhe(e);e._tfengine=new Tg(t)}return mhe(e._tfengine.ENV),Lhe(()=>e._tfengine),e._tfengine}const me=bj();function Vhe(e,t){const n={a:e,b:t};return me.runKernel(cy,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uhe(){return typeof navigator<"u"&&navigator!=null}function vj(e){if(e||Uhe()){if(e||(e=navigator),e.product==="ReactNative")return!0;const t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){const n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function wj(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Za=$e();Za.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Za.registerFlag("IS_BROWSER",()=>wj());Za.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Za.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Za.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Za.registerFlag("PROD",()=>!1);Za.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Za.getBool("DEBUG"));Za.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Za.registerFlag("IS_TEST",()=>!1);Za.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Za.getBool("DEBUG"));Za.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Za.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Za.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0(e,t){let n=e;if(wo(e))return t==="string"?[]:[e.length];if(mj(e)){const s=e.channels||"RGBA";return[e.height,e.width*s.length]}else if(gj(e))return[e.buffer.size/(t==null?4:H2(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||wo(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&$e().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&kj(e,r,[]),r}function kj(e,t,n){if(n=n||[],!Array.isArray(e)&&!wo(e)){Y(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}Y(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Y(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const r=t.slice(1);for(let s=0;s<e.length;++s)kj(e[s],r,n.concat(s))}function DW(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function ae(e,t,n,r="numeric"){if(e instanceof Re())return DW(r,e.dtype,t,n),e;let s=ly(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),DW(r,s,t,n),e==null||!wo(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){const l=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const a=Z0(e,s);!wo(e)&&!Array.isArray(e)&&(e=[e]);const o=s!=="string"?Dh(e,s):Qp(e,[],!0);return me.makeTensor(o,a,s)}function Ij(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,i)=>ae(a,`${t}[${i}]`,n,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ghe="__op";function ve(e){const t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+Ghe;const s=(...a)=>{me.startScope(n);try{const i=r(...a);return KR(i)&&console.error("Cannot return a Promise inside of tidy."),me.endScope(i),i}catch(i){throw me.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jhe(e,t){const n=ae(e,"real","complex"),r=ae(t,"imag","complex");jR(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return me.runKernel(rD,s)}const $g=ve({complex_:jhe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J0(e,t,n,r){if(r==null)r=ly(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(gj(e)||mj(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return me.backend.createTensorFromGPUData(e,t||n,r)}if(!wo(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){ju(t);const s=Oe(t),a=Oe(n);Y(s===a,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${a}`);for(let i=0;i<n.length;++i){const o=n[i],l=i===n.length-1?o!==Oe(t.slice(i)):!0;Y(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!wo(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?Dh(e,r):Qp(e,[],!0),me.makeTensor(e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sj(e,t,n){const r=Z0(e,n);return J0(e,t,r,n)}class dy{static join(t){return new dy(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(r=>wo(r)?r.buffer:r),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let r=0;r<t.length;r++){const s=t[r];r!==t.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=n+s.byteLength;this.shards.push({buffer:s,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);const r=this.findShardForByte(t);if(r===-1)throw new Error(`Could not find start shard for byte ${t}`);const s=n-t,a=new ArrayBuffer(s),i=new Uint8Array(a);let o=0;for(let l=r;l<this.shards.length;l++){const u=this.shards[l],d=t+o-u.start,p=o,m=Math.min(n,u.end)-u.start,g=new Uint8Array(u.buffer,d,m-d);if(i.set(g,p),o+=g.length,n<u.end)break}return a}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(s){return t<s.start?-1:t>=s.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=Hhe(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function Hhe(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(a===0)return s;a<0?r=s:n=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $l(){return me}function FW(){return me.memory()}function Se(e,t){return me.tidy(e,t)}function on(e){yj(e).forEach(n=>n.dispose())}function Ul(e){return me.keep(e)}function Cj(e,t,n=1){return me.registerBackend(e,t,n)}function qhe(){return me.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OW=4;async function MW(e,t){const n=[],r=[],s=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<s.length;++i){const o=s[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async d=>{const p=await l.bytes(),h=p.reduce((y,b)=>y+b.length,0)+OW*p.length,m=new Uint8Array(h);let g=0;for(let y=0;y<p.length;y++){const b=p[y],v=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(v,g),g+=OW,m.set(b,g),g+=b.length}d(m)});r.push(c)}else r.push(l.data());t!=null&&(u.group=t),n.push(u)}const a=await Promise.all(r);return{data:Khe(a),specs:n}}function Khe(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const r=new Uint8Array(t);let s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}const PD=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function LW(e){return PD?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function Xhe(e){if(PD)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function Yhe(e){if(PD){const r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function Zhe(e){return dy.join(e)}function Nj(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:LW(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:LW(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new dy(e.weightData).byteLength}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ba{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ba.instance==null&&(ba.instance=new ba),ba.instance}static registerSaveRouter(t){ba.getInstance().saveRouters.push(t)}static registerLoadRouter(t){ba.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return ba.getHandlers(t,"save")}static getLoadHandlers(t,n){return ba.getHandlers(t,"load",n)}static getHandlers(t,n,r){const s=[];return(n==="load"?ba.getInstance().loadRouters:ba.getInstance().saveRouters).forEach(i=>{const o=i(t,r);o!==null&&s.push(o)}),s}}const Jhe=e=>ba.getSaveHandlers(e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G_="tensorflowjs",j_=1,Dp="models_store",Fc="model_info_store";function Tj(){if(!$e().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function H_(e){const t=e.result;t.createObjectStore(Dp,{keyPath:"modelPath"}),t.createObjectStore(Fc,{keyPath:"modelPath"})}class eh{constructor(t){if(this.indexedDB=Tj(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((r,s)=>{const a=this.indexedDB.open(G_,j_);a.onupgradeneeded=()=>H_(a),a.onsuccess=()=>{const i=a.result;if(n==null){const o=i.transaction(Dp,"readonly"),u=o.objectStore(Dp).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return i.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(u.result.modelArtifacts)},u.onerror=c=>(i.close(),s(u.error)),o.oncomplete=()=>i.close()}else{n.weightData=dy.join(n.weightData);const o=Nj(n),l=i.transaction(Fc,"readwrite");let u=l.objectStore(Fc),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(p){return s(p)}let d;c.onsuccess=()=>{d=i.transaction(Dp,"readwrite");const p=d.objectStore(Dp);let h;try{h=p.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:o})}catch(m){return s(m)}h.onsuccess=()=>r({modelArtifactsInfo:o}),h.onerror=m=>{u=l.objectStore(Fc);const g=u.delete(this.modelPath);g.onsuccess=()=>(i.close(),s(h.error)),g.onerror=y=>(i.close(),s(h.error))}},c.onerror=p=>(i.close(),s(c.error)),l.oncomplete=()=>{d==null?i.close():d.oncomplete=()=>i.close()}}},a.onerror=i=>s(a.error)})}}eh.URL_SCHEME="indexeddb://";const $j=e=>$e().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(eh.URL_SCHEME)?Qhe(e.slice(eh.URL_SCHEME.length)):null;ba.registerSaveRouter($j);ba.registerLoadRouter($j);function Qhe(e){return new eh(e)}function efe(e){return e.startsWith(eh.URL_SCHEME)?e.slice(eh.URL_SCHEME.length):e}class tfe{constructor(){this.indexedDB=Tj()}async listModels(){return new Promise((t,n)=>{const r=this.indexedDB.open(G_,j_);r.onupgradeneeded=()=>H_(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(Fc,"readonly"),o=a.objectStore(Fc).getAll();o.onsuccess=()=>{const l={};for(const u of o.result)l[u.modelPath]=u.modelArtifactsInfo;t(l)},o.onerror=l=>(s.close(),n(o.error)),a.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(t){return t=efe(t),new Promise((n,r)=>{const s=this.indexedDB.open(G_,j_);s.onupgradeneeded=()=>H_(s),s.onsuccess=()=>{const a=s.result,i=a.transaction(Fc,"readwrite"),o=i.objectStore(Fc),l=o.get(t);let u;l.onsuccess=()=>{if(l.result==null)return a.close(),r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const c=o.delete(t),d=()=>{u=a.transaction(Dp,"readwrite");const h=u.objectStore(Dp).delete(t);h.onsuccess=()=>n(l.result.modelArtifactsInfo),h.onerror=m=>r(l.error)};c.onsuccess=d,c.onerror=p=>(d(),a.close(),r(l.error))}},l.onerror=c=>(a.close(),r(l.error)),i.oncomplete=()=>{u==null?a.close():u.oncomplete=()=>a.close()}},s.onerror=a=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $u="/",ig="tensorflowjs_models",Ej="info",nfe="model_topology",rfe="weight_specs",sfe="weight_data",afe="model_metadata";function _j(e){return{info:[ig,e,Ej].join($u),topology:[ig,e,nfe].join($u),weightSpecs:[ig,e,rfe].join($u),weightData:[ig,e,sfe].join($u),modelMetadata:[ig,e,afe].join($u)}}function Aj(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function ife(e){const t=e.split($u);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join($u)}function ofe(e){return e.startsWith(th.URL_SCHEME)?e.slice(th.URL_SCHEME.length):e}class th{constructor(t){if(!$e().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=_j(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),s=Nj(t),a=dy.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,Xhe(a));const i={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:s}}catch{throw Aj(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const o=JSON.parse(a);n.format=o.format,n.generatedBy=o.generatedBy,n.convertedBy=o.convertedBy,o.signature!=null&&(n.signature=o.signature),o.userDefinedMetadata!=null&&(n.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(n.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(n.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(n.trainingConfig=o.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=Yhe(i),n}}th.URL_SCHEME="localstorage://";const Rj=e=>$e().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(th.URL_SCHEME)?lfe(e.slice(th.URL_SCHEME.length)):null;ba.registerSaveRouter(Rj);ba.registerLoadRouter(Rj);function lfe(e){return new th(e)}class ufe{constructor(){Y($e().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Y(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},n=ig+$u,r=$u+Ej;for(let s=0;s<this.LS.length;++s){const a=this.LS.key(s);if(a.startsWith(n)&&a.endsWith(r)){const i=ife(a);t[i]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){t=ofe(t);const n=_j(t);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return Aj(n),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PW="://";class _l{constructor(){this.managers={}}static getInstance(){return _l.instance==null&&(_l.instance=new _l),_l.instance}static registerManager(t,n){Y(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(PW)&&(t=t.slice(0,t.indexOf(PW))),Y(t.length>0,()=>"scheme must not be an empty string.");const r=_l.getInstance();Y(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){const n=_l.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(_l.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cfe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(typeof window>"u"||!$e().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return uj(t)}}if($e().get("IS_BROWSER")){$e().setPlatform("browser",new cfe);try{_l.registerManager(th.URL_SCHEME,new ufe)}catch{}try{_l.registerManager(eh.URL_SCHEME,new tfe)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dfe={importFetch:()=>require("node-fetch")};let vE;class pfe{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return $e().global.fetch!=null?$e().global.fetch(t,n):(vE==null&&(vE=dfe.importFetch()),vE(t,n))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(t)}decode(t,n){return t.length===0?"":new this.util.TextDecoder(n).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}$e().get("IS_NODE")&&!$e().get("IS_BROWSER")&&$e().setPlatform("node",new pfe);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ln(e,t="float32",n){return t=t||"float32",ju(e),new Ks(e,t,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hfe(e,t){const n=ae(e,"x","cast");if(!ohe(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return me.runKernel(u0,r,s)}const lt=ve({cast_:hfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ffe(e){const n={x:ae(e,"x","clone","string_or_numeric")};return me.runKernel(k0,n)}const Wp=ve({clone_:ffe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mfe(e,t=!1){console.log(e.toString(t))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */bj();const gfe={buffer:ln,cast:lt,clone:Wp,print:mfe};Phe(gfe);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yfe(e,t){let n=ae(e,"a","add"),r=ae(t,"b","add");[n,r]=Pr(n,r);const s={a:n,b:r};return me.runKernel(cy,s)}const He=ve({add_:yfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xfe(e,t){let n=ae(e,"a","floorDiv"),r=ae(t,"b","floorDiv");[n,r]=Pr(n,r);const s={a:n,b:r};return me.runKernel(v0,s)}const Dj=ve({floorDiv_:xfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bfe(e,t){let n=ae(e,"a","div"),r=ae(t,"b","div");if([n,r]=Pr(n,r),n.dtype==="int32"&&r.dtype==="int32")return Dj(n,r);const s={a:n,b:r},a={};return me.runKernel(f0,s,a)}const Ot=ve({div_:bfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vfe(e,t){let n=ae(e,"a","mul"),r=ae(t,"b","mul");[n,r]=Pr(n,r);const s={a:n,b:r};return me.runKernel(A0,s)}const fe=ve({mul_:vfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wfe(e){const t=ae(e,"x","abs");if(t.dtype==="complex64"){const n={x:t};return me.runKernel(wS,n)}else{const n={x:t};return me.runKernel(fS,n)}}const va=ve({abs_:wfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kfe(e){const n={x:ae(e,"x","acos")};return me.runKernel(n0,n)}const Ife=ve({acos_:kfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sfe(e){const n={x:ae(e,"x","acosh")};return me.runKernel(r0,n)}const Cfe=ve({acosh_:Sfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nfe(e,t=null,n=!1){const s={x:ae(e,"x","all","bool")},a={axis:t,keepDims:n};return me.runKernel(ZR,s,a)}const Fj=ve({all_:Nfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tfe(e,t=null,n=!1){const s={x:ae(e,"x","any","bool")},a={axis:t,keepDims:n};return me.runKernel(JR,s,a)}const q_=ve({any_:Tfe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $fe(e,t=0){const r={x:ae(e,"x","argMax")},s={axis:t};return me.runKernel(mS,r,s)}const fv=ve({argMax_:$fe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Efe(e,t=0){const r={x:ae(e,"x","argMin")},s={axis:t};return me.runKernel(gS,r,s)}const _fe=ve({argMin_:Efe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Afe(e){const n={x:ae(e,"x","asin")};return me.runKernel(s0,n)}const Rfe=ve({asin_:Afe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dfe(e){const n={x:ae(e,"x","asinh")};return me.runKernel(a0,n)}const Ffe=ve({asinh_:Dfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ofe(e){const n={x:ae(e,"x","atan")};return me.runKernel(i0,n)}const Mfe=ve({atan_:Ofe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lfe(e,t){let n=ae(e,"a","atan2"),r=ae(t,"b","atan2");[n,r]=Pr(n,r);const s={a:n,b:r};return me.runKernel(l0,s)}const Pfe=ve({atan2_:Lfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zfe(e){const n={x:ae(e,"x","atanh")};return me.runKernel(o0,n)}const Bfe=ve({atanh_:zfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q0(e,t,n,r,s="NHWC",a){const i=e[3],o=[...t,i],l=qu(s);return Xs(e,o,n,a,r,null,null,l)}function So(e,t,n,r,s,a,i="channelsLast"){const[o,l]=mv(t);let u;if(i==="channelsLast")u=[o,l,e[3],e[3]];else if(i==="channelsFirst")u=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return Xs(e,u,n,r,s,a,!1,i)}function Hu(e,t,n,r,s,a,i="NDHWC"){const[o,l,u]=K_(t);let c,d;if(i==="NDHWC")d="channelsLast",c=[o,l,u,e[4],e[4]];else if(i==="NCDHW")d="channelsFirst",c=[o,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return kd(e,c,n,r,s,!1,d,a)}function Xs(e,t,n,r,s,a,i=!1,o="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,d]=e;else if(o==="channelsFirst")[l,d,u,c]=e;else throw new Error(`Unknown dataFormat ${o}`);const[p,h,,m]=t,[g,y]=mv(n),[b,v]=mv(r),k=mg(p,b),I=mg(h,v),{padInfo:S,outHeight:N,outWidth:T}=Ufe(s,u,c,g,y,k,I,a,o),A=i?m*d:m;let R;return o==="channelsFirst"?R=[l,A,N,T]:o==="channelsLast"&&(R=[l,N,T,A]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:N,outWidth:T,outChannels:A,padInfo:S,strideHeight:g,strideWidth:y,filterHeight:p,filterWidth:h,effectiveFilterHeight:k,effectiveFilterWidth:I,dilationHeight:b,dilationWidth:v,inShape:e,outShape:R,filterShape:t}}function kd(e,t,n,r,s,a=!1,i="channelsLast",o){let[l,u,c,d,p]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,d,p]=e;else if(i==="channelsFirst")[l,p,u,c,d]=e;else throw new Error(`Unknown dataFormat ${i}`);const[h,m,g,,y]=t,[b,v,k]=K_(n),[I,S,N]=K_(r),T=mg(h,I),A=mg(m,S),R=mg(g,N),{padInfo:D,outDepth:$,outHeight:_,outWidth:L}=Gfe(s,u,c,d,b,v,k,T,A,R,o),z=a?y*p:y;let W;return i==="channelsFirst"?W=[l,z,$,_,L]:i==="channelsLast"&&(W=[l,$,_,L,z]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:p,outDepth:$,outHeight:_,outWidth:L,outChannels:z,padInfo:D,strideDepth:b,strideHeight:v,strideWidth:k,filterDepth:h,filterHeight:m,filterWidth:g,effectiveFilterDepth:T,effectiveFilterHeight:A,effectiveFilterWidth:R,dilationDepth:I,dilationHeight:S,dilationWidth:N,inShape:e,outShape:W,filterShape:t}}function Wfe(e,t,n,r,s){r==null&&(r=zD(e,t,n));const a=e[0],i=e[1],o=gv((a-t+2*r)/n+1,s),l=gv((i-t+2*r)/n+1,s);return[o,l]}function Vfe(e,t,n,r,s,a){s==null&&(s=zD(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=gv((e[o]-t[o]+2*s)/r[o]+1,a));return i}function zD(e,t,n,r=1){const s=mg(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function mv(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function K_(e){return typeof e=="number"?[e,e,e]:e}function mg(e,t){return t<=1?e:e+(e-1)*(t-1)}function Ufe(e,t,n,r,s,a,i,o,l){let u,c,d;if(typeof e=="number"){u={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};const h=Wfe([t,n],a,r,e,o);c=h[0],d=h[1]}else if(e==="same"){c=Math.ceil(t/r),d=Math.ceil(n/s);const p=Math.max(0,(c-1)*r+a-t),h=Math.max(0,(d-1)*s+i-n),m=Math.floor(p/2),g=p-m,y=Math.floor(h/2),b=h-y;u={top:m,bottom:g,left:y,right:b,type:"SAME"}}else if(e==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),d=Math.ceil((n-i+1)/s);else if(typeof e=="object"){const p=l==="channelsLast"?e[1][0]:e[2][0],h=l==="channelsLast"?e[1][1]:e[2][1],m=l==="channelsLast"?e[2][0]:e[3][0],g=l==="channelsLast"?e[2][1]:e[3][1];u={top:p,bottom:h,left:m,right:g,type:p===0&&h===0&&m===0&&g===0?"VALID":"EXPLICIT"},c=gv((t-a+p+h)/r+1,o),d=gv((n-i+m+g)/s+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:c,outWidth:d}}function Gfe(e,t,n,r,s,a,i,o,l,u,c){let d,p,h,m;if(e==="valid"&&(e=0),typeof e=="number"){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};const y=Vfe([t,n,r,1],[o,l,u],1,[s,a,i],e,c);p=y[0],h=y[1],m=y[2]}else if(e==="same"){p=Math.ceil(t/s),h=Math.ceil(n/a),m=Math.ceil(r/i);const g=(p-1)*s+o-t,y=(h-1)*a+l-n,b=(m-1)*i+u-r,v=Math.floor(g/2),k=g-v,I=Math.floor(y/2),S=y-I,N=Math.floor(b/2),T=b-N;d={top:I,bottom:S,left:N,right:T,front:v,back:k,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:p,outHeight:h,outWidth:m}}function gv(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function nh(e){const[t,n,r]=mv(e);return t===1&&n===1&&r===1}function ua(e,t){return nh(e)||nh(t)}function rh(e){return mv(e).every(t=>t>0)}function qu(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function ri(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")Y(Ng(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(s=>{Y(Ng(s),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jfe(e,t){const r={x:ae(e,"x","reshape","string_or_numeric")},s={shape:t};return me.runKernel(tC,r,s)}const be=ve({reshape_:jfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hfe(e,t,n,r,s){const a=ae(e,"x","avgPool","float32"),i=1;Y(ua(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=a,l=!1;a.rank===3&&(l=!0,o=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Y(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),ri("avgPool",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let d=me.runKernel(yS,u,c);return d=lt(d,a.dtype),l?be(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const py=ve({avgPool_:Hfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qfe(e,t,n,r,s,a="NDHWC"){const i=ae(e,"x","avgPool3d","float32");let o=i,l=!1;i.rank===4&&(l=!0,o=be(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),Y(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Y(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),ri("avgPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let d=me.runKernel(xS,u,c);return d=lt(d,o.dtype),l?be(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Kfe=ve({avgPool3d_:qfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xfe(e,t=0){Y(e.length>=1,()=>"Pass at least one tensor to concat");const n=Ij(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return Wp(n[0]);const r=n,s={axis:t};return me.runKernel(kS,r,s)}const Ka=ve({concat_:Xfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yfe(e,t,n=!1,r=!1){let s=ae(e,"a","matMul"),a=ae(t,"b","matMul");[s,a]=Pr(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return me.runKernel(bS,i,o)}const An=ve({matMul_:Yfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zfe(e){const n={x:ae(e,"x","sigmoid","float32")};return me.runKernel(V0,n)}const hy=ve({sigmoid_:Zfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jfe(e,t,n){const r=ae(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return me.runKernel(iC,s,a)}const ar=ve({slice_:Jfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qfe(e){const n={x:ae(e,"x","tanh","float32")};return me.runKernel(K0,n)}const mC=ve({tanh_:Qfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eme(e,t,n){const r=ae(e,"x","batchToSpaceND"),s=t.reduce((o,l)=>o*l);Y(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),Y(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Y(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);const a={x:r},i={blockShape:t,crops:n};return me.runKernel(vS,a,i)}const BD=ve({batchToSpaceND_:eme});function tme(e){let t;return e.rank===0||e.rank===1?t=be(e,[1,1,1,e.size]):e.rank===2?t=be(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=be(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nme(e,t,n,r,s,a){a==null&&(a=.001);const i=ae(e,"x","batchNorm"),o=ae(t,"mean","batchNorm"),l=ae(n,"variance","batchNorm");let u;s!=null&&(u=ae(s,"scale","batchNorm"));let c;r!=null&&(c=ae(r,"offset","batchNorm")),Y(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Y(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Y(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:tme(i),scale:u,offset:c,mean:o,variance:l},h={varianceEpsilon:a},m=me.runKernel(AS,p,h);return be(m,i.shape)}const gC=ve({batchNorm_:nme});function rme(e,t,n,r,s,a){const i=ae(e,"x","batchNorm"),o=ae(t,"mean","batchNorm"),l=ae(n,"variance","batchNorm");let u;s!=null&&(u=ae(s,"scale","batchNorm"));let c;return r!=null&&(c=ae(r,"offset","batchNorm")),Y(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),Y(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),Y(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&Y(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&Y(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),gC(i,o,l,c,u,a)}const sme=ve({batchNorm2d_:rme});function ame(e,t,n,r,s,a){const i=ae(e,"x","batchNorm"),o=ae(t,"mean","batchNorm"),l=ae(n,"variance","batchNorm");let u;s!=null&&(u=ae(s,"scale","batchNorm"));let c;return r!=null&&(c=ae(r,"offset","batchNorm")),Y(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),Y(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),Y(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&Y(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&Y(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),gC(i,o,l,c,u,a)}const ime=ve({batchNorm3d_:ame});function ome(e,t,n,r,s,a){const i=ae(e,"x","batchNorm"),o=ae(t,"mean","batchNorm"),l=ae(n,"variance","batchNorm");let u;s!=null&&(u=ae(s,"scale","batchNorm"));let c;return r!=null&&(c=ae(r,"offset","batchNorm")),Y(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),Y(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),Y(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&Y(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&Y(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),gC(i,o,l,c,u,a)}const lme=ve({batchNorm4d_:ome});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ume(e,t,n){const r=ae(e,"x","bincount"),s=ae(t,"weights","bincount");Y(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),Y(n>=0,()=>`size must be non-negative, but got ${n}.`),Y(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const a={x:r,weights:s},i={size:n};return me.runKernel(tD,a,i)}const cme=ve({bincount_:ume});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dme(e,t){let n=ae(e,"broadcastTo","x");const r=n.shape;if(ju(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const u=n.shape.slice();for(;u.length<t.length;)u.unshift(1);n=be(n,u)}const s=n.shape,a=Array.from(t);for(let u=t.length-1;u>=0;u--)if(s[u]===t[u])a[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(a.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return Wp(n);const o={x:n},l={reps:a};return me.runKernel(X0,o,l)}const nv=ve({broadcastTo_:dme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pme(e){const n={x:ae(e,"x","ceil","float32")};return me.runKernel(c0,n)}const hme=ve({ceil_:pme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yC(e,t,n){ju(e),n=n||ly(t);const r={shape:e,value:t,dtype:n};return me.runKernel(gD,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fme(e,t,n){const r=ae(e,"x","clipByValue");if(Y(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return yC(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return me.runKernel(d0,s,a)}const qi=ve({clipByValue_:fme});function mme(e){return Ka(e,0)}const gme=ve({concat1d_:mme});function yme(e,t){return Ka(e,t)}const xme=ve({concat2d_:yme});function bme(e,t){return Ka(e,t)}const vme=ve({concat3d_:bme});function wme(e,t){return Ka(e,t)}const kme=ve({concat4d_:wme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ime(e,t,n,r,s="NHWC",a=[1,1],i){const o=ae(e,"x","conv2d","float32"),l=ae(t,"filter","conv2d","float32");let u=o,c=!1;o.rank===3&&(c=!0,u=be(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),Y(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ri("conv2d",r,i);const d=s==="NHWC"?u.shape[3]:u.shape[1];Y(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),Y(ua(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Y(rh(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),Y(rh(n),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:u,filter:l},h={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},m=me.runKernel(IS,p,h);return c?be(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const sh=ve({conv2d_:Ime});function Sme(e,t,n,r,s="NWC",a=1,i){const o=ae(e,"x","conv1d"),l=ae(t,"filter","conv1d");let u=o,c=!1;o.rank===2&&(c=!0,u=be(o,[1,o.shape[0],o.shape[1]])),Y(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),Y(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ri("conv1d",r,i),Y(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),Y(ua(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),Y(rh(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),Y(rh(n),()=>"Error in conv1D: Stride should be larger than 0."),Y(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=be(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=be(u,[u.shape[0],1,u.shape[1],u.shape[2]]),y=sh(p,d,[1,n],r,"NHWC",[1,a],i);return c?be(y,[y.shape[2],y.shape[3]]):be(y,[y.shape[0],y.shape[2],y.shape[3]])}const Oj=ve({conv1d_:Sme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cme(e,t,n,r,s,a="NHWC",i){Y(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;t.rank===3&&(u=!0,l=be(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Y(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),Y(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),Y(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=a==="NHWC"?o[3]:o[1],d=a==="NHWC"?l.shape[3]:l.shape[1];Y(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),Y(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),ri("conv2dDerInput",s,i);const p={dy:l,filter:n},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},m=me.runKernel(SS,p,h);return u?be(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const WD=ve({conv2DBackpropInput_:Cme});function Nme(e,t,n,r,s,a){const i=ae(e,"x","conv2dTranspose"),o=ae(t,"filter","conv2dTranspose");return WD(n,i,o,r,s,"NHWC",a)}const Mj=ve({conv2dTranspose_:Nme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tme(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=ae(e,"x","conv3d"),o=ae(t,"filter","conv3d");let l=i,u=!1;i.rank===4&&(u=!0,l=be(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),Y(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),Y(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),Y(ua(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Y(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),Y(rh(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),Y(rh(n),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:o},d={strides:n,pad:r,dataFormat:s,dilations:a},p=me.runKernel(CS,c,d);return u?be(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const $me=ve({conv3d_:Tme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eme(e,t,n,r,s){Y(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,i=t,o=!1;t.rank===4&&(o=!0,i=be(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const l=a[4],u=i.shape[4];Y(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),Y(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),Y(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),Y(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),Y(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c={dy:i,filter:n},d={pad:s,strides:r,inputShape:a},p=me.runKernel(iD,c,d);return o?be(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Lj=ve({conv3DBackpropInput_:Eme});function _me(e,t,n,r,s){const a=ae(e,"x","conv3dTranspose"),i=ae(t,"filter","conv3dTranspose");return Lj(n,a,i,r,s)}const Ame=ve({conv3dTranspose_:_me});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rme(e){const n={x:ae(e,"x","cos","float32")};return me.runKernel(p0,n)}const VD=ve({cos_:Rme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dme(e){const n={x:ae(e,"x","cosh","float32")};return me.runKernel(h0,n)}const Pj=ve({cosh_:Dme});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fme(e,t=0,n=!1,r=!1){const a={x:ae(e,"x","cumprod")},i={axis:t,exclusive:n,reverse:r};return me.runKernel(oD,a,i)}const X_=ve({cumprod_:Fme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ome(e,t=0,n=!1,r=!1){const a={x:ae(e,"x","cumsum")},i={axis:t,exclusive:n,reverse:r};return me.runKernel(NS,a,i)}const zj=ve({cumsum_:Ome});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mme(e,t,n,r=!1){const s=ae(e,"x","denseBincount"),a=ae(t,"weights","denseBincount");Y(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),Y(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),Y(n>=0,()=>`size must be non-negative, but got ${n}.`),Y(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);const i={x:s,weights:a},o={size:n,binaryOutput:r};return me.runKernel(uD,i,o)}const zW=ve({denseBincount_:Mme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lme(e,t,n="NHWC"){const r=ae(e,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];Y(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),Y(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),Y(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${r.shape}`),Y(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);const o={x:r},l={blockSize:t,dataFormat:n};return me.runKernel(cD,o,l)}const Pme=ve({depthToSpace_:Lme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zme(e,t,n,r,s="NHWC",a=[1,1],i){const o=ae(e,"x","depthwiseConv2d","float32"),l=ae(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;o.rank===3&&(c=!0,u=be(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),Y(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=s==="NHWC"?u.shape[3]:u.shape[1];Y(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),ri("depthwiseConv2d",r,i);const p={x:u,filter:l},h={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},m=me.runKernel(TS,p,h);return c?be(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const UD=ve({depthwiseConv2d_:zme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bme(e,t,n,r,s=[1,1],a="NHWC"){const i=ae(e,"x","dilation2d"),o=ae(t,"filter","dilation2d");Y(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),Y(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),Y(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=i,u=!1;i.rank===3&&(l=be(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Y(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const c={x:l,filter:o},d={strides:n,pad:r,dilations:s},p=me.runKernel($S,c,d);return u?be(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Wme=ve({dilation2d_:Bme});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eg(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&i===1&&r.unshift(a)}return r}function ys(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(s==null||s===1&&i>1)&&n.unshift(a)}return n}function Jt(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];a==null&&(a=1);let i=t[t.length-s-1];if(i==null&&(i=1),a===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=a;else if(a!==i){const o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else r[n-s-1]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vme(e,t){let n=ae(e,"a","equal","string_or_numeric"),r=ae(t,"b","equal","string_or_numeric");[n,r]=Pr(n,r),Jt(n.shape,r.shape);const s={a:n,b:r};return me.runKernel(ES,s)}const Zl=ve({equal_:Vme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ume(e,t,n){const r=ae(t,"a","where"),s=ae(n,"b","where"),a=ae(e,"condition","where","bool"),i=Jt(Jt(a.shape,r.shape),s.shape),o=nv(a,i),l=nv(r,i),u=nv(s,i),c={condition:o,t:l,e:u};return me.runKernel(aC,c)}const Ta=ve({where_:Ume});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gme(e){const n={x:ae(e,"x","zerosLike")};return me.runKernel(hC,n)}const vn=ve({zerosLike_:Gme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jme(e,t){let n=ae(e,"a","div"),r=ae(t,"b","div");[n,r]=Pr(n,r);const s=Ot(n,r),a=vn(s),i=Zl(r,a);return Ta(i,a,s)}const Hme=ve({divNoNan_:jme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qme(e,t){const n=ae(e,"t1","dot"),r=ae(t,"t2","dot");Y((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(Y(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){const i=be(n,[1,-1]),o=be(r,[-1,1]),l=An(i,o);return be(l,[])}else if(n.rank===1&&r.rank===2){const i=be(n,[1,-1]),o=be(r,[r.shape[0],r.shape[1]]),l=An(i,o);return be(l,[l.size])}else if(n.rank===2&&r.rank===1){const i=be(r,[-1,1]),o=An(n,i);return be(o,[o.size])}else{const i=be(r,[r.shape[0],r.shape[1]]);return An(n,i)}}const Kme=ve({dot_:qme});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xme(e,...t){const n=t.map((s,a)=>ae(s,`tensors${a}`,"einsum")),r={equation:e};return me.runKernel(hD,n,r)}const Ab=ve({einsum_:Xme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yme(e){const n={x:ae(e,"x","elu","float32")};return me.runKernel(m0,n)}const xC=ve({elu_:Yme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zme(e){let t=ae(e,"x","erf");Y(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=lt(t,"float32"));const n={x:t};return me.runKernel(g0,n)}const Bj=ve({erf_:Zme});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GD(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Wj(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?s.push(e[a++]):s.push(t[i++]);return s}function Os(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);const s=t.map(a=>e[a]);return[n,s]}function Jr(e,t){const n=t.map(r=>1);return Wj(e,n,t)}function Ys(e,t,n){Y(GD(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function _r(e,t){if(GD(e,t))return null;const n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function Id(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function zr(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jme(e,t=null,n=!1){const s={x:ae(e,"x","max")},a={reductionIndices:t,keepDims:n};return me.runKernel(WS,s,a)}const Yo=ve({max_:Jme});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qme(e,t=null,n=!1){const s={x:ae(e,"x","min")},a={axis:t,keepDims:n};return me.runKernel(jS,s,a)}const Z2=ve({min_:Qme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ege(e,t){let n=ae(e,"base","pow"),r=ae(t,"exp","pow");[n,r]=Pr(n,r);const s={a:n,b:r};return me.runKernel(R0,s)}const ah=ve({pow_:ege});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rn(e,t){if((wo(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&wo(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return J0(e,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tge(e){const n={x:ae(e,"x","sqrt","float32")};return me.runKernel(G0,n)}const ia=ve({sqrt_:tge});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nge(e){const t=ae(e,"x","square"),n={};return me.runKernel("Square",{x:t},n)}const hr=ve({square_:nge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rge(e,t=null,n=!1){let r=ae(e,"x","sum");r.dtype==="bool"&&(r=lt(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return me.runKernel(oC,s,a)}const Ft=ve({sum_:rge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sge(e,t="euclidean",n=null,r=!1){e=ae(e,"x","norm");const s=Vj(e,t,n);let a=s.shape;if(r){const i=un(n,e.shape);a=Jr(s.shape,i)}return be(s,a)}function Vj(e,t,n=null){if(e.rank===0)return va(e);if(e.rank!==1&&n===null)return Vj(be(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return Ft(va(e),n);if(t===1/0)return Yo(va(e),n);if(t===-1/0)return Z2(va(e),n);if(t==="euclidean"||t===2)return ia(Ft(ah(va(e),Rn(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Yo(Ft(va(e),n[0]),n[1]-1);if(t===1/0)return Yo(Ft(va(e),n[1]),n[0]);if(t===-1/0)return Z2(Ft(va(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return ia(Ft(hr(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const bC=ve({norm_:sge});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function age(e,t=null,n=!1){return bC(e,"euclidean",t,n)}const ige=ve({euclideanNorm_:age});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oge(e){const n={x:ae(e,"x","exp")};return me.runKernel(y0,n)}const Jl=ve({exp_:oge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lge(e,t=0){const n=ae(e,"x","expandDims","string_or_numeric");Y(t<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:t};return me.runKernel(_S,r,s)}const Va=ve({expandDims_:lge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uge(e){const n={x:ae(e,"x","expm1")};return me.runKernel(x0,n)}const cge=ve({expm1_:uge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dge(e,t){const n=ae(e,"x","tile","string_or_numeric");Y(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const r={x:n},s={reps:t};return me.runKernel(X0,r,s)}const Ko=ve({tile_:dge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pge(e,t,n,r="float32"){t==null&&(t=e);const s=ln([e,t],r),a=e<=t?e:t;for(let o=0;o<a;++o)s.set(1,o,o);const i=be(s.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Ko(Va(i,0),[n[0],1,1]);if(n.length===2)return Ko(Va(Va(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Ko(Va(Va(Va(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const Uj=ve({eye_:pge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hge(e){const n={x:ae(e,"x","floor","float32")};return me.runKernel(b0,n)}const vC=ve({floor_:hge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fge(e,t,n=0,r=0){const s=ae(e,"x","gather"),a=ae(t,"indices","gather","int32"),i={x:s,indices:a},o={axis:n,batchDims:r};return me.runKernel(RS,i,o)}const jD=ve({gather_:fge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mge(e,t){let n=ae(e,"a","greater","string_or_numeric"),r=ae(t,"b","greater","string_or_numeric");[n,r]=Pr(n,r),Jt(n.shape,r.shape);const s={a:n,b:r};return me.runKernel(DS,s)}const Zi=ve({greater_:mge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gge(e,t){let n=ae(e,"a","greaterEqual","string_or_numeric"),r=ae(t,"b","greaterEqual","string_or_numeric");[n,r]=Pr(n,r),Jt(n.shape,r.shape);const s={a:n,b:r};return me.runKernel(w0,s)}const Fh=ve({greaterEqual_:gge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yge(e){const n={input:ae(e,"input","imag")};return me.runKernel(bD,n)}const HD=ve({imag_:yge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xge(e){const n={x:ae(e,"x","isFinite")};return me.runKernel(I0,n)}const bge=ve({isFinite_:xge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vge(e){const n={x:ae(e,"x","isInf")};return me.runKernel(S0,n)}const wge=ve({isInf_:vge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kge(e){const n={x:ae(e,"x","isNaN")};return me.runKernel(C0,n)}const Ige=ve({isNaN_:kge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sge(e,t=.2){const r={x:ae(e,"x","leakyRelu")},s={alpha:t};return me.runKernel(FS,r,s)}const qD=ve({leakyRelu_:Sge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cge(e,t){let n=ae(e,"a","less","string_or_numeric"),r=ae(t,"b","less","string_or_numeric");[n,r]=Pr(n,r),Jt(n.shape,r.shape);const s={a:n,b:r};return me.runKernel(OS,s)}const J2=ve({less_:Cge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nge(e,t){let n=ae(e,"a","lessEqual","string_or_numeric"),r=ae(t,"b","lessEqual","string_or_numeric");[n,r]=Pr(n,r),Jt(n.shape,r.shape);const s={a:n,b:r};return me.runKernel(MS,s)}const fy=ve({lessEqual_:Nge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tge(e,t=5,n=1,r=1,s=.5){const a=ae(e,"x","localResponseNormalization");Y(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),Y(Ng(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=a,o=!1;a.rank===3&&(o=!0,i=be(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:s},c=me.runKernel(BS,l,u);return o?be(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const $ge=ve({localResponseNormalization_:Tge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ege(e){const n={x:ae(e,"x","log","float32")};return me.runKernel(N0,n)}const Ql=ve({log_:Ege});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ge(e){const n={x:ae(e,"x","log1p")};return me.runKernel(T0,n)}const Gj=ve({log1p_:_ge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Age(e,t){Y(R_(e),()=>"The f passed in variableGrads(f) must be a function"),Y(t==null||Array.isArray(t)&&t.every(u=>u instanceof Y2),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=t!=null;if(!n){t=[];for(const u in me.registeredVariables)t.push(me.registeredVariables[u])}const r=n?t.filter(u=>!u.trainable):null,s=t.length;t=t.filter(u=>u.trainable),Y(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const a=!0,{value:i,grads:o}=me.gradients(e,t,null,a);Y(o.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Y(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return t.forEach((u,c)=>{o[c]!=null&&(l[u.name]=o[c])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:i,grads:l}}function _g(e){return me.customGrad(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rge(e){const n={x:ae(e,"x","neg")};return me.runKernel(qS,n)}const Lr=ve({neg_:Rge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dge(e){const n={x:ae(e,"x","softplus")};return me.runKernel(U0,n)}const e1=ve({softplus_:Dge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fge(e){const t=ae(e,"x","logSigmoid");return _g(r=>({value:Lr(e1(Lr(r))),gradFunc:i=>fe(i,hy(Lr(r)))}))(t)}const Oge=ve({logSigmoid_:Fge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mge(e,t){let n=ae(e,"a","sub"),r=ae(t,"b","sub");[n,r]=Pr(n,r);const s={a:n,b:r};return me.runKernel(H0,s)}const Bt=ve({sub_:Mge});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lge(e,t=-1){const n=ae(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return _g((s,a)=>{const o=Yo(s,t,!0),l=Bt(s,o),u=Bt(lt(l,"float32"),Ql(Ft(Jl(l),t,!0)));return a([u]),{value:u,gradFunc:(d,p)=>{const[h]=p,m=!0,g=Jl(h);return Bt(d,fe(Ft(d,t,m),g))}}})(n)}const jj=ve({logSoftmax_:Lge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pge(e,t=null,n=!1){const r=ae(e,"x","logSumExp"),s=un(t,r.shape),a=Yo(r,s,!0),i=Bt(r,a),o=Jl(i),l=Ft(o,s),u=Ql(l),c=He(be(a,u.shape),u);if(n){const d=Jr(c.shape,s);return be(c,d)}return c}const Hj=ve({logSumExp_:Pge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zge(e,t){const n=ae(e,"a","logicalAnd","bool"),r=ae(t,"b","logicalAnd","bool");Jt(n.shape,r.shape);const s={a:n,b:r};return me.runKernel(LS,s)}const Lu=ve({logicalAnd_:zge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bge(e){const n={x:ae(e,"x","logicalNot","bool")};return me.runKernel(PS,n)}const KD=ve({logicalNot_:Bge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wge(e,t){const n=ae(e,"a","logicalOr","bool"),r=ae(t,"b","logicalOr","bool");Jt(n.shape,r.shape);const s={a:n,b:r};return me.runKernel(zS,s)}const qj=ve({logicalOr_:Wge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vge(e,t){const n=ae(e,"a","logicalXor","bool"),r=ae(t,"b","logicalXor","bool");return Jt(n.shape,r.shape),Lu(qj(e,t),KD(Lu(e,t)))}const Uge=ve({logicalXor_:Vge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gge(e,t,n,r,s){const a=ae(e,"x","maxPool"),i=1;let o=a,l=!1;a.rank===3&&(l=!0,o=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Y(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),Y(ua(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),ri("maxPool",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=me.runKernel(VS,u,c);return l?be(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const XD=ve({maxPool_:Gge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jge(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=ae(e,"x","maxPool3d");let o=i,l=!1;i.rank===4&&(l=!0,o=be(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),Y(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),ri("maxPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=me.runKernel(US,u,c);return l?be(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Hge=ve({maxPool3d_:jge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qge(e,t){let n=ae(e,"a","maximum"),r=ae(t,"b","maximum");[n,r]=Pr(n,r),n.dtype==="bool"&&(n=lt(n,"int32"),r=lt(r,"int32")),Jt(n.shape,r.shape);const s={a:n,b:r};return me.runKernel($0,s)}const Sd=ve({maximum_:qge});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kge(e,t=null,n=!1){const s={x:ae(e,"x","mean")},a={axis:t,keepDims:n};return me.runKernel(GS,s,a)}const qr=ve({mean_:Kge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Es(e,t="float32"){if(ju(e),t==="complex64"){const r=Es(e,"float32"),s=Es(e,"float32");return $g(r,s)}const n=aa(Oe(e),t);return me.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cd(e,t="float32"){if(ju(e),t==="complex64"){const r=Cd(e,"float32"),s=Es(e,"float32");return $g(r,s)}const n=qR(Oe(e),t);return me.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xge(e,t){let n=ae(e,"a","minimum"),r=ae(t,"b","minimum");[n,r]=Pr(n,r),n.dtype==="bool"&&(n=lt(n,"int32"),r=lt(r,"int32")),Jt(n.shape,r.shape);const s={a:n,b:r};return me.runKernel(E0,s)}const yv=ve({minimum_:Xge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yge(e,t,n){Y(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=ae(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Y(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)Y(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Y(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`);const a={paddings:t,mode:n},i={x:r};return me.runKernel(HS,i,a)}const Zge=ve({mirrorPad_:Yge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jge(e,t){let n=ae(e,"a","mod"),r=ae(t,"b","mod");[n,r]=Pr(n,r);const s={a:n,b:r};return me.runKernel(_0,s)}const Qge=ve({mod_:Jge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eye(e,t=null,n=!1){e=ae(e,"x","moments");const r=un(t,e.shape),s=qr(e,r,n);let a=s.shape;n||(a=Jr(s.shape,r));const i=hr(Bt(lt(e,"float32"),be(s,a))),o=qr(i,r,n);return{mean:s,variance:o}}const YD=ve({moments_:eye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tye(e,t){let n=ae(e,"a","notEqual","string_or_numeric"),r=ae(t,"b","notEqual","string_or_numeric");[n,r]=Pr(n,r),Jt(n.shape,r.shape);const s={a:n,b:r};return me.runKernel(KS,s)}const Q2=ve({notEqual_:tye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nye(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const i={indices:ae(e,"indices","oneHot","int32")},o={dtype:s,depth:t,onValue:n,offValue:r};return me.runKernel(YS,i,o)}const Kj=ve({oneHot_:nye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rye(e){const n={x:ae(e,"x","onesLike")};return me.runKernel(XS,n)}const ko=ve({onesLike_:rye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sye(e,t,n=0){const r=ae(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return me.runKernel(JS,a,s)}const ZD=ve({pad_:sye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aye(e,t,n){const r=ae(e,"x","spaceToBatchND");Y(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),Y(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Y(r.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const s={x:r},a={blockShape:t,paddings:n};return me.runKernel(lC,s,a)}const JD=ve({spaceToBatchND_:aye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iye(e,t,n,r,s,a,i){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");const o=ae(e,"x","maxPool");let l=o,u=!1;o.rank===3&&(u=!0,l=be(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(ua(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const c=So(l.shape,t,a,s,r),d=[c.dilationHeight,c.dilationWidth];let p;r==="same"?p=lye([c.filterHeight,c.filterWidth],d):p=[[0,0],[0,0]];const h=d[0]===1&&d[1]===1,[m,g]=oye([c.inHeight,c.inWidth],d,p),y=h?r:"valid",b=h?l:JD(l,d,m),k=(n==="avg"?()=>py(b,t,a,y,i):()=>XD(b,t,a,y,i))(),I=h?k:BD(k,d,g);return u?be(I,[I.shape[1],I.shape[2],I.shape[3]]):I}function oye(e,t,n){const r=n.map(c=>c[0]),s=n.map(c=>c[1]),a=e.concat(r,s),i=t.map((c,d)=>(c-a[d]%c)%c),o=s.map((c,d)=>c+i[d]),l=t.map((c,d)=>[r[d],o[d]]),u=t.map((c,d)=>[0,i[d]]);return[l,u]}function lye(e,t){const r=e.map((i,o)=>i+(i-1)*(t[o]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),a=r.map((i,o)=>i-s[o]);return r.map((i,o)=>[s[o],a[o]])}const uye=ve({pool_:iye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cye(e,t){const n=ae(e,"x","prelu"),r=ae(t,"alpha","prelu"),s={x:n,alpha:r};return me.runKernel(QS,s)}const QD=ve({prelu_:cye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dye(e,t=null,n=!1){let r=ae(e,"x","prod");r.dtype==="bool"&&(r=lt(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return me.runKernel(eC,s,a)}const pye=ve({prod_:dye});var y2={exports:{}},hye=y2.exports,BW;function fye(){return BW||(BW=1,function(e){(function(t,n,r){function s(l){var u=this,c=o();u.next=function(){var d=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=d-(u.c=d|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function a(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function i(l,u){var c=new s(l),d=u&&u.state,p=c.next;return p.int32=function(){return c.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,d&&(typeof d=="object"&&a(d,c),p.state=function(){return a(c,{})}),p}function o(){var l=4022871197,u=function(c){c=String(c);for(var d=0;d<c.length;d++){l+=c.charCodeAt(d);var p=.02519603282416938*l;l=p>>>0,p-=l,p*=l,l=p>>>0,p-=l,l+=p*4294967296}return(l>>>0)*23283064365386963e-26};return u}n&&n.exports?n.exports=i:this.alea=i})(hye,e)}(y2)),y2.exports}var x2={exports:{}},mye=x2.exports,WW;function gye(){return WW||(WW=1,function(e){(function(t,n,r){function s(o){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},o===(o|0)?l.x=o:u+=o;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function i(o,l){var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,h=(u.next()>>>0)/4294967296,m=(p+h)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:this.xor128=i})(mye,e)}(x2)),x2.exports}var b2={exports:{}},yye=b2.exports,VW;function xye(){return VW||(VW=1,function(e){(function(t,n,r){function s(o){var l=this,u="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:u+=o;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function i(o,l){var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,h=(u.next()>>>0)/4294967296,m=(p+h)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:this.xorwow=i})(yye,e)}(b2)),b2.exports}var v2={exports:{}},bye=v2.exports,UW;function vye(){return UW||(UW=1,function(e){(function(t,n,r){function s(o){var l=this;l.next=function(){var c=l.x,d=l.i,p,h;return p=c[d],p^=p>>>7,h=p^p<<24,p=c[d+1&7],h^=p^p>>>10,p=c[d+3&7],h^=p^p>>>3,p=c[d+4&7],h^=p^p<<7,p=c[d+7&7],p=p^p<<13,h^=p^p<<9,c[d]=h,l.i=d+1&7,h};function u(c,d){var p,h=[];if(d===(d|0))h[0]=d;else for(d=""+d,p=0;p<d.length;++p)h[p&7]=h[p&7]<<15^d.charCodeAt(p)+h[p+1&7]<<13;for(;h.length<8;)h.push(0);for(p=0;p<8&&h[p]===0;++p);for(p==8?h[7]=-1:h[p],c.x=h,c.i=0,p=256;p>0;--p)c.next()}u(l,o)}function a(o,l){return l.x=o.x.slice(),l.i=o.i,l}function i(o,l){o==null&&(o=+new Date);var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,h=(u.next()>>>0)/4294967296,m=(p+h)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,c&&(c.x&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:this.xorshift7=i})(bye,e)}(v2)),v2.exports}var w2={exports:{}},wye=w2.exports,GW;function kye(){return GW||(GW=1,function(e){(function(t,n,r){function s(o){var l=this;l.next=function(){var c=l.w,d=l.X,p=l.i,h,m;return l.w=c=c+1640531527|0,m=d[p+34&127],h=d[p=p+1&127],m^=m<<13,h^=h<<17,m^=m>>>15,h^=h>>>12,m=d[p]=m^h,l.i=p,m+(c^c>>>16)|0};function u(c,d){var p,h,m,g,y,b=[],v=128;for(d===(d|0)?(h=d,d=null):(d=d+"\0",h=0,v=Math.max(v,d.length)),m=0,g=-32;g<v;++g)d&&(h^=d.charCodeAt((g+32)%d.length)),g===0&&(y=h),h^=h<<10,h^=h>>>15,h^=h<<4,h^=h>>>13,g>=0&&(y=y+1640531527|0,p=b[g&127]^=h+y,m=p==0?m+1:0);for(m>=128&&(b[(d&&d.length||0)&127]=-1),m=127,g=4*128;g>0;--g)h=b[m+34&127],p=b[m=m+1&127],h^=h<<13,p^=p<<17,h^=h>>>15,p^=p>>>12,b[m]=h^p;c.w=y,c.X=b,c.i=m}u(l,o)}function a(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function i(o,l){o==null&&(o=+new Date);var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,h=(u.next()>>>0)/4294967296,m=(p+h)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,c&&(c.X&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:this.xor4096=i})(wye,e)}(w2)),w2.exports}var k2={exports:{}},Iye=k2.exports,jW;function Sye(){return jW||(jW=1,function(e){(function(t,n,r){function s(o){var l=this,u="";l.next=function(){var d=l.b,p=l.c,h=l.d,m=l.a;return d=d<<25^d>>>7^p,p=p-h|0,h=h<<24^h>>>8^m,m=m-d|0,l.b=d=d<<20^d>>>12^p,l.c=p=p-h|0,l.d=h<<16^p>>>16^m,l.a=m-d|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):u+=o;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function a(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function i(o,l){var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,h=(u.next()>>>0)/4294967296,m=(p+h)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:this.tychei=i})(Iye,e)}(k2)),k2.exports}var I2={exports:{}};const Cye={},Nye=Object.freeze(Object.defineProperty({__proto__:null,default:Cye},Symbol.toStringTag,{value:"Module"})),Tye=Zae(Nye);var $ye=I2.exports,HW;function Eye(){return HW||(HW=1,function(e){(function(t,n,r){var s=256,a=6,i=52,o="random",l=r.pow(s,a),u=r.pow(2,i),c=u*2,d=s-1,p;function h(I,S,N){var T=[];S=S==!0?{entropy:!0}:S||{};var A=b(y(S.entropy?[I,k(n)]:I??v(),3),T),R=new m(T),D=function(){for(var $=R.g(a),_=l,L=0;$<u;)$=($+L)*s,_*=s,L=R.g(1);for(;$>=c;)$/=2,_/=2,L>>>=1;return($+L)/_};return D.int32=function(){return R.g(4)|0},D.quick=function(){return R.g(4)/4294967296},D.double=D,b(k(R.S),n),(S.pass||N||function($,_,L,z){return z&&(z.S&&g(z,R),$.state=function(){return g(R,{})}),L?(r[o]=$,_):$})(D,A,"global"in S?S.global:this==r,S.state)}function m(I){var S,N=I.length,T=this,A=0,R=T.i=T.j=0,D=T.S=[];for(N||(I=[N++]);A<s;)D[A]=A++;for(A=0;A<s;A++)D[A]=D[R=d&R+I[A%N]+(S=D[A])],D[R]=S;(T.g=function($){for(var _,L=0,z=T.i,W=T.j,G=T.S;$--;)_=G[z=d&z+1],L=L*s+G[d&(G[z]=G[W=d&W+_])+(G[W]=_)];return T.i=z,T.j=W,L})(s)}function g(I,S){return S.i=I.i,S.j=I.j,S.S=I.S.slice(),S}function y(I,S){var N=[],T=typeof I,A;if(S&&T=="object")for(A in I)try{N.push(y(I[A],S-1))}catch{}return N.length?N:T=="string"?I:I+"\0"}function b(I,S){for(var N=I+"",T,A=0;A<N.length;)S[d&A]=d&(T^=S[d&A]*19)+N.charCodeAt(A++);return k(S)}function v(){try{var I;return p&&(I=p.randomBytes)?I=I(s):(I=new Uint8Array(s),(t.crypto||t.msCrypto).getRandomValues(I)),k(I)}catch{var S=t.navigator,N=S&&S.plugins;return[+new Date,t,N,t.screen,k(n)]}}function k(I){return String.fromCharCode.apply(0,I)}if(b(r.random(),n),e.exports){e.exports=h;try{p=Tye}catch{}}else r["seed"+o]=h})(typeof self<"u"?self:$ye,[],Math)}(I2)),I2.exports}var wE,qW;function _ye(){if(qW)return wE;qW=1;var e=fye(),t=gye(),n=xye(),r=vye(),s=kye(),a=Sye(),i=Eye();return i.alea=e,i.xor128=t,i.xorwow=n,i.xorshift7=r,i.xor4096=s,i.tychei=a,wE=i,wE}var eF=_ye();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xj{constructor(t,n,r,s,a){this.mean=t,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=a||Math.random();this.random=eF.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,n,r=!1;for(;!r;){let s,a,i;do s=2*this.random()-1,a=2*this.random()-1,i=s*s+a*a;while(i>=1||i===0);const o=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*s*o,n=this.mean+this.stdDev*a*o,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class Aye{constructor(t=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=n-t,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`);this.random=eF.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rye(e,t=0,n=1,r,s){if(ju(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const a=new Xj(t,n,r,!1,s),i=ln(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Dye=ve({randomNormal_:Rye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fye(e,t=0,n=1,r="float32",s){ju(e);const a=ln(e,r),i=new Aye(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const t1=ve({randomUniform_:Fye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xv(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return me.runKernel(ND,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oye(e){const n={input:ae(e,"input","real")};return me.runKernel(TD,n)}const eI=ve({real_:Oye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mye(e){const n={x:ae(e,"x","reciprocal")};return me.runKernel(D0,n)}const Lye=ve({reciprocal_:Mye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pye(e){const n={x:ae(e,"x","relu")};return me.runKernel(F0,n)}const Oh=ve({relu_:Pye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zye(e){const n={x:ae(e,"x","relu6")};return me.runKernel(O0,n)}const Yj=ve({relu6_:zye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bye(e,t){const r={x:ae(e,"x","reverse")},s={dims:t};return me.runKernel(sC,r,s)}const ih=ve({reverse_:Bye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wye(e){const n={x:ae(e,"x","round")};return me.runKernel(M0,n)}const Zj=ve({round_:Wye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vye(e){const n={x:ae(e,"x","rsqrt","float32")};return me.runKernel(L0,n)}const Jj=ve({rsqrt_:Vye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uye(e){const n={x:ae(e,"x","selu")};return me.runKernel(P0,n)}const Qj=ve({selu_:Uye});function Gye(e,t,n,r,s,a=[1,1],i="NHWC"){const o=ae(e,"x","separableConv2d"),l=ae(t,"depthwiseFilter","separableConv2d"),u=ae(n,"pointwiseFilter","separableConv2d");let c=o,d=!1;if(o.rank===3&&(d=!0,c=be(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Y(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),Y(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),Y(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),Y(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),Y(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const p=l.shape[2],h=l.shape[3];Y(u.shape[2]===p*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*h}, but got ${u.shape[2]}.`);const m=UD(c,l,r,s,i,a),y=sh(m,u,1,"valid",i);return d?be(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const eH=ve({separableConv2d_:Gye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jye(e){const n={x:ae(e,"x","sign")};return me.runKernel(W0,n)}const Hye=ve({sign_:jye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qye(e){const n={x:ae(e,"x","sin","float32")};return me.runKernel(z0,n)}const tH=ve({sin_:qye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kye(e){const n={x:ae(e,"x","sinh")};return me.runKernel(B0,n)}const nH=ve({sinh_:Kye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xye(e,t,n){const r=ae(e,"x","slice1d");return Y(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),ar(r,[t],[n])}const tF=ve({slice1d_:Xye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yye(e,t,n){const r=ae(e,"x","slice2d");return Y(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),ar(r,t,n)}const rH=ve({slice2d_:Yye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zye(e,t,n){const r=ae(e,"x","slice3d");return Y(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),ar(r,t,n)}const nF=ve({slice3d_:Zye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jye(e,t,n){const r=ae(e,"x","slice4d");return Y(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),ar(r,t,n)}const tI=ve({slice4d_:Jye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qye(e,t=-1){const n=ae(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return me.runKernel(cC,r,s)}const rF=ve({softmax_:Qye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function exe(e){Y(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return me.runKernel(mD,t)}const sH=ve({fft_:exe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function txe(e){Y(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return me.runKernel(xD,t)}const Y_=ve({ifft_:txe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nxe(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=be(e,[n,t]);r=Y_(s)}else{const s=[n,2*(t-1)],a=be(eI(e),[n,t]),i=be(HD(e),[n,t]),o=ih(ar(a,[0,1],[n,t-2]),1),l=fe(ih(ar(i,[0,1],[n,t-2]),1),Rn(-1)),u=Ka([a,o],1),c=Ka([i,l],1),d=be($g(u,c),[s[0],s[1]]);r=Y_(d)}if(r=eI(r),e.rank===3&&e.shape[0]!==0){const s=r,a=e.shape[0];r=be(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}const rxe=ve({irfft_:nxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sxe(e,t,n=0){const s={x:ae(e,"x","split")},a={numOrSizeSplits:t,axis:n};return me.runKernel(uC,s,a)}const ji=ve({split_:sxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function axe(e,t){Y(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(t!=null&&t<n){const m=e.shape.map(y=>0),g=e.shape.map(y=>y);g[e.shape.length-1]=t,s=ar(e,m,g),n=t}else if(t!=null&&t>n){const m=e.shape.map(g=>g);m[e.shape.length-1]=t-n,s=Ka([e,Es(m)],e.shape.length-1),n=t}else s=e;const a=vn(s),i=be($g(s,a),[r,n]),o=sH(i),l=Math.floor(n/2)+1,u=eI(o),c=HD(o),d=ji(u,[l,n-l],u.shape.length-1),p=ji(c,[l,n-l],c.shape.length-1),h=s.shape.slice();return h[s.shape.length-1]=l,be($g(d[0],p[0]),h)}const ixe=ve({rfft_:axe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oxe(e,t){let n=ae(e,"a","squaredDifference"),r=ae(t,"b","squaredDifference");[n,r]=Pr(n,r),Jt(n.shape,r.shape);const s={a:n,b:r},a={};return me.runKernel(j0,s,a)}const lxe=ve({squaredDifference_:oxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uxe(e,t){const n=ae(e,"x","squeeze","string_or_numeric");return be(n,vd(n.shape,t).newShape)}const n1=ve({squeeze_:uxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cxe(e,t=0){const n=Ij(e,"tensors","stack","string_or_numeric");Y(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Y(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:t};return me.runKernel(ZS,r,s)}const Pu=ve({stack_:cxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dxe(e,t=0){const r={x:ae(e,"x","step")},s={alpha:t};return me.runKernel(Y0,r,s)}const r1=ve({step_:dxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pxe(e,t,n,r,s=0,a=0,i=0,o=0,l=0){const c={x:ae(e,"x","stridedSlice","string_or_numeric")},d={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return me.runKernel(RD,c,d)}const hxe=ve({stridedSlice_:pxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fxe(e){const n={x:ae(e,"x","tan","float32")};return me.runKernel(q0,n)}const mxe=ve({tan_:fxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yi(e,t){HR(e);const n=Z0(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return J0(e,null,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kE(e,t,n){if(HR(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Z0(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return J0(e,t,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gxe(e,t,n){if(HR(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=Z0(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return J0(e,t,r,n)}function aH(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+` update.rank != ${s+e.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function yxe(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}aH(n,t,e)}function Mh(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let d=s;d<a;++d)i*=n[d];const o=s<1?1:s,l=Oe(t.shape)/o,u=[..._t(n.slice(0,s)),1],c=Oe(n);return{sliceRank:s,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xxe(e,t=1,n=!0){const r=ae(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,l]=me.runKernel(DD,a,i);return{values:o,indices:l}}const bxe=ve({topk_:xxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vxe(e,t=0,n=1,r,s){if(ju(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new Xj(t,n,r,!0,s),i=ln(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const iH=ve({truncatedNormal_:vxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wxe(e,t=0){const n=ae(e,"x","unique","string_or_numeric");Y(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:t},[a,i]=me.runKernel(OD,r,s);return{values:a,indices:i}}const kxe=ve({unique_:wxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ixe(e,t,n){const r=ae(e,"x","unsortedSegmentSum"),s=ae(t,"segmentIds","unsortedSegmentSum","int32");Y(Ng(n),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:s},i={numSegments:n};return me.runKernel(pC,a,i)}const oH=ve({unsortedSegmentSum_:Ixe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sxe(e,t=0){const n=ae(e,"x","unstack","string_or_numeric");Y(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:t};return me.runKernel(dC,r,s)}const oh=ve({unstack_:Sxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cxe(e,t=!0,n,r){return me.makeVariable(e,t,n,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lH(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const r=ln(e,"int32"),s=ln([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const i=r.indexToLoc(n[a]),o=a*e.length;s.values.set(i,o)}return s.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxe(e,t,n){const r=ae(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),Y(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{Y(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return r.dtype==="complex64"?Se(()=>{let i=eI(r),o=HD(r);return i=me.runKernel(fg,{x:i},a),o=me.runKernel(fg,{x:o},a),n&&(o=Lr(o)),$g(i,o)}):me.runKernel(fg,s,a)}const bn=ve({transpose_:Nxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Txe(e,t){if(t==null)return e.shape.slice();if(Dn(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $xe(e,t,n,r){const s=ae(e,"x","dropout");if(Y(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),Y(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof os?s.clone():s;const a=Txe(s,n),i=1-t,o=Ot(vC(He(t1(a,0,1,"float32",r),i)),i);return fe(s,o)}const Exe=ve({dropout_:$xe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _xe(e,t,n,r,s,a="NHWC",i){let o=e;e.rank===3&&(o=be(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=be(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Y(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),Y(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),Y(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u=a==="NHWC"?o.shape[3]:o.shape[1],c=a==="NHWC"?l.shape[3]:l.shape[1];Y(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),Y(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),ri("conv2dDerFilter",s,i);const d={x:o,dy:l},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return me.runKernel(sD,d,p)}const sF=ve({conv2DBackpropFilter_:_xe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aF(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return fe(e,r1(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function iF(e,t){let n=t;const r=ys(e.shape,t.shape);return r.length>0&&(n=Ft(n,r)),be(n,e.shape)}function oF(e,t,n,r){if(t==="linear")return e;if(t==="relu")return Oh(e);if(t==="elu")return xC(e);if(t==="relu6")return Yj(e);if(t==="prelu")return QD(e,n);if(t==="leakyrelu")return qD(e,r);if(t==="sigmoid")return hy(e);throw new Error(`Unknown fused activation ${t}.`)}const lF=(e,t)=>!(e>0)||t==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Axe({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",lF(me.state.gradientDepth,l)===!1){Y(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=sh(e,t,n,r,s,a,i);return o!=null&&(N=He(N,o)),oF(N,l,u,c)}const d=ae(e,"x","conv2d","float32"),p=ae(t,"filter","conv2d","float32");let h=d,m=!1;d.rank===3&&(m=!0,h=be(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Y(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),Y(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),ri("fused conv2d",r,i);const g=s==="NHWC"?h.shape[3]:h.shape[1];Y(p.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`),Y(ua(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const y=Xs(h.shape,p.shape,n,a,r,i);let b;o!=null&&(b=ae(o,"bias","fused conv2d"),[b]=Pr(b,d),s==="NHWC"?Jt(y.outShape,b.shape):(Y(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),Y(b.shape.length===0||b.shape[0]===y.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let v;if(u!=null){const N=u.shape;if(Y(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)Y(N[0]===1||N[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${y.outChannels}).`);else if(N.length===3)try{Jt(N,y.outShape)}catch{const A=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(A)}v=ae(u,"prelu weights","fused conv2d")}const k=(N,T)=>{Y(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[A,R,D,$]=T,_=aF(N,D,l);Y(nh(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const L=WD(R.shape,_,A,n,r),z=sF(R,_,A.shape,n,r),W=[L,z];if($!=null){const G=iF($,_);W.push(G)}return W},I={x:h,filter:p,bias:b,preluActivationWeights:v},S={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?_g((T,A,R)=>{let D=me.runKernel(K2,I,S);return R([A,T,D]),m&&(D=be(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:k}})(h,p):_g((T,A,R,D)=>{let $=me.runKernel(K2,I,S);return D([A,T,$,R]),m&&($=be($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:k}})(h,p,b)}const Rxe=ve({fusedConv2d_:Axe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dxe(e,t,n,r,s,a=[1,1],i){let o=e;e.rank===3&&(o=be(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=be(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return me.runKernel(dD,u,c)}const Fxe=ve({depthwiseConv2dNativeBackpropFilter_:Dxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oxe(e,t,n,r,s,a=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=be(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},d=me.runKernel(pD,u,c);return l?be(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Mxe=ve({depthwiseConv2dNativeBackpropInput_:Oxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lxe({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(lF(me.state.gradientDepth,a)===!1){let $=An(e,t,n,r);return s!=null&&($=He($,s)),oF($,a,i,o)}let l=ae(e,"a","fused matMul"),u=ae(t,"b","fused matMul");[l,u]=Pr(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),g=u.shape.slice(0,-2),y=Oe(m),b=Oe(g);Y(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);const k=Jt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,h]),I=n?be(l,[y,c,p]):be(l,[y,p,c]),S=r?be(u,[b,h,d]):be(u,[b,d,h]);let N;s!=null&&(N=ae(s,"bias","fused matMul"),[N]=Pr(N,l),Jt(k,N.shape));let T;i!=null&&(T=ae(i,"prelu weights","fused matMul"));const A=($,_)=>{const[L,z,W,G]=_,q=aF(be($,W.shape),W,a);let B,j;if(!n&&!r?(B=An(q,z,!1,!0),j=An(L,q,!0,!1)):!n&&r?(B=An(q,z,!1,!1),j=An(q,L,!0,!1)):n&&!r?(B=An(z,q,!1,!0),j=An(L,q,!1,!1)):(B=An(z,q,!0,!0),j=An(q,L,!0,!0)),s!=null){const H=iF(G,q);return[B,j,H]}else return[B,j]},R={a:I,b:S,bias:N,preluActivationWeights:T},D={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};return s==null?_g((_,L,z)=>{const W=me.runKernel(q2,R,D);return z([_,L,W]),{value:be(W,k),gradFunc:A}})(I,S):_g((_,L,z,W)=>{const G=me.runKernel(q2,R,D);return W([_,L,G,z]),{value:be(G,k),gradFunc:A}})(I,S,N)}const KW=ve({fusedMatMul_:Lxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pxe(e,t,n,r,s="bilinear",a=0){const i=ae(e,"image","cropAndResize"),o=ae(t,"boxes","cropAndResize","float32"),l=ae(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Y(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),Y(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),Y(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),Y(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),Y(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),Y(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:i,boxes:o,boxInd:l},d={method:s,extrapolationValue:a,cropSize:r};return me.runKernel(lD,c,d)}const zxe=ve({cropAndResize_:Pxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bxe(e){const t=ae(e,"image","flipLeftRight","float32");Y(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};return me.runKernel(yD,n,{})}const Wxe=ve({flipLeftRight_:Bxe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vxe(e){const t=ae(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Y(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),Y(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,Ko(t,s)}const Uxe=ve({grayscaleToRGB_:Vxe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gxe(e){const t=ae(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Y(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),Y(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=t.dtype,a=lt(t,"float32"),i=yi([.2989,.587,.114]);let o;switch(t.rank){case 2:o=Ab("ij,j->i",a,i);break;case 3:o=Ab("ijk,k->ij",a,i);break;case 4:o=Ab("ijkl,l->ijk",a,i);break;case 5:o=Ab("ijklm,m->ijkl",a,i);break;case 6:o=Ab("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=Va(o,-1),lt(o,s)}const jxe=ve({rgbToGrayscale_:Gxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hxe(e,t,n=0,r=.5){const s=ae(e,"image","rotateWithOffset","float32");Y(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const a={image:s},i={radians:t,fillValue:n,center:r};return me.runKernel(MD,a,i)}const qxe=ve({rotateWithOffset_:Hxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function my(e,t,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);const i=e.shape[0];return n=Math.min(n,i),Y(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),Y(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),Y(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),Y(t.rank===1,()=>"scores must be a 1D tensor"),Y(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),Y(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kxe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=ae(e,"boxes","nonMaxSuppression","float32"),i=ae(t,"scores","nonMaxSuppression","float32"),o=my(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return me.runKernel(ID,{boxes:a,scores:i},l)}const Xxe=ve({nonMaxSuppression_:Kxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yxe(e,t,n){const r=Zxe(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function Zxe(e,t,n){return Qxe(e,t,n||Jxe)}function Jxe(e,t){return e>t?1:e<t?-1:0}function Qxe(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uF(e,t,n,r,s){return pF(e,t,n,r,s,0)}function cF(e,t,n,r,s,a){return pF(e,t,n,r,s,0,!1,a,!0)}function dF(e,t,n,r,s,a){return pF(e,t,n,r,s,a,!0)}function pF(e,t,n,r,s,a,i=!1,o=!1,l=!1){const u=[];for(let y=0;y<t.length;y++)t[y]>s&&u.push({score:t[y],boxIndex:y,suppressBeginIndex:0});u.sort(XW);const c=a>0?-.5/a:0,d=[],p=[];for(;d.length<n&&u.length>0;){const y=u.pop(),{score:b,boxIndex:v,suppressBeginIndex:k}=y;if(b<s)break;let I=!1;for(let S=d.length-1;S>=k;--S){const N=ebe(e,v,d[S]);if(N>=r){I=!0;break}if(y.score=y.score*tbe(r,c,N),y.score<=s)break}y.suppressBeginIndex=d.length,I||(y.score===b?(d.push(v),p.push(y.score)):y.score>s&&Yxe(u,y,XW))}const h=d.length,m=n-h;o&&m>0&&(d.push(...new Array(m).fill(0)),p.push(...new Array(m).fill(0)));const g={selectedIndices:d};return i&&(g.selectedScores=p),l&&(g.validOutputs=h),g}function ebe(e,t,n){const r=e.subarray(t*4,t*4+4),s=e.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),h=(o-a)*(l-i),m=(d-u)*(p-c);if(h<=0||m<=0)return 0;const g=Math.max(a,u),y=Math.max(i,c),b=Math.min(o,d),v=Math.min(l,p),k=Math.max(b-g,0)*Math.max(v-y,0);return k/(h+m-k)}function tbe(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function XW(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nbe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=ae(e,"boxes","nonMaxSuppressionAsync"),i=ae(t,"scores","nonMaxSuppressionAsync"),o=my(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=uF(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),yi(d,"int32")}const rbe=nbe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sbe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=ae(e,"boxes","nonMaxSuppression"),o=ae(t,"scores","nonMaxSuppression"),l=my(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},d=me.runKernel(CD,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}const abe=ve({nonMaxSuppressionWithScore_:sbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ibe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=ae(e,"boxes","nonMaxSuppressionAsync"),o=ae(t,"scores","nonMaxSuppressionAsync"),l=my(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:p,selectedScores:h}=dF(c,d,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:yi(p,"int32"),selectedScores:yi(h)}}const obe=ibe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lbe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=ae(e,"boxes","nonMaxSuppression"),o=ae(t,"scores","nonMaxSuppression"),l=my(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,p={boxes:i,scores:o},h={maxOutputSize:u,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:a},m=me.runKernel(SD,p,h);return{selectedIndices:m[0],validOutputs:m[1]}}const ube=ve({nonMaxSuppressionPadded_:lbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function cbe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=ae(e,"boxes","nonMaxSuppressionAsync"),o=ae(t,"scores","nonMaxSuppressionAsync"),l=my(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[p,h]=await Promise.all([i.data(),o.data()]),{selectedIndices:m,validOutputs:g}=cF(p,h,u,c,d,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:yi(m,"int32"),validOutputs:Rn(g,"int32")}}const dbe=cbe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pbe(e,t,n=!1,r=!1){const s=ae(e,"images","resizeBilinear");Y(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),Y(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Y(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=be(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=me.runKernel(rC,o,l);return i?be(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const uH=ve({resizeBilinear_:pbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hbe(e,t,n=!1,r=!1){const s=ae(e,"images","resizeNearestNeighbor");Y(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),Y(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Y(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),Y(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=be(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=me.runKernel(nC,o,l);return i?be(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const cH=ve({resizeNearestNeighbor_:hbe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fbe(e,t="binary",n=!1,r=.5){const s=ae(e,"image","threshold"),a=.2989,i=.587,o=.114,l=s.shape[0]*s.shape[1];let u=fe(yi([r]),255),c,d,p,h;if(Y(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),Y(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),Y(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),Y(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),s.shape[2]===3){[c,d,p]=ji(s,[1,1,1],-1);const y=fe(c,a),b=fe(d,i),v=fe(p,o);h=He(He(y,b),v)}else h=e;if(t==="otsu"){const y=cme(lt(Zj(h),"int32"),Sj([]),256);u=mbe(y,l)}const m=n?fy(h,u):Zi(h,u);return lt(fe(m,255),"int32")}function mbe(e,t){let n=yi([-1]),r=yi([0]),s=yi([0]),a,i,o,l,u,c;for(let d=0;d<e.size-1;d++){a=ar(e,0,d+1),i=ar(e,d+1),u=Ot(Ft(a),t),c=Ot(Ft(i),t);const p=Ft(fe(a,xv(0,a.size)));o=Ot(p,Ft(a));const h=yC(i.shape,a.size),m=He(xv(0,i.size),h),g=fe(i,m);l=Ot(Ft(g),Ft(i));const y=Bt(o,l),b=Bt(o,l),v=fe(u,c);s=fe(fe(v,y),b);const k=Zi(s,r);r=Ta(k,s,r),n=Ta(k,yi([d]),n)}return n}const gbe=ve({threshold_:fbe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ybe(e,t,n="nearest",r="constant",s=0,a){const i=ae(e,"image","transform","float32"),o=ae(t,"transforms","transform","float32");Y(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),Y(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Y(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return me.runKernel(FD,l,u)}const xbe=ve({transform_:ybe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bbe(e,t,n){const r=ae(e,"a","bandPart");Y(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,i]=r.shape.slice(-2);let o,l;typeof t=="number"?(Y(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Y(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),o=ae(t<0?a:t,"numLower","bandPart")):(Y(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Ta(J2(t,0),a,yv(t,a))),typeof n=="number"?(Y(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),Y(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=ae(n<0?i:n,"numUpper","bandPart")):(Y(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Ta(J2(n,0),i,yv(n,i)));const u=be(xv(0,a,1,"int32"),[-1,1]),c=xv(0,i,1,"int32"),d=Bt(u,c),p=Lu(fy(d,o),Fh(d,Lr(l))),h=Es([a,i],r.dtype);return be(Pu(oh(be(r,[-1,a,i])).map(m=>Ta(p,m,h))),s)}const vbe=ve({bandPart_:bbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wbe(e){let t;if(Array.isArray(e)){t=!1,Y(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=e[0].shape[0];for(let a=1;a<e.length;++a)Y(e[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${s})`)}else t=!0,e=ji(e,e.shape[0],0).map(s=>n1(s,[0]));Y(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],r=e;for(let s=0;s<e.length;++s)n.push(me.tidy(()=>{let a=r[s];if(s>0)for(let i=0;i<s;++i){const o=fe(Ft(fe(n[i],a)),n[i]);a=Bt(a,o)}return Ot(a,bC(a,"euclidean"))}));return t?Pu(n,0):n}const kbe=ve({gramSchmidt_:wbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ibe(e,t=!1){if(Y(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return YW(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),r=oh(be(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach(l=>{const[u,c]=YW(l,t);s.push(u),a.push(c)});const i=be(Pu(s,0),e.shape),o=be(Pu(a,0),e.shape);return[i,o]}}function YW(e,t=!1){return me.tidy(()=>{Y(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],r=e.shape[1];let s=Uj(n),a=Wp(e);const i=kE([[1]],[1,1]);let o=Wp(i);const l=n>=r?r:n;for(let u=0;u<l;++u){const c=a,d=o,p=s;[o,a,s]=me.tidy(()=>{const h=ar(a,[u,u],[n-u,1]),m=bC(h),g=ar(a,[u,u],[1,1]),y=Ta(Zi(g,0),kE([[-1]]),kE([[1]])),b=Bt(g,fe(y,m)),v=Ot(h,b);v.shape[0]===1?o=Wp(i):o=Ka([i,ar(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);const k=Lr(Ot(An(y,b),m)),I=ar(a,[u,0],[n-u,r]),S=fe(k,o),N=bn(o);if(u===0)a=Bt(I,An(S,An(N,I)));else{const R=Bt(I,An(S,An(N,I)));a=Ka([ar(a,[0,0],[u,r]),R],0)}const T=bn(S),A=ar(s,[0,u],[n,s.shape[1]-u]);if(u===0)s=Bt(A,An(An(A,o),T));else{const R=Bt(A,An(An(A,o),T));s=Ka([ar(s,[0,0],[n,u]),R],1)}return[o,a,s]}),on([c,d,p])}return!t&&n>r&&(s=ar(s,[0,0],[n,r]),a=ar(a,[0,0],[r,r])),[s,a]})}const Sbe=ve({qr_:Ibe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yo={flipLeftRight:Wxe,grayscaleToRGB:Uxe,resizeNearestNeighbor:cH,resizeBilinear:uH,rgbToGrayscale:jxe,rotateWithOffset:qxe,cropAndResize:zxe,nonMaxSuppression:Xxe,nonMaxSuppressionAsync:rbe,nonMaxSuppressionWithScore:abe,nonMaxSuppressionWithScoreAsync:obe,nonMaxSuppressionPadded:ube,nonMaxSuppressionPaddedAsync:dbe,threshold:gbe,transform:xbe},Cbe={bandPart:vbe,gramSchmidt:kbe,qr:Sbe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nbe=new Map,Tbe=new Map;class gy{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class go{constructor(){this.classNameMap={}}static getMap(){return go.instance==null&&(go.instance=new go),go.instance}static register(t){go.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function ze(e,t,n){Y(e.className!=null,()=>"Class being registered does not have the static className property defined."),Y(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),Y(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);const r=n,s=t+">"+r;return go.register(e),Nbe.set(s,e),Tbe.set(e,s),e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nd extends gy{minimize(t,n=!1,r){const{value:s,grads:a}=this.computeGradients(t,r);if(r!=null){const i=r.map(o=>({name:o.name,tensor:a[o.name]}));this.applyGradients(i)}else this.applyGradients(a);return on(a),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return Age(t,n)}dispose(){this.iterations_!=null&&on(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Rn(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Nd,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dH extends Nd{static get className(){return"Adadelta"}constructor(t,n,r=null){super(),this.learningRate=t,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=me.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=me.registeredVariables[r],i=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:Se(()=>vn(a).variable(i))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:Se(()=>vn(a).variable(i))});const o=Array.isArray(t)?t[s].tensor:t[r];if(o==null)return;const l=this.accumulatedGrads[s].variable,u=this.accumulatedUpdates[s].variable;Se(()=>{const c=He(fe(l,this.rho),fe(hr(o),1-this.rho)),d=fe(Ot(ia(He(u,this.epsilon)),ia(He(l,this.epsilon))),o),p=He(fe(u,this.rho),fe(hr(d),1-this.rho));l.assign(c),u.assign(p);const h=He(fe(d,-this.learningRate),a);a.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(on(this.accumulatedGrads.map(t=>t.variable)),on(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=t.length/2,r=!1;this.accumulatedGrads=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pH extends Nd{static get className(){return"Adagrad"}constructor(t,n=.1){super(),this.learningRate=t,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=me.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:Se(()=>yC(a.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(t)?t[s].tensor:t[r];if(i==null)return;const o=this.accumulatedGrads[s].variable;Se(()=>{const l=He(o,hr(i));o.assign(l);const u=He(fe(Ot(i,ia(He(l,me.backend.epsilon()))),-this.learningRate),a);a.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&on(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulatedGrads=t.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hH extends Nd{static get className(){return"Adam"}constructor(t,n,r,s=null){super(),this.learningRate=t,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Se(()=>{this.accBeta1=Rn(n).variable(),this.accBeta2=Rn(r).variable()}),s==null&&(this.epsilon=me.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);Se(()=>{const r=Bt(1,this.accBeta1),s=Bt(1,this.accBeta2);n.forEach((a,i)=>{const o=me.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:Se(()=>vn(o).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${a}/v`,variable:Se(()=>vn(o).variable(l))});const u=Array.isArray(t)?t[i].tensor:t[a];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedSecondMoment[i].variable,p=He(fe(c,this.beta1),fe(u,1-this.beta1)),h=He(fe(d,this.beta2),fe(hr(u),1-this.beta2)),m=Ot(p,r),g=Ot(h,s);c.assign(p),d.assign(h);const y=He(fe(Ot(m,He(ia(g),this.epsilon)),-this.learningRate),o);o.assign(y)}),this.accBeta1.assign(fe(this.accBeta1,this.beta1)),this.accBeta2.assign(fe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&on(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&on(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),Se(()=>{this.accBeta1.assign(ah(this.beta1,this.iterations_+1)),this.accBeta2.assign(ah(this.beta2,this.iterations_+1))});const n=t.length/2,r=!1;this.accumulatedFirstMoment=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fH extends Nd{static get className(){return"Adamax"}constructor(t,n,r,s=null,a=0){super(),this.learningRate=t,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Se(()=>{this.iteration=Rn(0).variable(),this.accBeta1=Rn(n).variable()}),s==null&&(this.epsilon=me.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);Se(()=>{const r=Bt(1,this.accBeta1),s=Ot(-this.learningRate,He(fe(this.iteration,this.decay),1));n.forEach((a,i)=>{const o=me.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:vn(o).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${a}/v`,variable:vn(o).variable(l)});const u=Array.isArray(t)?t[i].tensor:t[a];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedWeightedInfNorm[i].variable,p=He(fe(c,this.beta1),fe(u,1-this.beta1)),h=fe(d,this.beta2),m=va(u),g=Sd(h,m);c.assign(p),d.assign(g);const y=He(fe(Ot(s,r),Ot(p,He(g,this.epsilon))),o);o.assign(y)}),this.iteration.assign(He(this.iteration,1)),this.accBeta1.assign(fe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&on(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&on(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hF extends Nd{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=Array.isArray(t)?t[s].tensor:t[r];if(a==null)return;const i=me.registeredVariables[r];Se(()=>{const o=He(fe(this.c,a),i);i.assign(o)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Ul(Rn(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mH extends hF{static get className(){return"Momentum"}constructor(t,n,r=!1){super(t),this.learningRate=t,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=Rn(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=me.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:Se(()=>vn(a).variable(!1))});const i=this.accumulations[s].variable,o=Array.isArray(t)?t[s].tensor:t[r];o!=null&&Se(()=>{let l;const u=He(fe(this.m,i),o);this.useNesterov?l=He(fe(this.c,He(o,fe(u,this.m))),a):l=He(fe(this.c,u),a),i.assign(u),a.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&on(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulations=t.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gH extends Nd{static get className(){return"RMSProp"}constructor(t,n=.9,r=0,s=null,a=!1){if(super(),this.learningRate=t,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,s==null&&(this.epsilon=me.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=me.registeredVariables[r],i=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:Se(()=>vn(a).variable(i))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:Se(()=>vn(a).variable(i))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:Se(()=>vn(a).variable(i))});const o=Array.isArray(t)?t[s].tensor:t[r];if(o==null)return;const l=this.accumulatedMeanSquares[s].variable,u=this.accumulatedMoments[s].variable;Se(()=>{const c=He(fe(l,this.decay),fe(hr(o),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[s].variable,p=He(fe(d,this.decay),fe(o,1-this.decay)),h=Ot(fe(o,this.learningRate),ia(Bt(c,He(hr(p),this.epsilon)))),m=He(fe(u,this.momentum),h);l.assign(c),d.assign(p),u.assign(m);const g=Bt(a,m);a.assign(g)}else{const d=He(fe(l,this.decay),fe(hr(o),1-this.decay)),p=He(fe(u,this.momentum),Ot(fe(o,this.learningRate),ia(He(d,this.epsilon))));l.assign(d),u.assign(p);const h=Bt(a,p);a.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&on(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&on(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&on(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2,r=!1;this.accumulatedMeanSquares=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $be=[dH,pH,hH,fH,mH,gH,hF];function Ebe(){for(const e of $be)ze(e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fp;function _be(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)a=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(P_(M_,me.backendName)!=null){const m={pixels:e},g={numChannels:t};return me.runKernel(M_,m,g)}const[u,c]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let d;if(i)d=e.getContext("2d").getImageData(0,0,u,c).data;else if(r||n)d=e.data;else if(a||s||o){if(fp==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")fp=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else fp=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});fp.canvas.width=u,fp.canvas.height=c,fp.drawImage(e,0,0,u,c),d=fp.getImageData(0,0,u,c).data}let p;if(t===4)p=new Int32Array(d);else{const m=u*c;p=new Int32Array(m*t);for(let g=0;g<m;g++)for(let y=0;y<t;++y)p[g*t+y]=d[g*4+y]}return gxe(p,[c,u,t],"int32")}const yH=ve({fromPixels_:_be});function fF(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(Oe(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const o=e.shape,l=s.slice();l.pop();let u=1;for(let d=a;d<n;++d)u*=o[d],l.push(o[d]);const c=[..._t(e.shape).map(d=>d/u),1].slice(0,a);return[l,i,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z_=-2,Abe=-1;function mF(e,t,n){const r=e.shape.length;Y(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),Y(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)Y(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function Rbe(e){const t=[];let n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function gF(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function xH(e,t,n,r){const s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function bH(e,t,n){return n<=e?n:n-(t-1)}function vH(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Dbe(e,t,n,r,s,a,i,o,l){const u=e.length;let c=new Array(u),d=new Array(u),p=new Array(u);if(t.length&&n>0){const h=t[0],m=n+1;c=wH(i,h,m,r,e),d=kH(o,h,m,s,e),p=xH(a,h,m,e)}else for(let h=0;h<u;h++)c[h]=SH(i,r,a,e,h,l),d[h]=CH(o,s,a,e,h,l),p[h]=IH(a,h,l);return{begin:c,end:d,strides:p}}function wH(e,t,n,r,s){const a=[...s],i=vH(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const l=bH(t,n,o);let u=r[l];e&1<<l&&(u=0),a[o]=u}return a}function kH(e,t,n,r,s){const a=[...s],i=vH(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const l=bH(t,n,o);let u=r[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),a[o]=u}for(let o=0;o<a.length;o++){const l=s[o];a[o]<0&&(a[o]+=l),a[o]=Jp(0,a[o],s[o])}return a}function IH(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function SH(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=Jp(0,i,l-1),i}function CH(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),o>0?i=Jp(0,i,l):i=Jp(-1,i,l-1),i}function yF(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function xF(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function wC(e,t,n){let r;const s=e.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(i=>{Y(i!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((i,o)=>i>=0?i:(Y(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,a]}function bF(e,t,n,r,s,a,i,o,l){let u;if(r==null?(u=new Array(t.length),u.fill(1)):u=r,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let k=0;k<d.dims;k++)c&&(1<<k&o)!==0&&d.numAddAxisAfterEllipsis++,1<<k&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const p={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Fbe(d,p);let h=!0,m=!0,g=!0;const y=[],b=[];for(let k=0;k<e.length;++k){if(p.strides[k]===0)throw Error(`strides[${k}] must be non-zero`);const I=!!(p.shrinkAxisMask&1<<k),S=e[k];if(S===-1){y.push(I?1:-1);continue}const N=[p.beginMask&1<<k,p.endMask&1<<k],T=[p.strides[k]>0?0:-1,p.strides[k]>0?S:S-1];if(I&&p.strides[k]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&p.strides[k]===1;const A=!!(p.beginMask&1<<k&&p.endMask&1<<k);if(p.beginValid&&p.endValid){if(I){const _=p.begin[k]<0?S+p.begin[k]:p.begin[k];if(p.begin[k]=_,p.end[k]=p.begin[k]+1,_<0||_>=S)throw Error(`slice index ${p.begin[k]} of dimension ${k} out of bounds.`)}else p.begin[k]=ZW(p.begin[k],0,p.strides[k],S,N,T),p.end[k]=ZW(p.end[k],1,p.strides[k],S,N,T);const $=p.strides[k]===1&&p.begin[k]===0&&p.end[k]===S;h=h&&$,m=m&&(k===0&&p.strides[k]===1||$)}else h=h&&p.strides[k]===1&&A,m=m&&(k===0&&p.strides[k]===1||A);let R,D=!1;if(p.beginValid&&p.endValid?(R=p.end[k]-p.begin[k],D=!0):I?(R=1,D=!0):A&&S>=0&&(p.strides[k]<0?R=-S:R=S,D=!0),D){let $;R===0||R<0!=p.strides[k]<0?$=0:$=Math.trunc(R/p.strides[k])+(R%p.strides[k]!==0?1:0),y.push($)}else y.push(-1)}for(let k=0;k<p.finalShapeGatherIndices.length;++k){const I=p.finalShapeGatherIndices[k];I>=0?b.push(y[I]):I===Z_&&b.push(1)}return{finalShapeSparse:b.filter((k,I)=>p.finalShapeGatherIndices[I]!==Z_),finalShape:b,isIdentity:h,sliceDim0:m,isSimpleSlice:g,begin:p.begin,end:p.end,strides:p.strides}}function Fbe(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Z_),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(Abe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function ZW(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const i=e<0?r+e:e;return i<a[0]?a[0]:i>a[1]?a[1]:i}}const Obe=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:mF,computeFlatOffset:xF,computeOutShape:gF,getNormalizedAxes:Dbe,isSliceContinous:yF,maskToAxes:Rbe,parseSliceParams:wC,sliceInfo:bF,startForAxis:SH,startIndicesWithElidedDims:wH,stopForAxis:CH,stopIndicesWithElidedDims:kH,stridesForAxis:IH,stridesWithElidedDims:xH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mbe{static sgd(t){return new hF(t)}static momentum(t,n,r=!1){return new mH(t,n,r)}static rmsprop(t,n=.9,r=0,s=null,a=!1){return new gH(t,n,r,s,a)}static adam(t=.001,n=.9,r=.999,s=null){return new hH(t,n,r,s)}static adadelta(t=.001,n=.95,r=null){return new dH(t,n,r)}static adamax(t=.002,n=.9,r=.999,s=null,a=0){return new fH(t,n,r,s,a)}static adagrad(t,n=.1){return new pH(t,n)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zm=Mbe;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lbe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function NH(){return new Promise(e=>Lbe(()=>e()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vF(e,t){const n=e[0].length;e.forEach((s,a)=>{Y(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),Y(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=e[0];e.forEach((s,a)=>{for(let i=0;i<n;i++)Y(i===t||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function Gl(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var jo;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(jo||(jo={}));function TH(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function $H(e){const t={FIRST_DIM_SIZE:jo.FIRST_DIM_SIZE,VALUE_ROWIDS:jo.VALUE_ROWIDS,ROW_LENGTHS:jo.ROW_LENGTHS,ROW_SPLITS:jo.ROW_SPLITS,ROW_LIMITS:jo.ROW_LIMITS,ROW_STARTS:jo.ROW_STARTS},n=[];for(const r of e)if(r in t)n.push(t[r]);else break;return n}function EH(e){return e.length===0?0:e[0]===jo.FIRST_DIM_SIZE?e.length-1:e.length}function _H(e,t){if(e==null||t==null)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const a=e[s],i=t[s+1];if(a>=0&&i>=0&&a!==1&&a!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${a} but ragged tensor input.flatValues.shape[${s-e.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wF=30;function kC(e){return e<=wF?e:D_(e,Math.floor(Math.sqrt(e)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kF(e,t,n){const r=n*(typeof e=="number"?e:e[0]),s=t*(typeof e=="number"?e:e[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s1(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const a=t.length;for(let i=0;i<a;++i)s=s.concat([e[i+1]/t[i],t[i]]);s=s.concat(e.slice(a+1))}return s}function a1(e,t,n=!0){const r=[];if(n){r.push(t);for(let s=t+1;s<e;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],a=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?a.push(i):s.push(i);r.push(...s),r.push(0),r.push(...a)}return r}function i1(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function IF(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function SF(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IC=1.7580993408473768,SC=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CF=.3275911,NF=.254829592,TF=-.284496736,$F=1.421413741,EF=-1.453152027,_F=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zu(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function AH(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function RH(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function DH(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function AF(e,t){const n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function FH(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function OH(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function MH(e,t,n){const r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IE="->",Pbe=/->/g,JW=",",QW="...";function RF(e,t){e=e.replace(/\s/g,"");const n=(e.length-e.replace(Pbe,"").length)/IE.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${IE}").`);const[r,s]=e.split(IE);Y(r.indexOf(QW)===-1,()=>`The ellipsis notation ("${QW}") is not supported yet.`);const a=r.split(JW),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let p=0;p<s.length;++p){const h=s[p];if(!a.some(m=>m.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);o.indexOf(h)===-1&&o.push(h)}for(let p=0;p<r.length;++p){const h=r[p];o.indexOf(h)===-1&&h!==JW&&o.push(h)}const l=new Array(a.length);for(let p=0;p<i;++p){if(new Set(a[p].split("")).size!==a[p].length)throw new Error(`Found duplicate axes in input component ${a[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let h=0;h<a[p].length;++h)l[p].push(o.indexOf(a[p][h]))}const u=o.length,c=s.length,d=[];for(let p=c;p<u;++p)d.push(p);return{allDims:o,summedDims:d,idDims:l}}function DF(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function FF(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const a=n[s].shape;for(let i=0;i<t[s].length;++i)r[t[s][i]]===void 0?r[t[s][i]]=a[i]:Y(r[t[s][i]]===a[i],()=>`Expected dimension ${r[t[s][i]]} at axis ${i} of input shaped ${JSON.stringify(a)}, but got dimension ${a[i]}`)}}function OF(e,t){const n=e,r=[];let s=0;e.length===0&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const a=[];for(let i=0;i<n.length;++i){const o=n[i],l=zbe(t,o);for(const u of l)a.indexOf(u)===-1&&(r[i].push(u),a.push(u))}return{path:n,steps:r}}function MF(e){return e.every((t,n)=>t===n)}function zbe(e,t){const n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function LF(e,t,n=0){let r=[];if(typeof t=="number")Y(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);Y(s<=1,()=>"There should be only one negative value in split array.");const a=t.indexOf(-1);if(a!==-1){const i=t.reduce((o,l)=>l>0?o+l:o);t[a]=e.shape[n]-i}Y(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LH(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function PH(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function zH(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BH(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function WH(e,t){return`size ${e} must be non-negative, not ${t}`}function VH(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function UH(e,t){const n=Oe(e),r=Oe(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function GH(e,t){const n=Oe(e),r=Oe(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_(){return"segment ids must be >= 0"}function jH(){return"segment ids are not increasing"}function HH(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function qH(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KH(e,t){let n=!1,r;for(e<=wF?(r=e,n=!0):r=D_(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=D_(e,r+1);return r}function XH(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function PF(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<s;d++)o.push(t.shape[d]);for(let d=n+1;d<a;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}const Bbe=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:PF,computeOutShape:XH,segOpComputeOptimalWindowSize:KH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bu(e){try{return e.map(t=>Yc(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function YH(e){return e.map(t=>Uc(t))}const Wbe=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:NF,ERF_A2:TF,ERF_A3:$F,ERF_A4:EF,ERF_A5:_F,ERF_P:CF,PARALLELIZE_THRESHOLD:wF,get RowPartitionType(){return jo},SELU_SCALE:SC,SELU_SCALEALPHA:IC,applyActivation:oF,assertAndGetBroadcastShape:Jt,assertAxesAreInnerMostDims:Ys,assertParamsConsistent:vF,assignToTypedArray:FH,axesAreInnerMostDims:GD,calculateShapes:Mh,checkEinsumDimSizes:FF,checkPadOnDimRoundingMode:ri,combineLocations:Wj,combineRaggedTensorToTensorShapes:TH,complexWithEvenIndex:RH,complexWithOddIndex:DH,computeConv2DInfo:Xs,computeConv3DInfo:kd,computeDefaultPad:zD,computeDilation2DInfo:Q0,computeOptimalWindowSize:kC,computeOutAndReduceShapes:Os,computeOutShape:Gl,computePool2DInfo:So,computePool3DInfo:Hu,convertConv2DDataFormat:qu,decodeEinsumEquation:RF,eitherStridesOrDilationsAreOne:ua,expandShapeToKeepDim:Jr,exponent:MH,exponents:OH,fromStringArrayToUint8:YH,fromUint8ToStringArray:Bu,getAxesPermutation:_r,getBroadcastDims:Eg,getComplexWithIndex:AF,getEinsumComputePath:OF,getEinsumPermutation:DF,getFusedBiasGradient:iF,getFusedDyActivation:aF,getImageCenter:kF,getInnerMostAxes:zr,getPermuted:a1,getRaggedRank:EH,getReductionAxes:ys,getReshaped:s1,getReshapedPermuted:i1,getRowPartitionTypesHelper:$H,getSliceBeginCoords:IF,getSliceSize:SF,getSparseFillEmptyRowsIndicesDenseShapeMismatch:LH,getSparseFillEmptyRowsNegativeIndexErrorMessage:PH,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:zH,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:VH,getSparseReshapeInputOutputMismatchErrorMessage:GH,getSparseReshapeInputOutputMultipleErrorMessage:UH,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:BH,getSparseReshapeNegativeOutputDimErrorMessage:WH,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:qH,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:J_,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:jH,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:HH,getUndoAxesPermutation:Id,isIdentityPermutation:MF,log:vhe,mergeRealAndImagArrays:zu,prepareAndValidate:fF,prepareSplitSize:LF,segment_util:Bbe,shouldFuse:lF,slice_util:Obe,splitRealAndImagArrays:AH,stridesOrDilationsArePositive:rh,tupleValuesAreOne:nh,upcastType:ki,validateDefaultValueShape:_H,validateInput:yxe,validateUpdateShape:aH,warn:Pi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ebe();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZH={kernelName:fS,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fe(e,r1(lt(n,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vbe={kernelName:n0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=hr(lt(n,"float32")),s=ia(Bt(Rn(1),r));return Lr(Ot(e,s))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ube={kernelName:r0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=ia(Bt(hr(lt(n,"float32")),1));return Ot(e,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gbe={kernelName:cy,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Jt(n.shape,r.shape);return{a:()=>{let o=e;const l=ys(n.shape,s);return l.length>0&&(o=Ft(o,l)),be(o,n.shape)},b:()=>{let o=e;const l=ys(r.shape,s);return l.length>0&&(o=Ft(o,l)),be(o,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jbe={kernelName:YR,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((r,s)=>{n[s]=()=>e.clone()}),n}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hbe={kernelName:mS,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>vn(n)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qbe={kernelName:gS,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>vn(n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kbe={kernelName:s0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ot(e,ia(Bt(Rn(1),hr(lt(n,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xbe={kernelName:a0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=ia(He(Rn(1),hr(lt(n,"float32"))));return Ot(e,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ybe={kernelName:l0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Jt(n.shape,r.shape);return{a:()=>{const o=He(hr(n),hr(r));let l=fe(e,Ot(r,o));const u=ys(n.shape,s);return u.length>0&&(l=Ft(l,u)),be(l,n.shape)},b:()=>{const o=He(hr(n),hr(r));let l=Lr(fe(e,Ot(n,o)));const u=ys(r.shape,s);return u.length>0&&(l=Ft(l,u)),be(l,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zbe={kernelName:i0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ot(e,He(hr(lt(n,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jbe={kernelName:o0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ot(e,Bt(Rn(1),hr(lt(n,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qbe(e,t,n,r,s,a){const i=ae(e,"dy","avgPool3dGrad"),o=ae(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;o.rank===4&&(c=!0,l=be(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=be(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Y(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),Y(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),ri("avgPool3dGrad",s,a);const d={dy:l,input:u},p={filterSize:n,strides:r,pad:s,dimRoundingMode:a},h=me.runKernel(eD,d,p);return c?be(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const eve=ve({avgPool3dGrad_:Qbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tve={kernelName:xS,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>eve(e,r,s,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nve(e,t,n,r,s){const a=ae(e,"dy","avgPoolGrad"),i=ae(t,"input","avgPoolGrad");Y(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,l=a,u=!1;i.rank===3&&(u=!0,o=be(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=be(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Y(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),Y(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c={dy:l,input:o},d={filterSize:n,strides:r,pad:s},p=me.runKernel(QR,c,d);return u?be(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const rve=ve({avgPoolGrad_:nve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sve={kernelName:yS,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>rve(e,r,s,a,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ave={kernelName:bS,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return!a&&!i?{a:()=>An(e,s,!1,!0),b:()=>An(r,e,!0,!1)}:!a&&i?{a:()=>An(e,s,!1,!1),b:()=>An(e,r,!0,!1)}:a&&!i?{a:()=>An(s,e,!1,!0),b:()=>An(r,e,!1,!1)}:{a:()=>An(s,e,!0,!0),b:()=>An(e,r,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ive={kernelName:vS,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>JD(e,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ove={kernelName:yhe,gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let l=s.length-1;l>=0;l--)if(s[l]===a[l])i[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>Ft(e,o,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lve={kernelName:u0,gradFunc:e=>({x:()=>e.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uve={kernelName:c0,gradFunc:e=>({x:()=>vn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cve={kernelName:d0,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>Ta(Lu(Fh(r,s),fy(r,a)),e,vn(e))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dve={kernelName:wS,inputsToSave:["x"],gradFunc:ZH.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pve={kernelName:kS,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map(l=>l.shape),{axis:s}=n,a=un(s,t[0].shape)[0],i=r.map(l=>l[a]);return ji(e,i,a).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hve={kernelName:IS,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return Y(nh(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>WD(r.shape,e,s,i,o,l),filter:()=>sF(r,e,s.shape,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fve={kernelName:SS,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>sh(e,s,a,i,o,1,l),filter:()=>sF(e,r,s.shape,a,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mve(e,t,n,r,s){let a=e;e.rank===4&&(a=be(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=be(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Y(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),Y(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),Y(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),Y(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),Y(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);const o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return me.runKernel(aD,o,l)}const gve=ve({conv3DBackpropFilter_:mve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yve={kernelName:CS,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;Y(nh(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,o]=t;return{x:()=>Lj(i.shape,e,o,s,a),filter:()=>gve(i,e,o.shape,s,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xve={kernelName:p0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fe(Lr(tH(lt(n,"float32"))),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bve={kernelName:h0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fe(nH(lt(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vve={kernelName:NS,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const o=_r([s],r.rank);let l=zj(e,s,a,!i);return o!=null&&(l=bn(l,o)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wve={kernelName:TS,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=r??[1,1];Y(nh(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,u]=t;return Y(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),Y(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),Y(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Y(ua(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),ri("depthwiseConv2d",a,i),{x:()=>Mxe(l.shape,e,u,s,a,o,i),filter:()=>Fxe(l,e,u.shape,s,a,o,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kve={kernelName:$S,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>me.runKernel(F_,a,n),filter:()=>me.runKernel(O_,i,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ive={kernelName:m0,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>me.runKernel(fD,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sve={kernelName:g0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=fe(Jl(Lr(hr(n))),2/Math.sqrt(Math.PI));return{x:()=>fe(e,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cve={kernelName:y0,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fe(e,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nve={kernelName:_S,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>be(e,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tve={kernelName:x0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fe(e,Jl(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ve={kernelName:b0,gradFunc:e=>({x:()=>vn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eve={kernelName:v0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Jt(n.shape,r.shape);return{a:()=>{const o=Ot(e,lt(r,"float32")),l=ys(n.shape,s);return l.length>0?be(Ft(o,l),n.shape):o},b:()=>{let o=fe(e,lt(n,"float32"));const l=ys(r.shape,s);l.length>0&&(o=be(Ft(o,l),r.shape));const u=hr(r);return Lr(Ot(o,lt(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ve={kernelName:AS,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,l=o??Rn(1),u=ys(a.shape,s.shape),c=[];if(a.rank===1){for(let I=0;I<s.shape.length-1;++I)c.push(s.shape[I]);c.push(1)}const d=Bt(s,a),p=fe(e,l),h=Jj(He(i,Rn(r))),m=fe(fe(fe(h,h),h),Rn(-.5));return{x:()=>a.rank===1?be(fe(fe(e,Ko(be(h,[1,1,1,a.shape[0]]),c)),l),s.shape):be(fe(fe(e,h),l),s.shape),mean:()=>{let I=fe(fe(h,Rn(-1)),p);return a.rank===1&&(I=Ft(I,u)),be(I,a.shape)},variance:()=>{let I=fe(fe(m,d),p);return a.rank===1&&(I=Ft(I,u)),be(I,a.shape)},scale:()=>{const I=fe(d,h);let S=fe(e,I);return a.rank===1&&(S=Ft(S,u)),be(S,a.shape)},offset:()=>{let I=e;return a.rank===1&&(I=Ft(I,u)),be(I,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ave={kernelName:RS,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,o=un(a,r.shape)[0],l=(u,c,d)=>()=>{const p=u.shape,h=c.size,m=p.slice(0,o),g=m.length,y=p.slice(a,p.length).slice(1),b=y.length,v=eV(0,g),k=eV(g+1,g+1+b),I=tV([m,[h],y]),S=be(d,I),N=be(c,[h]),T=tV([[g],v,k]),A=bn(S,T);let R=oH(A,N,u.shape[o]);const D=Id(T);return R=bn(R,D),R};if(i===1){const u=r.shape[0],c=r.split(u,0);return{x:()=>Pu(c.map((h,m)=>l(h,s.slice(m,1),e.slice(m,1))())).reshape(r.shape),indices:()=>s}}else return{x:l(r,s,e),indices:()=>s}}};function eV(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function tV(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rve={kernelName:w0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>vn(n),b:()=>vn(r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dve={kernelName:k0,gradFunc:e=>({x:()=>lt(e,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fve={kernelName:I0,gradFunc:e=>({x:()=>vn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ove={kernelName:S0,gradFunc:e=>({x:()=>vn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mve={kernelName:C0,gradFunc:e=>({x:()=>vn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lve={kernelName:FS,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=Zi(r,0);return{x:()=>Ta(a,e,fe(e,s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pve={kernelName:T0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ot(e,He(n,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zve={kernelName:N0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ot(e,lt(n,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bve={kernelName:bhe,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const i=Jl(r);return Bt(e,fe(Ft(e,s,!0),i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wve(e,t,n,r=5,s=1,a=1,i=.5){const o={x:e,y:t,dy:n},l={depthRadius:r,bias:s,alpha:a,beta:i};return me.runKernel(vD,o,l)}const Vve=ve({localResponseNormalizationBackprop_:Wve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uve={kernelName:BS,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>Vve(r,s,e,a,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JH(e,t,n,r){return t.rank<n.rank&&(t=be(t,Jr(t.shape,r))),e.rank<n.rank&&(e=be(e,Jr(e.shape,r))),{x:()=>fe(e,lt(Zl(n,t),e.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nV={kernelName:WS,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=t[1],o=un(s,a.shape),l=JH(e,i,a,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gve={kernelName:$0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>fe(e,lt(Fh(n,r),"float32")),b:()=>fe(e,lt(J2(n,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jve(e,t,n,r,s,a,i){const o=ae(e,"dy","maxPool3dGrad"),l=ae(t,"input","maxPool3dGrad"),u=ae(n,"output","maxPool3dGrad");let c=o,d=l,p=u,h=!1;l.rank===4&&(h=!0,c=be(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=be(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=be(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Y(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),Y(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),Y(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),ri("maxPool3dGrad",a,i);const m={dy:c,input:d,output:p},g={filterSize:r,strides:s,pad:a,dimRoundingMode:i},y=me.runKernel(kD,m,g);return h?be(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const Hve=ve({maxPool3dGrad_:jve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qve={kernelName:US,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>Hve(e,r,s,a,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kve(e,t,n,r,s,a,i){const o=ae(e,"dy","maxPoolGrad"),l=ae(t,"input","maxPoolGrad"),u=ae(n,"output","maxPoolGrad");Y(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),Y(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),Y(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),ri("maxPoolGrad",a,i);const c={dy:o,input:l,output:u},d={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return me.runKernel(wD,c,d)}const Xve=ve({maxPoolGrad_:Kve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yve={kernelName:VS,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>Xve(e,r,s,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zve={kernelName:GS,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=un(s,r.shape),o=Os(r.shape,a)[1],l=Oe(o);return{x:()=>{const c=r.shape.slice();a.forEach(h=>{c[h]=1});const d=be(e,c);return Ot(fe(d,Cd(r.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jve={kernelName:jS,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=un(s,a.shape),l=JH(e,i,a,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qve={kernelName:E0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>fe(e,lt(fy(n,r),"float32")),b:()=>fe(e,lt(Zi(n,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e0e={kernelName:HS,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>ar(e,a,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t0e={kernelName:_0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Jt(n.shape,r.shape);return{a:()=>{const o=ys(n.shape,s);return o.length>0?be(Ft(e,o),n.shape):e},b:()=>{const o=fe(e,Lr(vC(Ot(n,r)))),l=ys(r.shape,s);return l.length>0?be(Ft(o,l),r.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n0e={kernelName:A0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Jt(n.shape,r.shape);return{a:()=>{const o=fe(e,lt(r,"float32")),l=ys(n.shape,s);return l.length>0?be(Ft(o,l),n.shape):o},b:()=>{const o=fe(e,lt(n,"float32")),l=ys(r.shape,s);return l.length>0?be(Ft(o,l),r.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r0e={kernelName:qS,gradFunc:e=>({x:()=>Lr(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s0e={kernelName:YS,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>Es(n.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a0e={kernelName:XS,gradFunc:e=>({x:()=>vn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i0e={kernelName:ZS,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return oh(e,r).map(a=>()=>a)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rV={kernelName:JS,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>ar(e,a,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o0e={kernelName:R0,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=Jt(a.shape,i.shape);return{a:()=>{const c=lt(i,"float32");let d=fe(e,fe(c,ah(a,Bt(c,Rn(1)))));const p=ys(a.shape,o);return p.length>0&&(d=Ft(d,p)),be(d,a.shape)},b:()=>{const c=Zi(a,0),d=Ta(c,Ql(a),vn(a));let p=fe(e,fe(s,d));const h=ys(i.shape,o);return h.length>0&&(p=Ft(p,h)),be(p,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l0e={kernelName:QS,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=Zi(n,0);return{x:()=>Ta(s,e,fe(e,r)),alpha:()=>{let a=Ta(s,vn(e),fe(e,n));const i=ys(r.shape,e.shape);return i.length>0&&(a=Ft(a,i)),be(a,r.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u0e(e,t,n){const r=e.shape.slice();r[n]=1;const s=be(t,r),a=X_(e,n,!0,!1),i=X_(e,n,!0,!0),o=fe(a,i);return fe(s,o)}function c0e(e,t,n){const r=e.shape.length,s=r-n.length,a=_r(n,r);let i=e;a!=null&&(i=bn(e,a));const o=i.shape.slice(),u=o.splice(r-n.length,n.length).reduce((p,h)=>p*h,1);o.push(u);const c=i.reshape(o);let d=u0e(c,t,s);if(d=d.reshape(i.shape),a!=null){const p=Id(a);d=bn(d,p)}return d}const d0e={kernelName:eC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return s==null?a=r.shape.map((i,o)=>o):typeof s=="number"?a=[s]:a=s,{x:()=>c0e(r,e,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p0e={kernelName:f0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Jt(n.shape,r.shape);return{a:()=>{const o=Ot(e,lt(r,"float32")),l=ys(n.shape,s);return l.length>0?be(Ft(o,l),n.shape):o},b:()=>{let o=fe(e,lt(n,"float32"));const l=ys(r.shape,s);l.length>0&&(o=be(Ft(o,l),r.shape));const u=hr(r);return Lr(Ot(o,lt(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h0e={kernelName:D0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ot(e,Lr(hr(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f0e={kernelName:O0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=fe(fy(n,6),r1(n));return{x:()=>fe(e,lt(r,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m0e={kernelName:F0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fe(e,lt(r1(n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g0e={kernelName:tC,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>be(e,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y0e={kernelName:rC,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>me.runKernel(ED,s,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x0e={kernelName:nC,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>me.runKernel($D,s,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b0e={kernelName:sC,gradFunc:(e,t,n)=>{const{dims:r}=n,s=un(r,e.shape);return{x:()=>ih(e,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v0e={kernelName:M0,gradFunc:e=>({x:()=>vn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w0e={kernelName:L0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Lr(Ot(e,fe(ah(n,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k0e={kernelName:aC,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>lt(vn(n),"float32"),t:()=>fe(e,lt(n,e.dtype)),e:()=>fe(e,lt(KD(n),e.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I0e={kernelName:P0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=Zi(n,Rn(0)),s=Rn(IC),a=Rn(SC),i=fe(e,a),o=fe(fe(e,s),Jl(lt(n,"float32")));return Ta(r,i,o)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S0e={kernelName:V0,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fe(e,fe(n,Bt(Rn(1),n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C0e={kernelName:W0,gradFunc:e=>({x:()=>vn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N0e={kernelName:z0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fe(VD(lt(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T0e={kernelName:B0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fe(Pj(lt(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $0e={kernelName:iC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=wC(r,s,a),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>ZD(e,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E0e={kernelName:cC,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=!0,i=fe(e,r);return{logits:()=>Bt(i,fe(Ft(i,[s],a),r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _0e={kernelName:U0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fe(e,hy(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sV={kernelName:lC,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>BD(e,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aV={kernelName:uC,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>Ka(e,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A0e={kernelName:G0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ot(e,fe(ia(lt(n,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R0e={kernelName:_D,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fe(e,fe(lt(n,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D0e={kernelName:j0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Rn(2);return{a:()=>fe(e,fe(s,Bt(n,r))),b:()=>fe(e,fe(s,Bt(r,n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F0e={kernelName:Y0,gradFunc:e=>({x:()=>vn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O0e={kernelName:H0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Jt(n.shape,r.shape);return{a:()=>{let o=e;const l=ys(n.shape,s);return l.length>0&&(o=Ft(o,l)),be(o,n.shape)},b:()=>{let o=e;const l=ys(r.shape,s);return l.length>0&&(o=Ft(o,l)),be(Lr(o),r.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M0e={kernelName:oC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;un(a,r.shape).forEach(u=>{s[u]=1});const o=be(e,s),l=fe(o,Cd(r.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L0e={kernelName:q0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ot(e,hr(VD(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P0e={kernelName:K0,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fe(Bt(Rn(1),hr(n)),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z0e={kernelName:X0,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let i=vn(r);if(r.rank===1)for(let o=0;o<s[0];++o)i=He(i,ar(e,[o*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let o=0;o<s[0];++o)for(let l=0;l<s[1];++l)i=He(i,ar(e,[o*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let o=0;o<s[0];++o)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)i=He(i,ar(e,[o*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let o=0;o<s[0];++o)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)i=He(i,ar(e,[o*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return i}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B0e={kernelName:fg,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=Id(s);return{x:()=>bn(e,a)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W0e={kernelName:dC,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>Pu(e,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V0e={kernelName:pC,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>U0e(e,n)}}};function U0e(e,t){const n=Sd(t,vn(t)),r=jD(e,n);let s=Fh(t,Rn(0,"int32"));const a=r.rank-s.rank;for(let o=0;o<a;++o)s=Va(s,o+1);s=Lu(s,Cd(r.shape,"bool"));const i=vn(r);return Ta(s,r,i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G0e={kernelName:hC,gradFunc:e=>({x:()=>vn(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j0e=[ZH,Vbe,Ube,Gbe,jbe,Hbe,qbe,Kbe,Xbe,Ybe,Zbe,Jbe,tve,sve,ave,ive,ove,lve,uve,cve,dve,pve,fve,hve,yve,xve,bve,vve,wve,kve,p0e,Ive,Sve,Cve,Nve,Tve,Eve,$ve,_ve,Ave,Rve,Dve,Fve,Ove,Mve,Lve,Pve,zve,Bve,Uve,nV,nV,Gve,qve,Yve,Zve,Jve,Qve,e0e,t0e,n0e,r0e,s0e,a0e,i0e,rV,rV,o0e,l0e,d0e,h0e,f0e,m0e,g0e,y0e,x0e,b0e,v0e,w0e,k0e,I0e,S0e,C0e,N0e,T0e,$0e,E0e,_0e,sV,sV,aV,aV,A0e,D0e,R0e,F0e,O0e,M0e,L0e,P0e,z0e,B0e,W0e,V0e,G0e];for(const e of j0e)whe(e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.abs=function(){return this.throwIfDisposed(),va(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.acos=function(){return this.throwIfDisposed(),Ife(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.acosh=function(){return this.throwIfDisposed(),Cfe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.add=function(e){return this.throwIfDisposed(),He(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.all=function(e,t){return this.throwIfDisposed(),Fj(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.any=function(e,t){return this.throwIfDisposed(),q_(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.argMax=function(e){return this.throwIfDisposed(),fv(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.argMin=function(e){return this.throwIfDisposed(),_fe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.asScalar=function(){return this.throwIfDisposed(),Y(this.size===1,()=>"The array must have only 1 element."),be(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.asType=function(e){return this.throwIfDisposed(),lt(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.as1D=function(){return this.throwIfDisposed(),be(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.as2D=function(e,t){return this.throwIfDisposed(),be(this,[e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),be(this,[e,t,n])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),be(this,[e,t,n,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),be(this,[e,t,n,r,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.asin=function(){return this.throwIfDisposed(),Rfe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.asinh=function(){return this.throwIfDisposed(),Ffe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.atan=function(){return this.throwIfDisposed(),Mfe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.atan2=function(e){return this.throwIfDisposed(),Pfe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.atanh=function(){return this.throwIfDisposed(),Bfe(this)};Re().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),py(this,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),BD(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),gC(this,e,t,n,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.broadcastTo=function(e){return this.throwIfDisposed(),nv(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.cast=function(e){return this.throwIfDisposed(),lt(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.ceil=function(){return this.throwIfDisposed(),hme(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),qi(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof os&&(e=[e]),Ka([this,...e],t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Oj(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),Mj(this,e,t,n,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),sh(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.cos=function(){return this.throwIfDisposed(),VD(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.cosh=function(){return this.throwIfDisposed(),Pj(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),X_(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),zj(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Pme(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),UD(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),Wme(this,e,t,n,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.divNoNan=function(e){return this.throwIfDisposed(),Hme(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.div=function(e){return this.throwIfDisposed(),Ot(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.dot=function(e){return this.throwIfDisposed(),Kme(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.elu=function(){return this.throwIfDisposed(),xC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.equal=function(e){return this.throwIfDisposed(),Zl(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.erf=function(){return this.throwIfDisposed(),Bj(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),ige(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.exp=function(){return this.throwIfDisposed(),Jl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.expandDims=function(e){return this.throwIfDisposed(),Va(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.expm1=function(){return this.throwIfDisposed(),cge(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.fft=function(){return this.throwIfDisposed(),sH(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.flatten=function(){return this.throwIfDisposed(),be(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.floor=function(){return this.throwIfDisposed(),vC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.floorDiv=function(e){return this.throwIfDisposed(),Dj(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.gather=function(e,t,n){return this.throwIfDisposed(),jD(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Fh(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.greater=function(e){return this.throwIfDisposed(),Zi(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.ifft=function(){return this.throwIfDisposed(),Y_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.irfft=function(){return this.throwIfDisposed(),rxe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.isFinite=function(){return this.throwIfDisposed(),bge(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.isInf=function(){return this.throwIfDisposed(),wge(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.isNaN=function(){return this.throwIfDisposed(),Ige(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.leakyRelu=function(e){return this.throwIfDisposed(),qD(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.lessEqual=function(e){return this.throwIfDisposed(),fy(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.less=function(e){return this.throwIfDisposed(),J2(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),$ge(this,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.logSigmoid=function(){return this.throwIfDisposed(),Oge(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.logSoftmax=function(e){return this.throwIfDisposed(),jj(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Hj(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.log=function(){return this.throwIfDisposed(),Ql(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.log1p=function(){return this.throwIfDisposed(),Gj(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Lu(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.logicalNot=function(){return this.throwIfDisposed(),KD(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.logicalOr=function(e){return this.throwIfDisposed(),qj(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.logicalXor=function(e){return this.throwIfDisposed(),Uge(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),An(this,e,t,n)};Re().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),XD(this,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.max=function(e,t){return this.throwIfDisposed(),Yo(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.maximum=function(e){return this.throwIfDisposed(),Sd(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.mean=function(e,t){return this.throwIfDisposed(),qr(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.min=function(e,t){return this.throwIfDisposed(),Z2(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.minimum=function(e){return this.throwIfDisposed(),yv(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Zge(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.mod=function(e){return this.throwIfDisposed(),Qge(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.mul=function(e){return this.throwIfDisposed(),fe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.neg=function(){return this.throwIfDisposed(),Lr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.norm=function(e,t,n){return this.throwIfDisposed(),bC(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.notEqual=function(e){return this.throwIfDisposed(),Q2(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Kj(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.onesLike=function(){return this.throwIfDisposed(),ko(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.pad=function(e,t){return this.throwIfDisposed(),ZD(this,e,t)};Re().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),uye(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.pow=function(e){return this.throwIfDisposed(),ah(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.prelu=function(e){return this.throwIfDisposed(),QD(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.prod=function(e,t){return this.throwIfDisposed(),pye(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.reciprocal=function(){return this.throwIfDisposed(),Lye(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.relu=function(){return this.throwIfDisposed(),Oh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.relu6=function(){return this.throwIfDisposed(),Yj(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.reshapeAs=function(e){return this.throwIfDisposed(),be(this,e.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.reshape=function(e){return this.throwIfDisposed(),be(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),uH(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),cH(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.reverse=function(e){return this.throwIfDisposed(),ih(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.rfft=function(){return this.throwIfDisposed(),ixe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.round=function(){return this.throwIfDisposed(),Zj(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.rsqrt=function(){return this.throwIfDisposed(),Jj(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.selu=function(){return this.throwIfDisposed(),Qj(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),eH(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.sigmoid=function(){return this.throwIfDisposed(),hy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.sign=function(){return this.throwIfDisposed(),Hye(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.sin=function(){return this.throwIfDisposed(),tH(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.sinh=function(){return this.throwIfDisposed(),nH(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.slice=function(e,t){return this.throwIfDisposed(),ar(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.softmax=function(e){return this.throwIfDisposed(),rF(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.softplus=function(){return this.throwIfDisposed(),e1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),JD(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.split=function(e,t){return this.throwIfDisposed(),ji(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.sqrt=function(){return this.throwIfDisposed(),ia(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.square=function(){return this.throwIfDisposed(),hr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.squaredDifference=function(e){return this.throwIfDisposed(),lxe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.squeeze=function(e){return this.throwIfDisposed(),n1(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof os?[this,e]:[this,...e];return Pu(n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.step=function(e){return this.throwIfDisposed(),r1(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),hxe(this,e,t,n,r,s,a,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.sub=function(e){return this.throwIfDisposed(),Bt(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.sum=function(e,t){return this.throwIfDisposed(),Ft(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.tan=function(){return this.throwIfDisposed(),mxe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.tanh=function(){return this.throwIfDisposed(),mC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.tile=function(e){return this.throwIfDisposed(),Ko(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.toBool=function(){return this.throwIfDisposed(),lt(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.toFloat=function(){return this.throwIfDisposed(),lt(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.toInt=function(){return this.throwIfDisposed(),lt(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.topk=function(e,t){return this.throwIfDisposed(),bxe(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.transpose=function(e){return this.throwIfDisposed(),bn(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.unique=function(e){return this.throwIfDisposed(),kxe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),oH(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.unstack=function(e){return this.throwIfDisposed(),oh(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.where=function(e,t){return this.throwIfDisposed(),Ta(e,this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Re().prototype.zerosLike=function(){return this.throwIfDisposed(),vn(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Al extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Al.prototype)}}class xo extends Error{constructor(t){super(t),Object.setPrototypeOf(this,xo.prototype)}}class he extends Error{constructor(t){super(t),Object.setPrototypeOf(this,he.prototype)}}class rn extends Error{constructor(t){super(t),Object.setPrototypeOf(this,rn.prototype)}}class zF extends Error{constructor(t){super(t),Object.setPrototypeOf(this,zF.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class QH{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let n;return this.cache.has(t)&&(n=this.cache.get(t),this.cache.delete(t),this.cache.set(t,n)),n}put(t,n){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let n=0;n<this.maxEntries-t;n++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function lh(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{const n=new Array(t);return n.fill(e),n}}function Rl(e,t){if(!e)throw new zF(t)}function iV(e,t){let n=0;for(const r of e)r===t&&n++;return n}function Ua(e){return e.length===1?e[0]:e}function Wn(e){return Array.isArray(e)?e:[e]}function Su(e){const n=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function Cp(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}let lo={};function BF(e){if(e==null)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Q_(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>Q_(t));else{const t=Object.keys(e);for(const n of t){const r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:Q_(r))}}}function o1(e,t={},n={},r="object",s=!1){if(typeof e=="string"){const a=e;let i;if(a in n)i=n[a];else if(a in lo)i=lo[a];else if(i=t[a],i==null)throw new he(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{const a=e;if(a.className==null||a.config==null)throw new he(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in lo?[o,l]=lo.className:i in t&&([o,l]=t[i]),o==null)throw new he(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const h of Object.keys(lo))u[h]=lo[h];for(const h of Object.keys(n))u[h]=n[h];const c=a.config;c.customObjects=u;const d=Object.assign({},lo);for(const h of Object.keys(n))lo[h]=n[h];Q_(a.config);const p=l(o,a.config,n,s);return lo=Object.assign({},d),p}else{const u=Object.assign({},lo);for(const d of Object.keys(n))lo[d]=n[d];const c=new o(a.config);return lo=Object.assign({},u),c}}}function H0e(e,t){return e<t?-1:e>t?1:0}function Mk(e,t){return-1*H0e(e,t)}function Gc(e){if(e==null)return e;const t=[];for(const n of e)t.indexOf(n)===-1&&t.push(n);return t}function q0e(e){if(e==null)throw new he(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function Lh(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new he(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function WF(e,t,n=0,r=1/0){return Rl(n>=0),Rl(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(s=>typeof s===t)}function _s(e,t){Array.isArray(e)?(Y(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>_s(n,`element ${r+1} of ${t}`))):Y(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${e8(e)}.`)}function e8(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>e8(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function K0e(e,t,n){let r=n!=null?n():Wa(),s;return(...i)=>{const o=n!=null?n():Wa();return o-r<t||(r=o,s=e(...i)),s}}function t8(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let X0e=0;function n8(){return X0e++}const Lk={};function CC(e=""){return e in Lk||(Lk[e]=0),Lk[e]+=1,e+Lk[e].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Y0e=["channelsFirst","channelsLast"],Z0e=["nearest","bilinear"],J0e=["valid","same","causal"],Q0e=["max","avg"],e1e=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Jm=new Map;function Br(e){Lh(Y0e,"DataFormat",e)}function t1e(e){Lh(Z0e,"InterpolationFormat",e)}function Ji(e){Lh(J0e,"PaddingMode",e)}function r8(e){Lh(Q0e,"PoolMode",e)}const rv=[],oV="/";function Vp(e,t){rv.push(e);try{const n=t();return rv.pop(),n}catch(n){throw rv.pop(),n}}function n1e(){return rv.length===0?"":rv.join(oV)+oV}function s8(e){if(!i8(e))throw new Error("Not a valid tensor name: '"+e+"'");return n1e()+e}function a8(e){if(!i8(e))throw new Error("Not a valid tensor name: '"+e+"'");Jm.has(e)||Jm.set(e,0);const t=Jm.get(e);if(Jm.set(e,Jm.get(e)+1),t>0){const n=`${e}_${t}`;return Jm.set(n,1),n}else return e}const r1e=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function i8(e){return!!e.match(r1e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function s1e(e){return e===parseInt(e.toString(),10)}function jc(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function Ag(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function Zc(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function sl(e,t){if(t<e)throw new he(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let SE;function ls(){return SE==null&&(SE=qhe().epsilon()),SE}function al(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function jl(e,t){return lt(e,t)}function l1(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),be(e,n)}function a1e(e,t){return Se(()=>{if(e.shape.length!==2)throw new he(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);const n=l1(e,1);return eA(n,[1,t,1])})}function i1e(e){const t=[jc(e.shape)];return be(e,t)}function o1e(e){if(e.rank<=1)throw new he(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],jc(e.shape,1)];return be(e,t)}function Up(e,t,n){return Se(()=>{switch(e.rank){case 1:return tF(e,t,n);case 2:return rH(e,[t,0],[n,e.shape[1]]);case 3:return nF(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return tI(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return ar(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return ar(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new he(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function CE(e,t,n){return Se(()=>{switch(e.rank){case 1:return tF(e,t,n);case 2:return rH(e,[0,t],[e.shape[0],n]);case 3:return nF(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return tI(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new he(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Pk(e,t,n,r){return Se(()=>{switch(e.rank){case 1:return tF(e,t,n);case 2:switch(r){case 1:return Up(e,t,n);case 2:return CE(e,t,n);default:throw new he(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Up(e,t,n);case 2:return nF(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return CE(e,t,n);default:throw new he(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Up(e,t,n);case 2:return tI(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return tI(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return CE(e,t,n);default:throw new he(`The axis is not within the rank of the tensor ${r}`)}default:throw new he(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function VF(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),Ka(e,t)}function lV(e,t){switch(e.rank){case 1:return gme([e,t]);case 2:return xme([e,t],0);case 3:return vme([e,t],0);case 4:return kme([e,t],0);default:throw new he(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function eA(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new he(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Ko(e,t)}function NC(e,t=0,n=1,r,s){return Dye(e,t,n,r,s)}function Hl(e,t,n,r){if(e.rank<2||t.rank<2)throw new rn(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){const s=e.shape.slice(-1)[0],a=t.shape.slice(-2)[0];if(s!==a)throw new rn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return KW({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?tA(e.rank,r,al()):null,activation:n});{const s=e.shape.slice(),a=s.pop();e=be(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},(m,g)=>g===0?t.rank-2:g<=t.rank-2?g-1:g);t=be(bn(t,c),[l,-1]);const d=[...s,...u];return be(KW({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?tA(e.rank,r,al()):null,activation:n}),d)}}function o8(e,t,n){return Se(()=>(Array.isArray(t)?t=yi(t,"int32"):t=lt(t,"int32"),jD(e,t,n)))}function u1(e){return fe(e,e)}function tA(e,t,n){const r=t.shape;if(t.rank!==1&&t.rank!==e)throw new he(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?be(t,[1,r[0],1,1,1]):be(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?be(t,[1,1,1,1,r[0]]):be(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?be(t,[1,r[0],1,1]):be(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?be(t,[1,1,1,r[0]]):be(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?be(t,[1,r[0],1]):be(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?be(t,[1,1,r[0]]):be(t,[1].concat(r))}else if(e<3)return t;throw new he(`Unsupported input rank by biasAdd: ${t.rank}`)}function fl(e,t,n){return Se(()=>(n==null&&(n=al()),Br(n),He(e,tA(e.rank,t,n))))}function l1e(e,t=1){if(t!==1)throw new rn(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return xC(e)}function u1e(e){return Se(()=>Ot(e,He(va(e),1)))}function l8(e,t,n,r){return Se(()=>Exe(e,t,n,r))}function c1e(e){return Se(()=>{const t=He(.5,fe(.2,e));return qi(t,0,1)})}function c1(e,t,n=!1){return n?e():t()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const d1e=["fanIn","fanOut","fanAvg"],p1e=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function h1e(e){Lh(d1e,"FanMode",e)}function f1e(e){Lh(p1e,"Distribution",e)}class Co extends gy{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class u8 extends Co{apply(t,n){return Es(t,n)}}u8.className="Zeros";ze(u8);class UF extends Co{apply(t,n){return Cd(t,n)}}UF.className="Ones";ze(UF);class c8 extends Co{constructor(t){if(super(),typeof t!="object")throw new he(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new he(`config must have value set but got ${t}`);this.value=t.value}apply(t,n){return Se(()=>fe(Rn(this.value),Cd(t,n)))}getConfig(){return{value:this.value}}}c8.className="Constant";ze(c8);class d8 extends Co{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,n){return t1(t,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}d8.className="RandomUniform";ze(d8);class p8 extends Co{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new rn(`randomNormal does not support dType ${n}.`);return NC(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}p8.className="RandomNormal";ze(p8);class h8 extends Co{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new rn(`truncatedNormal does not support dType ${n}.`);return iH(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}h8.className="TruncatedNormal";ze(h8);class f8 extends Co{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,n){return Se(()=>{if(t.length!==2||t[0]!==t[1])throw new he("Identity matrix initializer can only be used for 2D square matrices.");return fe(this.gain,Uj(t[0]))})}getConfig(){return{gain:this.gain}}}f8.className="Identity";ze(f8);function m1e(e,t="channelsLast"){let n,r;if(Br(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){const s=jc(e,2);n=e[1]*s,r=e[0]*s}else if(t==="channelsLast"){const s=jc(e,0,e.length-2);n=e[e.length-2]*s,r=e[e.length-1]*s}}else{const s=jc(e);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}class Ii extends Co{constructor(t){if(super(),t.scale<0)throw new he(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,h1e(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,f1e(this.distribution),this.seed=t.seed}apply(t,n){const r=m1e(t),s=r[0],a=r[1];let i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,s):this.mode==="fanOut"?i/=Math.max(1,a):i/=Math.max(1,(s+a)/2),this.distribution==="normal"){const o=Math.sqrt(i);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new rn(`${this.getClassName()} does not support dType ${n}.`);return iH(t,0,o,n,this.seed)}else{const o=Math.sqrt(3*i);return t1(t,-o,o,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Ii.className="VarianceScaling";ze(Ii);class GF extends Ii{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ii.className}}GF.className="GlorotUniform";ze(GF);class jF extends Ii{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ii.className}}jF.className="GlorotNormal";ze(jF);class HF extends Ii{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ii.className}}HF.className="HeNormal";ze(HF);class qF extends Ii{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ii.className}}qF.className="HeUniform";ze(qF);class KF extends Ii{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ii.className}}KF.className="LeCunNormal";ze(KF);class XF extends Ii{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ii.className}}XF.className="LeCunUniform";ze(XF);class m8 extends Co{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,n){return Se(()=>{if(t.length<2)throw new rn("Shape must be at least 2D.");if(n!=="int32"&&n!=="float32"&&n!==void 0)throw new TypeError(`Unsupported data type ${n}.`);n=n;const r=Oe(t.slice(0,-1)),s=t[t.length-1],a=r*s;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const i=[Math.max(s,r),Math.min(s,r)],o=NC(i,0,1,n,this.seed),l=Cbe.qr(o,!1);let u=l[0];const d=l[1].flatten().stridedSlice([0],[Math.min(s,r)*Math.min(s,r)],[Math.min(s,r)+1]);return u=fe(u,d.sign()),r<s&&(u=u.transpose()),fe(Rn(this.gain),u.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}m8.className="Orthogonal";ze(m8);const uV={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function cV(e,t={}){return o1(e,go.getMap().classNameMap,t,"initializer")}function Nr(e){return BF(e)}function xr(e){if(typeof e=="string"){const t=e in uV?uV[e]:e;if(t==="GlorotNormal")return new jF;if(t==="GlorotUniform")return new GF;if(t==="HeNormal")return new HF;if(t==="HeUniform")return new qF;if(t==="LeCunNormal")return new KF;if(t==="LeCunUniform")return new XF;{const n={};return n.className=t,n.config={},cV(n)}}else return e instanceof Co?e:cV(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nA(e){return Array.isArray(e)&&Array.isArray(e[0])}function nI(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Wt(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new he(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Cn(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new he(`Expected exactly 1 Shape; got ${e.length}`)}else return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function rI(e){let t=0;for(const n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,s)=>r*s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const dV="Variable";class g1e{constructor(t,n="float32",r=dV,s=!0,a=null){this.dtype=n??"float32",this.shape=t.shape,this.id=n8(),r=r??dV,this.originalName=s8(r),this.name=a8(this.originalName),this.trainable_=s,this.constraint=a,this.val=Cxe(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),y1e(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function y1e(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function rA(e){return e.map(t=>t.read())}function YF(e){e.forEach(t=>{t[0].write(t[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class us{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class eu{constructor(t,n,r,s,a,i,o){this.dtype=t,this.shape=n,this.sourceLayer=r,this.inputs=s,this.callArgs=a,this.outputTensorIndex=o,this.id=n8(),i!=null&&(this.originalName=s8(i),this.name=a8(this.originalName)),this.rank=n.length}}let x1e=0,TC=class{constructor(t,n){this.callArgs=n,this.id=x1e++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)r!=null&&r.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const n of this.inboundLayers)n!=null?t.push(n.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},b1e=0;class cn extends gy{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=b1e++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=t.name;if(!n){const r=this.getClassName();n=Su(r)+"_"+CC(r)}if(this.name=n,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let r;if(t.batchInputShape!=null)r=t.batchInputShape;else if(t.inputShape!=null){let a=null;t.batchSize!=null&&(a=t.batchSize),r=[a].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;s==null&&(s=t.inputDType),s==null&&(s="float32"),this.dtype=s}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,n){return t.name+"_ib-"+n.toString()}getNodeAtIndex(t,n){if(this.inboundNodes.length===0)throw new xo(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=t)throw new he(`Asked to get ${n} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Ua(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Ua(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Al(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Al(`Layer ${this.name} is not connected, no input to return.`);return Ua(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Al(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Al(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Ua(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(n=>n.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const n=Wn(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const r=Wn(this.inputSpec);if(n.length!==r.length)throw new he(`Layer ${this.name} expects ${r.length} inputs, but it received ${n.length} input tensors. Input received: ${t}`);for(let s=0;s<n.length;s++){const a=n[s],i=r[s];if(i==null)continue;const o=a.rank;if(i.ndim!=null&&o!==i.ndim)throw new he(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(i.maxNDim!=null&&o>i.maxNDim)throw new he(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(i.minNDim!=null&&o<i.minNDim)throw new he(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(i.dtype!=null&&a.dtype!==i.dtype)throw new he(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${a.dtype}.`);if(i.axes){const l=a.shape;for(const u in i.axes){const c=Number(u),d=i.axes[u],p=c>=0?l[c]:l[l.length+c];if(d!=null&&[d,null].indexOf(p)===-1)throw new he(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${d} but got shape ${l}.`)}}if(i.shape!=null)for(let l=0;l<i.shape.length;++l){const u=i.shape[l],c=a.shape[l];if(u!=null&&c!=null&&u!==c)throw new he(`Input ${s} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${a.shape}.`)}}}call(t,n){return t}invokeCallHook(t,n){this._callHook!=null&&this._callHook(t,n)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,n){n=n||{},this.assertNotDisposed();const r=Wn(t),s=k1e(t),a=I1e(t);if(s===a)throw new he("Arguments to apply() must be all SymbolicTensors or all Tensors");return Vp(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const i=[];for(const o of Wn(t))i.push(o.shape);this.build(Ua(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let i=this.call(t,n);this.supportsMasking&&this.setMaskMetadata(t,i);const o=Wn(i),l=[];for(let u of o)r.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(i=Ua(l),this.activityRegularizer!=null)throw new rn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{const i=v1e(t),o=this.computeOutputShape(i);let l;const u=w1e(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((c,d)=>new eu(u,c,this,Wn(t),n,this.name,d)):l=new eu(u,o,this,Wn(t),n,this.name),this.addInboundNode(t,l,null,null,i,o,n),this._refCount++,this.activityRegularizer!=null)throw new rn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&t[s]!=null&&t[s]!==r&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Al(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const n of this.inboundNodes){const r=JSON.stringify(n.outputShapes);t.indexOf(r)===-1&&t.push(r)}if(t.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new Al(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new xo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return rI(this.weights)}build(t){this.built=!0}getWeights(t=!1){return rA(t?this.trainableWeights:this.weights)}setWeights(t){Se(()=>{const n=this.weights;if(n.length!==t.length)throw new he(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${n.length} weights. Provided weights: ${t}...`);if(n.length===0)return;const r=[],s=rA(n);for(let a=0;a<s.length;++a){const i=s[a],o=n[a],l=t[a];if(!Dn(i.shape,l.shape))throw new he(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([o,l])}YF(r)})}addWeight(t,n,r,s,a,i,o,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new he(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=l!=null?l():xr("zeros"));const u=s.apply(n,r),c=new g1e(u,r,t,i,o);return u.dispose(),a!=null&&this.addLoss(()=>a.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Wn(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}setMaskMetadata(t,n,r){if(!this.supportsMasking)return;const s=this.computeMask(t,r),a=Wn(n),i=Wn(s);if(a.length!==i.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let o=0;o<a.length;o++)a[o].kerasMask=i[o]}addInboundNode(t,n,r,s,a,i,o=null){const l=Wn(t);n=Wn(n),r=Wn(r),s=Wn(s),a=nI(a),i=nI(i);const u=[],c=[],d=[];for(const p of l)u.push(p.sourceLayer),c.push(p.nodeIndex),d.push(p.tensorIndex);new TC({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:n,inputMasks:r,outputMasks:s,inputShapes:a,outputShapes:i},o);for(let p=0;p<n.length;p++)n[p].sourceLayer=this,n[p].nodeIndex=this.inboundNodes.length-1,n[p].tensorIndex=p}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function v1e(e){e=Wn(e);const t=[];for(const n of e)t.push(n.shape);return Ua(t)}function w1e(e){return"float32"}function g8(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{const r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{const s=[];for(let a=0;a<r.inboundLayers.length;a++){const i=r.inputTensors[a],o=r.inboundLayers[a],l=r.nodeIndices[a],u=g8(i,o,l);for(const c of u)s.indexOf(c)===-1&&s.push(c)}return s}}}function k1e(e){let t=!0;for(const n of Wn(e))if(!(n instanceof eu)){t=!1;break}return t}function I1e(e){let t=!0;for(const n of Wn(e))if(n instanceof eu){t=!1;break}return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class d1 extends cn{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:CC("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new he("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=t.batchInputShape;if(n==null){if(t.inputShape==null)throw new he("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new he("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=t.dtype||"float32";this.batchInputShape=n,this.dtype=r,this.inputSpec=[{shape:n}];const s=new eu(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new TC({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(t,n){throw new he(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}d1.className="InputLayer";ze(d1);function S1e(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new he("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new d1({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function C1e(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return lt(t,e.dtype)}catch{throw new he(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}class Oc{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Oc)for(const n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(const n of t)this.add(n.key,n.value)}}add(t,n,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=C1e(t,n),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new he(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof eu){if(this.id2Value[t.id]==null)throw new he(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const n=this.name2Id[t];if(n==null)throw new he(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof eu){if(this.id2Value[t.id]==null)throw new he(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const n=this.name2Id[t];if(n==null)throw new he(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&on(this.id2Mask)}}const sI=new QH,aI=new QH;function N1e(e){sI!=null&&sI.setMaxEntries(e),aI!=null&&aI.setMaxEntries(e)}function Vb(e,t,n,r){const s=n==null?!1:n.training,a=Array.isArray(e),i=a?e:[e],o=i.map(m=>m.name),l=[],u=t.names();for(const m of o)u.indexOf(m)!==-1?l.push(t.getValue(m)):l.push(null);const c=o.join(",")+"|"+t.names().sort().join(",");let d=sI.get(c),p;if(d==null){const m=T1e(i,t);d=m.sorted,p=m.recipientCounts,sI.put(c,d),aI.put(c,p)}p={},s||Object.assign(p,aI.get(c));const h=new Oc(t);for(let m=0;m<d.length;++m){const g=d[m],y=g.sourceLayer;if(y instanceof d1)continue;const b=[],v=[],k=[];let I=!1;for(const R of g.inputs){const D=h.getValue(R),$=h.getMask(R);b.push(D),v.push($),$!=null&&(I=!0),s||(p[R.name]--,p[R.name]===0&&!t.hasKey(R)&&o.indexOf(R.name)===-1&&!D.isDisposed&&R.sourceLayer.stateful!==!0&&k.push(D))}I&&(n=n||{},n.mask=v[0]);const S=Wn(y.apply(b,n));let N=null;y.supportsMasking&&(N=y.computeMask(b,v));const T=E1e(g),A=Array.isArray(T)?T:[T];for(let R=0;R<A.length;++R){h.hasKey(A[R])||h.add(A[R],S[R],Array.isArray(N)?N[0]:N);const D=o.indexOf(A[R].name);D!==-1&&(l[D]=S[R])}s||on(k)}return h.disposeMasks(),a?l:l[0]}function T1e(e,t){Y(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){const s=pV(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:i,recipientMap:o}=pV(a,t);for(const l of i)s.has(l.name)||(n.push(l),s.add(l.name));for(const l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:$1e(r)}}function $1e(e){const t={};for(const n in e)t[n]=e[n].size;return t}function pV(e,t){const n=new Set,r=[],s={};for(const o of t.names())n.add(o);const a=[],i=[];for(a.push(e);a.length>0;){const o=a[a.length-1];if(n.has(o.name)){a.pop();continue}const l=i[i.length-1]===a.length-1;if(o.inputs.length===0||l)a.pop(),r.push(o),n.add(o.name),l&&i.pop();else{i.push(a.length-1);for(const u of o.inputs)s[u.name]==null&&(s[u.name]=new Set),s[u.name].add(o.name),!n.has(u.name)&&a.push(u)}}return{sorted:r,recipientMap:s}}function E1e(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(const s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _1e=$e();_1e.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,N1e);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ZF(e,t){return Se(()=>ia(Ft(fe(e,e),t,!0)))}class p1 extends gy{getConfig(){return{}}}class y8 extends p1{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Se(()=>{const n=ZF(t,this.axis),r=qi(n,0,this.maxValue);return fe(t,Ot(r,He(ls(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}y8.className="MaxNorm";ze(y8);class x8 extends p1{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Se(()=>Ot(t,He(ls(),ZF(t,this.axis))))}getConfig(){return{axis:this.axis}}}x8.className="UnitNorm";ze(x8);class b8 extends p1{apply(t){return Oh(t)}}b8.className="NonNeg";ze(b8);class v8 extends p1{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Se(()=>{const n=ZF(t,this.axis),r=He(fe(this.rate,qi(n,this.minValue,this.maxValue)),fe(1-this.rate,n));return fe(t,Ot(r,He(ls(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}v8.className="MinMaxNorm";ze(v8);const hV={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ps(e){return BF(e)}function fV(e,t={}){return o1(e,go.getMap().classNameMap,t,"constraint")}function hs(e){if(e==null)return null;if(typeof e=="string"){const n={className:e in hV?hV[e]:e,config:{}};return fV(n)}else return e instanceof p1?e:fV(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function mp(e){if(e==null)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if(typeof a!="number"){const i=a;t.push(i.data()),n.push(s),r.push(i)}}if(t.length>0){const s=await Promise.all(t);for(let a=0;a<s.length;++a)e[n[a]]=s[a][0];on(r)}}function w8(e){if(e!=null)for(const t in e){const n=e[t];typeof n!="number"&&n.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var mV;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(mV||(mV={}));const A1e=125;class bv{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,n){}async onEpochEnd(t,n){}async onBatchBegin(t,n){}async onBatchEnd(t,n){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class R1e{constructor(t,n=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=n}append(t){this.callbacks.push(t)}setParams(t){for(const n of this.callbacks)n.setParams(t)}setModel(t){for(const n of this.callbacks)n.setModel(t)}async onEpochBegin(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onEpochBegin(t,n)}async onEpochEnd(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onEpochEnd(t,n)}async onBatchBegin(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onBatchBegin(t,n)}async onBatchEnd(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onBatchEnd(t,n)}async onTrainBegin(t){t==null&&(t={});for(const n of this.callbacks)await n.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const n of this.callbacks)await n.onTrainEnd(t)}}class D1e extends bv{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,n){n==null&&(n={});const r=n.size==null?0:n.size;this.seen+=r;for(const s in n){const a=n[s];if(typeof a=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+a*r;else{let i;s in this.totals?i=this.totals[s]:this.totals[s]=0;const o=Se(()=>He(this.totals[s],fe(a,r)));this.totals[s]=o,i!=null&&i.dispose()}}}async onEpochEnd(t,n){if(n!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?n[r]=this.totals[r]/this.seen:Se(()=>{const s=fe(Ot(1,this.seen),this.totals[r]);n[r]=s,this.totals[r].dispose(),Ul(n[r])}))}}class F1e extends bv{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,n){n==null&&(n={}),this.epoch.push(t);for(const r in n)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(n[r])}async syncData(){const t=[],n=[],r=[];for(const a in this.history){const i=this.history[a];for(let o=0;o<i.length;++o)if(typeof i[o]!="number"){const l=i[o];t.push(l.data()),n.push(a),r.push(o)}}const s=await Promise.all(t);for(let a=0;a<s.length;++a)this.history[n[a]][r[a]].dispose(),this.history[n[a]][r[a]]=s[a][0]}}class O1e extends bv{constructor(t,n){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||NH,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=A1e),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");A_(this.yieldEvery)&&(this.maybeWait=K0e(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,n,r){const s=[];this.yield!=null&&(await mp(r),s.push(this.yield(t,n,r))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(t,n){this.currentEpoch=t,this.epochBegin!=null&&(await mp(n),await this.epochBegin(t,n))}async onEpochEnd(t,n){const r=[];this.epochEnd!=null&&(await mp(n),r.push(this.epochEnd(t,n))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(t,n){this.batchBegin!=null&&(await mp(n),await this.batchBegin(t,n))}async onBatchEnd(t,n){const r=[];this.batchEnd!=null&&(await mp(n),r.push(this.batchEnd(t,n))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):A_(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,t,n)),await Promise.all(r)}async onTrainBegin(t){this.trainBegin!=null&&(await mp(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await mp(t),await this.trainEnd(t))}}function k8(e,t){return e==null&&(e={}),e instanceof bv?[e]:Array.isArray(e)&&e[0]instanceof bv?e:Wn(e).map(r=>new O1e(r,t))}class ho{constructor(){}static registerCallbackConstructor(t,n){Y(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),ho.checkForDuplicate(n),ho.constructors[t]==null&&(ho.constructors[t]=[]),ho.constructors[t].push(n)}static checkForDuplicate(t){for(const n in ho.constructors)ho.constructors[+n].forEach(s=>{if(s===t)throw new he("Duplicate callback constructor.")})}static clear(){ho.constructors={}}static createCallbacks(t){const n=[];for(const r in ho.constructors){const s=+r;t>=s&&n.push(...ho.constructors[s])}return n.map(r=>new r)}}ho.constructors={};function I8(e,t,n,r,s,a,i,o,l){const u=new F1e,c=[new D1e,...ho.createCallbacks(t)];e!=null&&c.push(...e),c.push(u);const d=new R1e(c);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Au(e,t={},n=!1){return o1(e,go.getMap().classNameMap,t,"layer",n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function iI(e,t){return Se(()=>{e.dtype!=="float32"&&(e=lt(e,"float32"));const n=Ft(u1(e),t,!0),r=yC(n.shape,ls()),s=ia(Sd(n,r));return Ot(e,s)})}function $C(e,t){return Se(()=>qr(u1(Bt(t,e)),-1))}function JF(e,t){return Se(()=>qr(va(Bt(t,e)),-1))}function QF(e,t){return Se(()=>{const n=Bt(e,t),r=qi(va(e),ls(),Number.MAX_VALUE),s=va(Ot(n,r));return fe(100,qr(s,-1))})}function M1e(e,t){return Se(()=>{const n=qi(t,ls(),Number.MAX_VALUE),r=Ql(He(1,n)),s=qi(e,ls(),Number.MAX_VALUE),a=Ql(He(1,s));return qr(u1(Bt(r,a)),-1)})}function L1e(e,t){return Se(()=>{const n=Sd(0,Bt(1,fe(e,t)));return qr(u1(n),-1)})}function P1e(e,t){return Se(()=>{const n=Sd(0,Bt(1,fe(e,t)));return qr(n,-1)})}function z1e(e,t){return Se(()=>{const n=Ft(fe(e,t),-1),r=Yo(fe(Bt(1,e),t),-1);return Sd(0,He(1,Bt(r,n)))})}function B1e(e,t){return Se(()=>{const n=Math.log(2),r=Bt(t,e),s=Bt(He(r,e1(fe(-2,r))),n);return qr(s,-1)})}function vv(e,t,n=!1){return Se(()=>{if(n)t=rF(t);else{const r=Ft(t,t.shape.length-1,!0);t=Ot(t,r)}return t=qi(t,ls(),1-ls()),Lr(Ft(fe(lt(e,"float32"),Ql(t)),t.shape.length-1))})}function oI(e,t,n=!1){return Se(()=>{const r=lt(vC(i1e(e)),"int32");t=qi(t,ls(),1-ls());const s=t.shape,a=be(Kj(r,s[s.length-1]),s);return vv(a,t,n)})}function W1e(e,t){if(!Dn(e.shape,t.shape))throw new he(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return Se(()=>{const n=Oh(t),r=Lr(va(t));return He(Bt(n,fe(t,e)),Gj(Jl(r)))})}function EC(e,t){return Se(()=>{let n;return n=qi(t,ls(),1-ls()),n=Ql(Ot(n,Bt(1,n))),qr(W1e(e,n),-1)})}function V1e(e,t){return Se(()=>{const n=qi(e,ls(),1),r=qi(t,ls(),1);return Ft(fe(e,Ql(Ot(n,r))),-1)})}function U1e(e,t){return Se(()=>{const n=Ql(He(ls(),t));return qr(Bt(t,fe(e,n)),-1)})}function S8(e,t){return Se(()=>{const n=iI(e,-1),r=iI(t,-1),s=fe(n,r);return Lr(Ft(s,-1))})}const lI={meanSquaredError:$C,meanAbsoluteError:JF,meanAbsolutePercentageError:QF,meanSquaredLogarithmicError:M1e,squaredHinge:L1e,hinge:P1e,categoricalHinge:z1e,logcosh:B1e,categoricalCrossentropy:vv,sparseCategoricalCrossentropy:oI,binaryCrossentropy:EC,kullbackLeiblerDivergence:V1e,poisson:U1e,cosineProximity:S8};function NE(e){if(typeof e=="string"){if(e in lI)return lI[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new he(t)}else return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function C8(e,t){return Se(()=>{const n=fe(.5,ko(t)),r=jl(Zi(t,n),e.dtype);return qr(Zl(e,r),-1)})}function N8(e,t){return Se(()=>jl(Zl(fv(e,-1),fv(t,-1)),"float32"))}function G1e(e,t){return Se(()=>lt(Ft(Lu(Zl(e,1),Zl(t,1))),"float32"))}function j1e(e,t){return Se(()=>lt(Ft(Lu(Zl(e,0),Zl(t,1))),"float32"))}function H1e(e,t){return Se(()=>{const n=G1e(e,t),r=j1e(e,t),s=He(n,r);return lt(Ta(Zi(s,0),Ot(n,s),0),"float32")})}function q1e(e,t){return EC(e,t)}function K1e(e,t){return e.rank===t.rank&&(e=n1(e,[e.rank-1])),t=fv(t,-1),t.dtype!==e.dtype&&(t=lt(t,e.dtype)),lt(Zl(e,t),"float32")}const X1e=$C,Y1e=$C,Z1e=JF,J1e=JF,Q1e=QF,ewe=QF,T8=vv,twe=S8,$8=oI,uI={binaryAccuracy:C8,categoricalAccuracy:N8,precision:H1e,categoricalCrossentropy:T8,sparseCategoricalCrossentropy:$8,mse:X1e,MSE:Y1e,mae:Z1e,MAE:J1e,mape:Q1e,MAPE:ewe,cosine:twe};function nwe(e){if(typeof e=="string"&&e in uI)return uI[e];if(typeof e!="string"&&e!=null)return e;throw new he(`Unknown metric ${e}`)}function zk(e){if(Rl(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(const n of Object.keys(lI))if(lI[n]===e){t=n;break}if(t!==void 0)return t;for(const n of Object.keys(uI))if(uI[n]===e){t=n;break}return t!==void 0?t:e.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function rwe(e){const t={Adagrad:()=>Zm.adagrad(.01),Adadelta:()=>Zm.adadelta(1,.95,ls()),Adam:()=>Zm.adam(.001,.9,.999,ls()),Adamax:()=>Zm.adamax(.002,.9,.999,ls(),0),RMSProp:()=>Zm.rmsprop(.001,.9,0,ls()),SGD:()=>Zm.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new he(`Unknown Optimizer ${e}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const gV=1*1024*1024;function yV(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!sA(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const r=JSON.stringify(e);r.length>gV&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${gV}.`)}}function sA(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t)if(typeof n!="string"||!sA(e[n]))return!1;return!0}else if(Array.isArray(e)){for(const t of e)if(!sA(t))return!1;return!0}else return!1;else{const t=typeof e;return t==="string"||t==="number"||t==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function swe(e,t,n,r=console.log){const s=iwe(e),a=["Layer (type)","Input Shape","Output shape","Param #"];s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let i;if(!s){a.push("Receives inputs"),i=[];for(const c in e.nodesByDepth)i.push(...e.nodesByDepth[c])}r("_".repeat(t)),cI(a,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)s?owe(o[c],n,r):lwe(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=awe(e),u=rI(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function awe(e){let t;return e.collectedTrainableWeights!=null?t=rI(e.collectedTrainableWeights):t=rI(e.trainableWeights),t}function iwe(e){let t=!0;const n=[],r=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of e.layers){let a=!1;for(const i of s.inboundNodes)if(r.indexOf(i)!==-1)if(a){t=!1;break}else a=!0;if(!t)break}return t}function cI(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function owe(e,t,n){let r,s;try{s=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}const a=e.name,i=e.getClassName(),o=[`${a} (${i})`,s,r,e.countParams().toString()];cI(o,t,n)}function lwe(e,t,n,r){let s,a;try{a=e.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{a="multiple"}try{s=JSON.stringify(e.outputShape)}catch{s="multiple"}const i=[];for(const d of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let p=0;p<d.inboundLayers.length;++p){const h=d.inboundLayers[p].name,m=d.nodeIndices[p],g=d.tensorIndices[p];i.push(`${h}[${m}][${g}]`)}const o=e.name,l=e.getClassName(),u=i.length===0?"":i[0],c=[`${o} (${l})`,a,s,e.countParams().toString(),u];cI(c,t,r);for(let d=1;d<i.length;++d)cI(["","","","",i[d]],t,r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function E8(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function aA(e,t){if(e===null)return null;if(typeof e=="string")return Cp(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const a=e[s];E8(t,s,a)?n.push(a):n.push(aA(a,t))}return n}else{const n={};for(const r of Object.keys(e)){const s=e[r];if(r==="name"&&typeof s=="string")n[r]=s;else{const a=Cp(r);n[a]=aA(s,a)}}return n}}function iA(e,t){if(e==null)return null;if(typeof e=="string")return Su(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const a=e[s];E8(t,s,a)?n.push(a):n.push(iA(a,t))}return n}else{const n={};for(const r of Object.keys(e)){const s=e[r],a=Su(r);(r==="name"||r==="className")&&typeof s=="string"?n[a]=s:n[a]=iA(s,r)}return n}}/** @license See the LICENSE file. */const _8="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const uwe=e=>{const t=Object.keys(e);if(t.length===0)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))};class Uo extends cn{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const v=this.getClassName().toLowerCase();this.name=CC(v)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Gc(this.inputs).length!==this.inputs.length)throw new he(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(v=>v.name)}`);Gc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(v=>v.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const v of this.outputs){const k=v.sourceLayer,I=v.nodeIndex,S=v.tensorIndex;this.outputLayers.push(k),this.outputLayersNodeIndices.push(I),this.outputLayersTensorIndices.push(S)}for(const v of this.inputs){const k=v.sourceLayer,I=v.nodeIndex,S=v.tensorIndex;Rl(I===0,"input layer has >1 nodes"),Rl(S===0,"input layer has >1 tensors"),this.inputLayers.push(k),this.inputLayersNodeIndices.push(I),this.inputLayersTensorIndices.push(S)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let v=0;v<this.inputLayers.length;v++){const k=this.inputLayers[v];if(!(k instanceof d1))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${v} (0-based) originates from layer type ${k.getClassName()}.`);this.inputNames.push(k.name),this.feedInputShapes.push(k.batchInputShape),this.feedInputNames.push(k.name)}for(const v of this.outputLayers)this.outputNames.push(v.name);this.internalInputShapes=this.inputs.map(v=>v.shape),this.internalOutputShapes=this.outputs.map(v=>v.shape);const n={},r={},s={},a={},i={},o=[],l=(v,k,I,S,N,T)=>{(S==null||N==null||T==null)&&(S=v.sourceLayer,N=v.nodeIndex,T=v.tensorIndex);const A=S.inboundNodes[N];if(I.indexOf(A)!==-1)throw new xo(`The tensor ${v.name} at layer "${S.name}" is part of a cycle.`);if(k.indexOf(A)!==-1)return;this.containerNodes.add(Uo.nodeKey(S,N)),S.id in i||(i[S.id]=Object.keys(i).length),I.indexOf(A)===-1&&I.push(A);const R=A.inboundLayers.length;for(let D=0;D<R;D++){const $=A.inputTensors[D],_=A.inboundLayers[D],L=A.nodeIndices[D],z=A.tensorIndices[D];l($,k,I,_,L,z)}for(k.push(A);I.indexOf(A)>=0;)I.splice(I.indexOf(A),1);o.push(A)},u=[],c=[];for(const v of this.outputs)l(v,u,c);const d=o.slice().reverse();for(const v of d){r[v.id]=v,v.id in n||(n[v.id]=0);let k=n[v.id];const I=s[v.outboundLayer.id]==null?0:s[v.outboundLayer.id];k=Math.max(k,I),s[v.outboundLayer.id]=k,a[v.outboundLayer.id]=v.outboundLayer,n[v.id]=k;for(let S=0;S<v.inboundLayers.length;S++){const N=v.inboundLayers[S],T=v.nodeIndices[S],A=N.inboundNodes[T],R=n[A.id]==null?0:n[A.id];n[A.id]=Math.max(k+1,R),r[A.id]=A}}const p={};for(const v in n){const k=n[v];k in p||(p[k]=[]),p[k].push(r[v])}const h={};for(const v in s){const k=s[v];k in h||(h[k]=[]),h[k].push(a[v])}let m=Object.keys(h).map(v=>parseInt(v,10)).sort(Mk);this.layers=[];for(const v of m){const k=h[v];k.sort((I,S)=>{const N=i[I.id],T=i[S.id];return N<T?-1:N>T?1:0});for(const I of k)I instanceof Uo&&this.internalContainerRefs.push(I),this.layers.push(I)}this.layersByDepth=h,m=Object.keys(p).map(v=>parseInt(v,10)).sort(Mk);const g=this.inputs.slice(),y=[];for(const v of m)for(const k of p[v]){const I=k.outboundLayer;if(I!=null){for(const S of k.inputTensors)if(g.indexOf(S)===-1)throw new xo(`Graph disconnected: cannot obtain value for tensor ${S} at layer "${I.name}". The following previous layers were accessed without issue: ${y}`);for(const S of k.outputTensors)g.push(S);y.push(I.name)}}this.nodesByDepth=p;const b=this.layers.map(v=>v.name);for(const v of b){const k=b.filter(I=>I===v).length;if(k!==1)throw new xo(`The name "${v}" is used ${k} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new TC({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(v=>null),outputMasks:this.outputs.map(v=>null),inputShapes:this.inputs.map(v=>v.shape),outputShapes:this.outputs.map(v=>v.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new he("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){const r={};let s=0;const a=uwe(t);a&&this.parseWeights(t);for(const o of this.layers)for(const[l,u]of o.weights.entries()){const c=a?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(r[c]!=null)throw new he(`Duplicate weight name: ${c}`);r[c]=u,s++}const i=[];for(const o in t){let l=o;if(r[o]==null){const u=o.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(r[l]!=null)i.push([r[l],t[o]]);else if(n)throw new he(`Provided weight data has no target variable: ${o}`);delete r[l]}if(n){const o=[];for(const l in r)o.push(l);if(o.length>0)throw new he(`${o.length} of ${s} weights are not set: ${o}`)}YF(i)}parseWeights(t){for(const n in Object.keys(t)){const r=n.split("/"),s=["vars","layer_checkpoint_dependencies"],a=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!s.includes(i)).join("/");a!==n&&(t[a]=t[n],delete t[n])}}updatedConfig(){const t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${_8}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){const r=iA(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return Se(()=>{t=Wn(t);const r=new Oc;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Vb(this.outputs,r,n)})}computeMask(t,n){return Se(()=>{t=Wn(t);let r;return n==null?r=lh(null,t.length):r=Wn(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const n=nI(t);if(n.length!==this.inputLayers.length)throw new he(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let o=0;o<n.length;o++){const l=this.inputLayers[o],u=n[o],c=l.name+"_0_0";r[c]=u}const s=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Mk);if(s.length>1)for(const o of s){const l=this.nodesByDepth[o];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(c.id)!==-1)continue;const d=[];for(let g=0;g<u.inboundLayers.length;g++){const y=u.inboundLayers[g],b=u.nodeIndices[g],v=u.tensorIndices[g],k=`${y.name}_${b}_${v}`,I=r[k];d.push(I)}const p=c.computeOutputShape(Ua(d)),h=nI(p),m=c.inboundNodes.indexOf(u);for(let g=0;g<h.length;g++){const y=`${c.name}_${m}_${g}`;r[y]=h[g]}}}const a=[],i=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],d=`${l.name}_${u}_${c}`;i.push(d)}for(let o=0;o<i.length;o++){const l=i[o];Rl(l in r),a.push(r[l])}return Ua(a)}runInternalGraph(t,n){n==null&&(n=lh(null,t.length));const r={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=t[l],d=n[l];r[u.id]=[c,d]}const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Mk);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,p=c.inputTensors,h=c.outputTensors,m=new Array;for(const g of p)g.id in r&&m.push(r[g.id]);if(m.length===p.length){let g={},y,b,v,k;if(c.callArgs!=null&&(g=c.callArgs),m.length===1){const[I,S]=m[0];g.mask==null&&(g.mask=S),v=Wn(d.call(I,g)),k=Wn(d.computeMask(I,S)),y=[I],b=[S]}else y=m.map(I=>I[0]),b=m.map(I=>I[1]),g.mask==null&&(g.mask=b),v=Wn(d.call(y,g)),k=Wn(d.computeMask(y,b));if(d.activityRegularizer)throw new rn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let I=0;I<h.length;++I){const S=h[I],N=v[I],T=k[I];r[S.id]=[N,T]}}}}const a=[],i=[],o=[];for(const l of this.outputs){Rl(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];o.push(u.shape),a.push(u),i.push(c)}return[a,i,o]}buildNodeConversionMap(t){const n={};let r;for(const s of this.layers){r=s instanceof Uo?1:0;for(let a=0;a<s.inboundNodes.length;a++){const i=Uo.nodeKey(s,a);this.containerNodes.has(i)&&(n[i]=r,r+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new he("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const r of this.layers)if(r.name===t)return r;throw new he(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new he(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return Se(()=>{const t=[];for(const n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){const s=Uo.nodeKey(n,r);this.containerNodes.has(s)&&t.push(...n.calculateLosses())}return t})}getConfig(){const t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(const i of this.layers){const o=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){const p=i.inboundNodes[d],h=Uo.nodeKey(i,d);let m={};if(this.containerNodes.has(h)){if(p.callArgs)try{JSON.stringify(p.callArgs),m=p.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),m={}}if(p.inboundLayers.length>0){const g=[];for(let y=0;y<p.inboundLayers.length;y++){const b=p.inboundLayers[y],v=p.nodeIndices[y],k=p.tensorIndices[y],I=Uo.nodeKey(b,v);let S=n[I];S==null&&(S=0),g.push([b.name,S,k,m])}u.push(g)}}}const c={};c.name=i.name,c.className=o,c.config=l,c.inboundNodes=u,r.push(c)}t.layers=r;const s=[];for(let i=0;i<this.inputLayers.length;i++){const o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=Uo.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const d=this.inputLayersTensorIndices[i];s.push([o.name,c,d])}t.inputLayers=s;const a=[];for(let i=0;i<this.outputLayers.length;i++){const o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=Uo.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const d=this.outputLayersTensorIndices[i];a.push([o.name,c,d])}return t.outputLayers=a,t}static fromConfig(t,n,r={},s=!1){const a={},i={};function o(y,b){y.name in i?i[y.name].push(b):i[y.name]=[b]}function l(y,b){const v=[];let k;for(const I of b){const S=I[0],N=I[1],T=I[2];if(k=I[3]==null?{}:I[3],!(S in a)){o(y,b);return}const A=a[S];if(A.inboundNodes.length<=N){o(y,b);return}const R=A.inboundNodes[N];v.push(R.outputTensors[T])}v.length>0&&y.apply(Ua(v),k)}function u(y){const b=y.name,v=Au(y,n.customObjects!=null?n.customObjects:{});v.setFastWeightInitDuringBuild(s),a[b]=v,y.inboundNodes.forEach(I=>{if(!(I instanceof Array))throw new he(`Corrupted configuration, expected array for nodeData: ${I}`);o(v,I)})}const c=n.name,d=n.layers;for(const y of d)u(y);for(;!q0e(i);)for(const y of d){const b=a[y.name];if(b.name in i){const v=i[b.name];delete i[b.name];for(const k of v)l(b,k)}}const p=[],h=[],m=n.inputLayers;for(const y of m){const b=y[0],v=y[1],k=y[2];Rl(b in a);const S=a[b].inboundNodes[v].outputTensors;p.push(S[k])}const g=n.outputLayers;for(const y of g){const b=y[0],v=y[1],k=y[2];Rl(b in a);const S=a[b].inboundNodes[v].outputTensors;h.push(S[k])}return new t({inputs:p,outputs:h,name:c})}get stateful(){if(this._stateful)throw new he("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){Se(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function cwe(e,t,n){const r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){const s=[];return t.forEach(a=>{a in e?s.push(e[a]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function A8(e,t){return cwe(e,t,"classWeight")}async function R8(e,t,n,r){if(n!=null){const s=Se(()=>{if(e.shape.length===1)return Wp(e);if(e.shape.length===2){if(e.shape[1]>1)return fv(e,1);if(e.shape[1]===1)return be(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await s.data());on(s);const i=[];return a.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),yi(i,"float32")}else return null}function dwe(e,t){return fe(e,t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const pwe=32;function D8(e,t){let n,r;const s=t;n=s.xs,r=s.ys,Y(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const a=xV("input",e.inputNames,n),i=xV("output",e.outputNames,r),o=a[0].shape[0];Y(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),Y(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<a.length;l++)Y(a[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)Y(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:a,ys:i}}function xV(e,t,n){if(n instanceof os)return[n];if(Array.isArray(n))return Y(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{const r=[];for(const s of t){if(n[s]==null)throw new he(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function hwe(e){if(e.length===3)throw new rn("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function fwe(e,t,n){const r=n.batchesPerEpoch!=null;if(Y(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),Y(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),Y(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),Y(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),Y(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=n.validationData!=null;let a,i;if(s)if(bV(n.validationData))Y(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const y=hwe(n.validationData);a=y.xs,i=y.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;s?u=l.slice().concat(l.map(y=>"val_"+y)):u=l.slice();const c=k8(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:p,history:h}=I8(c,d,n.epochs,null,null,mwe(t,n),null,s,u);p.setModel(e),e.history=h,await p.onTrainBegin(),e.stopTraining_=!1;let m=n.initialEpoch==null?0:n.initialEpoch,g=await t.iterator();for(;m<n.epochs;){const y={};await p.onEpochBegin(m);let b=0,v=0;for(r||(g=await t.iterator());!r||b<n.batchesPerEpoch;){const k=await g.next();if(r&&k.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(k.value!=null){const{xs:I,ys:S}=D8(e,k.value),N={};N.batch=v,N.size=I[0].shape[0],await p.onBatchBegin(v,N);const T=[];if(n.classWeight!=null){const D=A8(n.classWeight,e.outputNames);for(let $=0;$<D.length;++$)T.push(await R8(S[$],null,D[$]))}const A=I.concat(S).concat(T),R=o(A);on(A);for(let D=0;D<l.length;++D){const $=l[D],_=R[D];N[$]=_,Ul(_)}await p.onBatchEnd(v,N),w8(N),v++,b++}if(r?b>=n.batchesPerEpoch:k.done){if(s){let I;bV(n.validationData)?I=Wn(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):I=Wn(e.evaluate(a,i,{batchSize:n.validationBatchSize==null?pwe:n.validationBatchSize,verbose:0}));for(let S=0;S<e.metricsNames.length;++S)y[`val_${e.metricsNames[S]}`]=I[S]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(m,y),m++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function mwe(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function bV(e){return typeof e.iterator=="function"}function gwe(e){return typeof e.next=="function"}async function ywe(e,t,n){n=n||{};const r=n.batches!=null,s=e.testFunction;let a=[];if(n.verbose>0)throw new rn("Verbose mode is not implemented yet.");Y(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i=gwe(t)?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const u=await i.next();if(a=Se(()=>{if(u.value){const{xs:c,ys:d}=D8(e,u.value),p=c.concat(d),h=Se(()=>s(p));if(on(p),l===0)for(let g=0;g<h.length;++g)a.push(Rn(0));const m=p[0].shape[0];for(let g=0;g<h.length;++g){const y=h[g],b=a[g];a[g]=Se(()=>He(a[g],fe(m,y))),l>0&&on(b)}on(h),o+=m,++l}return a}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){const c=a[u];a[u]=Ot(a[u],o),on(c)}return Ua(a)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function TE(e){Y(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Rb(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>Up(r,t,n-t)):Up(e,t,n-t)}function oA(e,t){return Se(()=>e==null?null:Array.isArray(e)?e.map(n=>oA(n,t)):o8(e,t.dtype==="int32"?t:lt(t,"int32")))}function $E(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function F8(e){const t=[];e instanceof os&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(r.rank===1)t.push(l1(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Po(e,t){if(e==null)return;const n=[];if(t instanceof os)n.push(t.id);else if(Array.isArray(t))t.forEach(s=>n.push(s.id));else if(t!=null)for(const s in t){const a=t[s];n.push(a.id)}const r=[];if(e instanceof os)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(e!=null)for(const s in e){const a=e[s];n.indexOf(a.id)===-1&&r.push(a)}r.forEach(s=>{s.isDisposed||s.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function xwe(e){return e instanceof os}function lA(e){return Array.isArray(e)}function vV(e){return!xwe(e)&&!lA(e)}function wV(e,t,n,r=!0,s=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(lA(e)&&e.length>0)i=!0;else if(vV(e)){for(const o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new he(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let a;if(vV(e)){e=e,a=[];for(const i of t){if(e[i]==null)throw new he(`No data provided for "${i}". Need data for each key in: ${t}`);a.push(e[i])}}else if(lA(e)){if(e=e,e.length!==t.length)throw new he(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new he(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=F8(a),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new he(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;const u=o.shape[l],c=n[i][l];if(c!=null&&c>=0&&u!==c)throw new he(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function bwe(e,t,n){const r=Gc(e.map(a=>a.shape[0]));r.sort();const s=Gc(t.map(a=>a.shape[0]));if(s.sort(),r.length>1)throw new he(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>1)throw new he(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(r.length>0&&s.length>0&&!Dn(r,s))throw new he(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function vwe(e,t,n){const r=[$C,EC,vv];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(i!=null){if(i===vv&&a.shape[a.shape.length-1]===1)throw new he(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){const l=a.shape.slice(1),u=o.slice(1);for(let c=0;c<l.length;++c){const d=l[c],p=u[c];if(p!=null&&d!==p)throw new he(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function kV(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new he(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new he(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new he(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;const u=o.shape[l],c=n[i][l];if(c!=null&&c!==u)throw new he(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function wwe(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{const r=[];for(const s of t){let a=n.hasOwnProperty(s)?n[s]:[];Array.isArray(a)||(a=[a]),r.push(a)}return r}}const kwe="layers-model";class gg extends Uo{constructor(t){super(t),this.isTraining=!1}summary(t,n,r=console.log){if(!this.built)throw new he("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");swe(this,t,n,r)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=rwe(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Nd))throw new he("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const i in t.loss)if(this.outputNames.indexOf(i)===-1)throw new he(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)t.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),n.push(NE(t.loss[i]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new he(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);n=t.loss.map(o=>NE(o))}else{const i=NE(t.loss);this.outputs.forEach(o=>{n.push(i)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const o=this.internalOutputShapes[i],l=this.outputNames[i];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[i])}const r=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Vp("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(r.indexOf(i)!==-1)continue;const o=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([o,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const s=wwe(t.metrics,this.outputNames),a=(i,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[i]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,i])};Vp("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(r.indexOf(i)!==-1)continue;const o=s[i];(u=>{const c="";let d,p,h;for(const m of u){if(typeof m=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(m)!==-1){const y=this.internalOutputShapes[i];y[y.length-1]===1||this.lossFunctions[i]===EC?["accuracy","acc"].indexOf(m)!==-1?p=C8:["crossentropy","ce"].indexOf(m)!==-1&&(p=q1e):this.lossFunctions[i]===oI?["accuracy","acc"].indexOf(m)!==-1?p=K1e:["crossentropy","ce"].indexOf(m)!==-1&&(p=$8):["accuracy","acc"].indexOf(m)!==-1?p=N8:["crossentropy","ce"].indexOf(m)!==-1&&(p=T8);let b;["accuracy","acc"].indexOf(m)!==-1?b="acc":["crossentropy","ce"].indexOf(m)!==-1&&(b="ce"),h=p,d=c+b}else h=nwe(m),d=c+zk(m);let g;Vp(d,()=>{g=h}),a(i,d,g)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,n,r={}){const s=r.batchSize==null?32:r.batchSize;TE(s);const i=this.standardizeUserDataXY(t,n,!0,s);try{const o=i[0].concat(i[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,o,s,r.verbose,r.steps);return Ua(u)}finally{Po(i[0],t),Po(i[1],n)}}async evaluateDataset(t,n){return this.makeTestFunction(),ywe(this,t,n)}checkNumSamples(t,n,r,s="steps"){let a;if(r!=null){if(a=null,n!=null)throw new he(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(t!=null)Array.isArray(t)?a=t[0].shape[0]:a=t.shape[0];else throw new he(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return a}execute(t,n){if(Array.isArray(n)&&n.length===0)throw new he("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(n),s=r?n:[n],a=this.retrieveSymbolicTensors(s),i=new Oc;if(t instanceof os&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new he(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)i.add(this.inputs[l],t[l])}else for(const l of this.inputs){const u=t[l.name];if(u==null)throw new he(`No value is provided for the model's input ${l.name}`);i.add(l,u)}const o=Vb(a,i);return r?o:o[0]}retrieveSymbolicTensors(t){const n=lh(null,t.length);let r=t.length;for(const s of this.layers){const a=Array.isArray(s.output)?s.output:[s.output],i=a.map(o=>o.name);for(let o=0;o<t.length;++o){const l=i.indexOf(t[o]);if(l!==-1&&(n[o]=a[l],r--),r===0)break}if(r===0)break}if(r>0){const s=[];throw n.forEach((a,i)=>{a==null&&s.push(t[i])}),new he(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return n}predictLoop(t,n=32,r=!1){return Se(()=>{const s=this.checkNumSamples(t);if(r)throw new rn("Verbose predictLoop() is not implemented yet.");const a=$E(s,n),i=this.outputs.map(o=>[]);for(let o=0;o<a.length;++o)Se(()=>{const u=a[o][0],c=a[o][1],d=Rb(t,u,c),p=[];if(Array.isArray(d))for(let m=0;m<d.length;++m)p.push({key:this.inputs[m],value:d[m]});else p.push({key:this.inputs[0],value:d});const h=new Oc(p);return Vb(this.outputs,h)}).forEach((u,c)=>i[c].push(u));return Ua(i.map(o=>Ka(o,0)))})}predict(t,n={}){const r=F8(t);kV(r,this.inputNames,this.feedInputShapes,!1);try{const s=n.batchSize==null?32:n.batchSize;return TE(s),this.predictLoop(r,s)}finally{Po(r,t)}}predictOnBatch(t){kV(t,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,n)}standardizeUserDataXY(t,n,r=!0,s){if(this.optimizer_==null)throw new xo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let i=0;i<this.feedOutputShapes.length;++i){const o=this.feedOutputShapes[i];this.feedLossFns[i]===oI?a.push(o.slice(0,o.length-1).concat([1])):a.push(o)}if(t=wV(t,this.feedInputNames,this.feedInputShapes,!1,"input"),n=wV(n,this.feedOutputNames,a,!1,"target"),bwe(t,n),vwe(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&t[0].shape[0]%s!==0)throw new he(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${t[0].shape[0]} sample(s).`);return[t,n]}async standardizeUserData(t,n,r,s,a=!0,i){const[o,l]=this.standardizeUserDataXY(t,n,a,i);if(r!=null)throw new Error("sample weight is not supported yet.");let u=null;if(s!=null){const c=A8(s,this.outputNames);u=[];for(let d=0;d<c.length;++d)u.push(await R8(l[d],null,c[d]))}return[o,l,u]}testLoop(t,n,r,s=0,a){return Se(()=>{const i=this.checkNumSamples(n,r,a,"steps"),o=[];if(s>0)throw new rn("Verbose mode is not implemented yet.");if(a!=null)throw new rn("steps mode in testLoop() is not implemented yet");{const l=$E(i,r),u=yi(sl(0,i));for(let c=0;c<l.length;++c){const d=l[c][0],p=l[c][1],h=Up(u,d,p-d),m=oA(n,h),g=t(m);if(c===0)for(let y=0;y<g.length;++y)o.push(Rn(0));for(let y=0;y<g.length;++y){const b=g[y];o[y]=He(o[y],fe(p-d,b))}}for(let c=0;c<o.length;++c)o[c]=Ot(o[c],i)}return o})}getDedupedMetricsNames(){const t=this.metricsNames,n=[];for(let r=0;r<t.length;++r){const s=t[r];let a=s;if(iV(t,s)>1){const i=iV(t.slice(0,r),s);a+=`_${i}`}n.push(a)}return n}makeTrainFunction(){return t=>{const n=[],r=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],o=()=>{const d=[];for(let g=0;g<this.inputs.length;++g)d.push({key:this.inputs[g],value:r[g]});const p=new Oc(d),h=Vb(this.outputs,p,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){const y=this.lossFunctions[g];let b=y(s[g],h[g]);a[g]!=null&&(b=dwe(b,a[g]));const v=qr(b);n.push(v),g===0?m=b:m=He(m,b)}for(let g=0;g<this.metricsTensors.length;++g){let y;if(this.outputs.length>1&&g<this.outputs.length)y=n[g];else{const b=this.metricsTensors[g][0],v=this.metricsTensors[g][1];y=qr(b(s[v],h[v]))}Ul(y),i.push(y)}return m=qr(m),this.calculateLosses().forEach(g=>{m=He(m,g)}),m},l=this.collectedTrainableWeights.map(d=>d.read());return[this.optimizer_.minimize(o,!0,l)].concat(i)}}makeTestFunction(){this.testFunction=t=>Se(()=>{const n=[];let r;const s=t.slice(0,this.inputs.length),a=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let u=0;u<this.inputs.length;++u)i.push({key:this.inputs[u],value:s[u]});const o=new Oc(i),l=Vb(this.outputs,o);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],d=qr(c(a[u],l[u]));u===0?r=d:r=He(r,d),n.push(r)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],d=this.metricsTensors[u][1],p=qr(c(a[d],l[d]));n.push(p)}return n})}async fit(t,n,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let s,a,i,o,l,u,c,d,p;try{const h=r.batchSize==null?32:r.batchSize;TE(h);const g=await this.standardizeUserData(t,n,r.sampleWeight,r.classWeight,!1,h);s=g[0],a=g[1],p=g[2];let y=!1,b;if(r.validationData!=null&&r.validationData.length>0){if(y=!0,r.validationData.length===2)l=r.validationData[0],u=r.validationData[1];else throw r.validationData.length===3?new rn("validationData including sample weights is not supported yet."):new he(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const D=await this.standardizeUserData(l,u,null,null,!0,h);c=D[0],d=D[1],b=c.concat(d)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){y=!0;const R=Math.floor(s[0].shape[0]*(1-r.validationSplit)),D=s[0].shape[0];c=Rb(s,R,D),i=s,s=Rb(s,0,R),d=Rb(a,R,D),o=a,a=Rb(a,0,R),b=c.concat(d)}else r.validationSteps!=null&&(y=!0);const v=s.concat(a).concat(p);this.checkTrainableWeightsConsistency();const k=this.makeTrainFunction(),I=this.getDedupedMetricsNames();let S,N;y?(this.makeTestFunction(),S=this.testFunction,N=I.slice().concat(I.map(R=>"val_"+R))):(S=null,b=[],N=I.slice());const T=k8(r.callbacks,r.yieldEvery);return await this.fitLoop(k,v,I,h,r.epochs,r.verbose,T,S,b,r.shuffle,N,r.initialEpoch,null,null)}finally{this.isTraining=!1,Po(s,t),Po(a,n),Po(i,t),Po(o,n),Po(c,l),Po(d,u),p!=null&&on(p)}}async fitLoop(t,n,r,s,a,i,o,l,u,c,d,p,h,m){s==null&&(s=32),a==null&&(a=1),c==null&&(c=!0),p==null&&(p=0);let g=!1;if(l!=null&&u!=null&&(g=!0),m!=null&&(g=!0,h==null))throw new he("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const y=this.checkNumSamples(n,s,h,"steps_per_epoch");let b;y!=null&&(b=sl(0,y)),i==null&&(i=1);const{callbackList:v,history:k}=I8(o,i,a,p,y,h,s,g,d);v.setModel(this),this.history=k,await v.onTrainBegin(),this.stopTraining_=!1;for(let I=p;I<a;++I){await v.onEpochBegin(I);const S={};if(h!=null)throw new rn("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new rn("batch shuffling is not implemneted yet");c&&she(b);const N=yi(b),T=$E(y,s);for(let A=0;A<T.length;++A){const R={};if(await v.onBatchBegin(A,R),Se(()=>{const D=T[A][0],$=T[A][1],_=Up(N,D,$-D);R.batch=A,R.size=$-D;const L=oA(n,_),z=t(L);for(let W=0;W<r.length;++W){const G=r[W],q=z[W];R[G]=q,Ul(q)}if(A===T.length-1&&g){const W=this.testLoop(l,u,s);for(let G=0;G<r.length;++G){const q=r[G],B=W[G];Ul(B),S["val_"+q]=B}}}),await v.onBatchEnd(A,R),w8(R),this.stopTraining_)break}N.dispose()}if(await v.onEpochEnd(I,S),this.stopTraining_)break}return await v.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,n){return fwe(this,t,n)}async trainOnBatch(t,n){const r=await this.standardizeUserData(t,n),s=r[0],a=r[1],o=this.makeTrainFunction()(s.concat(a)),l=[];for(const u of o){const c=await u.data();l.push(c[0])}return on(o),Po(r[0],t),Po(r[1],n),Ua(l)}getNamedWeights(t){const n=[],r=t!=null&&t.trainableOnly,s=r?this.trainableWeights:this.weights,a=this.getWeights(r);for(let i=0;i<s.length;++i)r&&!s[i].trainable||n.push({name:s[i].originalName,tensor:a[i]});return n}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=FW().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=n-FW().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Su(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(n=>Su(n))}else{const n=Object.keys(this.loss);t={};const r=this.loss;for(const s of n)if(typeof r[s]=="string")t[s]=Su(r[s]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Su(zk(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Su(zk(t)));{const t={};for(const n in this.metrics)t[n]=Su(zk(this.metrics[n]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=aA(t.optimizer_config),r=Au(n);let s;if(typeof t.loss=="string")s=Cp(t.loss);else if(Array.isArray(t.loss))s=t.loss.map(i=>Cp(i));else if(t.loss!=null){s={};for(const i in t.loss)s[i]=Cp(t.loss[i])}let a;if(Array.isArray(t.metrics))a=t.metrics.map(i=>Cp(i));else if(t.metrics!=null){a={};for(const i in t.metrics)a[i]=Cp(t.metrics[i])}this.compile({loss:s,metrics:a,optimizer:r})}async save(t,n){if(typeof t=="string"){const u=Jhe(t);if(u.length===0)throw new he(`Cannot find any save handlers for URL '${t}'`);if(u.length>1)throw new he(`Found more than one (${u.length}) save handlers for URL '${t}'`);t=u[0]}if(t.save==null)throw new he("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await MW(this.getNamedWeights(n)),o={modelTopology:this.toJSON(null,!1),format:kwe,generatedBy:`TensorFlow.js tfjs-layers v${_8}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:d}=await MW(await this.optimizer.getWeights(),u);r.specs.push(...d),r.data=Zhe([r.data,c])}return this.userDefinedMetadata!=null&&(yV(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=r.data,o.weightSpecs=r.specs,t.save(o)}setUserDefinedMetadata(t){yV(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}gg.className="Model";ze(gg);class O8 extends gg{}O8.className="Functional";ze(O8);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class wv extends gg{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:CC("sequential_"),t.layers!=null)for(const n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new he(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const n=t instanceof wv||t instanceof gg;let r;if(n){if(r=t,r.outputs.length!==1)throw new he("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new he("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new he("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=S1e({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(s)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new he(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new he("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=g8(this.outputs[0])}this.inboundNodes=[],new TC({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:lh(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=t.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(Cn(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new gg({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,r=console.log){this.built||this.build(),super.summary(t,n,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,r={}){if(!this.built)throw new xo("The model needs to be compiled before being used.");return this.model.evaluate(t,n,r)}async evaluateDataset(t,n){if(!this.built)throw new xo("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,r={}){if(!this.built)throw new xo("The model needs to be compiled before being used.");return this.model.fit(t,n,r)}async fitDataset(t,n){if(!this.built)throw new xo("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,r={},s=!1){let a,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new he("Legacy serialization format not supported yet.");a=n}else Y(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,i=n;const o=new t(i);if(!(o instanceof wv))throw new rn(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of a){const c=Au(l,void 0,s);s&&c.setFastWeightInitDuringBuild(!0),o.add(c)}return o}set stopTraining(t){if(this.model==null)throw new he("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new he("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const n of this.layers){const r={};r.className=n.getClassName(),r.config=n.getConfig(),t.push(r)}return{name:this.name,layers:t}}}wv.className="Sequential";ze(wv);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let ca=class extends gy{getConfig(){return{}}};class M8 extends ca{apply(t,n=1){return l1e(t,n)}}M8.className="elu";ze(M8);class L8 extends ca{apply(t){return Qj(t)}}L8.className="selu";ze(L8);class P8 extends ca{apply(t){return Oh(t)}}P8.className="relu";ze(P8);class z8 extends ca{apply(t){return Se(()=>yv(6,Oh(t)))}}z8.className="relu6";ze(z8);class B8 extends ca{apply(t){return t}}B8.className="linear";ze(B8);class W8 extends ca{apply(t){return hy(t)}}W8.className="sigmoid";ze(W8);class V8 extends ca{apply(t){return c1e(t)}}V8.className="hardSigmoid";ze(V8);class U8 extends ca{apply(t){return e1(t)}}U8.className="softplus";ze(U8);class G8 extends ca{apply(t){return u1e(t)}}G8.className="softsign";ze(G8);class j8 extends ca{apply(t){return mC(t)}}j8.className="tanh";ze(j8);let e3=class extends ca{apply(t,n=-1){return rF(t,n)}};e3.className="softmax";ze(e3);class H8 extends ca{apply(t,n=-1){return jj(t,n)}}H8.className="logSoftmax";ze(H8);class q8 extends ca{apply(t){return Se(()=>Se(()=>{const n=Math.sqrt(2),r=fe(.5,He(1,Bj(Ot(t,n))));return fe(t,r)}))}}q8.className="gelu";ze(q8);class K8 extends ca{apply(t){return Se(()=>fe(.5,fe(t,He(1,mC(fe(ia(Ot(2,Math.PI)),He(t,fe(.044715,ah(t,3)))))))))}}K8.className="gelu_new";ze(K8);class X8 extends ca{apply(t){return Se(()=>fe(t,mC(e1(t))))}}X8.className="mish";ze(X8);class Y8 extends ca{apply(t,n=1){return Se(()=>fe(hy(fe(t,n)),t))}}Y8.className="swish";ze(Y8);function Jc(e){return e.getClassName()}function EE(e,t={}){return o1(e,go.getMap().classNameMap,t,"activation")}function Qc(e){if(e==null){const t={};return t.className="linear",t.config={},EE(t)}if(typeof e=="string"){const t={};return t.className=e,t.config={},EE(t)}else return e instanceof ca?e:EE(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Iwe(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}class Z8 extends gy{}class J8 extends Z8{constructor(t){super(),Iwe(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return Se(()=>{let n=Es([1]);return this.hasL1&&(n=He(n,Ft(fe(this.l1,va(t))))),this.hasL2&&(n=He(n,Ft(fe(this.l2,u1(t))))),be(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,n){return new t({l1:n.l1,l2:n.l2})}}J8.className="L1L2";ze(J8);const IV={l1l2:"L1L2"};function nr(e){return BF(e)}function SV(e,t={}){return o1(e,go.getMap().classNameMap,t,"regularizer")}function vr(e){if(e==null)return null;if(typeof e=="string"){const n={className:e in IV?IV[e]:e,config:{}};return SV(n)}else return e instanceof Z8?e:SV(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Q8 extends cn{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,n){t=Wt(t);let r=Oh(t);return this.maxValue!=null&&(r=qi(r,0,this.maxValue)),r}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},n=super.getConfig();return Object.assign(t,n),t}}Q8.className="ReLU";ze(Q8);class e7 extends cn{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const r=Wt(t);return qD(r,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}}e7.className="LeakyReLU";ze(e7);class t7 extends cn{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=xr(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=vr(t.alphaRegularizer),this.alphaConstraint=hs(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new he(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=Cn(t);const n=t.slice(1);if(this.sharedAxes!=null)for(const s of this.sharedAxes)n[s-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let s=1;s<t.length;++s)r[s]=t[s];this.inputSpec=[new us({ndim:t.length,axes:r})],this.built=!0}call(t,n){return t=Wt(t),QD(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Nr(this.alphaInitializer),alphaRegularizer:nr(this.alphaRegularizer),alphaConstraint:ps(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(t,n),t}}t7.className="PReLU";ze(t7);let n7=class extends cn{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new rn(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const r=Wt(t);return xC(r)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}};n7.className="ELU";ze(n7);class r7 extends cn{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,n){const r=Wt(t);return fe(r,lt(Zi(r,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},n=super.getConfig();return Object.assign(t,n),t}}r7.className="ThresholdedReLU";ze(r7);class s7 extends cn{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new e3().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,n){return Se(()=>{let r=Wt(t);const s=n.mask;if(s!=null){const a=fe(Bt(Cd(r.shape),lt(s,r.dtype)),Rn(-1e9));r=He(r,a)}return this.axis instanceof Array?this.axis.length>1?Jl(Bt(r,Hj(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}s7.className="Softmax";ze(s7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yg(e,t,n){if(typeof e=="number")return lh(e,t);if(e.length!==t)throw new he(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const s=e[r];if(!s1e(s))throw new he(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function Zo(e,t,n,r,s=1){if(e==null)return e;const a=t+(t-1)*(s-1);let i;return n==="same"?i=e:i=e-a+1,Math.floor((i+r-1)/r)}function Dl(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+Zc([n-t,0]);else if(r==="same")e=e*t;else throw new he(`Unsupport padding mode: ${r}.`);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function t3(e,t){return Se(()=>(Br(t),t==="channelsFirst"?bn(e,[0,2,3,1]):e))}function a7(e,t){return Se(()=>(Br(t),t==="channelsFirst"?bn(e,[0,2,3,4,1]):e))}function Swe(e,t,n,r=1,s="valid",a,i=1){return Se(()=>{if(a==null&&(a=al()),Br(a),e.shape.length!==3)throw new he(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new he(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new he(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(a==="channelsFirst"&&(e=bn(e,[0,2,1])),s==="causal")throw new rn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Oj(e,t,r,s==="same"?"same":"valid","NWC",i);return n!=null&&(o=fl(o,n)),o})}function CV(e,t,n,r=[1,1],s="valid",a,i,o=null){return Se(()=>{if(a==null&&(a=al()),Br(a),e.rank!==3&&e.rank!==4)throw new he(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new he(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=t3(e,a);if(s==="causal")throw new rn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Rxe({x:l,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),a==="channelsFirst"&&(l=bn(l,[0,3,1,2])),l})}function Cwe(e,t,n,r=[1,1,1],s="valid",a,i){return Se(()=>{if(a==null&&(a=al()),Br(a),e.rank!==4&&e.rank!==5)throw new he(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new he(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=a7(e,a);if(s==="causal")throw new rn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=$me(o,t,r,s==="same"?"same":"valid","NDHWC",i),n!=null&&(o=fl(o,n)),a==="channelsFirst"&&(o=bn(o,[0,4,1,2,3])),o})}class _C extends cn{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",_C.verifyArgs(n),this.rank=t,_s(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new rn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=yg(n.kernelSize,t,"kernelSize"),this.strides=yg(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,Ji(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Br(this.dataFormat),this.activation=Qc(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=xr(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=hs(n.biasConstraint),this.biasRegularizer=vr(n.biasRegularizer),this.activityRegularizer=vr(n.activityRegularizer),this.dilationRate=yg(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new he(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new he(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new he(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Rl("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!WF(t.kernelSize,"number",1,3))throw new he(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Jc(this.activation),useBias:this.useBias,biasInitializer:Nr(this.biasInitializer),biasRegularizer:nr(this.biasRegularizer),activityRegularizer:nr(this.activityRegularizer),biasConstraint:ps(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}class yy extends _C{constructor(t,n){super(t,n),this.kernel=null,yy.verifyArgs(n),this.filters=n.filters,_s(this.filters,"filters"),this.kernelInitializer=xr(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=hs(n.kernelConstraint),this.kernelRegularizer=vr(n.kernelRegularizer)}build(t){t=Cn(t);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new he(`The channel dimension of the input should be defined. Found ${t[n]}`);const r=t[n],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return Se(()=>{t=Wt(t);let r;const s=this.bias==null?null:this.bias.read(),a=t8(this.activation.getClassName());if(a!=null&&this.rank===2)r=CV(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)r=Swe(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=CV(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=Cwe(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new rn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Cn(t);const n=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<r.length;++a){const i=Zo(r[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);n.push(i)}let s=[t[0]];return this.dataFormat==="channelsLast"?(s=s.concat(n),s.push(this.filters)):(s.push(this.filters),s=s.concat(n)),s}getConfig(){const t={filters:this.filters,kernelInitializer:Nr(this.kernelInitializer),kernelRegularizer:nr(this.kernelRegularizer),kernelConstraint:ps(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new he(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class h1 extends yy{constructor(t){super(2,t),h1.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!WF(t.kernelSize,"number",1,2))throw new he(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}h1.className="Conv2D";ze(h1);class f1 extends yy{constructor(t){super(3,t),f1.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new he(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}f1.className="Conv3D";ze(f1);class i7 extends h1{constructor(t){if(super(t),this.inputSpec=[new us({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new he(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Cn(t),t.length!==4)throw new he("Input should have rank 4; Received input shape: "+JSON.stringify(t));const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new he("The channel dimension of the inputs should be defined. Found `None`.");const r=t[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new us({ndim:4,axes:{[n]:r}})],this.built=!0}call(t,n){return Se(()=>{let r=Wt(t);if(r.shape.length!==4)throw new he(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,a=s[0];let i,o;this.dataFormat==="channelsFirst"?(i=2,o=3):(i=1,o=2);const l=s[i],u=s[o],c=this.kernelSize[0],d=this.kernelSize[1],p=this.strides[0],h=this.strides[1],m=Dl(l,p,c,this.padding),g=Dl(u,h,d,this.padding),y=[a,m,g,this.filters];this.dataFormat!=="channelsLast"&&(r=bn(r,[0,2,3,1]));let b=Mj(r,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(b=bn(b,[0,3,1,2])),this.bias!=null&&(b=fl(b,this.bias.read(),this.dataFormat)),this.activation!=null&&(b=this.activation.apply(b)),b})}computeOutputShape(t){t=Cn(t);const n=t.slice();let r,s,a;this.dataFormat==="channelsFirst"?(r=1,s=2,a=3):(r=3,s=1,a=2);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return n[r]=this.filters,n[s]=Dl(n[s],l,i,this.padding),n[a]=Dl(n[a],u,o,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}i7.className="Conv2DTranspose";ze(i7);class o7 extends f1{constructor(t){if(super(t),this.inputSpec=[new us({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new he(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Cn(t),t.length!==5)throw new he("Input should have rank 5; Received input shape: "+JSON.stringify(t));const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new he("The channel dimension of the inputs should be defined. Found `None`.");const r=t[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new us({ndim:5,axes:{[n]:r}})],this.built=!0}call(t,n){return Se(()=>{let r=Wt(t);if(r.shape.length!==5)throw new he(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,a=s[0];let i,o,l;this.dataFormat==="channelsFirst"?(l=2,i=3,o=4):(l=1,i=2,o=3);const u=s[l],c=s[i],d=s[o],p=this.kernelSize[0],h=this.kernelSize[1],m=this.kernelSize[2],g=this.strides[0],y=this.strides[1],b=this.strides[2],v=Dl(u,g,p,this.padding),k=Dl(c,y,h,this.padding),I=Dl(d,b,m,this.padding),S=[a,v,k,I,this.filters];this.dataFormat!=="channelsLast"&&(r=bn(r,[0,2,3,4,1]));let N=Ame(r,this.kernel.read(),S,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(N=bn(N,[0,4,1,2,3])),this.bias!==null&&(N=fl(N,this.bias.read(),this.dataFormat)),this.activation!==null&&(N=this.activation.apply(N)),N})}computeOutputShape(t){t=Cn(t);const n=t.slice();let r,s,a,i;this.dataFormat==="channelsFirst"?(r=1,s=2,a=3,i=4):(r=4,s=1,a=2,i=3);const o=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],d=this.strides[1],p=this.strides[2];return n[r]=this.filters,n[s]=Dl(n[s],c,o,this.padding),n[a]=Dl(n[a],d,l,this.padding),n[i]=Dl(n[i],p,u,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}o7.className="Conv3DTranspose";ze(o7);class l7 extends yy{constructor(t,n){if(super(t,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new he("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new he("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new he(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=xr(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=vr(n.depthwiseRegularizer),this.depthwiseConstraint=hs(n.depthwiseConstraint),this.pointwiseInitializer=xr(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=vr(n.pointwiseRegularizer),this.pointwiseConstraint=hs(n.pointwiseConstraint)}build(t){if(t=Cn(t),t.length<this.rank+2)throw new he(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null||t[n]<0)throw new he(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[n])}`);const r=t[n],s=this.kernelSize.concat([r,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(r*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new us({ndim:this.rank+2,axes:{[n]:r}})],this.built=!0}call(t,n){return Se(()=>{t=Wt(t);let r;if(this.rank===1)throw new rn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=bn(t,[0,2,3,1])),r=eH(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=fl(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=bn(r,[0,3,1,2])),r})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Nr(this.depthwiseInitializer),t.pointwiseInitializer=Nr(this.pointwiseInitializer),t.depthwiseRegularizer=nr(this.depthwiseRegularizer),t.pointwiseRegularizer=nr(this.pointwiseRegularizer),t.depthwiseConstraint=ps(this.depthwiseConstraint),t.pointwiseConstraint=ps(this.pointwiseConstraint),t}}l7.className="SeparableConv";class u7 extends l7{constructor(t){super(2,t)}}u7.className="SeparableConv2D";ze(u7);class AC extends yy{constructor(t){super(1,t),AC.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!WF(t.kernelSize,"number",1,1))throw new he(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}AC.className="Conv1D";ze(AC);class c7 extends cn{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,n){return Se(()=>{if(t=Wt(t),this.dataFormat==="channelsLast"){const r=Pk(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Pk(r,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=Pk(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Pk(r,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}c7.className="Cropping2D";ze(c7);class d7 extends cn{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Br(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,t1e(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const n=t[2]==null?null:this.size[0]*t[2],r=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],n,r]}else{const n=t[1]==null?null:this.size[0]*t[1],r=t[2]==null?null:this.size[1]*t[2];return[t[0],n,r,t[3]]}}call(t,n){return Se(()=>{let r=Wt(t);const s=r.shape;if(this.dataFormat==="channelsFirst"){r=bn(r,[0,2,3,1]);const a=this.size[0]*s[2],i=this.size[1]*s[3],o=this.interpolation==="nearest"?yo.resizeNearestNeighbor(r,[a,i]):yo.resizeBilinear(r,[a,i]);return bn(o,[0,3,1,2])}else{const a=this.size[0]*s[1],i=this.size[1]*s[2];return this.interpolation==="nearest"?yo.resizeNearestNeighbor(r,[a,i]):yo.resizeBilinear(r,[a,i])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(t,n),t}}d7.className="UpSampling2D";ze(d7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Nwe(e,t,n=[1,1],r="valid",s,a){return Se(()=>{s==null&&(s=al()),Br(s);let i=t3(e,s);if(e.rank!==4)throw new he(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new he(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=UD(i,t,n,r==="same"?"same":"valid","NHWC",a),s==="channelsFirst"&&(i=bn(i,[0,3,1,2])),i})}class p7 extends _C{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=xr(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=hs(t.depthwiseConstraint),this.depthwiseRegularizer=vr(t.depthwiseRegularizer)}build(t){if(t=Cn(t),t.length<4)throw new he(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(t[n]==null||t[n]<0)throw new he(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[n]}).`);const r=t[n],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return Se(()=>{t=Wt(t);let r=Nwe(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=fl(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(t){t=Cn(t);const n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,a=Zo(n,this.kernelSize[0],this.padding,this.strides[0]),i=Zo(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],s,a,i]:[t[0],a,i,s]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Nr(this.depthwiseInitializer),t.depthwiseRegularizer=nr(this.depthwiseRegularizer),t.depthwiseConstraint=ps(this.depthwiseRegularizer),t}}p7.className="DepthwiseConv2D";ze(p7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function h7(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new he("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(a){return a==null||Array.isArray(a)?a:[a]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function f7(e,t,n,r=!1,s,a,i=!1,o=!1){return Se(()=>{const l=t.shape.length;if(l<3)throw new he(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(sl(2,l));t=bn(t,u),i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=lt(lt(s,"bool"),"float32"),s.rank===l-1&&(s=Va(s,-1)),s=bn(s,u)),r&&(t=ih(t,0),s!=null&&(s=ih(s,0)));const c=[];let d,p=n;const h=t.shape[0],m=oh(t);let g;s!=null&&(g=oh(s));for(let b=0;b<h;++b){const v=m[b],k=Se(()=>e(v,p));if(s==null)d=k[0],p=k[1];else{const I=Se(()=>{const S=g[b],N=Bt(ko(S),S),T=He(fe(k[0],S),fe(p[0],N)),A=p.map((R,D)=>He(fe(k[1][D],S),fe(R,N)));return{output:T,newStates:A}});d=I.output,p=I.newStates}o&&c.push(d)}let y;return o&&(y=Pu(c,1)),[d,y,p]})}class Td extends cn{constructor(t){super(t);let n;if(t.cell==null)throw new he("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new s3({cells:t.cell}):n=t.cell,n.stateSize==null)throw new he("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new us({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return sl(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){nA(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const r=n[0];let s;if(this.returnSequences?s=[t[0],t[1],r]:s=[t[0],r],this.returnState){const a=[];for(const i of n)a.push([t[0],i]);return[s].concat(a)}else return s}computeMask(t,n){return Se(()=>{Array.isArray(n)&&(n=n[0]);const r=this.returnSequences?n:null;if(this.returnState){const s=this.states.map(a=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<t;++r)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new rn("Constants support is not implemented in RNN yet.");nA(t)&&(t=t[0]),t=t;const n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new us({shape:[n,null,...r]});const s=[t[0]].concat(t.slice(2));this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!Dn(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new he(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new us({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){Se(()=>{if(!this.stateful)throw new Al("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new he("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Es([r,s])):this.states_=[Es([r,this.cell.stateSize])];else if(t==null)on(this.states_),this.keptStates!=null&&(on(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Es([r,s])):this.states_[0]=Es([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new he(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):on(this.states_);for(let s=0;s<this.states_.length;++s){const a=t[s],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,o=[r,i];if(!Dn(a.shape,o))throw new he(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[s]=a}}this.states_=this.states_.map(s=>Ul(s.clone()))})}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});const a=h7(t,r,s,this.numConstants);t=a.inputs,r=a.initialState,s=a.constants;let i=[],o=[];if(r!=null){n.initialState=r,i=i.concat(r),this.stateSpec=[];for(const u of r)this.stateSpec.push(new us({shape:u.shape}));o=o.concat(this.stateSpec)}if(s!=null&&(n.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof eu){const u=[t].concat(i),c=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=c;const p=super.apply(u,n);return this.inputSpec=d,p}else return super.apply(t,n)}call(t,n){return Se(()=>{const r=n==null?null:n.mask,s=n==null?null:n.training;let a=n==null?null:n.initialState;t=Wt(t),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(t));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new he(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:s},u=f7((m,g)=>{const y=this.cell.call([m].concat(g),o);return[y[0],y.slice(1)]},t,a,this.goBackwards,r,null,this.unroll,this.returnSequences),c=u[0],d=u[1],p=u[2];this.stateful&&this.resetStates(p,s);const h=this.returnSequences?d:c;return this.returnState?[h].concat(p):h})}getInitialState(t){return Se(()=>{let n=Es(t.shape);return n=Ft(n,[1,2]),n=l1(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?eA(n,[1,r]):n):this.cell.stateSize>1?[eA(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===Td.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(t,n,r={}){const s=n.cell,a=Au(s,r);return new t(Object.assign(n,{cell:a}))}}Td.className="RNN";ze(Td);class RC extends cn{}class n3 extends RC{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,_s(this.units,"units"),this.activation=Qc(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=xr(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=xr(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=xr(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vr(t.kernelRegularizer),this.recurrentRegularizer=vr(t.recurrentRegularizer),this.biasRegularizer=vr(t.biasRegularizer),this.kernelConstraint=hs(t.kernelConstraint),this.recurrentConstraint=hs(t.recurrentConstraint),this.biasConstraint=hs(t.biasConstraint),this.dropout=Ag([1,Zc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Ag([1,Zc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Cn(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return Se(()=>{if(t=t,t.length!==2)throw new he(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let r=t[1];t=t[0];const s=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ed({ones:()=>ko(t),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ed({ones:()=>ko(r),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let a;const i=this.dropoutMask,o=this.recurrentDropoutMask;i!=null?a=Hl(fe(t,i),this.kernel.read()):a=Hl(t,this.kernel.read()),this.bias!=null&&(a=fl(a,this.bias.read())),o!=null&&(r=fe(r,o));let l=He(a,Hl(r,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:Jc(this.activation),useBias:this.useBias,kernelInitializer:Nr(this.kernelInitializer),recurrentInitializer:Nr(this.recurrentInitializer),biasInitializer:Nr(this.biasInitializer),kernelRegularizer:nr(this.kernelRegularizer),recurrentRegularizer:nr(this.recurrentRegularizer),biasRegularizer:nr(this.biasRegularizer),activityRegularizer:nr(this.activityRegularizer),kernelConstraint:ps(this.kernelConstraint),recurrentConstraint:ps(this.recurrentConstraint),biasConstraint:ps(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),n)}}n3.className="SimpleRNNCell";ze(n3);class m7 extends Td{constructor(t){t.cell=new n3(t),super(t)}call(t,n){return Se(()=>{this.cell.dropoutMask!=null&&(on(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(on(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return new t(n)}}m7.className="SimpleRNN";ze(m7);class r3 extends RC{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new he("GRUCell does not support reset_after parameter set to true.");this.units=t.units,_s(this.units,"units"),this.activation=Qc(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Qc(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=xr(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=xr(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=xr(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vr(t.kernelRegularizer),this.recurrentRegularizer=vr(t.recurrentRegularizer),this.biasRegularizer=vr(t.biasRegularizer),this.kernelConstraint=hs(t.kernelConstraint),this.recurrentConstraint=hs(t.recurrentConstraint),this.biasConstraint=hs(t.biasConstraint),this.dropout=Ag([1,Zc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Ag([1,Zc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Cn(t);const n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return Se(()=>{if(t=t,t.length!==2)throw new he(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const r=n.training==null?!1:n.training;let s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ed({ones:()=>ko(t),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ed({ones:()=>ko(s),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u;0<this.dropout&&this.dropout<1&&(t=fe(t,a[0]));let c=Hl(t,this.kernel.read());this.useBias&&(c=fl(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=fe(s,i[0]));const d=this.recurrentKernel.read(),[p,h]=ji(d,[2*this.units,this.units],d.rank-1),m=Hl(s,p),[g,y,b]=ji(c,3,c.rank-1),[v,k]=ji(m,2,m.rank-1);o=this.recurrentActivation.apply(He(g,v)),l=this.recurrentActivation.apply(He(y,k));const I=Hl(fe(l,s),h);u=this.activation.apply(He(b,I));const S=He(fe(o,s),fe(He(1,Lr(o)),u));return[S,S]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:Jc(this.activation),recurrentActivation:Jc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Nr(this.kernelInitializer),recurrentInitializer:Nr(this.recurrentInitializer),biasInitializer:Nr(this.biasInitializer),kernelRegularizer:nr(this.kernelRegularizer),recurrentRegularizer:nr(this.recurrentRegularizer),biasRegularizer:nr(this.biasRegularizer),activityRegularizer:nr(this.activityRegularizer),kernelConstraint:ps(this.kernelConstraint),recurrentConstraint:ps(this.recurrentConstraint),biasConstraint:ps(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),n)}}r3.className="GRUCell";ze(r3);class g7 extends Td{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new r3(t),super(t)}call(t,n){return Se(()=>{this.cell.dropoutMask!=null&&(on(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(on(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}}g7.className="GRU";ze(g7);class DC extends RC{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,_s(this.units,"units"),this.activation=Qc(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Qc(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=xr(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=xr(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=xr(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=vr(t.kernelRegularizer),this.recurrentRegularizer=vr(t.recurrentRegularizer),this.biasRegularizer=vr(t.biasRegularizer),this.kernelConstraint=hs(t.kernelConstraint),this.recurrentConstraint=hs(t.recurrentConstraint),this.biasConstraint=hs(t.biasConstraint),this.dropout=Ag([1,Zc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Ag([1,Zc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var n;t=Cn(t);const r=t[t.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){const a=this.biasInitializer,i=this.units;s=new(n=class extends Co{apply(l,u){const c=a.apply([i]),d=new UF().apply([i]),p=a.apply([i*2]);return lV(lV(c,d),p)}},n.className="CustomInit",n)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,n){return Se(()=>{const r=n.training==null?!1:n.training;if(t=t,t.length!==3)throw new he(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=t[1];const a=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ed({ones:()=>ko(t),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ed({ones:()=>ko(s),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let l,u,c,d;0<this.dropout&&this.dropout<1&&(t=fe(t,i[0]));let p=Hl(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=fe(s,o[0])),p=He(p,Hl(s,this.recurrentKernel.read())),this.useBias&&(p=fl(p,this.bias.read()));const[h,m,g,y]=ji(p,4,p.rank-1);l=this.recurrentActivation.apply(h),u=this.recurrentActivation.apply(m),c=He(fe(u,a),fe(l,this.activation.apply(g))),d=this.recurrentActivation.apply(y);const b=fe(d,this.activation.apply(c));return[b,b,c]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:Jc(this.activation),recurrentActivation:Jc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Nr(this.kernelInitializer),recurrentInitializer:Nr(this.recurrentInitializer),biasInitializer:Nr(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:nr(this.kernelRegularizer),recurrentRegularizer:nr(this.recurrentRegularizer),biasRegularizer:nr(this.biasRegularizer),activityRegularizer:nr(this.activityRegularizer),kernelConstraint:ps(this.kernelConstraint),recurrentConstraint:ps(this.recurrentConstraint),biasConstraint:ps(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),n)}}DC.className="LSTMCell";ze(DC);class y7 extends Td{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new DC(t),super(t)}call(t,n){return Se(()=>{this.cell.dropoutMask!=null&&(on(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(on(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}}y7.className="LSTM";ze(y7);class s3 extends RC{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?t.push(...n.stateSize):t.push(n.stateSize);return t}call(t,n){return Se(()=>{t=t;let r=t.slice(1);const s=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?s.push(r.splice(0,o.stateSize.length)):s.push(r.splice(0,1));s.reverse();const a=[];let i;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];r=s[o],o===0?i=[t[0]].concat(r):i=[i[0]].concat(r),i=l.call(i,n),a.push(i.slice(1))}r=[];for(const o of a.slice().reverse())r.push(...o);return[i[0]].concat(r)})}build(t){nA(t)&&(t=t[0]),t=t;let n;this.cells.forEach((r,s)=>{Vp(`RNNCell_${s}`,()=>{r.build(t),Array.isArray(r.stateSize)?n=r.stateSize[0]:n=r.stateSize,t=[t[0],n]})}),this.built=!0}getConfig(){const t=super.getConfig(),n=a=>({className:a.getClassName(),config:a.getConfig()}),s={cells:this.cells.map(n)};return Object.assign(Object.assign({},t),s)}static fromConfig(t,n,r={}){const s=[];for(const a of n.cells)s.push(Au(a,r));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const n of this.cells)t.push(...n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.cells)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const r of this.cells)n.push(...r.trainableWeights);return n.concat(t)}return t}getWeights(){const t=[];for(const n of this.cells)t.push(...n.weights);return rA(t)}setWeights(t){const n=[];for(const r of this.cells){const s=r.weights.length,a=t.splice(s);for(let i=0;i<r.weights.length;++i)n.push([r.weights[i],a[i]])}YF(n)}}s3.className="StackedRNNCells";ze(s3);function ed(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>a!=null?a(t(),n):l8(t(),n),o=()=>c1(i,t,r);return!s||s<=1?Ul(o().clone()):Array(s).fill(void 0).map(o).map(u=>Ul(u.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Twe=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n};class x7 extends Td{constructor(t){if(t.unroll)throw new rn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new rn("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new us({ndim:5})]}call(t,n){return Se(()=>{if(this.cell.dropoutMask!=null&&(on(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(on(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new he("ConvRNN2D cell does not support constants");const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}computeOutputShape(t){let n=this.computeSingleOutputShape(t);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([t[0],...n.slice(-3)])]),n}getInitialState(t){return Se(()=>{const{stateSize:n}=this.cell,r=t.shape,s=this.computeSingleOutputShape(r),a=[s[0],...s.slice(2)],i=Es(a);return Array.isArray(n)?Array(n.length).fill(i):[i]})}resetStates(t,n=!1){Se(()=>{if(!this.stateful)throw new Al("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),a=[s[0],...s.slice(2)];if(r[0]==null)throw new he("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Es(a)):this.states_=[Es(a)];else if(t==null)on(this.states_),this.keptStates!=null&&(on(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Es(a)):this.states_[0]=Es(a);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new he(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n?this.keptStates.push(this.states_.slice()):on(this.states_);for(let o=0;o<this.states_.length;++o){const l=t[o],u=a;if(!Dn(l.shape,u))throw new he(`State ${o} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[o]=l}}this.states_=this.states_.map(o=>Ul(o.clone()))})}computeSingleOutputShape(t){const{dataFormat:n,filters:r,kernelSize:s,padding:a,strides:i,dilationRate:o}=this.cell,l=n==="channelsFirst",u=t[l?3:2],c=t[l?4:3],d=Zo(u,s[0],a,i[0],o[0]),p=Zo(c,s[1],a,i[1],o[1]);return[...t.slice(0,2),...l?[r,d,p]:[d,p,r]]}}x7.className="ConvRNN2D";class a3 extends DC{constructor(t){const{filters:n,kernelSize:r,strides:s,padding:a,dataFormat:i,dilationRate:o}=t;super(Object.assign(Object.assign({},t),{units:n})),this.filters=n,_s(this.filters,"filters"),this.kernelSize=yg(r,2,"kernelSize"),this.kernelSize.forEach(l=>_s(l,"kernelSize")),this.strides=yg(s||1,2,"strides"),this.strides.forEach(l=>_s(l,"strides")),this.padding=a||"valid",Ji(this.padding),this.dataFormat=i||"channelsLast",Br(this.dataFormat),this.dilationRate=yg(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>_s(l,"dilationRate"))}build(t){var n;t=Cn(t);const r=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[r]==null)throw new he(`The channel dimension of the input should be defined. Found ${t[r]}`);const s=t[r],a=4,i=this.kernelSize.concat([s,this.filters*a]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(n=class extends Co{apply(p,h){const m=u.apply([c]),g=Cd([c]),y=u.apply([c*2]);return VF([m,g,y])}},n.className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,n){return Se(()=>{if(t.length!==3)throw new he(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const r=n.training||!1,s=t[0],a=t[1],i=t[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ed({ones:()=>ko(s),rate:this.dropout,training:r,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(H,P,X)=>!P||!P[X]?H:fe(P[X],H);let c=u(s,l,0),d=u(s,l,1),p=u(s,l,2),h=u(s,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ed({ones:()=>ko(a),rate:this.recurrentDropout,training:r,count:o,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let g=u(a,m,0),y=u(a,m,1),b=u(a,m,2),v=u(a,m,3);const k=3,[I,S,N,T]=ji(this.kernel.read(),o,k),[A,R,D,$]=this.useBias?ji(this.bias.read(),o):[null,null,null,null];c=this.inputConv(c,I,A,this.padding),d=this.inputConv(d,S,R,this.padding),p=this.inputConv(p,N,D,this.padding),h=this.inputConv(h,T,$,this.padding);const[_,L,z,W]=ji(this.recurrentKernel.read(),o,k);g=this.recurrentConv(g,_),y=this.recurrentConv(y,L),b=this.recurrentConv(b,z),v=this.recurrentConv(v,W);const G=this.recurrentActivation.apply(He(c,g)),q=this.recurrentActivation.apply(He(d,y)),B=He(fe(q,i),fe(G,this.activation.apply(He(p,b)))),j=fe(this.recurrentActivation.apply(He(h,v)),this.activation.apply(B));return[j,j,B]})}getConfig(){const t=super.getConfig(),{units:n}=t,r=Twe(t,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},r),s)}inputConv(t,n,r,s){const a=sh(t,n,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?fl(a,r,this.dataFormat):a}recurrentConv(t,n){return sh(t,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}a3.className="ConvLSTM2DCell";ze(a3);class b7 extends x7{constructor(t){const n=new a3(t);super(Object.assign(Object.assign({},t),{cell:n}))}static fromConfig(t,n){return new t(n)}}b7.className="ConvLSTM2D";ze(b7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class i3 extends cn{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const n=t.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?n[s]:this.noiseShape[s]);return r}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const r=Wt(t);if(0<this.rate&&this.rate<1){const s=n.training==null?!1:n.training,a=this.getNoiseShape(r);return c1(()=>l8(r,this.rate,a,this.seed),()=>r,s)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(t,n),t}dispose(){return super.dispose()}}i3.className="Dropout";ze(i3);class v7 extends i3{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const n=t.shape;return[n[0],1,n[2]]}}v7.className="SpatialDropout1D";ze(v7);class w7 extends cn{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let n=null;t.batchSize!=null&&(n=t.batchSize),this.batchInputShape=[n,t.inputDim]}this.units=t.units,_s(this.units,"units"),this.activation=Qc(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=xr(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=xr(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=hs(t.kernelConstraint),this.biasConstraint=hs(t.biasConstraint),this.kernelRegularizer=vr(t.kernelRegularizer),this.biasRegularizer=vr(t.biasRegularizer),this.activityRegularizer=vr(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=Cn(t);const n=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(t){t=Cn(t);const n=t.slice();return n[n.length-1]=this.units,n}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const r=Wt(t),s=t8(this.activation.getClassName());let a;return s!=null?a=Hl(r,this.kernel.read(),s,this.bias?this.bias.read():null):(a=Hl(r,this.kernel.read()),this.bias!=null&&(a=fl(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){const t={units:this.units,activation:Jc(this.activation),useBias:this.useBias,kernelInitializer:Nr(this.kernelInitializer),biasInitializer:Nr(this.biasInitializer),kernelRegularizer:nr(this.kernelRegularizer),biasRegularizer:nr(this.biasRegularizer),activityRegularizer:nr(this.activityRegularizer),kernelConstraint:ps(this.kernelConstraint),biasConstraint:ps(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}w7.className="Dense";ze(w7);class k7 extends cn{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Cn(t);for(const n of t.slice(1))if(n==null)throw new he(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],jc(t,1)]}call(t,n){return Se(()=>{this.invokeCallHook(t,n);let r=Wt(t);if(this.dataFormat==="channelsFirst"&&r.rank>1){const s=[0];for(let a=2;a<r.rank;++a)s.push(a);s.push(1),r=bn(r,s)}return o1e(r)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(t,n),t}}k7.className="Flatten";ze(k7);class I7 extends cn{constructor(t){super(t),this.supportsMasking=!0,this.activation=Qc(t.activation)}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const r=Wt(t);return this.activation.apply(r)})}getConfig(){const t={activation:Jc(this.activation)},n=super.getConfig();return Object.assign(t,n),t}}I7.className="Activation";ze(I7);class S7 extends cn{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,n){return Se(()=>(t=Wt(t),a1e(t,this.n)))}getConfig(){const t={n:this.n},n=super.getConfig();return Object.assign(t,n),t}}S7.className="RepeatVector";ze(S7);class C7 extends cn{constructor(t){super(t),this.targetShape=t.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,n){const r="Total size of new array must be unchanged.",s=n.slice();let a=1,i=null;for(let l=0;l<s.length;++l){const u=s[l];if(this.isUnknown(u))if(i===null)i=l;else throw new he("Can only specifiy one unknown dimension.");else a*=u}const o=jc(t);if(i!==null){if(a===0||o%a!==0)throw new he(r);s[i]=o/a}else if(o!==a)throw new he(r);return s}computeOutputShape(t){let n=!1;for(let r=0;r<t.length;++r)if(this.isUnknown(t[r])){n=!0;break}return n?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const r=Wt(t),s=r.shape,a=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return be(r,a)})}getConfig(){const t={targetShape:this.targetShape},n=super.getConfig();return Object.assign(t,n),t}}C7.className="Reshape";ze(C7);class N7 extends cn{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const n=sl(1,t.dims.length+1);if(!Dn(t.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new us({ndim:this.dims.length+1})]}computeOutputShape(t){t=Cn(t);const n=t.slice();return this.dims.forEach((r,s)=>{n[s+1]=t[r]}),n}call(t,n){return bn(Wt(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},n=super.getConfig();return Object.assign(t,n),t}}N7.className="Permute";ze(N7);class T7 extends cn{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,t),n}computeMask(t,n){const r=Wt(t);return q_(Q2(r,this.maskValue),-1)}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const r=Wt(t),i=q_(Q2(r,this.maskValue),-1,!0);return fe(r,lt(i,r.dtype))})}}T7.className="Masking";ze(T7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class $7 extends cn{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let n=null;t.batchSize!=null&&(n=t.batchSize),t.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(Wn(t.inputLength))}this.inputDim=t.inputDim,_s(this.inputDim,"inputDim"),this.outputDim=t.outputDim,_s(this.outputDim,"outputDim"),this.embeddingsInitializer=xr(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=vr(t.embeddingsRegularizer),this.activityRegularizer=vr(t.activityRegularizer),this.embeddingsConstraint=hs(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,n){return Se(()=>this.maskZero?(t=Wt(t),Q2(t,vn(t))):null)}computeOutputShape(t){if(t=Cn(t),this.inputLength==null)return[...t,this.outputDim];const n=Wn(this.inputLength);if(n.length!==t.length-1)throw new he(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let r=0;for(let s=0;s<n.length;++s){const a=n[s],i=t[s+1];if(a!=null&&i!=null&&a!==i)throw new he(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);a==null&&(n[r]=i),r++}}return[t[0],...n,this.outputDim]}call(t,n){return Se(()=>{this.invokeCallHook(t,n);let r=Wt(t);r.dtype!=="int32"&&(r=jl(r,"int32"));const s=o8(this.embeddings.read(),be(r,[r.size]));return be(s,Cn(this.computeOutputShape(r.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Nr(this.embeddingsInitializer),embeddingsRegularizer:nr(this.embeddingsRegularizer),activityRegularizer:nr(this.activityRegularizer),embeddingsConstraint:ps(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(t,n),t}}$7.className="Embedding";ze($7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ph extends cn{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new rn}computeElementwiseOpOutputShape(t,n){if(t==null||n==null)return null;if(t.length<n.length)return this.computeElementwiseOpOutputShape(n,t);if(n.length===0)return t;const r=t.slice(0,t.length-n.length);for(let s=0;s<n.length;++s){const a=t[t.length-n.length+s],i=n[s];if(a==null||i==null||a<0||i<0)r.push(null);else if(a===1)r.push(i);else if(i===1)r.push(a);else{if(a!==i)throw new he("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(n));r.push(a)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Cn(t)]),t=t,t.length<2)throw new he(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let n=[];for(const a of t)a!=null&&a[0]!==null&&n.push(a[0]);if(n=Gc(n),n.length>1)throw new he(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=t[0]==null?null:t[0].slice(1);for(let a=1;a<t.length;++a){const i=t[a]==null?null:t[a].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}const s=t.map(a=>a.length);t.indexOf(null)===-1&&Gc(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,n){return Se(()=>{if(t=t,this.reshapeRequired){const r=[],s=t.map(a=>a.rank);if(s.indexOf(null)===-1){const a=Zc(s);for(let i of t){const o=i.rank;for(let l=0;l<a-o;++l)i=l1(i,1);r.push(i)}return this.mergeFunction(r)}else{let a=!1;for(const l of t){const u=l.rank;if(u==null){const c=l.shape,d=c[0],p=c.slice(1).concat([d]);let h=be(l,[d].concat(jc(c.slice(1))));h=bn(h,[1,0]),h=be(h,p),r.push(h),a=!0}else if(u>1){const c=sl(1,u).concat([0]);r.push(bn(l,c)),a=!0}else r.push(l)}let i=this.mergeFunction(r);const o=i.rank;if(a){if(o==null){const l=i.shape,u=l.length,c=l[u-1],d=[c].concat(l.slice(0,l.length-1));i=be(bn(be(i,[-1,c]),[1,0]),d)}else if(o>1){const l=[o-1].concat(sl(0,o-1));i=bn(i,l)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let n;t[0]==null?n=null:n=t[0].slice(1);for(let s=1;s<t.length;++s){const a=t[s]==null?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let r=[];for(const s of t)s!=null&&s[0]!==null&&r.push(s[0]);return r=Gc(r),r.length===1?n=r.concat(n):n=[null].concat(n),n}computeMask(t,n){return Se(()=>{if(n==null)return null;if(!Array.isArray(n))throw new he("`mask` should be an Array");if(!Array.isArray(t))throw new he("`inputs` should be an Array");if(n.length!==t.length)throw new he(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${n.length})`);if(n.every(s=>s==null))return null;n=n.map(s=>s==null?s:Va(s,0));let r=n[0];for(let s=1;s<n.length-1;++s)r=Lu(r,n[s]);return r})}}class E7 extends Ph{constructor(t){super(t)}mergeFunction(t){return Se(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=He(n,t[r]);return n})}}E7.className="Add";ze(E7);class _7 extends Ph{constructor(t){super(t)}mergeFunction(t){return Se(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=fe(n,t[r]);return n})}}_7.className="Multiply";ze(_7);class A7 extends Ph{constructor(t){super(t)}mergeFunction(t){return Se(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=He(n,t[r]);return fe(1/t.length,n)})}}A7.className="Average";ze(A7);class R7 extends Ph{constructor(t){super(t)}mergeFunction(t){return Se(()=>{let n=t[0];for(let r=1;r<t.length;++r)n=Sd(n,t[r]);return n})}}R7.className="Maximum";ze(R7);class D7 extends Ph{constructor(t){super(t)}mergeFunction(t){return Se(()=>{let n=t[0];for(let r=1;r<t.length;++r)n=yv(n,t[r]);return n})}}D7.className="Minimum";ze(D7);class F7 extends Ph{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new he("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let n=!0;for(const s of t)if(s!=null){n=!1;break}if(n)return;const r=[];for(let s=0;s<t.length;++s){const a=t[s].slice();a.splice(this.axis,1);let i=!1;for(const o of r)if(Dn(o,a)){i=!0;break}i||r.push(a)}if(r.length>1)throw new he("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return Se(()=>VF(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new he("A `Concatenate` layer should be called on a list of inputs.");const n=t,r=n[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(const a of n.slice(1)){if(r[s]==null||a[s]==null){r[s]=null;break}r[s]+=a[s]}return r}computeMask(t,n){if(n==null)return null;if(!Array.isArray(n))throw new he("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new he("`inputs` should be an array for Concatenate");if(n.length!==t.length)throw new he(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${t.length})`);return Se(()=>{let r=!0;if(n.forEach(i=>{if(i!=null){r=!1;return}}),r)return null;const s=[];for(let i=0;i<t.length;++i)n[i]==null?s.push(lt(ko(t[i]),"bool")):n[i].rank<t[i].rank?s.push(Va(n[i],-1)):s.push(n[i]);const a=Ka(s,this.axis);return Fj(a,-1,!1)})}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}F7.className="Concatenate";ze(F7);function Db(e,t){for(;e<0;)e+=t;return e}function $we(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new rn("batchDot is not implemented for tensors of 4D or higher rank yet");if(Y(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),Y(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new rn("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;n==null&&(n=[r-1,s-2]);const a=n;return Se(()=>{let i;if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);t=be(t,t.shape.concat(l))}else if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);e=be(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)a[0]===a[1]?o=Ft(fe(e,t),a[0]):o=Ft(fe(bn(e,[1,0]),t),a[1]);else{const l=a[0]!==e.shape.length-1,u=a[1]===t.shape.length-1;o=An(e,t,l,u)}if(i>0){let l;r>s?l=r+s-3:l=r-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);o=n1(o,u)}return o.shape.length===1&&(o=Va(o,1)),o})}class O7 extends Ph{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){Y(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0],r=t[1];if(n.length>3||r.length>3)throw new rn("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(n,r);if(n[s[0]]!==r[s[1]])throw new he(`Dimension incompatibility: ${n[s[0]]} !== ${r[s[1]]}`)}mergeFunction(t){if(t.length!==2)throw new he(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let n=t[0],r=t[1],s;return Array.isArray(this.axes)?s=this.axes.map((a,i)=>Db(a,t[i].shape.length)):s=[Db(this.axes,n.shape.length),Db(this.axes,r.shape.length)],this.normalize&&(n=iI(n,s[0]),r=iI(r,s[1])),$we(n,r,s)}interpretAxes(t,n){let r;return Array.isArray(this.axes)?r=this.axes:r=[Db(this.axes,t.length),Db(this.axes,n.length)],r}computeOutputShape(t){Y(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0].slice(),r=t[1].slice();if(n.length>3||r.length>3)throw new rn("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(n,r);n.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);const a=n.concat(r);return a.length===1&&a.push(1),a}computeMask(t,n){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(t,n),t}}O7.className="Dot";ze(O7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class M7 extends cn{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,t),n}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const r=Wt(t);return c1(()=>He(NC(r.shape,0,this.stddev),r),()=>r,n.training||!1)})}}M7.className="GaussianNoise";ze(M7);class L7 extends cn{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const r=Wt(t);return this.rate>0&&this.rate<1?c1(()=>{const a=Math.sqrt(this.rate/(1-this.rate));return fe(r,NC(r.shape,1,a))},()=>r,n.training||!1):r})}}L7.className="GaussianDropout";ze(L7);class P7 extends cn{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Wt(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return Se(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(t);return c1(()=>{const a=Wt(t),o=-1.6732632423543772*1.0507009873554805;let l=Fh(t1(r),this.rate);l=jl(l,"float32");const u=((1-this.rate)*(1+this.rate*o**2))**-.5,c=-u*o*this.rate,d=He(fe(a,l),fe(He(l,-1),o));return He(fe(d,u),c)},()=>Wt(t),n.training||!1)}return t})}}P7.className="AlphaDropout";ze(P7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function kv(e,t,n,r,s,a=.001){let i;if(e.rank===2)i=sme(e,t,n,r,s,a);else if(e.rank===3)i=ime(e,t,n,r,s,a);else if(e.rank===4)i=lme(e,t,n,r,s,a);else throw new rn(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function Ewe(e,t,n,r,s=.001){return Se(()=>{const a=YD(e,r),i=a.mean,o=a.variance;return[kv(e,i,o,n,t,s),i,o]})}function _we(e,t,n,r,s=.001){return Se(()=>{const a=YD(e,r),i=a.mean,o=a.variance,l=[];for(const m of sl(0,e.rank))r.indexOf(m)!==-1?l.push(1):l.push(e.shape[m]);const u=be(i,l),c=be(o,l),d=t==null?null:be(t,l),p=n==null?null:be(n,l);return[kv(e,u,c,p,d,s),i,o]})}function Awe(e,t,n,r,s=.001){return Dn(r.slice().sort(),sl(0,e.rank-1))?Ewe(e,t,n,r,s):_we(e,t,n,r,s)}class z7 extends cn{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=xr(t.betaInitializer||"zeros"),this.gammaInitializer=xr(t.gammaInitializer||"ones"),this.movingMeanInitializer=xr(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=xr(t.movingVarianceInitializer||"ones"),this.betaConstraint=hs(t.betaConstraint),this.gammaConstraint=hs(t.gammaConstraint),this.betaRegularizer=vr(t.betaRegularizer),this.gammaRegularizer=vr(t.gammaRegularizer)}build(t){t=Cn(t);const n=this.axis>=0?this.axis:this.axis+t.length,r=t[n];if(r==null)throw new he(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new us({ndim:t.length,axes:{[n]:r}})];const s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,n){return Se(()=>{const r=n.training==null?!1:n.training,s=Wt(t),a=s.shape,i=a.length,o=sl(0,i),l=this.axis>=0?this.axis:this.axis+i;o.splice(l,1);const u=lh(1,i);u[l]=a[l];const c=o.slice();c.sort();const d=!Dn(c,sl(0,i).slice(0,i-1)),p=()=>{if(d){const v=be(this.movingMean.read(),u),k=be(this.movingVariance.read(),u),I=this.center?be(this.beta.read(),u):null,S=this.scale?be(this.gamma.read(),u):null;return kv(s,v,k,I,S,this.epsilon)}else return kv(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return p();const[h,m,g]=Awe(s,this.gamma.read(),this.beta.read(),o,this.epsilon),y=(v,k,I)=>{Se(()=>{const S=1-I,N=v.read(),T=fe(Bt(N,k),S);v.write(Bt(N,T))})};return(()=>{y(this.movingMean,m,this.momentum),y(this.movingVariance,g,this.momentum)})(),h})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Nr(this.betaInitializer),gammaInitializer:Nr(this.gammaInitializer),movingMeanInitializer:Nr(this.movingMeanInitializer),movingVarianceInitializer:Nr(this.movingVarianceInitializer),betaRegularizer:nr(this.betaRegularizer),gammaRegularizer:nr(this.gammaRegularizer),betaConstraint:ps(this.betaConstraint),gammaConstraint:ps(this.gammaConstraint)},n=super.getConfig();return Object.assign(t,n),t}}z7.className="BatchNormalization";ze(z7);class B7 extends cn{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=xr(t.betaInitializer||"zeros"),this.gammaInitializer=xr(t.gammaInitializer||"ones"),this.betaRegularizer=vr(t.betaRegularizer),this.gammaRegularizer=vr(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=Cn(t);const n=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=n);for(const a of this.axis)if(a<0||a>=n)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==Gc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(a=>t[a]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(t,n){const r=Wt(t),s=r.shape,a=s.length;return Se(()=>{let{mean:o,variance:l}=YD(r,this.axis,!0);const u=lh(1,a);for(const g of this.axis)u[g]=s[g];const c=g=>g!=null&&g.shape.length!==a?be(g,u):g;let d=this.scale?c(this.gamma.read()):null,p=this.center?c(this.beta.read()):null;const h=[],m=[];for(let g=0;g<a;++g)this.axis.indexOf(g)!==-1?(h.push(s[g]),m.push(1)):(h.push(1),m.push(s[g]));return o=Ko(o,h),l=Ko(l,h),d!=null&&(d=Ko(d,m)),p!=null&&(p=Ko(p,m)),kv(r,o,l,p,d,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Nr(this.betaInitializer),gammaInitializer:Nr(this.gammaInitializer),betaRegularizer:nr(this.betaRegularizer),gammaRegularizer:nr(this.gammaRegularizer)},n=super.getConfig();return Object.assign(t,n),t}}B7.className="LayerNormalization";ze(B7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Rwe(e,t,n){return Se(()=>{if(e.rank!==4)throw new he(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new he("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=al()),n!=="channelsLast"&&n!=="channelsFirst")throw new he(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],ZD(e,r)})}class W7 extends cn{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?al():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new he(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let n,r;if(typeof t.padding[0]=="number")n=[t.padding[0],t.padding[0]],r=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new he(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(n=t.padding[0],t.padding[1].length!==2)throw new he(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);r=t.padding[1]}this.padding=[n,r]}this.inputSpec=[new us({ndim:4})]}computeOutputShape(t){t=Cn(t);let n,r;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?n=t[2]+this.padding[0][0]+this.padding[0][1]:n=null,t[3]!=null&&t[3]>=0?r=t[3]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],t[1],n,r]):(t[1]!=null&&t[1]>=0?n=t[1]+this.padding[0][0]+this.padding[0][1]:n=null,t[2]!=null&&t[2]>=0?r=t[2]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],n,r,t[3]])}call(t,n){return Se(()=>Rwe(Wt(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}W7.className="ZeroPadding2D";ze(W7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function FC(e,t,n,r,s,a){return Se(()=>{Br(s),r8(a),Ji(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=al()),a==null&&(a="max"),e=t3(e,s);let i;const o=r==="same"?"same":"valid";return a==="max"?i=XD(e,t,n,o):i=py(e,t,n,o),s==="channelsFirst"&&(i=bn(i,[0,3,1,2])),i})}function V7(e,t,n,r,s,a){return Se(()=>{Br(s),r8(a),Ji(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=al()),a==null&&(a="max"),e=a7(e,s);let i;const o=r==="same"?"same":"valid";return a==="max"?i=Hge(e,t,n,o):i=Kfe(e,t,n,o),s==="channelsFirst"&&(i=bn(i,[0,4,1,2,3])),i})}class U7 extends cn{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new he(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(_s(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new he(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);_s(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,Ji(this.padding),this.inputSpec=[new us({ndim:3})]}computeOutputShape(t){t=Cn(t);const n=Zo(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],n,t[2]]}call(t,n){return Se(()=>{this.invokeCallHook(t,n),t=l1(Wt(t),2);const r=this.poolingFunction(Wt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return n1(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(t,n),t}}class G7 extends U7{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return Br(a),Ji(s),FC(t,n,r,s,a,"max")}}G7.className="MaxPooling1D";ze(G7);class j7 extends U7{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return Br(a),Ji(s),FC(t,n,r,s,a,"avg")}}j7.className="AveragePooling1D";ze(j7);class H7 extends cn{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new he(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];_s(this.poolSize,"poolSize"),_s(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Br(this.dataFormat),Ji(this.padding),this.inputSpec=[new us({ndim:4})]}computeOutputShape(t){t=Cn(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2];return n=Zo(n,this.poolSize[0],this.padding,this.strides[0]),r=Zo(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,r]:[t[0],n,r,t[3]]}call(t,n){return Se(()=>(this.invokeCallHook(t,n),this.poolingFunction(Wt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class q7 extends H7{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return Br(a),Ji(s),FC(t,n,r,s,a,"max")}}q7.className="MaxPooling2D";ze(q7);class K7 extends H7{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return Br(a),Ji(s),FC(t,n,r,s,a,"avg")}}K7.className="AveragePooling2D";ze(K7);class X7 extends cn{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new he(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];_s(this.poolSize,"poolSize"),_s(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Br(this.dataFormat),Ji(this.padding),this.inputSpec=[new us({ndim:5})]}computeOutputShape(t){t=Cn(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[4]:t[3];return n=Zo(n,this.poolSize[0],this.padding,this.strides[0]),r=Zo(r,this.poolSize[1],this.padding,this.strides[1]),s=Zo(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,r,s]:[t[0],n,r,s,t[4]]}call(t,n){return Se(()=>(this.invokeCallHook(t,n),this.poolingFunction(Wt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class Y7 extends X7{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return Br(a),Ji(s),V7(t,n,r,s,a,"max")}}Y7.className="MaxPooling3D";ze(Y7);class Z7 extends X7{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return Br(a),Ji(s),V7(t,n,r,s,a,"avg")}}Z7.className="AveragePooling3D";ze(Z7);class J7 extends cn{constructor(t){super(t),this.inputSpec=[new us({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,n){throw new rn}}class Q7 extends J7{constructor(t){super(t||{})}call(t,n){return Se(()=>{const r=Wt(t);return qr(r,1)})}}Q7.className="GlobalAveragePooling1D";ze(Q7);class eq extends J7{constructor(t){super(t||{})}call(t,n){return Se(()=>{const r=Wt(t);return Yo(r,1)})}}eq.className="GlobalMaxPooling1D";ze(eq);class tq extends cn{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Br(this.dataFormat),this.inputSpec=[new us({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,n){throw new rn}getConfig(){const t={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class nq extends tq{call(t,n){return Se(()=>{const r=Wt(t);return this.dataFormat==="channelsLast"?qr(r,[1,2]):qr(r,[2,3])})}}nq.className="GlobalAveragePooling2D";ze(nq);class rq extends tq{call(t,n){return Se(()=>{const r=Wt(t);return this.dataFormat==="channelsLast"?Yo(r,[1,2]):Yo(r,[2,3])})}}rq.className="GlobalMaxPooling2D";ze(rq);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class sq extends cn{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(t,n),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,n,r={}){const s=n.layer,a=Au(s,r);delete n.layer;const i={layer:a};return Object.assign(i,n),new t(i)}}class aq extends sq{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=Cn(t),t.length<3)throw new he(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=Cn(t);const n=[t[0]].concat(t.slice(2)),r=this.layer.computeOutputShape(n),s=t[1];return[r[0],s].concat(r.slice(1))}call(t,n){return Se(()=>(t=Wt(t),f7((i,o)=>[Wt(this.layer.call(i,n)),[]],t,[],!1,null,null,!1,!0)[1]))}}aq.className="TimeDistributed";ze(aq);function Dwe(e){Lh(e1e,"BidirectionalMergeMode",e)}const Fwe="concat";class iq extends sq{constructor(t){super(t);const n=t.layer.getConfig(),r={};r.className=t.layer.getClassName(),r.config=n,this.forwardLayer=Au(r),n.goBackwards=n.goBackwards!==!0;const s={};if(s.className=t.layer.getClassName(),s.config=n,this.backwardLayer=Au(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?Fwe:t.mergeMode,Dwe(this.mergeMode),t.weights)throw new rn("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const n=t.length,r=Math.floor(n/2);this.forwardLayer.setWeights(t.slice(0,r)),this.backwardLayer.setWeights(t.slice(r))}computeOutputShape(t){let n=this.forwardLayer.computeOutputShape(t);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let r,s,a;return this.returnState&&(a=n.slice(1)),r=n[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,s=[r]):this.mergeMode==null?s=[r,r.slice()]:s=[r],this.returnState?this.mergeMode==null?s.concat(a).concat(a.slice()):[r].concat(a).concat(a.slice()):Ua(s)}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});const a=h7(t,r,s,this.numConstants);if(t=a.inputs,r=a.initialState,s=a.constants,Array.isArray(t)&&(r=t.slice(1),t=t[0]),(r==null||r.length===0)&&s==null)return super.apply(t,n);const i=[],o=[];if(r!=null){const u=r.length;if(u%2>0)throw new he("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,i.push(...r);const c=r.map(d=>new us({shape:d.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),o.push(...c)}if(s!=null)throw new rn("Support for constants in Bidirectional layers is not implemented yet.");const l=i[0]instanceof eu;for(const u of i)if(u instanceof eu!==l)throw new he("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[t].concat(i),c=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=c;const p=super.apply(u,n);return this.inputSpec=d,p}else return super.apply(t,n)}call(t,n){return Se(()=>{const r=n.initialState;let s,a;if(r==null)s=this.forwardLayer.call(t,n),a=this.backwardLayer.call(t,n);else{const l=r.slice(0,r.length/2),u=r.slice(r.length/2);s=this.forwardLayer.call(t,Object.assign(n,{initialState:l})),a=this.backwardLayer.call(t,Object.assign(n,{initialState:u}))}let i;this.returnState&&(Array.isArray(s)&&(i=s.slice(1).concat(a.slice(1))),s=s[0],a=a[0]),this.returnSequences&&(a=ih(a,1));let o;return this.mergeMode==="concat"?o=VF([s,a]):this.mergeMode==="sum"?o=He(s,a):this.mergeMode==="ave"?o=fe(.5,He(s,a)):this.mergeMode==="mul"?o=fe(s,a):this.mergeMode==null&&(o=[s,a]),this.returnState?this.mergeMode==null?o.concat(i):[o].concat(i):o})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Vp(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Vp(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,n){Array.isArray(n)&&(n=n[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[n,n]:r=n:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const a=this.forwardLayer.states.map(i=>null);return Array.isArray(r)?r.concat(a).concat(a):[r].concat(a).concat(a)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(t,n),t}static fromConfig(t,n){const r=Au(n.layer);if(delete n.layer,n.numConstants!=null)throw new rn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=n;return s.layer=r,new t(s)}}iq.className="Bidirectional";ze(iq);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class oq extends cn{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return Se(()=>(t=Wt(t),t.dtype!=="float32"&&(t=jl(t,"float32")),He(fe(t,this.scale),this.offset)))}}oq.className="Rescaling";ze(oq);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:Owe,cropAndResize:Mwe}=yo;class lq extends cn{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,n,r,s,a,i,o,l){return Se(()=>{let u,c=!1;const d=n/i,p=r/o,h=(s+n)/i,m=(a+r)/o,g=[d,p,h,m],y=[];t.rank===3?(c=!0,u=Pu([t])):u=t;for(let S=0;S<u.shape[0];S++)y.push(g);const b=Sj(y,[y.length,4]),v=xv(0,y.length,1,"int32"),I=Mwe(u,b,v,[s,a],"nearest");return jl(c?Wt(oh(I)):I,l)})}upsize(t,n,r,s){return Se(()=>{const a=Owe(t,[n,r]);return jl(a,s)})}call(t,n){return Se(()=>{const r=Wt(t),s=r.dtype,a=r.shape,i=a[a.length-3],o=a[a.length-2];let l=0;i!==this.height&&(l=Math.floor((i-this.height)/2));let u=0;return o!==this.width&&(u=Math.floor((o-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(r,l,u,this.height,this.width,i,o,s):this.upsize(t,this.height,this.width,s)})}getConfig(){const t={height:this.height,width:this.width},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=Cn(t);const n=t.length-3,r=t.length-2;return t[n]=this.height,t[r]=this.width,t}}lq.className="CenterCrop";ze(lq);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Lwe(e,t,n,r){let s=Wt(e);if(s.dtype!=="int32"&&(s=jl(s,"int32")),t==="int")return s;const a=s.shape;if(s.rank===0&&(s=Va(s,-1)),t==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=Va(s,-1)),s.rank>2)throw new he(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t),o=s;let l;if(typeof r<"u"&&t==="count"?l=zW(o,r,n,i):l=zW(o,[],n,i),t!=="tfIdf")return l;if(r)return fe(l,r);throw new he("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class uq extends cn{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){return t=Cn(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,n){return Se(()=>{t=Wt(t),t.dtype!=="int32"&&(t=jl(t,"int32"));let r;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new he(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);r=Wt(n.countWeights)}const s=Yo(t),a=Z2(t),i=Zi(this.numTokens,s).bufferSync().get(0),o=Fh(a,0).bufferSync().get(0);if(!(i&&o))throw new he(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Lwe(t,this.outputMode,this.numTokens,r)})}}uq.className="CategoryEncoding";ze(uq);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Pwe=["bilinear","nearest"],NV=new Set(Pwe);class cq extends cn{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(NV.has(t.interpolation))this.interpolation=t.interpolation;else throw new he(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=Cn(t);const n=t[2];return[this.height,this.width,n]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return Se(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return yo.resizeBilinear(t,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return yo.resizeNearestNeighbor(t,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...NV]} are supported`)})}}cq.className="Resizing";ze(cq);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class dq{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}dq.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class pq extends cn{constructor(t){super(t),this.randomGenerator=new dq(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(t,n),t}}pq.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const zwe=["bilinear","nearest"],TV=new Set(zwe);class hq extends pq{constructor(t){super(t);const{factor:n,interpolation:r="bilinear"}=t;if(this.factor=n,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new he(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new he(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new he(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(TV.has(r))this.interpolation=r;else throw new he(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=Cn(t);const n=t[2];return[this.imgHeight,-1,n]}call(t,n){return Se(()=>{const r=Wt(t);this.imgHeight=r.shape[r.shape.length-3];const s=r.shape[r.shape.length-2];this.widthFactor=t1([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*s;a=Math.round(a);const i=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return yo.resizeBilinear(t,i);case"nearest":return yo.resizeNearestNeighbor(t,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...TV]} are supported`)}})}}hq.className="RandomWidth";ze(hq);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bwe=$e();Bwe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var $V;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})($V||($V={}));var EV;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(EV||(EV={}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var _V;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(_V||(_V={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vt(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&Y(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wwe=lH;class OC extends UR{nextDataId(){return OC.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new D5(this,$l())}write(t,n,r){this.firstUse&&(this.firstUse=!1,$e().get("IS_NODE")&&Pi(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:r,refCount:1}),s}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&t0(r[0])){const a=r.map(i=>Uc(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return{dataId:s,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){const n=this.data.get(t);n.refCount--}}move(t,n,r,s,a){this.data.set(t,{values:n,dtype:s,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:n,complexTensorInfos:r}=this.data.get(t);if(n==="complex64"){const s=this.readSync(r.real.dataId),a=this.readSync(r.imag.dataId);return zu(s,a)}return che(this.data.get(t).values,n)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const r=n.map(s=>Yc(s));return ln(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ln(t.shape,t.dtype,n)}makeOutput(t,n,r){return $l().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const n=Wa();return t(),{kernelMs:Wa()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){vt([t],"where");const n=this.readSync(t.dataId);return Wwe(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}OC.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fq(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const Vwe=e=>{const{x:t}=e.inputs,n=e.backend;vt(t,"abs");let r=new Float32Array(Oe(t.shape));const s=n.data.get(t.dataId).values;return r=fq(s),n.makeOutput(r,t.shape,t.dtype)},Uwe={kernelName:fS,backendName:"cpu",kernelFunc:Vwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wr(e){return(t,n,r,s,a)=>{const i=Jt(t,n),o=i.length,l=_t(i),u=Oe(i),c=sa(a,u),d=t.length,p=n.length,h=_t(t),m=_t(n),g=Eg(t,i),y=Eg(n,i);if(g.length+y.length===0)for(let b=0;b<c.length;++b)c[b]=e(r[b%r.length],s[b%s.length]);else for(let b=0;b<c.length;++b){const v=uy(b,o,l),k=v.slice(-d);g.forEach(T=>k[T]=0);const I=Vl(k,d,h),S=v.slice(-p);y.forEach(T=>S[T]=0);const N=Vl(S,p,m);c[b]=e(r[I],s[N])}return[c,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mi(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const Gwe={kernelName:rD,backendName:"cpu",kernelFunc:mi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dI(e,t,n="float32"){if(n==="complex64"){const s=dI(e,t,"float32"),a=dI(e,t,"float32");return mi({inputs:{real:s,imag:a},backend:e})}const r=aa(Oe(t),n);return e.makeTensorInfo(t,n,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tu(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const jwe={kernelName:k0,backendName:"cpu",kernelFunc:tu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uh(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const Hwe={kernelName:TD,backendName:"cpu",kernelFunc:uh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mq(e,t,n,r){if(r==="int32"){const s=Int32Array.from(e);return[t,"int32",s]}if(r==="bool"){const s=Dh([0],n),[a,i]=Wr((o,l)=>o!==l?1:0)(t,[],e,s,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function td(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return tu({inputs:{x:s},backend:n});const c=dI(n,s.shape,s.dtype),d=td({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),p=mi({inputs:{real:d,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),p}if(s.dtype==="complex64"){const c=uh({inputs:{input:s},backend:n}),d=td({inputs:{x:c},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(c),d}if(!O5(s.dtype,a)){const c=tu({inputs:{x:s},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,l,u]=mq(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}const qwe={kernelName:u0,backendName:"cpu",kernelFunc:td};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xs(e,t,n,r){return n==null?({inputs:s,backend:a})=>{const{a:i,b:o}=s,l=a;vt([i,o],e);const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d=i.dtype==="string"?Bu(u):u,p=i.dtype==="string"?Bu(c):c,h=r||i.dtype,[m,g]=t(i.shape,o.shape,d,p,h);return l.makeTensorInfo(g,h,m)}:({inputs:s,backend:a})=>{const{a:i,b:o}=s,l=a;if(i.dtype==="complex64"||o.dtype==="complex64"){const u=td({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),d=c.complexTensorInfos.real,p=c.complexTensorInfos.imag,h=l.data.get(d.dataId).values,m=l.data.get(p.dataId).values,g=td({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),y=l.data.get(g.dataId),b=y.complexTensorInfos.real,v=y.complexTensorInfos.imag,k=l.data.get(b.dataId).values,I=l.data.get(v.dataId).values,[S,N,T]=n(i.shape,o.shape,h,m,k,I),A=l.makeTensorInfo(T,"float32",S),R=l.makeTensorInfo(T,"float32",N),D=mi({inputs:{real:A,imag:R},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(A),l.disposeIntermediateTensorInfo(R),D}else{const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d=r||i.dtype,[p,h]=t(i.shape,o.shape,u,c,d);return l.makeTensorInfo(h,d,p)}}}function o3(e){return(t,n,r,s,a,i)=>{const o=Jt(t,n),l=Oe(o),u=o.length,c=_t(o),d=sa("float32",l),p=sa("float32",l),h=Eg(t,o),m=Eg(n,o),g=zu(r,s),y=zu(a,i),b=t.length,v=_t(t),k=n.length,I=_t(n);if(h.length+m.length===0)for(let S=0;S<d.length;S++){const N=S%g.length,T=S%y.length,A=e(g[N*2],g[N*2+1],y[T*2],y[T*2+1]);d[S]=A.real,p[S]=A.imag}else for(let S=0;S<d.length;S++){const N=uy(S,u,c),T=N.slice(-b);h.forEach(_=>T[_]=0);const A=Vl(T,b,v),R=N.slice(-k);m.forEach(_=>R[_]=0);const D=Vl(R,k,I),$=e(g[A*2],g[A*2+1],y[D*2],y[D*2+1]);d[S]=$.real,p[S]=$.imag}return[d,p,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gq=Wr((e,t)=>e+t),Kwe=o3((e,t,n,r)=>({real:e+n,imag:t+r})),Rg=xs(cy,gq,Kwe),Xwe={kernelName:cy,backendName:"cpu",kernelFunc:Rg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l3(e,t,n,r,s){const a=Oe(r),i=aa(s,n);for(let o=0;o<e.length;o++){const l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(a>0?i[l]+=t[o]:i[l]+=1)}return i}function yq(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=ln([s,n],t.dtype);for(let o=0;o<s;o++)for(let l=0;l<a;l++){const u=e.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(r?i.set(1,o,u):t.size>0?i.set(i.get(o,u)+t.get(o,l),o,u):i.set(i.get(o,u)+1,o,u))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xq=Wr((e,t)=>e&t),Ywe=xs(nD,xq),Zwe={kernelName:nD,backendName:"cpu",kernelFunc:Ywe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lu(e){return(t,n,r)=>{const s=Mr(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jn(e,t,n){const r=lu(t);return $d(e,r,n)}function $d(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;vt(i,e);const o=a,l=o.data.get(i.dataId).values;let u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=Bu(l)}else u=l;const c=n||i.dtype,d=t(u,c,s);return o.makeTensorInfo(i.shape,c,d)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bq=lu(e=>Math.ceil(e)),Jwe=$d(c0,bq),Qwe={kernelName:c0,backendName:"cpu",kernelFunc:Jwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vq(e,t,n,r){const s=Mr(n,Oe(t));if(r&&n!=="string"){let a=0;e.forEach(i=>{const o=Oe(i.shape);s.set(i.vals,a),a+=o})}else{let a=0;e.forEach(i=>{const o=n==="string"?Bu(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*t[1]+a;for(let d=0;d<i.shape[1];++d)s[c+d]=o[l++]}a+=i.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wq=Wr((e,t)=>e===t?1:0),kq=xs(ES,wq,null,"bool"),eke={kernelName:ES,backendName:"cpu",kernelFunc:kq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iq=lu(e=>Math.exp(e)),Sq=$d(y0,Iq,"float32"),tke={kernelName:y0,backendName:"cpu",kernelFunc:Sq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cq=lu(e=>Math.expm1(e)),nke=$d(x0,Cq),rke={kernelName:x0,backendName:"cpu",kernelFunc:nke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nq=lu(e=>Math.floor(e)),ske=$d(b0,Nq),ake={kernelName:b0,backendName:"cpu",kernelFunc:ske};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tq=Wr((e,t)=>Math.floor(e/t)),ike=xs(v0,Tq,null,"int32"),oke={kernelName:v0,backendName:"cpu",kernelFunc:ike};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $q(e,t,n,r,s,a,i,o,l){const u=ln([r,a],n);for(let c=0;c<r;c++){const d=[];let p=0;for(let h=0;h<s;h++){const m=e[c*s+h];p+=m*i[h],d.push(m)}if(p<0||p>=l/a)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let h=0;h<a;h++)u.values[c*a+h]=t.get(...t.indexToLoc(p*a+h))}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eq(e,t,n){const r=ln(n,e.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),o=i[0],l=i[2],u=t.locToIndex([o,l]);i[2]=t.values[u];const c=e.locToIndex(i);0<=c&&c<e.values.length&&(r.values[s]=e.values[c])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _q=Wr((e,t)=>e>t?1:0),lke=xs(DS,_q,null,"bool"),uke={kernelName:DS,backendName:"cpu",kernelFunc:lke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aq=Wr((e,t)=>e>=t?1:0),cke=xs(w0,Aq,null,"bool"),dke={kernelName:w0,backendName:"cpu",kernelFunc:cke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rq=Wr((e,t)=>e<t?1:0),pke=xs(OS,Rq,null,"bool"),hke={kernelName:OS,backendName:"cpu",kernelFunc:pke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dq=Wr((e,t)=>e<=t?1:0),fke=xs(MS,Dq,null,"bool"),mke={kernelName:MS,backendName:"cpu",kernelFunc:fke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fq(e,t,n){const r=(t-e)/(n-1),s=aa(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oq=lu(e=>Math.log(e)),gke=$d(N0,Oq),yke={kernelName:N0,backendName:"cpu",kernelFunc:gke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mq(e,t,n,r){const s=sa(r,Oe(n));for(let a=0;a<s.length;++a){const i=a*t;let o=e[i];for(let l=0;l<t;++l){const u=e[i+l];(Number.isNaN(u)||u>o)&&(o=u)}s[a]=o}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lq=Wr((e,t)=>Math.max(e,t)),xke=xs($0,Lq),bke={kernelName:$0,backendName:"cpu",kernelFunc:xke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pq=Wr((e,t)=>Math.min(e,t)),vke=xs(E0,Pq),wke={kernelName:E0,backendName:"cpu",kernelFunc:vke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u3=Wr((e,t)=>e*t),kke=o3((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),MC=xs(A0,u3,kke),Ike={kernelName:A0,backendName:"cpu",kernelFunc:MC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zq(e,t,n){const r=wd(-1,n);return u3([],t,r,e,n)}function Ske(e){const{inputs:t,backend:n}=e,{x:r}=t;vt(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=zq(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}const Cke={kernelName:qS,backendName:"cpu",kernelFunc:Ske};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bq=Wr((e,t)=>e!==t?1:0),Nke=xs(KS,Bq,null,"bool"),Tke={kernelName:KS,backendName:"cpu",kernelFunc:Nke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c3(e,t,n,r,s){const a=t.length,i=Oe(t),o=_t(t),l=_t(s),u=sa(n,Oe(s));for(let c=0;c<i;++c){const d=uy(c,a,o),p=new Array(d.length);for(let m=0;m<p.length;m++)p[m]=d[r[m]];const h=Vl(p,a,l);u[h]=e[c]}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ja(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;vt(s,"transpose");const i=s.shape.length,o=new Array(i);for(let d=0;d<o.length;d++)o[d]=s.shape[a[d]];const l=r.data.get(s.dataId).values,u=c3(l,s.shape,s.dtype,a,o);return{dataId:r.write(u,o,s.dtype),shape:o,dtype:s.dtype}}const $ke={kernelName:fg,backendName:"cpu",kernelFunc:Ja};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wq(e,t,n,r){const[s,a]=Os(e,r),i=ki(t,"int32"),o=aa(Oe(s),i),l=Oe(a);for(let u=0;u<o.length;++u){const c=u*l;let d=1;for(let p=0;p<l;++p)d*=n[c+p];o[u]=d}return{outVals:o,outShape:s,outDtype:i}}function Eke(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;vt(s,"prod");const o=s.shape.length,l=un(a,s.shape),u=_r(l,o);let c=l,d=s;const p=[];u!=null&&(d=Ja({inputs:{x:s},backend:n,attrs:{perm:u}}),p.push(d),c=zr(c.length,o));const h=n.data.get(d.dataId).values,{outVals:m,outShape:g,outDtype:y}=Wq(d.shape,d.dtype,h,c);let b=g;return i&&(b=Jr(g,l)),p.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(b,y,m)}const _ke={kernelName:eC,backendName:"cpu",kernelFunc:Eke};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ake(e,t,n){e.forEach((r,s)=>{if(r<0||r>=n){const a=uy(s,t.length,_t(t)).join(",");throw new Error(`indices[${a}] = ${r} is not in [0, ${n})`)}})}function Rke(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let a=1;a<r.length;++a)if(r[a-1]>r[a])throw new Error("Ragged splits must be sorted in ascending order")}}function Dke(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);Rke(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const c=t[u+1];for(let d=1;d<l+1;++d)o[u].push(d*c)}for(let u=0;u<e.length;++u){let c=e[u],d=e[u]+1;for(let p=0;p<n.length;++p){const h=n[p],m=p+t.length-1;if(m>=0){const g=o[m],y=g[g.length-1]-h[c];for(let b=c;b<d;++b)o[m].push(h[b+1]+y)}c=h[c],d=h[d]}d!==c&&(s.push([c,d]),a+=d-c)}return{outSplits:o,valueSlices:s,numValues:a}}function Fke(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n].length,s=Mr("int32",r);t.push(s),e[n].forEach((a,i)=>s[i]=a)}return t}function AV(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function Oke(e,t,n,r,s,a){const i=AV(t,2)[1],o=AV(a,2)[1];let l=0;for(const u of n)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)s[l*o+d]=e[c*i+d];++l}}function Mke(e,t,n,r,s){const a=t.slice();a[0]=s;const i=Mr(n,Oe(a)),o=e.length,l=o===0?0:o/t[0];return Oke(e,t,r,l,i,a),[i,a]}function Vq(e,t,n,r,s,a,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const l=t[0][0]-1;if(Ake(a,i,l),r.length===0)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:c,valueSlices:d,numValues:p}=Dke(a,i,e,u),h=Fke(c),m=Mke(n,r,s,d,p);return[h,m[0],m[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RV=2147483647;function Uq(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=t.length===0,l=s.length===0,u=i.length===0,c=[];o||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let y=1;y<c.length;++y)if(c[y]!==c[y-1])throw new Error("starts, limits, and deltas must have the same shape");const d=c.length===0?1:c[0],p=Mr("int32",d+1);p[0]=0;for(let y=0;y<d;++y){const b=o?e[0]:e[y],v=l?r[0]:r[y],k=u?a[0]:a[y];if(k===0)throw new Error("Requires delta != 0");let I;if(k>0&&v<b||k<0&&v>b)I=0;else if(I=Math.ceil(Math.abs((v-b)/k)),I>RV)throw new Error(`Requires ((limit - start) / delta) <= ${RV}`);p[y+1]=p[y]+I}const h=p[d],m=Mr(n,h);let g=0;for(let y=0;y<d;++y){const b=p[y+1]-p[y];let v=o?e[0]:e[y];const k=u?a[0]:a[y];for(let I=0;I<b;++I)m[g++]=v,v+=k}return[p,m]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var uo=jo;class pI{constructor(t,n,r,s,a,i,o,l,u,c){this.shape=t,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=$H(c),this.raggedRank=EH(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===uo.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===uo.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case uo.VALUE_ROWIDS:return pI.getMaxWidthValueRowID(n);case uo.ROW_SPLITS:return pI.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${uo[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const n=t.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){const a=t[s+1]-t[s];a>r&&(r=a)}return r}static getMaxWidthValueRowID(t){const n=t.length;if(n===0)return 0;let r=0,s=t[0],a=0;for(let i=1;i<n;++i){const o=t[i];o!==s&&(s=o,a=Math.max(i-r,a),r=i)}return Math.max(n-r,a)}tensorShapeFromTensor(t,n,r=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return FV(t,r)}calculateOutputSize(t){const n=this.valuesShape,r=this.defaultValueShape;_H(r,n);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=TH(this.raggedRank,s,n);i[0]<0&&(i[0]=t);for(let o=1;o<=this.raggedRank;++o)i[o]<0&&(i[o]=this.getMaxWidth(o));return i}calculateFirstParentOutputIndex(t,n,r){const s=Math.min(t,r),a=[];let i=0;for(let o=0;o<s;++o,i+=n)a.push(i);for(let o=s;o<t;++o)a.push(-1);return Y(a.length===t,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(t,n,r,s){const a=t.length,i=[];for(let o=0;o<a-1;++o){const l=t[o+1]-t[o];let u=Math.min(s,l),c=n[o];c===-1&&(u=0);for(let d=0;d<u;++d)i.push(c),c+=r;for(let d=0;d<l-u;++d)i.push(-1)}if(a>0&&i.length!==t[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,r,s){const a=t.length,i=[];if(a===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];i.push(u);for(let c=1;c<a;++c){const d=t[c];if(d===l)u>=0&&(++o,o<s?u+=r:u=-1);else{if(o=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);u=n[d]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,r,s){const a=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case uo.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,r,s);case uo.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,r,s);default:throw new Error(`Unsupported partition type: ${uo[i]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case uo.FIRST_DIM_SIZE:return t[0];case uo.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case uo.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${uo[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),r=this.calculateOutputSize(n),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const a=FV(r,!1),i=Mr(this.valuesDType,Oe(a));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(n,s[0],r[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,s[u],r[u]);this.setOutput(this.raggedRank,l,i,a)}return[a,i]}setOutput(t,n,r,s){if(r.length===0)return;const a=this.values,i=r;let o=s.slice();o=o.slice(t+1);const l=Oe(o),u=n.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const m=this.defaultValueShape;Se(()=>{const g=be(c,m);c=nv(g,o).dataSync()})}let d=0,p=0,h=0;for(let m=0;m<=u;++m){let g=m<u?n[m]:-1;if(g===h){++h;continue}if(p<h){const y=a.subarray(d*l),b=i.subarray(p*l),v=(h-p)*l;DV(b,y,v)}if(m>=u){const y=r.length;g=Math.floor(y/l)}if(g>h)if(this.defaultValue.length===1)i.subarray(h*l,g*l).fill(this.defaultValue[0]),h=g;else for(;g>h;){const y=i.slice(h*l);DV(y,c,l),++h}g<0?(d=m+1,p=h):(d=m,p=h,h=p+1)}}}function DV(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function FV(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function Gq(e,t,n,r,s,a,i,o,l,u){return new pI(e,t,n,r,s,a,i,o,l,u).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jq(e,t,n,r){const s=e===t,a=e<t&&n<0,i=t<e&&n>1;if(s||a||i)return aa(0,r);const o=Math.abs(Math.ceil((t-e)/n)),l=aa(o,r);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hq=lu(e=>1/Math.sqrt(e)),Lke=$d(L0,Hq),Pke={kernelName:L0,backendName:"cpu",kernelFunc:Lke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fp(e,t,n,r,s,a,i,o,l,u){const c=[r/s,s],d=e.values,p=t.values;if(r===0)return ln(n,t.dtype);const h=l instanceof Ks?l:ln(c,t.dtype);typeof l=="string"||typeof l=="number"?h.values.fill(l):typeof l=="boolean"&&h.values.fill(+l);for(let m=0;m<a;m++){const g=[];let y=0;for(let b=0;b<i;b++){const v=d[m*i+b];g.push(v),y+=v*o[b]}if(y<0||y>=r/s)throw new Error(`Invalid indices: ${g} does not index into ${n}`);for(let b=0;b<s;b++)u?h.values[y*s+b]+=p[m*s+b]:h.values[y*s+b]=t.rank===0?p[0]:p[m*s+b]}return h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zke=lu(e=>1/(1+Math.exp(-e))),qq=jn(V0,e=>1/(1+Math.exp(-e))),Bke={kernelName:V0,backendName:"cpu",kernelFunc:qq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kq(e,t,n,r,s){const a=yF(r,t,n),i=Oe(n),o=_t(r);if(a){const d=xF(t,o);return s==="string"?e.slice(d,d+i):e.subarray(d,d+i)}const l=s==="string"?Bu(e):e,u=ln(r,s,l),c=ln(n,s);for(let d=0;d<c.size;++d){const p=c.indexToLoc(d),h=p.map((m,g)=>m+t[g]);c.set(u.get(...h),...p)}return s==="string"?YH(c.values):c.values}function ch(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;vt(s,"slice");const[o,l]=wC(s,a,i);mF(s,o,l);const u=n.data.get(s.dataId).values,c=Kq(u,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,c)}const Wke={kernelName:iC,backendName:"cpu",kernelFunc:ch};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xq(e,t,n,r,s,a,i){const o=t[0],l=a[0],u=new Array(l),c=new Array(o),d=t[1];if(l===0){if(o!==0)throw new Error(LH(o));const y=Mr(n,0),b=Mr(s,0);return[y,[0,d],b,u,c]}let p=!0,h=0;const m=new Array(l).fill(0);for(let y=0;y<o;++y){const b=e[y*d];if(b<0)throw new Error(PH(y,b));if(b>=l)throw new Error(zH(y,b,l));++m[b],p=p&&b>=h,h=b}let g=!0;for(let y=0;y<l;++y){const b=m[y]===0;u[y]=b,g=g&&!b,m[y]=Math.max(m[y],1),y>0&&(m[y]+=m[y-1])}if(g&&p){const y=e,b=r;for(let v=0;v<o;++v)c[v]=v;return[y,[o,d],b,u,c]}else{const y=m[l-1],b=Mr(n,y*d),v=Mr(s,y),k=new Array(l).fill(0);for(let I=0;I<o;++I){const S=e[I*d],N=k[S],T=(S===0?0:m[S-1])+N;k[S]++;for(let A=0;A<d;++A)b[T*d+A]=e[I*d+A];v[T]=r[I],c[I]=T}for(let I=0;I<l;++I)if(k[I]===0){const N=I===0?0:m[I-1];b[N*d+0]=I;for(let T=1;T<d;++T)b[N*d+T]=0;v[N]=i}return[b,[y,d],v,u,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yq(e,t,n,r,s){const a=Oe(r),i=t[0],o=s.length,l=[];let u=1,c=-1;for(let y=0;y<o;++y){const b=s[y];if(b===-1){if(c!==-1)throw new Error(BH(c,y));c=y,l.push(1)}else{if(b<0)throw new Error(WH(y,b));u*=b,l.push(b)}}if(c!==-1){if(u<=0)throw new Error(VH());const y=Math.trunc(a/u);if(u*y!==a)throw new Error(UH(r,l));l[c]=y}if(Oe(l)!==a)throw new Error(GH(r,l));const p=r.length,h=[];if(p>0){h[p-1]=1;for(let y=p-2;y>=0;--y)h[y]=h[y+1]*r[y+1]}const m=[];if(o>0){m[o-1]=1;for(let y=o-2;y>=0;--y)m[y]=m[y+1]*l[y+1]}const g=Mr(n,i*o);for(let y=0;y<i;++y){let b=0;for(let v=0;v<p;++v)b+=e[y*p+v]*h[v];for(let v=0;v<o;++v)g[y*o+v]=Math.trunc(b/m[v]),b%=m[v]}return[g,[i,o],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d3(e,t,n,r,s,a=!1,i=0){const o=r.length,l=[t[0],e.length/t[0]],u=l[1],d=o>0?s[o-1]+1:0;if(d<0)throw new Error(J_());const p=t.slice();p[0]=d;const h=p.reduce((k,I)=>k*I,1),m=Mr(n,h);if(o===0)return d>0&&m.fill(i),[m,p];if(d<=0)throw new Error(J_());let g=0,y=1,b=0,v=s[g];for(;;){let k=0;if(y<o){if(k=s[y],v===k){++y;continue}if(v>=k)throw new Error(jH())}if(v<0||v>=d)throw new Error(HH(v,d));v>b&&m.fill(i,b*u,v*u);for(let I=g;I<y;++I){const S=r[I];if(S<0||S>=l[0])throw new Error(qH(I,r[I],l[0]));for(let N=0;N<u;N++)m[v*u+N]+=e[S*u+N]}if(a)for(let I=0;I<u;I++)m[v*u+I]/=y-g;if(g=y,++y,b=v+1,v=k,y>o)break}return b<d&&m.fill(i,b*u,d*u),[m,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vke=lu(e=>Math.sqrt(e)),Uke=jn(G0,e=>Math.sqrt(e)),Gke={kernelName:G0,backendName:"cpu",kernelFunc:Uke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zq=Wr((e,t)=>{const n=e-t;return n*n}),jke=xs(j0,Zq),Hke={kernelName:j0,backendName:"cpu",kernelFunc:jke};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jq=lu((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)}),qke=$d(AD,Jq),Kke={kernelName:AD,backendName:"cpu",kernelFunc:qke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qq(e,t,n,r){const s=ln(e,t.dtype);for(let a=0;a<s.size;a++){const i=s.indexToLoc(a),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+r[l];s.set(t.get(...o),...i)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xke{constructor(t,n,r,s,a,i){this.separator=Uc(t),this.nGramWidths=n,this.leftPad=Uc(r),this.rightPad=Uc(s),this.padWidth=a,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){const r=this.getPadWidth(n);return Math.max(0,t+2*r-n+1)}createNGrams(t,n,r,s,a,i){for(let o=0;o<a;++o){const l=this.getPadWidth(i),u=Math.max(0,l-o),c=Math.max(0,l-(a-(o+1))),d=i-(u+c),p=n+(u>0?0:o-l);let h=0;h+=u*this.leftPad.length;for(let v=0;v<d;++v)h+=t[p+v].length;h+=c*this.rightPad.length;const m=u+c+d-1;h+=m*this.separator.length,r[s+o]=new Uint8Array(h);const g=r[s+o];let y=0;const b=v=>v.forEach(k=>g[y++]=k);for(let v=0;v<u;++v)b(this.leftPad),b(this.separator);for(let v=0;v<d-1;++v)b(t[p+v]),b(this.separator);if(d>0){b(t[p+d-1]);for(let v=0;v<c;++v)b(this.separator),b(this.rightPad)}else{for(let v=0;v<c-1;++v)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(t,n){const r=t.length,s=n.length;if(s>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<s;++u){let c=n[u]>=l;if(c=c&&n[u]<=r,!c)throw new Error(`Invalid split value ${n[u]}, must be in [${l}, ${r}]`);l=n[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const a=s-1,i=Mr("int32",s);if(r===0||s===0){const l=new Array(r);for(let u=0;u<=a;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=a;++l){const u=n[l]-n[l-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(u,d)}),this.preserveShort&&u>0&&c===0&&(c=1),i[l]=i[l-1]+c}const o=new Array(i[a]);for(let l=0;l<a;++l){const u=n[l];let c=i[l];if(this.nGramWidths.forEach(d=>{const p=n[l+1]-n[l],h=this.getNumNGrams(p,d);this.createNGrams(t,u,o,c,h,d),c+=h}),this.preserveShort&&c===i[l]){const d=n[l+1]-n[l];if(d===0)continue;const p=d+2*this.padWidth;this.createNGrams(t,u,o,c,1,p)}}return[o,i]}}function e9(e,t,n,r,s,a,i,o){return new Xke(n,r,s,a,i,o).compute(e,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yke(e,t,n,r){if(!e.length)return;if(t.length===0){for(let a=0;a<e.length;++a)r.push(e.subarray(a,a+1));return}if(t.length===1){const a=t[0];let i=e.indexOf(a);for(;i!==-1;){const o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(a)}(!n||e.length!==0)&&r.push(e);return}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||t.indexOf(e[a])!==-1){const i=e.subarray(s,a);(!n||i.length!==0)&&r.push(i),s=a+1}}function t9(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let p=0;p<r;++p){const h=s.length;Yke(e[p],t,n,s);const m=s.length-h;o[p]=m,a+=m,i=Math.max(i,m)}const l=Mr("int32",a*2),u=new Array(a),c=[r,i];let d=0;for(let p=0;p<r;++p)for(let h=0;h<o[p];++h)l[d*2]=p,l[d*2+1]=h,u[d]=s[d],++d;return[l,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n9(e,t){const n=Mr("int32",e.length);for(let r=0;r<e.length;++r)n[r]=$he(e[r]).modulo(t).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r9=Wr((e,t)=>e-t),Zke=o3((e,t,n,r)=>({real:e-n,imag:t-r})),p3=xs(H0,r9,Zke),Jke={kernelName:H0,backendName:"cpu",kernelFunc:p3};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s9(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=ln(n,e.dtype);for(let s=0;s<r.values.length;++s){const a=r.indexToLoc(s),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=a[l]%e.shape[l];const o=e.locToIndex(i);r.values[s]=e.values[o]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ub=(e,t)=>{const n=t.value-e.value;return n===0?e.index-t.index:n};function a9(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const o=r-n+1,l=t-n+1,u=Math.log(o),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(o-c)/o)*Math.sign(l-o/2),p=Math.max(n,Math.floor(t-l*c/o+d)),h=Math.min(r,Math.floor(t+(o-l)*c/o+d));a9(e,t,p,h)}const s=e[t];let a=n,i=r;for(sg(e,n,t),Ub(e[r],s)>0&&sg(e,n,r);a<i;){for(sg(e,a,i),a++,i--;Ub(e[a],s)<0;)a=a+1;for(;Ub(e[i],s)>0;)i=i-1}Ub(e[n],s)===0?sg(e,n,i):(i=i+1,sg(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function i9(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],l=sa(n,i*r),u=sa("int32",i*r);for(let d=0;d<i;d++){const p=d*o,h=e.subarray(p,p+o);let m=new Array(h.length);h.forEach((v,k)=>m[k]={value:v,index:k}),r<m.length&&(a9(m,r),m=m.slice(0,r)),s&&m.sort(Ub);const g=d*r,y=l.subarray(g,g+r),b=u.subarray(g,g+r);for(let v=0;v<r;v++)y[v]=m[v].value,b[v]=m[v].index}const c=t.slice();return c[c.length-1]=r,[ln(c,n,l),ln(c,"int32",u)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o9(e,t,n,r){const s=un(t,n)[0],a=[1,n[0],1];for(let m=0;m<s;m++)a[0]*=n[m];a[1]=n[s];for(let m=s+1;m<n.length;m++)a[2]*=n[m];const i=new Map,o=new Int32Array(n[s]),l=new Ks(a,r,e),u=[],c=a[0]===1&&a[2]===1;for(let m=0;m<n[s];m++){let g;if(c)g=e[m].toString();else{const b=[];for(let v=0;v<a[0];v++)for(let k=0;k<a[2];k++)b.push(l.get(v,m,k));g=b.join(",")}const y=i.get(g);if(y!=null)o[m]=y;else{const b=i.size;i.set(g,b),o[m]=b,u.push(m)}}const d=a.slice();d[1]=i.size;const p=new Ks(d,r);u.forEach((m,g)=>{for(let y=0;y<a[0];y++)for(let b=0;b<a[2];b++)p.set(l.get(y,m,b),y,g,b)});const h=n.slice();return h[s]=d[1],{outputValues:p.values,outputShape:h,indices:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qke=Object.freeze(Object.defineProperty({__proto__:null,addImpl:gq,bincountImpl:l3,bincountReduceImpl:yq,bitwiseAndImpl:xq,castImpl:mq,ceilImpl:bq,concatImpl:vq,equalImpl:wq,expImpl:Iq,expm1Impl:Cq,floorDivImpl:Tq,floorImpl:Nq,gatherNdImpl:$q,gatherV2Impl:Eq,greaterEqualImpl:Aq,greaterImpl:_q,lessEqualImpl:Dq,lessImpl:Rq,linSpaceImpl:Fq,logImpl:Oq,maxImpl:Mq,maximumImpl:Lq,minimumImpl:Pq,multiplyImpl:u3,negImpl:zq,notEqualImpl:Bq,prodImpl:Wq,raggedGatherImpl:Vq,raggedRangeImpl:Uq,raggedTensorToTensorImpl:Gq,rangeImpl:jq,rsqrtImpl:Hq,scatterImpl:Fp,sigmoidImpl:zke,simpleAbsImpl:fq,sliceImpl:Kq,sparseFillEmptyRowsImpl:Xq,sparseReshapeImpl:Yq,sparseSegmentReductionImpl:d3,sqrtImpl:Vke,squaredDifferenceImpl:Zq,staticRegexReplaceImpl:Jq,stridedSliceImpl:Qq,stringNGramsImpl:e9,stringSplitImpl:t9,stringToHashBucketFastImpl:n9,subImpl:r9,tileImpl:s9,topKImpl:i9,transposeImpl:c3,uniqueImpl:o9},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Cj("cpu",()=>new OC,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l9=jn(m0,e=>e>=0?e:Math.exp(e)-1),e2e={kernelName:m0,backendName:"cpu",kernelFunc:l9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u9(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;vt([s],"leakyRelu");const i=Oe(s.shape),o=n.data.get(s.dataId).values,l=sa("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?a*o[u]:o[u];return n.makeTensorInfo(s.shape,"float32",l)}const t2e={kernelName:FS,backendName:"cpu",kernelFunc:u9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n2e=Wr((e,t)=>e<0?t*e:e);function c9(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;vt([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=n2e(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}const r2e={kernelName:QS,backendName:"cpu",kernelFunc:c9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d9=jn(F0,e=>Math.max(0,e)),s2e={kernelName:F0,backendName:"cpu",kernelFunc:d9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p9=jn(O0,e=>Math.min(Math.max(0,e),6)),a2e={kernelName:O0,backendName:"cpu",kernelFunc:p9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hI(e,t,n,r,s){if(n==="linear")return tu({inputs:{x:t},backend:e});if(n==="relu")return d9({inputs:{x:t},backend:e});if(n==="elu")return l9({inputs:{x:t},backend:e});if(n==="relu6")return p9({inputs:{x:t},backend:e});if(n==="prelu")return c9({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return u9({inputs:{x:t},backend:e,attrs:{alpha:s}});if(n==="sigmoid")return qq({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lr(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=Oe(s.shape),o=F5(a,i),l=Oe(o);Y(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,d=u.complexTensorInfos.imag;c.shape=o,d.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const i2e={kernelName:tC,backendName:"cpu",kernelFunc:lr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h9(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;vt([s,a],"matMul");const l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=o?a.shape[u-1]:a.shape[u-2],p=i?s.shape[l-1]:s.shape[l-2],h=o?a.shape[u-2]:a.shape[u-1],m=s.shape.slice(0,-2),g=a.shape.slice(0,-2),y=Oe(m),b=Oe(g),k=Jt(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([p,h]);Y(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const I=i?[y,c,p]:[y,p,c],S=o?[b,h,d]:[b,d,h],N=lr({inputs:{x:s},backend:n,attrs:{shape:I}}),T=lr({inputs:{x:a},backend:n,attrs:{shape:S}}),A=i?N.shape[1]:N.shape[2],R=i?N.shape[2]:N.shape[1],D=o?T.shape[1]:T.shape[2],$=Math.max(y,b),_=n.data.get(N.dataId).values,L=n.data.get(T.dataId).values,z=_t(N.shape),W=_t(T.shape),[G,q,B]=i?[z[0],1,z[1]]:[z[0],z[1],1],[j,H,P]=o?[1,W[1],W[0]]:[W[1],1,W[0]],X=R*D,Q=ln([$,R,D],N.dtype),re=Q.values,le=n.blockSize;for(let ke=0;ke<$;ke++){const Ne=ke%y,we=ke%b;for(let _e=0;_e<R;_e+=le){const Le=Math.min(_e+le,R);for(let Be=0;Be<D;Be+=le){const Ze=Math.min(Be+le,D);for(let ut=0;ut<A;ut+=le){const ft=Math.min(ut+le,A);for(let et=_e;et<Le;et++)for(let Qe=Be;Qe<Ze;Qe++){let ot=0;for(let gt=ut;gt<ft;gt++){const At=_[Ne*G+et*q+gt*B],Et=L[gt*j+Qe*H+we*P];ot+=At*Et}re[ke*X+(et*D+Qe)]+=ot}}}}}return n.disposeIntermediateTensorInfo(N),n.disposeIntermediateTensorInfo(T),n.makeTensorInfo(k,Q.dtype,Q.values)}const o2e={kernelName:bS,backendName:"cpu",kernelFunc:h9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2e(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let p,h,m;const g=[];p=h9({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(h=Rg({inputs:{a:p,b:i},backend:n}),g.push(p),p=h),c&&(m=hI(n,p,c,o,d),g.push(p),p=m);for(const b of g)n.disposeIntermediateTensorInfo(b);return p}const u2e={kernelName:q2,backendName:"cpu",kernelFunc:l2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c2e=jn(n0,e=>Math.acos(e)),d2e={kernelName:n0,backendName:"cpu",kernelFunc:c2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p2e=jn(r0,e=>Math.acosh(e)),h2e={kernelName:r0,backendName:"cpu",kernelFunc:p2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f2e(e){const{inputs:t,backend:n}=e,r=t;vt(t,"addN");const s=r.map(o=>n.data.get(o.dataId).values),a=ln(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){const l=s[o];for(let u=0;u<i.length;u++)i[u]+=l[u]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}const m2e={kernelName:YR,backendName:"cpu",kernelFunc:f2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g2e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;vt(s,"all");const o=un(a,s.shape);let l=o;const u=_r(l,s.shape.length);let c=s;u!=null&&(c=Ja({inputs:{x:s},backend:n,attrs:{perm:u}}),l=zr(l.length,s.shape.length)),Ys("all",l,c.shape.length);const[d,p]=Os(c.shape,l),h=Oe(p),m=aa(Oe(d),c.dtype),g=n.data.get(c.dataId).values;for(let b=0;b<m.length;++b){const v=b*h;let k=g[v];for(let I=0;I<h;++I){const S=g[v+I];k=k&&S}m[b]=k}u!=null&&n.disposeIntermediateTensorInfo(c);const y=n.makeTensorInfo(d,c.dtype,m);if(i){const b=Jr(d,o),v=lr({inputs:{x:y},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(y),v}return y}const y2e={kernelName:ZR,backendName:"cpu",kernelFunc:g2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;vt(s,"any");const o=un(a,s.shape);let l=o;const u=_r(l,s.shape.length);let c=s;u!=null&&(c=Ja({inputs:{x:s},backend:n,attrs:{perm:u}}),l=zr(l.length,s.shape.length)),Ys("any",l,c.shape.length);const[d,p]=Os(c.shape,l),h=Oe(p),m=aa(Oe(d),c.dtype),g=n.data.get(c.dataId).values;for(let b=0;b<m.length;++b){const v=b*h;let k=g[v];for(let I=0;I<h;++I){const S=g[v+I];k=k||S}m[b]=k}u!=null&&n.disposeIntermediateTensorInfo(c);const y=n.makeTensorInfo(d,c.dtype,m);if(i){const b=Jr(d,o),v=lr({inputs:{x:y},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(y),v}return y}const b2e={kernelName:JR,backendName:"cpu",kernelFunc:x2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v2e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;vt(s,"argMax");let i=un(a,s.shape);const o=_r(i,s.shape.length);let l=s;const u=[];o!=null&&(l=Ja({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=zr(i.length,l.shape.length)),i=[i[0]],Ys("argMax",i,l.shape.length);const[c,d]=Os(l.shape,i),p=Oe(c),h=aa(p,"int32"),m=Oe(d),g=n.data.get(l.dataId).values;for(let y=0;y<h.length;++y){const b=y*m;let v=g[b],k=0;for(let I=0;I<m;++I){const S=g[b+I];S>v&&(v=S,k=I)}h[y]=k}return u.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(c,"int32",h)}const w2e={kernelName:mS,backendName:"cpu",kernelFunc:v2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k2e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;vt(s,"argMin");let i=un(a,s.shape);const o=_r(i,s.shape.length);let l=s;const u=[];o!=null&&(l=Ja({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=zr(i.length,l.shape.length)),i=[i[0]],Ys("argMin",i,l.shape.length);const[c,d]=Os(l.shape,i),p=Oe(c),h=aa(p,"int32"),m=Oe(d),g=n.data.get(l.dataId).values;for(let y=0;y<h.length;++y){const b=y*m;let v=g[b],k=0;for(let I=0;I<m;++I){const S=g[b+I];S<v&&(v=S,k=I)}h[y]=k}return u.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(c,"int32",h)}const I2e={kernelName:gS,backendName:"cpu",kernelFunc:k2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S2e=jn(s0,e=>Math.asin(e)),C2e={kernelName:s0,backendName:"cpu",kernelFunc:S2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N2e=jn(a0,e=>Math.asinh(e)),T2e={kernelName:a0,backendName:"cpu",kernelFunc:N2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $2e=jn(i0,e=>Math.atan(e)),E2e={kernelName:i0,backendName:"cpu",kernelFunc:$2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _2e=Wr((e,t)=>Math.atan2(e,t)),A2e=xs(l0,_2e),R2e={kernelName:l0,backendName:"cpu",kernelFunc:A2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D2e=jn(o0,e=>Math.atanh(e)),F2e={kernelName:o0,backendName:"cpu",kernelFunc:D2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h3(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,h=s.padInfo.left,m=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=ln(s.outShape,n),y=g.values,b=s.outShape[1]*s.outShape[2]*s.outShape[3],v=s.outShape[2]*s.outShape[3],k=s.outShape[3];for(let I=0;I<s.batchSize;++I){const S=I*b,N=I*r[0];for(let T=0;T<s.inChannels;++T)for(let A=0;A<s.outHeight;++A){const R=A*i-p,D=Math.max(0,R),$=Math.min(s.inHeight,c+R),_=S+A*v;for(let L=0;L<s.outWidth;++L){const z=L*o-h,W=Math.max(0,z),G=Math.min(s.inWidth,d+z);let q=m,B=0,j=0;for(let P=D;P<$;P+=l){const X=N+P*r[1];for(let Q=W;Q<G;Q+=u){const re=X+Q*r[2],le=e[re+T];a==="max"&&le>q?q=le:a==="avg"&&(B+=le,j++)}if(isNaN(q))break}const H=_+L*k+T;y[H]=a==="avg"?B/j:q}}}return g}function f9(e,t,n,r,s=!1,a=!1){const i=ln(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,h=r.padInfo.top,m=r.padInfo.left,g=ln(t,n,e);for(let y=0;y<r.batchSize;++y)for(let b=0;b<r.inChannels;++b)for(let v=0;v<r.outHeight;++v){const k=v*o-h;let I=k;for(;I<0;)I+=u;const S=Math.min(r.inHeight,d+k);for(let N=0;N<r.outWidth;++N){const T=N*l-m;let A=T;for(;A<0;)A+=c;const R=Math.min(r.inWidth,p+T);let D=Number.NEGATIVE_INFINITY,$=-1;for(let _=I;_<S;_+=u){const L=_-k;for(let z=A;z<R;z+=c){const W=z-T,G=g.get(y,_,z,b);G>D&&(D=G,s?$=a?((y*r.inHeight+_)*r.inWidth+z)*r.inChannels+b:(_*r.inWidth+z)*r.inChannels+b:$=L*p+W)}}i.set($,y,v,N,b)}}return i}function m9(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,p=s.effectiveFilterDepth,h=s.effectiveFilterHeight,m=s.effectiveFilterWidth,g=s.padInfo.front,y=s.padInfo.top,b=s.padInfo.left,v=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,k=ln(s.outShape,n),I=k.values,S=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],N=s.outShape[2]*s.outShape[3]*s.outShape[4],T=s.outShape[3]*s.outShape[4],A=s.outShape[4];for(let R=0;R<s.batchSize;++R){const D=R*S,$=R*r[0];for(let _=0;_<s.inChannels;++_)for(let L=0;L<s.outDepth;++L){const z=L*i-g;let W=z;for(;W<0;)W+=u;const G=Math.min(s.inDepth,p+z),q=D+L*N;for(let B=0;B<s.outHeight;++B){const j=B*o-y;let H=j;for(;H<0;)H+=c;const P=Math.min(s.inHeight,h+j),X=q+B*T;for(let Q=0;Q<s.outWidth;++Q){const re=Q*l-b;let le=re;for(;le<0;)le+=d;const ke=Math.min(s.inWidth,m+re),Ne=X+Q*A;let we=v,_e=0,Le=0;for(let Ze=W;Ze<G;Ze+=u){const ut=$+Ze*r[1];for(let ft=H;ft<P;ft+=c){const et=ut+ft*r[2];for(let Qe=le;Qe<ke;Qe+=d){const ot=et+Qe*r[3],gt=e[ot+_];if(a==="max"&&gt>we?we=gt:a==="avg"&&(_e+=gt,Le++),isNaN(we))break}if(isNaN(we))break}if(isNaN(we))break}const Be=Ne+_;I[Be]=a==="avg"?_e/Math.max(Le,1):we}}}}return k}function O2e(e,t){const n=ln(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=t.padInfo.front,h=t.padInfo.top,m=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let y=0;y<t.inChannels;++y)for(let b=0;b<t.outDepth;++b){const v=b*r-p;let k=v;for(;k<0;)k+=i;const I=Math.min(t.inDepth,u+v);for(let S=0;S<t.outHeight;++S){const N=S*s-h;let T=N;for(;T<0;)T+=o;const A=Math.min(t.inHeight,c+N);for(let R=0;R<t.outWidth;++R){const D=R*a-m;let $=D;for(;$<0;)$+=l;const _=Math.min(t.inWidth,d+D);let L=Number.NEGATIVE_INFINITY,z=-1;for(let W=k;W<I;W+=i){const G=W-v;for(let q=T;q<A;q+=o){const B=q-N;for(let j=$;j<_;j+=l){const H=j-D,P=e.get(g,W,q,j,y);P>=L&&(L=P,z=G*c*d+B*c+H)}}}n.set(z,g,b,S,R,y)}}}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M2e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;vt(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Y(ua(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=So(s.shape,a,i,u,o,l);let d;if(c.filterWidth===1&&c.filterHeight===1&&Dn(c.inShape,c.outShape))d=tu({inputs:{x:s},backend:n});else{const p=n.data.get(s.dataId).values,h=_t(s.shape),m=h3(p,s.shape,s.dtype,h,c,"avg");d=n.makeTensorInfo(c.outShape,s.dtype,m.values)}return d}const L2e={kernelName:yS,backendName:"cpu",kernelFunc:M2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P2e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;vt(s,"avgPool3d");const c=Hu(s.shape,a,i,1,o,l,u),d=n.data.get(s.dataId).values,p=m9(d,s.shape,s.dtype,_t(s.shape),c,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}const z2e={kernelName:xS,backendName:"cpu",kernelFunc:P2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B2e(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;vt([s,a],"avgPool3DGrad");const c=Hu(a.shape,i,o,1,l,u),d=c.strideDepth,p=c.strideHeight,h=c.strideWidth,m=c.filterDepth,g=c.filterHeight,y=c.filterWidth,b=c.dilationDepth,v=c.dilationHeight,k=c.dilationWidth,I=c.effectiveFilterDepth,S=c.effectiveFilterHeight,N=c.effectiveFilterWidth,T=I-1-c.padInfo.front,A=N-1-c.padInfo.left,R=S-1-c.padInfo.top,D=ln(a.shape,"float32"),$=1/(m*g*y),_=n.bufferSync(s);for(let L=0;L<c.batchSize;++L)for(let z=0;z<c.inChannels;++z)for(let W=0;W<c.inDepth;++W)for(let G=0;G<c.inHeight;++G)for(let q=0;q<c.inWidth;++q){const B=W-T,j=G-R,H=q-A;let P=0;for(let X=0;X<I;X+=b){const Q=(B+X)/d;if(!(Q<0||Q>=c.outDepth||Math.floor(Q)!==Q))for(let re=0;re<S;re+=v){const le=(j+re)/p;if(!(le<0||le>=c.outHeight||Math.floor(le)!==le))for(let ke=0;ke<N;ke+=k){const Ne=(H+ke)/h;if(Ne<0||Ne>=c.outWidth||Math.floor(Ne)!==Ne)continue;const we=_.get(L,Q,le,Ne,z);P+=we}}}D.set(P*$,L,W,G,q,z)}return n.makeTensorInfo(D.shape,D.dtype,D.values)}const W2e={kernelName:eD,backendName:"cpu",kernelFunc:B2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V2e(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;vt([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=So(i.shape,o,l,1,u),d=c.strideHeight,p=c.strideWidth,h=c.filterHeight,m=c.filterWidth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterHeight,v=c.effectiveFilterWidth,k=v-1-c.padInfo.left,I=b-1-c.padInfo.top,S=ln(i.shape,"float32"),N=1/(h*m),T=n.data.get(s.dataId).values,A=ln(s.shape,"float32",T);for(let R=0;R<c.batchSize;++R)for(let D=0;D<c.inChannels;++D)for(let $=0;$<c.inHeight;++$)for(let _=0;_<c.inWidth;++_){const L=$-I,z=_-k;let W=0;for(let G=0;G<b;G+=g){const q=(L+G)/d;if(!(q<0||q>=c.outHeight||Math.floor(q)!==q))for(let B=0;B<v;B+=y){const j=(z+B)/p;if(j<0||j>=c.outWidth||Math.floor(j)!==j)continue;const H=A.get(R,q,j,D);W+=H}}S.set(W*N,R,$,_,D)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const U2e={kernelName:QR,backendName:"cpu",kernelFunc:V2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G2e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;Y(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Y(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Y(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),vt([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);const c=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,p=n.data.get(l.dataId).values,h=a?n.data.get(a.dataId).values:new Float32Array([1]),m=i?n.data.get(i.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),y=m.length,b=h.length,v=p.length,k=d.length;let I=0,S=0,N=0,T=0;for(let A=0;A<c.length;++A)g[A]=m[I++]+(c[A]-d[S++])*h[N++]/Math.sqrt(p[T++]+u),I>=y&&(I=0),S>=k&&(S=0),N>=b&&(N=0),T>=v&&(T=0);return n.makeTensorInfo(s.shape,s.dtype,g)}const j2e={kernelName:AS,backendName:"cpu",kernelFunc:G2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H2e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;vt([s],"batchToSpaceND");const o=a.reduce((b,v)=>b*v),l=s1(s.shape,a,o),u=a1(l.length,a.length),c=i1(s.shape,a,o),d=IF(i,a.length),p=SF(c,i,a.length),h=lr({inputs:{x:s},backend:n,attrs:{shape:l}}),m=Ja({inputs:{x:h},backend:n,attrs:{perm:u}}),g=lr({inputs:{x:m},backend:n,attrs:{shape:c}}),y=ch({inputs:{x:g},backend:n,attrs:{begin:d,size:p}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}const q2e={kernelName:vS,backendName:"cpu",kernelFunc:H2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K2e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=l3(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}const X2e={kernelName:tD,backendName:"cpu",kernelFunc:K2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y2e(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=Jt(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Z2e={kernelName:B5,backendName:"cpu",kernelFunc:Y2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J2e=jn(d0,(e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),Q2e={kernelName:d0,backendName:"cpu",kernelFunc:J2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eIe=e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Oe(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const c=o[u],d=l[u];r[u]=Math.hypot(c,d)}return n.makeOutput(r,t.shape,"float32")},tIe={kernelName:wS,backendName:"cpu",kernelFunc:eIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dg(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const nIe={kernelName:bD,backendName:"cpu",kernelFunc:Dg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fg(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=un(s,t[0].shape)[0],i=t.map(g=>g.shape);vF(i,a);let o=Gl(t.map(g=>g.shape),a);if(Oe(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter(g=>Oe(g.shape)>0);if(l.length===1)return tu({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){const g=l.map(I=>uh({inputs:{input:I},backend:n})),y=l.map(I=>Dg({inputs:{input:I},backend:n})),b=Fg({inputs:g,backend:n,attrs:{axis:a}}),v=Fg({inputs:y,backend:n,attrs:{axis:a}}),k=mi({inputs:{real:b,imag:v},backend:n});return g.forEach(I=>n.disposeIntermediateTensorInfo(I)),y.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),k}const u=l.map(g=>{const b=[-1,Oe(g.shape.slice(a))];return lr({inputs:{x:g},backend:n,attrs:{shape:b}})}),c=u.map(g=>({vals:n.data.get(g.dataId).values,shape:g.shape}));o=Gl(u.map(g=>g.shape),1);const d=u[0].shape[0]===1,p=vq(c,o,t[0].dtype,d),h=Gl(l.map(g=>g.shape),a),m=n.makeTensorInfo(h,t[0].dtype,p);return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const rIe={kernelName:kS,backendName:"cpu",kernelFunc:Fg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g9(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;vt([s,a],"conv2d");const d=qu(l),p=Xs(s.shape,a.shape,i,u,o,c,!1,d),h=p.filterHeight,m=p.filterWidth,g=p.dilationHeight,y=p.dilationWidth,b=p.padInfo.left,v=p.padInfo.top,k=p.dataFormat==="channelsLast",I=new Ks(p.outShape,s.dtype),S=_t(s.shape),N=_t(a.shape),T=S[0],A=k?S[1]:S[2],R=k?S[2]:1,D=k?1:S[1],$=I.strides[0],_=k?I.strides[1]:I.strides[2],L=k?I.strides[2]:1,z=k?1:I.strides[1],W=n.data.get(s.dataId).values,G=n.data.get(a.dataId).values,q=I.values;for(let B=0;B<p.batchSize;++B){const j=B*T,H=B*$;for(let P=0;P<p.outHeight;++P){const X=H+P*_,Q=P*p.strideHeight-v;for(let re=0;re<h;++re){const le=Q+re*g;if(le<0||le>=p.inHeight)continue;const ke=re*N[0],Ne=j+le*A;for(let we=0;we<p.outWidth;++we){const _e=X+we*L,Le=we*p.strideWidth-b;for(let Be=0;Be<m;++Be){const Ze=Le+Be*y;if(Ze<0||Ze>=p.inWidth)continue;const ut=ke+Be*N[1],ft=Ne+Ze*R;let et=ut;for(let Qe=0;Qe<p.inChannels;++Qe){const ot=W[ft+Qe*D];for(let gt=0;gt<p.outChannels;++gt)q[_e+gt*z]+=ot*G[et+gt];et+=p.outChannels}}}}}}return n.makeTensorInfo(I.shape,I.dtype,q)}const sIe={kernelName:IS,backendName:"cpu",kernelFunc:g9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;vt([s,a],"conv2dBackpropFilter");const d=qu(l),p=Xs(s.shape,c,i,1,o,u,!1,d),{strideHeight:h,strideWidth:m,filterHeight:g,filterWidth:y}=p,b=p.dataFormat==="channelsLast",v=new Ks(p.filterShape,"float32"),k=p.padInfo.left,I=p.padInfo.top,S=n.data.get(s.dataId).values,N=n.data.get(a.dataId).values,T=new Ks(s.shape,s.dtype,S),A=new Ks(a.shape,a.dtype,N);for(let R=0;R<g;++R){const D=Math.max(0,Math.ceil((I-R)/h)),$=Math.min(p.outHeight,(p.inHeight+I-R)/h);for(let _=0;_<y;++_){const L=Math.max(0,Math.ceil((k-_)/m)),z=Math.min(p.outWidth,(p.inWidth+k-_)/m);for(let W=0;W<p.inChannels;++W)for(let G=0;G<p.outChannels;++G){let q=0;for(let B=0;B<p.batchSize;++B)for(let j=D;j<$;++j){const H=R+j*h-I;for(let P=L;P<z;++P){const X=_+P*m-k;b?q+=T.get(B,H,X,W)*A.get(B,j,P,G):q+=T.get(B,W,H,X)*A.get(B,G,j,P)}}v.set(q,R,_,W,G)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const iIe={kernelName:sD,backendName:"cpu",kernelFunc:aIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oIe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;vt([s,a],"conv2dBackpropInput");const d=_t(a.shape),p=_t(s.shape);let h=qu(u);const m=Xs(i,a.shape,o,1,l,c,!1,h),g=new Ks(m.inShape,"float32"),y=g.values,b=n.data.get(s.dataId).values,v=n.data.get(a.dataId).values,[k,I,S]=d,{batchSize:N,filterHeight:T,filterWidth:A,inChannels:R,inHeight:D,inWidth:$,outChannels:_,outHeight:L,outWidth:z,strideHeight:W,strideWidth:G}=m;h=m.dataFormat;const q=T-1-m.padInfo.top,B=A-1-m.padInfo.left,j=h==="channelsLast",H=g.strides[0],P=j?g.strides[1]:g.strides[2],X=j?g.strides[2]:1,Q=j?1:g.strides[1],re=p[0],le=j?p[1]:p[2],ke=j?p[2]:1,Ne=j?1:p[1];for(let we=0;we<N;++we)for(let _e=0;_e<R;++_e)for(let Le=0;Le<D;++Le){const Be=Le-q,Ze=Math.max(0,Math.ceil(Be/W)),ut=Math.min(L,(T+Be)/W);for(let ft=0;ft<$;++ft){const et=ft-B,Qe=Math.max(0,Math.ceil(et/G)),ot=Math.min(z,(A+et)/G);let gt=0;for(let Et=Ze;Et<ut;++Et){const dn=Et*W-Be;for(let Xt=Qe;Xt<ot;++Xt){const In=Xt*G-et,Ve=re*we+le*Et+ke*Xt,tt=k*(T-1-dn)+I*(A-1-In)+S*_e;for(let Rt=0;Rt<_;++Rt){const Dt=b[Ve+Ne*Rt],Ut=v[tt+Rt];gt+=Dt*Ut}}}const At=H*we+P*Le+X*ft+Q*_e;y[At]=gt}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const lIe={kernelName:SS,backendName:"cpu",kernelFunc:oIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;vt([s,a],"conv3d");const u=kd(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:p,dilationDepth:h,dilationHeight:m,dilationWidth:g,padInfo:y}=u,b=y.front,v=y.left,k=y.top,I=new Ks(u.outShape,s.dtype),S=n.data.get(s.dataId).values,N=n.data.get(a.dataId).values,T=I.values,A=_t(s.shape),R=_t(a.shape);for(let D=0;D<u.batchSize;++D){const $=D*A[0],_=D*I.strides[0];for(let L=0;L<u.outDepth;++L){const z=_+L*I.strides[1],W=L*u.strideDepth-b;for(let G=0;G<c;++G){const q=W+G*h;if(q<0||q>=u.inDepth)continue;const B=G*R[0],j=$+q*A[1];for(let H=0;H<u.outHeight;++H){const P=z+H*I.strides[2],X=H*u.strideHeight-k;for(let Q=0;Q<d;++Q){const re=X+Q*m;if(re<0||re>=u.inHeight)continue;const le=B+Q*R[1],ke=j+re*A[2];for(let Ne=0;Ne<u.outWidth;++Ne){const we=P+Ne*u.outChannels,_e=Ne*u.strideWidth-v;for(let Le=0;Le<p;++Le){const Be=_e+Le*g;if(Be<0||Be>=u.inWidth)continue;const Ze=le+Le*R[2],ut=ke+Be*u.inChannels;let ft=Ze;for(let et=0;et<u.inChannels;++et){const Qe=S[ut+et];for(let ot=0;ot<u.outChannels;++ot)T[we+ot]+=Qe*N[ft+ot];ft+=u.outChannels}}}}}}}}return n.makeTensorInfo(I.shape,I.dtype,I.values)}const cIe={kernelName:CS,backendName:"cpu",kernelFunc:uIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;vt([s,a],"conv3dBackpropFilterV2");const u=_t(s.shape),c=_t(a.shape),d=kd(s.shape,l,i,1,o),p=d.strideDepth,h=d.strideHeight,m=d.strideWidth,g=d.filterDepth,y=d.filterHeight,b=d.filterWidth,v=new Ks(d.filterShape,"float32"),k=v.values,[I,S,N,T]=v.strides,A=n.data.get(a.dataId).values,[R,D,$,_]=c,L=n.data.get(s.dataId).values,[z,W,G,q]=u,B=d.padInfo.front,j=d.padInfo.left,H=d.padInfo.top;for(let P=0;P<g;++P){const X=Math.max(0,Math.ceil((B-P)/p)),Q=Math.min(d.outDepth,(d.inDepth+B-P)/p),re=P*I;for(let le=0;le<y;++le){const ke=Math.max(0,Math.ceil((H-le)/h)),Ne=Math.min(d.outHeight,(d.inHeight+H-le)/h),we=le*S+re;for(let _e=0;_e<b;++_e){const Le=Math.max(0,Math.ceil((j-_e)/m)),Be=Math.min(d.outWidth,(d.inWidth+j-_e)/m),Ze=_e*N+we;for(let ut=0;ut<d.inChannels;++ut){const ft=ut*T+Ze;for(let et=0;et<d.outChannels;++et){let Qe=0;for(let ot=0;ot<d.batchSize;++ot){const gt=ot*z,At=ot*R;for(let Et=X;Et<Q;++Et){const Xt=(P+Et*p-B)*W+gt,In=Et*D+At;for(let Ve=ke;Ve<Ne;++Ve){const Rt=(le+Ve*h-H)*G+Xt,Dt=Ve*$+In;for(let Ut=Le;Ut<Be;++Ut){const dr=(_e+Ut*m-j)*q+Rt,zn=Ut*_+Dt;Qe+=L[dr+ut]*A[zn+et]}}}}k[ft+et]=Qe}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const pIe={kernelName:aD,backendName:"cpu",kernelFunc:dIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hIe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;vt([s],"conv3dBackpropInputV2");const u=_t(s.shape),c=_t(a.shape),d=kd(l,a.shape,o,1,i),p=new Ks(d.inShape,"float32"),h=p.values,[m,g,y,b]=p.strides,v=n.data.get(s.dataId).values,[k,I,S,N]=u,T=n.data.get(a.dataId).values,[A,R,D,$]=c,{batchSize:_,filterDepth:L,filterHeight:z,filterWidth:W,inChannels:G,inDepth:q,inHeight:B,inWidth:j,outChannels:H,outDepth:P,outHeight:X,outWidth:Q,strideDepth:re,strideHeight:le,strideWidth:ke}=d,Ne=L-1-d.padInfo.front,we=z-1-d.padInfo.top,_e=W-1-d.padInfo.left;for(let Le=0;Le<_;++Le)for(let Be=0;Be<G;++Be)for(let Ze=0;Ze<q;++Ze){const ut=Ze-Ne,ft=Math.max(0,Math.ceil(ut/re)),et=Math.min(P,(L+ut)/re);for(let Qe=0;Qe<B;++Qe){const ot=Qe-we,gt=Math.max(0,Math.ceil(ot/le)),At=Math.min(X,(z+ot)/le);for(let Et=0;Et<j;++Et){const dn=Et-_e,Xt=Math.max(0,Math.ceil(dn/ke)),In=Math.min(Q,(W+dn)/ke);let Ve=0;for(let tt=ft;tt<et;++tt){const Rt=tt*re-ut;for(let Dt=gt;Dt<At;++Dt){const Ut=Dt*le-ot;for(let Pn=Xt;Pn<In;++Pn){const dr=Pn*ke-dn,zn=k*Le+I*tt+S*Dt+N*Pn,Gr=A*(L-1-Rt)+R*(z-1-Ut)+D*(W-1-dr)+$*Be;for(let Sn=0;Sn<H;++Sn){const pn=v[zn+Sn],Fn=T[Gr+Sn];Ve+=pn*Fn}}}}h[m*Le+g*Ze+y*Qe+b*Et+Be]=Ve}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}const fIe={kernelName:iD,backendName:"cpu",kernelFunc:hIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mIe=jn(p0,e=>Math.cos(e)),gIe={kernelName:p0,backendName:"cpu",kernelFunc:mIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yIe=jn(h0,e=>Math.cosh(e)),xIe={kernelName:h0,backendName:"cpu",kernelFunc:yIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bIe(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,p,h]=s.shape,m=a.shape[0],[g,y]=o,b=ln([m,g,y,h],"float32"),v=n.data.get(a.dataId).values,k=n.data.get(i.dataId).values,I=n.data.get(s.dataId).values,S=_t(s.shape),N=_t(b.shape);for(let T=0;T<m;T++){const A=T*4,R=v[A],D=v[A+1],$=v[A+2],_=v[A+3],L=k[T];if(L>=c)continue;const z=g>1?($-R)*(d-1)/(g-1):0,W=y>1?(_-D)*(p-1)/(y-1):0;for(let G=0;G<g;G++){const q=g>1?R*(d-1)+G*z:.5*(R+$)*(d-1);if(q<0||q>d-1){for(let B=0;B<y;B++)for(let j=0;j<h;j++){const H=j+B*N[2]+G*N[1]+T*N[0];b.values[H]=u}continue}if(l==="bilinear"){const B=Math.floor(q),j=Math.ceil(q),H=q-B;for(let P=0;P<y;P++){const X=y>1?D*(p-1)+P*W:.5*(D+_)*(p-1);if(X<0||X>p-1){for(let ke=0;ke<h;ke++){const Ne=ke+P*N[2]+G*N[1]+T*N[0];b.values[Ne]=u}continue}const Q=Math.floor(X),re=Math.ceil(X),le=X-Q;for(let ke=0;ke<h;ke++){let Ne=ke+Q*S[2]+B*S[1]+L*S[0];const we=I[Ne];Ne=ke+re*S[2]+B*S[1]+L*S[0];const _e=I[Ne];Ne=ke+Q*S[2]+j*S[1]+L*S[0];const Le=I[Ne];Ne=ke+re*S[2]+j*S[1]+L*S[0];const Be=I[Ne],Ze=we+(_e-we)*le,ut=Le+(Be-Le)*le;Ne=ke+P*N[2]+G*N[1]+T*N[0],b.values[Ne]=Ze+(ut-Ze)*H}}}else for(let B=0;B<y;++B){const j=y>1?D*(p-1)+B*W:.5*(D+_)*(p-1);if(j<0||j>p-1){for(let X=0;X<h;X++){const Q=X+B*N[2]+G*N[1]+T*N[0];b.values[Q]=u}continue}const H=Math.round(j),P=Math.round(q);for(let X=0;X<h;X++){const Q=X+H*S[2]+P*S[1]+L*S[0],re=X+B*N[2]+G*N[1]+T*N[0];b.values[re]=I[Q]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const vIe={kernelName:lD,backendName:"cpu",kernelFunc:bIe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;vt(s,"cumprod");const l=_r([a],s.shape.length);let u=s;l!=null&&(u=Ja({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=zr(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=ki(u.dtype,"int32"),p=qR(Oe(u.shape),d),h=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],g=o?(b,v)=>b+m-v-1:(b,v)=>b+v;for(let b=0;b<h.length;b+=m)for(let v=0;v<m;v++){const k=g(b,v);if(v===0)p[k]=i?1:h[k];else{const I=g(b,v-1);p[k]=i?h[I]*p[I]:h[k]*p[I]}}const y=n.makeTensorInfo(u.shape,d,p);if(l!=null){const b=Id(l),v=Ja({inputs:{x:y},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(u),v}return y}const kIe={kernelName:oD,backendName:"cpu",kernelFunc:wIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;vt(s,"cumsum");const l=_r([a],s.shape.length);let u=s;l!=null&&(u=Ja({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=zr(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=ki(u.dtype,"int32"),p=aa(Oe(u.shape),d),h=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],g=o?(b,v)=>b+m-v-1:(b,v)=>b+v;for(let b=0;b<h.length;b+=m)for(let v=0;v<m;v++){const k=g(b,v);if(v===0)p[k]=i?0:h[k];else{const I=g(b,v-1);p[k]=i?h[I]+p[I]:h[k]+p[I]}}const y=n.makeTensorInfo(u.shape,d,p);if(l!=null){const b=Id(l),v=Ja({inputs:{x:y},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(u),v}return y}const SIe={kernelName:NS,backendName:"cpu",kernelFunc:IIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){const l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=l3(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){const l=n.bufferSync(s),u=n.bufferSync(a),c=yq(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const NIe={kernelName:uD,backendName:"cpu",kernelFunc:CIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;Y(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*a,p=u*a,h=c/(a*a),m=n.data.get(s.dataId).values,g=new Float32Array(o*d*p*h);let y=0;for(let b=0;b<o;++b)for(let v=0;v<d;++v){const k=Math.floor(v/a),I=v%a;for(let S=0;S<p;++S){const N=Math.floor(S/a),T=S%a,A=(I*a+T)*h;for(let R=0;R<h;++R){const $=R+A+c*(N+u*(k+l*b));g[y++]=m[$]}}}return n.makeTensorInfo([o,d,p,h],s.dtype,g)}const $Ie={kernelName:cD,backendName:"cpu",kernelFunc:TIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y9(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;vt([s,a],"depthwiseConv2DNative");const c=_t(s.shape),d=_t(a.shape);let p=l;p==null&&(p=[1,1]),Y(ua(i,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);const h=Xs(s.shape,a.shape,i,p,o,u,!0),{filterHeight:m,filterWidth:g,dilationHeight:y,dilationWidth:b,padInfo:v}=h,k=v.left,I=v.top,S=h.outChannels/h.inChannels,N=new Ks(h.outShape,s.dtype),T=n.data.get(s.dataId).values,A=n.data.get(a.dataId).values,R=N.values;for(let D=0;D<h.batchSize;++D){const $=D*c[0],_=D*N.strides[0];for(let L=0;L<h.outHeight;++L){const z=_+L*N.strides[1],W=L*h.strideHeight-I;for(let G=0;G<m;++G){const q=W+G*y;if(q<0||q>=h.inHeight)continue;const B=G*d[0],j=$+q*c[1];for(let H=0;H<h.outWidth;++H){const P=z+H*N.strides[2],X=H*h.strideWidth-k;for(let Q=0;Q<g;++Q){const re=X+Q*b;if(re<0||re>=h.inWidth)continue;const le=B+Q*d[1],ke=j+re*h.inChannels;let Ne=P,we=le;for(let _e=0;_e<h.inChannels;++_e){const Le=T[ke+_e];for(let Be=0;Be<S;++Be)R[Ne+Be]+=Le*A[we+Be];Ne+=S,we+=S}}}}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}const EIe={kernelName:TS,backendName:"cpu",kernelFunc:y9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ie(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;vt([s,a],"depthwiseConv2dNativeBackpropFilter");const d=Xs(s.shape,c,i,o,l,u,!0),{strideHeight:p,strideWidth:h,filterHeight:m,filterWidth:g}=d,y=new Ks(d.filterShape,"float32"),b=d.padInfo.left,v=d.padInfo.top,k=d.outChannels/d.inChannels,I=n.data.get(s.dataId).values,S=new Ks(s.shape,s.dtype,I),N=n.data.get(a.dataId).values,T=new Ks(a.shape,a.dtype,N);for(let A=0;A<m;++A){const R=Math.max(0,Math.ceil((v-A)/p)),D=Math.min(d.outHeight,(d.inHeight+v-A)/p);for(let $=0;$<g;++$){const _=Math.max(0,Math.ceil((b-$)/h)),L=Math.min(d.outWidth,(d.inWidth+b-$)/h);for(let z=0;z<d.outChannels;++z){const W=Math.trunc(z/k),G=z%k;let q=0;for(let B=0;B<d.batchSize;++B)for(let j=R;j<D;++j){const H=A+j*p-v;for(let P=_;P<L;++P){const X=$+P*h-b;q+=S.get(B,H,X,W)*T.get(B,j,P,z)}}y.set(q,A,$,W,G)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const AIe={kernelName:dD,backendName:"cpu",kernelFunc:_Ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RIe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;vt([s,a],"depthwiseConv2DNativeBackpropInput");const d=_t(s.shape),p=_t(a.shape),h=Xs(c,a.shape,i,o,l,u,!0),m=new Ks(h.inShape,"float32"),g=m.values,[y,b,v]=m.strides,k=n.data.get(s.dataId).values,[I,S,N]=d,T=n.data.get(a.dataId).values,[A,R,D]=p,{batchSize:$,filterHeight:_,filterWidth:L,inChannels:z,inHeight:W,inWidth:G,outChannels:q,outHeight:B,outWidth:j,strideHeight:H,strideWidth:P}=h,X=_-1-h.padInfo.top,Q=L-1-h.padInfo.left,re=q/z;for(let le=0;le<$;++le)for(let ke=0;ke<z;++ke)for(let Ne=0;Ne<W;++Ne){const we=Ne-X,_e=Math.max(0,Math.ceil(we/H)),Le=Math.min(B,(_+we)/H);for(let Be=0;Be<G;++Be){const Ze=Be-Q,ut=Math.max(0,Math.ceil(Ze/P)),ft=Math.min(j,(L+Ze)/P);let et=0;for(let Qe=_e;Qe<Le;++Qe){const ot=Qe*H-we;for(let gt=ut;gt<ft;++gt){const At=gt*P-Ze,Et=I*le+S*Qe+N*gt,dn=A*(_-1-ot)+R*(L-1-At)+D*ke;for(let Xt=0;Xt<re;++Xt){const In=ke*re+Xt,Ve=k[Et+In],tt=T[dn+Xt];et+=Ve*tt}}}g[y*le+b*Ne+v*Be+ke]=et}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const DIe={kernelName:pD,backendName:"cpu",kernelFunc:RIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FIe(e){const{inputs:t,backend:n}=e,{x:r}=t,s=Oe(r.shape),a=n.data.get(r.dataId).values,i=ln([s,s],r.dtype),o=i.values;for(let u=0;u<a.length;u++)o[u*s+u]=a[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}const OIe={kernelName:W5,backendName:"cpu",kernelFunc:FIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MIe={kernelName:$S,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,p=s.shape.length,{batchSize:h,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:k,strideHeight:I,strideWidth:S,filterHeight:N,filterWidth:T,dilationHeight:A,dilationWidth:R,outShape:D}=Q0(r.shape,s.shape,a,i,"NHWC",o),$=Oe(D),_=D.length,L=Mr(r.dtype,$);for(let W=0;W<h;++W)for(let G=0;G<b;++G){const q=G*I-k.top;for(let B=0;B<v;++B){const j=B*S-k.left;for(let H=0;H<y;++H){let P=Number.MIN_SAFE_INTEGER;for(let Q=0;Q<N;++Q){const re=q+Q*A;if(re>=0&&re<m)for(let le=0;le<T;++le){const ke=j+le*R;if(ke>=0&&ke<g){const Ne=Vl([W,re,ke,H],c,_t(r.shape)),we=Vl([Q,le,H],p,_t(s.shape)),_e=u[Ne]+d[we];_e>P&&(P=_e)}}}const X=Vl([W,G,B,H],_,_t(D));L[X]=P}}}return{dataId:l.write(Dh(L,r.dtype),D,r.dtype),shape:D,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LIe={kernelName:O_,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=Xo(r.shape,u.data.get(r.dataId).values),d=Xo(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:h,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:k,strideWidth:I,filterHeight:S,filterWidth:N,dilationHeight:T,dilationWidth:A,outShape:R}=Q0(r.shape,s.shape,i,o,"NHWC",l);Y(a.rank===R.length,()=>`Error in ${O_}, dy must have the same rank as output ${R.length}, but got ${a.rank}`);const D=Xo(R,u.data.get(a.dataId).values),$=L5(s.shape,s.dtype);for(let L=0;L<p;++L)for(let z=0;z<y;++z){const W=z*k-v.top;for(let G=0;G<b;++G){const q=G*I-v.left;for(let B=0;B<g;++B){let j=Number.MIN_SAFE_INTEGER,H=0,P=0;for(let X=0;X<S;++X){const Q=W+X*T;if(Q>=0&&Q<h)for(let re=0;re<N;++re){const le=q+re*A;if(le>=0&&le<m){const ke=c[L][Q][le][B]+d[X][re][B];ke>j&&(j=ke,H=X,P=re)}}}$[H][P][B]+=D[L][z][G][B]}}}return{dataId:u.write(Dh($,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PIe={kernelName:F_,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=Xo(r.shape,u.data.get(r.dataId).values),d=Xo(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:h,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:k,strideWidth:I,filterHeight:S,filterWidth:N,dilationHeight:T,dilationWidth:A,outShape:R}=Q0(r.shape,s.shape,i,o,"NHWC",l);Y(a.rank===R.length,()=>`Error in ${F_}, dy must have the same rank as output ${R.length}, but got ${a.rank}`);const D=Xo(R,u.data.get(a.dataId).values),$=L5(r.shape,r.dtype);for(let L=0;L<p;++L)for(let z=0;z<y;++z){const W=z*k-v.top;for(let G=0;G<b;++G){const q=G*I-v.left;for(let B=0;B<g;++B){let j=Number.MIN_SAFE_INTEGER,H=W<0?0:W,P=q<0?0:q;for(let X=0;X<S;++X){const Q=W+X*T;if(Q>=0&&Q<h)for(let re=0;re<N;++re){const le=q+re*A;if(le>=0&&le<m){const ke=c[L][Q][le][B]+d[X][re][B];ke>j&&(j=ke,H=Q,P=le)}}}$[L][H][P][B]+=D[L][z][G][B]}}}return{dataId:u.write(Dh($,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zIe(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(l==null?void 0:l.alpha)||1,c=(o==null?void 0:o.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=a.getContext(c,(o==null?void 0:o.contextAttributes)||{});if(d==null)throw new Error(`Could not get the context with ${c} type.`);const[p,h]=s.shape.slice(0,2),m=s.shape.length===2?1:s.shape[2],g=n.data.get(s.dataId).values,y=s.dtype==="float32"?255:1,b=new Uint8ClampedArray(h*p*4);for(let k=0;k<p*h;++k){const I=[0,0,0,255*u];for(let N=0;N<m;N++){const T=g[k*m+N];if(s.dtype==="float32"){if(T<0||T>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${T}.`)}else if(s.dtype==="int32"&&(T<0||T>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${T}.`);m===1?(I[0]=T*y,I[1]=T*y,I[2]=T*y):I[N]=T*y}const S=k*4;b[S+0]=Math.round(I[0]),b[S+1]=Math.round(I[1]),b[S+2]=Math.round(I[2]),b[S+3]=Math.round(I[3])}a.width=h,a.height=p;const v=new ImageData(b,h,p);return d.putImageData(v,0,0),s}const BIe={kernelName:xhe,backendName:"cpu",kernelFunc:zIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m1(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;vt(s,"sum");let o;s.dtype==="bool"?o=td({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):o=tu({inputs:{x:s},backend:n});const l=o.shape.length,u=un(a,o.shape),c=_r(u,l);let d=u,p=o;c!=null&&(p=Ja({inputs:{x:o},backend:n,attrs:{perm:c}}),d=zr(d.length,l)),Ys("sum",d,p.shape.length);const[h,m]=Os(p.shape,d),g=ki(p.dtype,"int32");let y=dI(n,h,g);const b=Oe(m),v=n.data.get(y.dataId).values,k=n.data.get(p.dataId).values;for(let I=0;I<v.length;++I){const S=I*b;let N=0;for(let T=0;T<b;++T)N+=k[S+T];v[I]=N}if(i){const I=Jr(y.shape,u),S=y;y=lr({inputs:{x:y},backend:n,attrs:{shape:I}}),n.disposeIntermediateTensorInfo(S)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(p),y}const WIe={kernelName:oC,backendName:"cpu",kernelFunc:m1};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VIe(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=RF(s,a.length);FF(i.length,l,a);const{path:u,steps:c}=OF(o,l),d=c.length;let p=null,h=i.length;const m=[];for(let g=0;g<d;++g){for(const y of c[g]){const{permutationIndices:b,expandDims:v}=DF(h,l[y]);let k;MF(b)?k=a[y]:(k=Ja({inputs:{x:a[y]},backend:n,attrs:{perm:b}}),m.push(k));const I=k.shape.slice();for(let S=0;S<v.length;++S)I.splice(v[S],0,1);Dn(k.shape,I)||(k=lr({inputs:{x:k},backend:n,attrs:{shape:I}}),m.push(k)),p===null?p=k:(p=MC({inputs:{a:k,b:p},backend:n}),m.push(p))}g<d-1&&(u[g]>=0&&(p=m1({inputs:{x:p},backend:n,attrs:{axis:u[g]-(i.length-h),keepDims:!1}}),m.push(p)),h--)}for(const g of m)g!==p&&n.disposeIntermediateTensorInfo(g);return p}const UIe={kernelName:hD,backendName:"cpu",kernelFunc:VIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GIe(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;vt([r,s],"eluGrad");const a=new Float32Array(Oe(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];u>=0?a[l]=o[l]:a[l]=o[l]*(u+1)}return n.makeTensorInfo(s.shape,"float32",a)}const jIe={kernelName:fD,backendName:"cpu",kernelFunc:GIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HIe=CF,qIe=NF,KIe=TF,XIe=$F,YIe=EF,ZIe=_F,JIe=jn(g0,e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+HIe*n);return t*(1-((((ZIe*r+YIe)*r+XIe)*r+KIe)*r+qIe)*r*Math.exp(-n*n))}),QIe={kernelName:g0,backendName:"cpu",kernelFunc:JIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fI(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(Y(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),lr({inputs:{x:s},backend:n,attrs:{shape:o}})}const eSe={kernelName:_S,backendName:"cpu",kernelFunc:fI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tSe=Wr((e,t)=>e/t),f3=xs(f0,tSe),uA={kernelName:f0,backendName:"cpu",kernelFunc:f3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x9(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=Oe(u),d=sa("float32",c),p=sa("float32",c);for(let y=0;y<s;y++){const b=ch({inputs:{x:o},backend:n,attrs:{begin:[y,0],size:[1,a]}}),v=ch({inputs:{x:l},backend:n,attrs:{begin:[y,0],size:[1,a]}}),k=mi({inputs:{real:b,imag:v},backend:n}),{real:I,imag:S}=nSe(k,t,n),N=zu(I,S);for(let T=0;T<a;T++){const A=AF(N,T);d[y*a+T]=A.real,p[y*a+T]=A.imag}n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(k)}const h=n.makeTensorInfo(u,"float32",d),m=n.makeTensorInfo(u,"float32",p),g=mi({inputs:{real:h,imag:m},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}function nSe(e,t,n){const r=Oe(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(rSe(r)){const o=cA(a,i,r,t,n),l=[e.shape[0],e.shape[1]];if(t){const u=n.makeTensorInfo(l,"float32",o.real),c=n.makeTensorInfo(l,"float32",o.imag),d=n.makeTensorInfo([],"float32",wd(r,"float32")),p=tu({inputs:{x:d},backend:n}),h=uA.kernelFunc({inputs:{a:u,b:d},backend:n}),m=uA.kernelFunc({inputs:{a:c,b:p},backend:n}),g=n.data.get(h.dataId).values,y=n.data.get(m.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),{real:g,imag:y}}return o}else{const o=zu(a,i),l=sSe(o,r,t);return AH(l)}}function rSe(e){return(e&e-1)===0}function cA(e,t,n,r,s){if(n===1)return{real:e,imag:t};const a=zu(e,t),i=n/2,o=RH(a),l=o.real,u=o.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),p=s.makeTensorInfo(c,"float32",u),h=mi({inputs:{real:d,imag:p},backend:s}),m=DH(a),g=m.real,y=m.imag,b=[g.length],v=s.makeTensorInfo(b,"float32",g),k=s.makeTensorInfo(b,"float32",y),I=mi({inputs:{real:v,imag:k},backend:s}),S=cA(l,u,i,r,s),N=S.real,T=S.imag,A=[N.length],R=s.makeTensorInfo(A,"float32",N),D=s.makeTensorInfo(A,"float32",T),$=mi({inputs:{real:R,imag:D},backend:s}),_=cA(g,y,i,r,s),L=_.real,z=_.imag,W=[L.length],G=s.makeTensorInfo(W,"float32",L),q=s.makeTensorInfo(W,"float32",z),B=mi({inputs:{real:G,imag:q},backend:s}),j=OH(n,r),H=[j.real.length],P=s.makeTensorInfo(H,"float32",j.real),X=s.makeTensorInfo(H,"float32",j.imag),Q=mi({inputs:{real:P,imag:X},backend:s}),re=MC({inputs:{a:Q,b:B},backend:s}),le=Rg({inputs:{a:$,b:re},backend:s}),ke=p3({inputs:{a:$,b:re},backend:s}),Ne=uh({inputs:{input:le},backend:s}),we=uh({inputs:{input:ke},backend:s}),_e=Dg({inputs:{input:le},backend:s}),Le=Dg({inputs:{input:ke},backend:s}),Be=Fg({inputs:[Ne,we],backend:s,attrs:{axis:0}}),Ze=Fg({inputs:[_e,Le],backend:s,attrs:{axis:0}}),ut=s.data.get(Be.dataId).values,ft=s.data.get(Ze.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(k),s.disposeIntermediateTensorInfo(I),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(X),s.disposeIntermediateTensorInfo(Q),s.disposeIntermediateTensorInfo(re),s.disposeIntermediateTensorInfo(le),s.disposeIntermediateTensorInfo(ke),s.disposeIntermediateTensorInfo(Ne),s.disposeIntermediateTensorInfo(_e),s.disposeIntermediateTensorInfo(we),s.disposeIntermediateTensorInfo(Le),s.disposeIntermediateTensorInfo(Be),s.disposeIntermediateTensorInfo(Ze),{real:ut,imag:ft}}function sSe(e,t,n){const r=new Float32Array(t*2);for(let s=0;s<t;s++){let a=0,i=0;for(let o=0;o<t;o++){const l=MH(s*o,t,n),u=AF(e,o);a+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}n&&(a/=t,i/=t),FH(r,a,i,s)}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aSe(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Oe(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=lr({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=x9(o,!1,n),u=lr({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}const iSe={kernelName:mD,backendName:"cpu",kernelFunc:aSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m3(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||ly(s),o=Mr(i,Oe(r));return lSe(o,s,i),t.makeTensorInfo(r,i,o)}const oSe={kernelName:gD,backendName:"cpu",kernelFunc:m3};function lSe(e,t,n){e.fill(t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uSe={kernelName:yD,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,s=n,a=sa(r.dtype,Oe(r.shape)),[i,o,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let p=0;p<i;p++){const h=p*l*o*u;for(let m=0;m<o;m++){const g=m*(l*u);for(let y=0;y<l;y++){const b=y*u;for(let v=0;v<u;v++){const k=Math.round(l-y-1),I=h+g+b+v;let S=c[I];if(k>=0&&k<l){const N=k*u,T=h+g+N+v;S=c[T]}a[I]=S}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cSe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=r;let g=g9({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p}});if(i){const y=g;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const b=lr({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});g=Rg({inputs:{a:g,b},backend:n}),n.disposeIntermediateTensorInfo(b)}else g=Rg({inputs:{a:g,b:i},backend:n});n.disposeIntermediateTensorInfo(y)}if(h){const y=g;if(c==="NCHW"&&h==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const b=lr({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});g=hI(n,g,h,b,m),n.disposeIntermediateTensorInfo(b)}else g=hI(n,g,h,o,m);n.disposeIntermediateTensorInfo(y)}return g}const dSe={kernelName:K2,backendName:"cpu",kernelFunc:cSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pSe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=r;let g=y9({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p}});if(i){const y=g;g=Rg({inputs:{a:g,b:i},backend:n}),n.disposeIntermediateTensorInfo(y)}if(h){const y=g;g=hI(n,g,h,o,m),n.disposeIntermediateTensorInfo(y)}return g}const hSe={kernelName:ij,backendName:"cpu",kernelFunc:pSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fSe(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=Oe(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,d]=fF(r,s);if(u===0)return n.makeTensorInfo(l,r.dtype,[]);const p=n.data.get(s.dataId).values,h=n.bufferSync(r),m=$q(p,h,r.dtype,u,o,c,d,r.shape,a);return n.makeTensorInfo(l,r.dtype,m.values)}const mSe={kernelName:V5,backendName:"cpu",kernelFunc:fSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gSe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;vt([s,a],"gatherV2");const l=un(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let I=0;I<u.length;++I){const S=u[I];Y(S<=c-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${c-1}]`)}let d=o;o==null&&(d=0);const p=Oe(a.shape),h=PF(s,a,l,d),m=lr({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),g=lr({inputs:{x:a},backend:n,attrs:{shape:[h.batchSize,p/h.batchSize]}}),y=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],b=n.bufferSync(g),v=n.bufferSync(m),k=Eq(v,b,y);return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(h.outputShape,k.dtype,k.values)}const ySe={kernelName:RS,backendName:"cpu",kernelFunc:gSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xSe(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Oe(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=lr({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=x9(o,!0,n),u=lr({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}const bSe={kernelName:xD,backendName:"cpu",kernelFunc:xSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vSe=jn(I0,e=>Number.isFinite(e)?1:0,"bool"),wSe={kernelName:I0,backendName:"cpu",kernelFunc:vSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kSe=jn(S0,e=>Math.abs(e)===1/0?1:0,"bool"),ISe={kernelName:S0,backendName:"cpu",kernelFunc:kSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SSe=jn(C0,e=>Number.isNaN(e)?1:0,"bool"),CSe={kernelName:C0,backendName:"cpu",kernelFunc:SSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NSe(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=Fq(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}const TSe={kernelName:U5,backendName:"cpu",kernelFunc:NSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Se=jn(T0,e=>Math.log1p(e)),ESe={kernelName:T0,backendName:"cpu",kernelFunc:$Se};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Se=Wr((e,t)=>e&&t),ASe=xs(LS,_Se,null,"bool"),RSe={kernelName:LS,backendName:"cpu",kernelFunc:ASe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DSe=jn(PS,e=>e?0:1,"bool"),FSe={kernelName:PS,backendName:"cpu",kernelFunc:DSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OSe=Wr((e,t)=>e||t),MSe=xs(zS,OSe,null,"bool"),LSe={kernelName:zS,backendName:"cpu",kernelFunc:MSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PSe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;vt(s,"LRN");const u=s.shape[3],c=u-1,d=n.data.get(s.dataId).values,p=Oe(s.shape),h=new Float32Array(p);function m(g){const y=g%u;let b=g-y+Math.max(0,y-a);const v=g-y+Math.min(y+a,c);let k=0;for(;b<=v;b++){const I=d[b];k+=I*I}return k}for(let g=0;g<p;g++){const y=m(g),b=d[g]*Math.pow(i+o*y,-l);h[g]=b}return n.makeTensorInfo(s.shape,s.dtype,h)}const zSe={kernelName:BS,backendName:"cpu",kernelFunc:PSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BSe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;vt(i,"LRNGrad");const d=Oe(i.shape),p=i.shape[3],h=n.data.get(i.dataId).values,m=n.data.get(s.dataId).values,g=n.data.get(a.dataId).values,y=new Float32Array(d),b=d;for(let v=0;v<b;v++){const k=v%p,I=v-k+Math.max(0,k-o),S=v-k+Math.min(p,k+o+1);let N=0;for(let T=I;T<S;T++)N+=Math.pow(m[T],2);N=u*N+l;for(let T=I;T<S;T++){let A=-2*u*c*m[T]*g[v]/N;v===T&&(A+=Math.pow(N,-c)),A*=h[v],y[T]+=A}}return n.makeTensorInfo(i.shape,s.dtype,y)}const WSe={kernelName:vD,backendName:"cpu",kernelFunc:BSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b9(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let l=s.shape;const u=l.length,c=un(a,l);let d=c;const p=_r(d,u);let h=o.data.get(s.dataId).values;if(p!=null){const I=new Array(u);for(let S=0;S<I.length;S++)I[S]=l[p[S]];h=c3(h,l,s.dtype,p,I),d=zr(d.length,u),l=I}vt(s,"max"),Ys("max",d,u);const[m,g]=Os(l,d),y=Oe(g),b=Mq(h,y,m,s.dtype),v=o.write(b,m,s.dtype);let k=m;return i&&(k=Jr(m,c)),{dataId:v,shape:k,dtype:s.dtype}}const VSe={kernelName:WS,backendName:"cpu",kernelFunc:b9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function USe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;vt(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Y(ua(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=So(s.shape,a,i,u,o,l);let d;if(c.filterWidth===1&&c.filterHeight===1&&Dn(c.inShape,c.outShape))d=tu({inputs:{x:s},backend:n});else{const p=n.data.get(s.dataId).values,h=_t(s.shape),m=h3(p,s.shape,s.dtype,h,c,"max");d=n.makeTensorInfo(c.outShape,s.dtype,m.values)}return d}const GSe={kernelName:VS,backendName:"cpu",kernelFunc:USe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jSe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;vt(s,"maxPool3d");const c=Hu(s.shape,a,i,1,o,l,u),d=n.data.get(s.dataId).values,p=m9(d,s.shape,s.dtype,_t(s.shape),c,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}const HSe={kernelName:US,backendName:"cpu",kernelFunc:jSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qSe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;vt([s,a],"maxPool3DGrad");const c=Hu(a.shape,i,o,1,l,u),d=n.bufferSync(a),p=O2e(d,c),h=c.strideDepth,m=c.strideHeight,g=c.strideWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,k=c.effectiveFilterDepth,I=c.effectiveFilterHeight,S=c.effectiveFilterWidth,N=k-1-c.padInfo.front,T=S-1-c.padInfo.left,A=I-1-c.padInfo.top,R=ln(a.shape,"float32"),D=n.bufferSync(s);for(let $=0;$<c.batchSize;++$)for(let _=0;_<c.inChannels;++_)for(let L=0;L<c.inDepth;++L)for(let z=0;z<c.inHeight;++z)for(let W=0;W<c.inWidth;++W){const G=L-N,q=z-A,B=W-T;let j=0;for(let H=0;H<k;H+=y){const P=(G+H)/h;if(!(P<0||P>=c.outDepth||Math.floor(P)!==P))for(let X=0;X<I;X+=b){const Q=(q+X)/m;if(!(Q<0||Q>=c.outHeight||Math.floor(Q)!==Q))for(let re=0;re<S;re+=v){const le=(B+re)/g;if(le<0||le>=c.outWidth||Math.floor(le)!==le)continue;const ke=k*I*S-1-p.get($,P,Q,le,_),Ne=H*I*S+X*S+re,we=ke===Ne?1:0;if(we===0)continue;const _e=D.get($,P,Q,le,_);j+=_e*we}}}R.set(j,$,L,z,W,_)}return n.makeTensorInfo(R.shape,R.dtype,R.values)}const KSe={kernelName:kD,backendName:"cpu",kernelFunc:qSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XSe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;vt([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,p=So(o.shape,l,u,1,c,d),h=n.data.get(o.dataId).values,m=ln(p.outShape,o.dtype,f9(h,o.shape,o.dtype,p).values),g=p.strideHeight,y=p.strideWidth,b=p.dilationHeight,v=p.dilationWidth,k=p.effectiveFilterHeight,I=p.effectiveFilterWidth,S=I-1-p.padInfo.left,N=k-1-p.padInfo.top,T=ln(o.shape,"float32"),A=n.data.get(s.dataId).values,R=ln(s.shape,"float32",A);for(let D=0;D<p.batchSize;++D)for(let $=0;$<p.inChannels;++$)for(let _=0;_<p.inHeight;++_)for(let L=0;L<p.inWidth;++L){const z=_-N,W=L-S;let G=0;for(let q=0;q<k;q+=b){const B=(z+q)/g;if(!(B<0||B>=p.outHeight||Math.floor(B)!==B))for(let j=0;j<I;j+=v){const H=(W+j)/y;if(H<0||H>=p.outWidth||Math.floor(H)!==H)continue;const P=k*I-1-m.get(D,B,H,$),X=q*I+j,Q=P===X?1:0;if(Q===0)continue;const re=R.get(D,B,H,$);G+=re*Q}}T.set(G,D,_,L,$)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}const YSe={kernelName:wD,backendName:"cpu",kernelFunc:XSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZSe(e,t,n,r,s){const a=_t(t),i=h3(e,t,n,a,s,"max"),o=f9(e,t,n,s,!0,r);return[i.values,o.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JSe={kernelName:G5,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;vt(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=So(r.shape,s,a,[1,1],i),[d,p]=ZSe(u,r.shape,r.dtype,o,c),h=l.write(d,c.outShape,r.dtype),m=l.write(p,c.outShape,r.dtype);return[{dataId:h,shape:c.outShape,dtype:r.dtype},{dataId:m,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QSe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=un(a,s.shape),u=Os(s.shape,o)[1],c=Oe(u),d=[],p=n.makeTensorInfo([],"float32",new Float32Array([c]));d.push(p);const h=td({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});d.push(h);const m=f3({inputs:{a:h,b:p},backend:n});d.push(m);const g=m1({inputs:{x:m},backend:n,attrs:{axis:a,keepDims:i}});return d.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const eCe={kernelName:GS,backendName:"cpu",kernelFunc:QSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tCe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;vt(s,"min");const o=un(a,s.shape);let l=o;const u=_r(l,s.shape.length);let c=s;u!=null&&(c=Ja({inputs:{x:s},backend:n,attrs:{perm:u}}),l=zr(l.length,s.shape.length)),Ys("min",l,c.shape.length);const[d,p]=Os(c.shape,l),h=Oe(p),m=aa(Oe(d),c.dtype),g=n.data.get(c.dataId).values;for(let b=0;b<m.length;++b){const v=b*h;let k=g[v];for(let I=0;I<h;++I){const S=g[v+I];(Number.isNaN(S)||S<k)&&(k=S)}m[b]=k}u!=null&&n.disposeIntermediateTensorInfo(c);const y=n.makeTensorInfo(d,c.dtype,m);if(i){const b=Jr(d,o),v=lr({inputs:{x:y},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(y),v}return y}const nCe={kernelName:jS,backendName:"cpu",kernelFunc:tCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rCe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;vt(s,"mirrorPad");const o=a.map((k,I)=>k[0]+s.shape[I]+k[1]),l=a.map(k=>k[0]),u=a.map((k,I)=>k[0]+s.shape[I]),c=i==="reflect"?0:1,d=n.data.get(s.dataId).values,p=s.shape.length,h=_t(s.shape),m=Oe(o),g=o.length,y=_t(o),b=sa(s.dtype,m);for(let k=0;k<m;k++){let I=uy(k,g,y);for(let N=0;N<g;N++)I[N]<l[N]?I[N]=l[N]*2-I[N]-c:I[N]>=u[N]&&(I[N]=(u[N]-1)*2-I[N]+c);I=I.map((N,T)=>N-l[T]);const S=Vl(I,p,h);b[k]=d[S]}return{dataId:n.write(b,o,s.dtype),shape:o,dtype:s.dtype}}const sCe={kernelName:HS,backendName:"cpu",kernelFunc:rCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aCe=Wr((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),iCe=xs(_0,aCe),oCe={kernelName:_0,backendName:"cpu",kernelFunc:iCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v9(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=un([o],s.shape),u=b9({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=Jr(u.shape,l),d=lr({inputs:{x:u},backend:n,attrs:{shape:c}}),p=p3({inputs:{a:s,b:d},backend:n}),h=Sq({inputs:{x:p},backend:n}),m=m1({inputs:{x:h},backend:n,attrs:{axis:l,keepDims:!1}}),g=lr({inputs:{x:m},backend:n,attrs:{shape:c}}),y=f3({inputs:{a:h,b:g},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}const lCe={kernelName:cC,backendName:"cpu",kernelFunc:v9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uCe(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;vt(s,"multinomial");const l=o?s:v9({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,p=[u,a],h=aa(Oe(p),"int32");for(let m=0;m<u;++m){const g=m*c,y=new Float32Array(c-1);y[0]=d[g];for(let k=1;k<y.length;++k)y[k]=y[k-1]+d[g+k];const b=eF.alea(i.toString()),v=m*a;for(let k=0;k<a;++k){const I=b();h[v+k]=y.length;for(let S=0;S<y.length;S++)if(I<y[S]){h[v+k]=S;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(p,"int32",h)}const cCe={kernelName:j5,backendName:"cpu",kernelFunc:uCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dCe=uF;function pCe(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;vt(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d}=dCe(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const hCe={kernelName:ID,backendName:"cpu",kernelFunc:pCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fCe=cF;function mCe(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;vt(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:p,validOutputs:h}=fCe(c,d,i,o,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}const gCe={kernelName:SD,backendName:"cpu",kernelFunc:mCe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yCe=dF;function xCe(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;vt(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,p=i,h=o,m=l,g=u,{selectedIndices:y,selectedScores:b}=yCe(c,d,p,h,m,g);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const bCe={kernelName:CD,backendName:"cpu",kernelFunc:xCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vCe(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r;vt(s,"oneHot");const u=Oe(s.shape),c=new Float32Array(u*i);c.fill(l);const d=n.data.get(s.dataId).values;for(let p=0;p<u;++p)d[p]>=0&&d[p]<i&&(c[p*i+d[p]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}const wCe={kernelName:YS,backendName:"cpu",kernelFunc:vCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mI(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const s=uh({inputs:{input:r},backend:n}),a=mI({inputs:{x:s},backend:n}),i=Dg({inputs:{input:r},backend:n}),o=mI({inputs:{x:i},backend:n}),l=mi({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return m3({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const kCe={kernelName:hC,backendName:"cpu",kernelFunc:mI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w9(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const s=uh({inputs:{input:r},backend:n}),a=w9({inputs:{x:s},backend:n}),i=Dg({inputs:{input:r},backend:n}),o=mI({inputs:{x:i},backend:n}),l=mi({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return m3({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const ICe={kernelName:XS,backendName:"cpu",kernelFunc:w9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k9(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return fI({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(c=>{jR(a,c.shape,"All tensors passed to stack must have matching shapes"),Y(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=t.map(c=>{const d=fI({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=Fg({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const SCe={kernelName:ZS,backendName:"cpu",kernelFunc:k9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CCe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;vt(s,"pad");const o=a.map((v,k)=>v[0]+s.shape[k]+v[1]),l=a.map(v=>v[0]),u=n.data.get(s.dataId).values,c=Oe(s.shape),d=s.shape.length,p=_t(s.shape),h=Oe(o),m=o.length,g=_t(o),y=sa(s.dtype,h);i!==0&&y.fill(i);for(let v=0;v<c;v++){const I=uy(v,d,p).map((N,T)=>N+l[T]),S=Vl(I,m,g);y[S]=u[v]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}const I9={kernelName:JS,backendName:"cpu",kernelFunc:CCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NCe=Wr((e,t)=>Math.pow(e,t)),TCe=xs(R0,NCe),$Ce={kernelName:R0,backendName:"cpu",kernelFunc:TCe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ECe(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map(b=>n.data.get(b.dataId).values),u=s.map(b=>b.shape),c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,[p,h,m]=Vq(l,u,c,a.shape,a.dtype,d,i.shape),g=p.map(b=>n.makeTensorInfo([b.length],"int32",b)),y=n.makeTensorInfo(m,a.dtype,h);return g.concat([y])}const _Ce={kernelName:H5,backendName:"cpu",kernelFunc:ECe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ACe(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=Uq(i,r.shape,r.dtype,o,s.shape,l,a.shape),d=n.makeTensorInfo([u.length],"int32",u),p=n.makeTensorInfo([c.length],r.dtype,c);return[d,p]}const RCe={kernelName:q5,backendName:"cpu",kernelFunc:ACe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DCe(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,p=o.map(y=>n.data.get(y.dataId).values),h=o.map(y=>y.shape),[m,g]=Gq(u,s.shape,c,a.shape,a.dtype,d,i.shape,p,h,l);return n.makeTensorInfo(m,a.dtype,g)}const FCe={kernelName:K5,backendName:"cpu",kernelFunc:DCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OCe(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=jq(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}const MCe={kernelName:ND,backendName:"cpu",kernelFunc:OCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LCe=jn(D0,e=>1/e),PCe={kernelName:D0,backendName:"cpu",kernelFunc:LCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zCe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;vt(s,"resizeBilinear");const l=_t(s.shape),[u,c]=o,[d,p,h,m]=s.shape,g=n.data.get(s.dataId).values,y=new Float32Array(Oe([d,u,c,m])),b=[a&&u>1?p-1:p,a&&c>1?h-1:h],v=[a&&u>1?u-1:u,a&&c>1?c-1:c];let k=0;const I=b[0]/v[0],S=b[1]/v[1];for(let N=0;N<d;N++)for(let T=0;T<u;T++){let A;i?A=I*(T+.5)-.5:A=I*T;const R=Math.max(0,Math.floor(A)),D=A-R,$=Math.min(p-1,Math.ceil(A)),_=N*l[0]+R*l[1],L=N*l[0]+$*l[1];for(let z=0;z<c;z++){let W;i?W=S*(z+.5)-.5:W=S*z;const G=Math.max(0,Math.floor(W)),q=W-G,B=Math.min(h-1,Math.ceil(W)),j=_+G*l[2],H=L+G*l[2],P=_+B*l[2],X=L+B*l[2];for(let Q=0;Q<m;Q++){const re=g[j+Q],le=g[H+Q],ke=g[P+Q],Ne=g[X+Q],we=re+(ke-re)*q,_e=le+(Ne-le)*q,Le=we+(_e-we)*D;y[k++]=Le}}}return n.makeTensorInfo([d,u,c,m],"float32",y)}const BCe={kernelName:rC,backendName:"cpu",kernelFunc:zCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WCe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;vt([a,s],"resizeBilinearGrad");const o=_t(s.shape),[l,u,c,d]=s.shape,[,p,h]=a.shape,m=new Float32Array(l*u*c*d),g=[i&&p>1?u-1:u,i&&h>1?c-1:c],y=[i&&p>1?p-1:p,i&&h>1?h-1:h],b=g[0]/y[0],v=g[1]/y[1],k=n.data.get(a.dataId).values;let I=0;for(let S=0;S<l;S++){const N=S*o[0];for(let T=0;T<p;T++){const A=T*b,R=Math.floor(A),D=Math.min(Math.ceil(A),u-1),$=N+R*o[1],_=N+D*o[1],L=A-R,z=1-L;for(let W=0;W<h;W++){const G=W*v,q=Math.floor(G),B=Math.min(Math.ceil(G),c-1),j=G-q,H=1-j,P=$+q*o[2],X=$+B*o[2],Q=_+q*o[2],re=_+B*o[2],le=z*H,ke=z*j,Ne=L*H,we=L*j;for(let _e=0;_e<d;_e++){const Le=k[I++];m[P+_e]+=Le*le,m[X+_e]+=Le*ke,m[Q+_e]+=Le*Ne,m[re+_e]+=Le*we}}}}return n.makeTensorInfo([l,c,u,d],"float32",m)}const VCe={kernelName:ED,backendName:"cpu",kernelFunc:WCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UCe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;vt(s,"resizeNearestNeighbor");const l=_t(s.shape),[u,c]=o,[d,p,h,m]=s.shape,g=n.data.get(s.dataId).values,y=new Float32Array(d*u*c*m),b=[a&&u>1?p-1:p,a&&c>1?h-1:h],v=[a&&u>1?u-1:u,a&&c>1?c-1:c],k=b[0]/v[0],I=b[1]/v[1];let S=0;for(let N=0;N<d;N++){const T=N*l[0];for(let A=0;A<u;A++){const R=i?k*(A+.5):k*A;let D=Math.min(p-1,a?Math.round(R):Math.floor(R));i&&(D=Math.max(0,D));const $=T+D*l[1];for(let _=0;_<c;_++){const L=i?I*(_+.5):I*_;let z=Math.min(h-1,a?Math.round(L):Math.floor(L));i&&(z=Math.max(0,z));const W=$+z*l[2];for(let G=0;G<m;G++){const q=g[W+G];y[S++]=q}}}}return n.makeTensorInfo([d,u,c,m],s.dtype,y)}const GCe={kernelName:nC,backendName:"cpu",kernelFunc:UCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jCe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;vt([a,s],"resizeNearestNeighborGrad");const o=_t(s.shape),l=_t(a.shape),[u,c,d,p]=s.shape,[,h,m]=a.shape,g=new Float32Array(u*c*d*p),y=n.data.get(a.dataId).values,b=[i&&h>1?c-1:c,i&&m>1?d-1:d],v=[i&&h>1?h-1:h,i&&m>1?m-1:m],k=b[0]/v[0],I=b[1]/v[1],S=1/k,N=1/I,T=Math.ceil(S)*2+2,A=Math.ceil(N)*2+2;for(let R=0;R<u;R++){const D=R*o[0];for(let $=0;$<c;$++){const _=D+$*o[1],L=Math.floor($*S),z=Math.floor(L-T/2);for(let W=0;W<d;W++){const G=_+W*o[2],q=Math.floor(W*N),B=Math.floor(q-A/2);for(let j=0;j<p;j++){let H=0;for(let P=0;P<T;P++){const X=P+z;if(X<0||X>=h)continue;const Q=D+X*l[1],re=X*k,le=Math.min(c-1,i?Math.round(re):Math.floor(re));if($===le)for(let ke=0;ke<A;ke++){const Ne=ke+B;if(Ne<0||Ne>=m)continue;const we=Q+Ne*l[2],_e=Ne*I,Le=Math.min(d-1,i?Math.round(_e):Math.floor(_e));W===Le&&(H+=y[we+j])}}g[G+j]=H}}}}return n.makeTensorInfo(s.shape,s.dtype,g)}const HCe={kernelName:$D,backendName:"cpu",kernelFunc:jCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qCe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;vt(s,"reverse");const i=s.shape.length,o=un(a,s.shape);if(i===0)return tu({inputs:{x:s},backend:n});const l=new Ks(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),p=d.slice();o.forEach(h=>p[h]=s.shape[h]-1-p[h]),l.set(u.get(...p),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}const KCe={kernelName:sC,backendName:"cpu",kernelFunc:qCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XCe={kernelName:MD,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=sa(r.dtype,Oe(r.shape)),[u,c,d,p]=r.shape,[h,m]=kF(i,c,d),g=255,y=Math.sin(s),b=Math.cos(s),v=o.data.get(r.dataId).values;for(let I=0;I<u;I++){const S=I*d*c*p;for(let N=0;N<c;N++){const T=N*(d*p);for(let A=0;A<d;A++){const R=A*p;for(let D=0;D<p;D++){const $=[u,N,A,D],_=$[2],L=$[1];let z=(_-h)*b-(L-m)*y,W=(_-h)*y+(L-m)*b;z=Math.round(z+h),W=Math.round(W+m);let G=a;if(typeof a!="number"&&(D===3?G=g:G=a[D]),z>=0&&z<d&&W>=0&&W<c){const B=W*(d*p),j=z*p,H=S+B+j+D;G=v[H]}const q=S+T+R+D;l[q]=G}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YCe=jn(M0,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),ZCe={kernelName:M0,backendName:"cpu",kernelFunc:YCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JCe(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Mh(a,s,i),p=!0,h=n.bufferSync(s),m=n.bufferSync(a),g=Fp(h,m,i,d,u,l,o,c,0,p);return n.makeTensorInfo(i,g.dtype,g.values)}const QCe={kernelName:X5,backendName:"cpu",kernelFunc:JCe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eNe(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function tNe(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}function nNe(e,t,n,r,s,a){const i=Mr("int32",n*s);for(let o=0;o<n;++o){const l=e.slice(o*r,(o+1)*r),u=o*s;for(let c=0;c<s;++c)i[u+c]=a==="left"?eNe(l,t[c+u]):tNe(l,t[c+u])}return i}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rNe(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=nNe(o,l,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",u)}const sNe={kernelName:Z5,backendName:"cpu",kernelFunc:rNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aNe(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;vt([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=ki(s.dtype,a.dtype),d=aa(Oe(s.shape),c);let p=0;const h=i===0||i>1||s.shape.length===1?1:Oe(s.shape.slice(1));for(let m=0;m<o.length;m++)for(let g=0;g<h;g++)o[m]===1?d[p++]=l[m]:d[p++]=u[m];return n.makeTensorInfo(s.shape,c,d)}const iNe={kernelName:aC,backendName:"cpu",kernelFunc:aNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oNe=IC,lNe=SC,uNe=jn(P0,e=>e>=0?lNe*e:oNe*(Math.exp(e)-1)),cNe={kernelName:P0,backendName:"cpu",kernelFunc:uNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dNe=jn(W0,e=>e<0?-1:e>0?1:0),pNe={kernelName:W0,backendName:"cpu",kernelFunc:dNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hNe=jn(z0,e=>Math.sin(e)),fNe={kernelName:z0,backendName:"cpu",kernelFunc:hNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mNe=jn(B0,e=>Math.sinh(e)),gNe={kernelName:B0,backendName:"cpu",kernelFunc:mNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yNe=11920928955078125e-23,OV=Math.log(yNe)+2,xNe=jn(U0,e=>{const t=e>-OV,n=e<OV,r=Math.exp(e);let s;return n?s=r:t?s=e:s=Math.log(1+r),s}),bNe={kernelName:U0,backendName:"cpu",kernelFunc:xNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;vt([s],"spaceToBatchND");const o=Oe(a),l=[[0,0]];l.push(...i);for(let N=1+a.length;N<s.shape.length;++N)l.push([0,0]);const u=I9.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=s1(u.shape,a,o,!1),d=a1(c.length,a.length,!1),p=i1(u.shape,a,o,!1),g=lr({inputs:{x:u},backend:n,attrs:{shape:c}}),v=Ja({inputs:{x:g},backend:n,attrs:{perm:d}}),S=lr({inputs:{x:v},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(v),S}const wNe={kernelName:lC,backendName:"cpu",kernelFunc:vNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kNe(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[d,p,h,m,g]=Xq(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(p,r.dtype,d),n.makeTensorInfo([p[0]],s.dtype,h),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(y=>Number(y)))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}const INe={kernelName:J5,backendName:"cpu",kernelFunc:kNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SNe(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,d]=Yq(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const CNe={kernelName:Q5,backendName:"cpu",kernelFunc:SNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NNe(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=d3(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}const TNe={kernelName:ej,backendName:"cpu",kernelFunc:NNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ne(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=d3(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}const ENe={kernelName:tj,backendName:"cpu",kernelFunc:$Ne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ne(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=Mh(a,s,o),h=!1,m=n.bufferSync(s);let g;switch(a.dtype){case"bool":{const y=n.bufferSync(a),b=!!n.data.get(i.dataId).values[0];g=Fp(m,y,o,p,c,u,l,d,b,h);break}case"float32":{const y=n.bufferSync(a),b=n.data.get(i.dataId).values[0];g=Fp(m,y,o,p,c,u,l,d,b,h);break}case"int32":{const y=n.bufferSync(a),b=n.data.get(i.dataId).values[0];g=Fp(m,y,o,p,c,u,l,d,b,h);break}case"string":{const y=n.bufferSync(a),b=Yc(n.data.get(i.dataId).values[0]);g=Fp(m,y,o,p,c,u,l,d,b,h);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,g.dtype,g.values)}const ANe={kernelName:nj,backendName:"cpu",kernelFunc:_Ne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=un(i,s.shape)[0],l=LF(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{const p=[...c];p[o]=d;const h=ch({inputs:{x:s},backend:n,attrs:{begin:u,size:p}});return u[o]+=d,h})}const DNe={kernelName:uC,backendName:"cpu",kernelFunc:RNe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FNe={kernelName:_D,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;vt(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let o=0;o<s.length;++o){const l=s[o];a[o]=l*l}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ONe=jn(Y0,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),MNe={kernelName:Y0,backendName:"cpu",kernelFunc:ONe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=r;vt(s,"stridedSlice");const{finalShapeSparse:h,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:k,strides:I}=bF(s.shape,a,i,o,l,u,c,d,p);let S;if(g)S=lr({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){Y(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const N=gF(v,k,I),T=ch({inputs:{x:s},backend:n,attrs:{begin:v,size:N}});S=lr({inputs:{x:T},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(T)}else{const N=n.bufferSync(s),T=Qq(h,N,I,v);S=n.makeTensorInfo(m,T.dtype,T.values)}return S}const PNe={kernelName:RD,backendName:"cpu",kernelFunc:LNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zNe(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,p=n.data.get(c.dataId).values,h=n.data.get(d.dataId).values,[m,g]=e9(p,h,s,a,i,o,l,u);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(d.shape,"int32",g)]}const BNe={kernelName:rj,backendName:"cpu",kernelFunc:zNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WNe(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=t9(o,l,s),p=c.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const VNe={kernelName:sj,backendName:"cpu",kernelFunc:WNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UNe(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.data.get(a.dataId).values,o=n9(i,s);return n.makeTensorInfo(a.shape,"int32",o)}const GNe={kernelName:aj,backendName:"cpu",kernelFunc:UNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jNe=jn(q0,e=>Math.tan(e)),HNe={kernelName:q0,backendName:"cpu",kernelFunc:jNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qNe=jn(K0,e=>Math.tanh(e)),KNe={kernelName:K0,backendName:"cpu",kernelFunc:qNe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XNe(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=Mh(a,s,r.shape),d=!1,p=n.bufferSync(s),h=n.bufferSync(a),m=n.bufferSync(r),g=Fp(p,h,r.shape,c,l,o,i,u,m,d);return n.makeTensorInfo(r.shape,g.dtype,g.values)}const YNe={kernelName:Y5,backendName:"cpu",kernelFunc:XNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;vt(s,"tile");const i=s9(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const JNe={kernelName:X0,backendName:"cpu",kernelFunc:ZNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;vt(s,"topk");const o=n.data.get(s.dataId).values,[l,u]=i9(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}const eTe={kernelName:DD,backendName:"cpu",kernelFunc:QNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tTe(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,p,h]=s.shape,[m,g]=u??[d,p],y=[c,m,g,h],b=_t(s.shape),v=b[0],k=b[1],I=b[2],S=_t(y),N=S[0],T=S[1],A=S[2],R=sa(s.dtype,Oe(y));R.fill(l);const D=r.data.get(s.dataId).values,$=r.data.get(a.dataId).values;for(let L=0;L<c;++L){const z=a.shape[0]===1?$:$.subarray(L*8,L*8+8);for(let W=0;W<m;++W)for(let G=0;G<g;++G)for(let q=0;q<h;++q){let B;const j=z[6]*G+z[7]*W+1;if(j===0)continue;const H=(z[0]*G+z[1]*W+z[2])/j,P=(z[3]*G+z[4]*W+z[5])/j,X=MV(H,p,o),Q=MV(P,d,o);switch(i){case"nearest":B=oTe(D,d,p,v,k,I,L,Q,X,q,l);break;case"bilinear":B=lTe(D,d,p,v,k,I,L,Q,X,q,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const re=L*N+W*T+G*A+q;R[re]=B}return r.makeTensorInfo(y,s.dtype,R)}return{dataId:r.write(R,y,s.dtype),shape:s.shape,dtype:s.dtype}}const nTe={kernelName:FD,backendName:"cpu",kernelFunc:tTe};function MV(e,t,n){switch(n){case"reflect":return rTe(e,t);case"wrap":return sTe(e,t);case"nearest":return iTe(e,t);case"constant":default:return aTe(e)}}function rTe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{const r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return Jp(0,n,t-1)}function sTe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{const r=t-1;n-=t*Math.trunc(n/r)}return Jp(0,n,t-1)}function aTe(e,t){return e}function iTe(e,t){return Jp(0,e,t-1)}function Gb(e,t,n,r,s,a,i,o,l,u,c){const d=i*r+o*s+l*a+u;return 0<=o&&o<t&&0<=l&&l<n?e[d]:c}function oTe(e,t,n,r,s,a,i,o,l,u,c){const d=Math.round(o),p=Math.round(l);return Gb(e,t,n,r,s,a,i,d,p,u,c)}function lTe(e,t,n,r,s,a,i,o,l,u,c){const d=Math.floor(o),p=Math.floor(l),h=d+1,m=p+1,g=(m-l)*Gb(e,t,n,r,s,a,i,d,p,u,c)+(l-p)*Gb(e,t,n,r,s,a,i,d,m,u,c),y=(m-l)*Gb(e,t,n,r,s,a,i,h,p,u,c)+(l-p)*Gb(e,t,n,r,s,a,i,h,m,u,c);return(h-o)*g+(o-d)*y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uTe(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;vt(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=o9(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}const cTe={kernelName:OD,backendName:"cpu",kernelFunc:uTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dTe(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],l=new Array(i-1);let u=0;for(let h=0;h<i;h++)h!==a&&(l[u++]=s.shape[h]);const c=new Array(i).fill(0),d=s.shape.slice();d[a]=1;const p=new Array(o);for(let h=0;h<p.length;h++){c[a]=h;const m=ch({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});p[h]=lr({inputs:{x:m},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(m)}return p}const pTe={kernelName:dC,backendName:"cpu",kernelFunc:dTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hTe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;vt(s,"unsortedSegmentSum");const o=s.shape.length,l=a.shape.length,u=[],c=[],d=o-l;let p=a;for(let m=0;m<d;++m){const g=fI({inputs:{input:p},backend:n,attrs:{dim:m+1}});p=g,c.push(g)}for(let m=0;m<i;++m){const g=wd(m,"int32"),y=n.makeTensorInfo([],"int32",g),b=kq({inputs:{a:y,b:p},backend:n}),v=td({inputs:{x:b},backend:n,attrs:{dtype:"float32"}}),k=MC({inputs:{a:v,b:s},backend:n}),I=m1({inputs:{x:k},backend:n,attrs:{axis:0,keepDims:!1}});u.push(I),c.push(y),c.push(b),c.push(v),c.push(k),c.push(I)}const h=k9({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),h}const fTe={kernelName:pC,backendName:"cpu",kernelFunc:hTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mTe=[u2e,Uwe,d2e,h2e,Xwe,m2e,y2e,b2e,w2e,I2e,C2e,T2e,E2e,R2e,F2e,L2e,z2e,W2e,U2e,o2e,j2e,q2e,X2e,Zwe,Z2e,qwe,Qwe,Q2e,Gwe,tIe,rIe,sIe,iIe,lIe,cIe,pIe,fIe,gIe,xIe,vIe,kIe,SIe,NIe,$Ie,EIe,AIe,DIe,OIe,MIe,LIe,PIe,BIe,UIe,e2e,jIe,eke,QIe,tke,eSe,rke,iSe,oSe,uSe,ake,oke,dSe,hSe,mSe,ySe,uke,dke,jwe,bSe,nIe,wSe,ISe,CSe,t2e,hke,mke,TSe,yke,ESe,RSe,FSe,LSe,zSe,WSe,VSe,bke,GSe,HSe,KSe,YSe,JSe,eCe,nCe,wke,sCe,oCe,cCe,Ike,Cke,hCe,gCe,bCe,Tke,wCe,ICe,SCe,I9,$Ce,r2e,_ke,_Ce,RCe,FCe,MCe,Hwe,uA,PCe,s2e,a2e,i2e,BCe,VCe,GCe,HCe,KCe,XCe,ZCe,Pke,QCe,sNe,iNe,cNe,Bke,pNe,fNe,gNe,Wke,lCe,bNe,wNe,INe,CNe,TNe,ENe,ANe,DNe,Gke,FNe,Hke,Kke,MNe,PNe,BNe,VNe,GNe,Jke,WIe,HNe,KNe,YNe,JNe,eTe,nTe,$ke,cTe,pTe,fTe,kCe];for(const e of mTe)oj(e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Np={},Bk={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function gTe(e,t){Np[e]=t}function il(e,t){if(!(e in Np)||t!=null){const r=xTe(e,t);if(r!==null)Np[e]=r;else return console.log("Could not get context for WebGL version",e),null}const n=Np[e];return n==null||n.isContextLost()?(delete Np[e],il(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Np[e])}function yTe(e){if(!$e().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function xTe(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=t??yTe(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Np[e]},!1),$e().getBool("SOFTWARE_WEBGL_ENABLED")&&(Bk.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",Bk)||n.getContext("experimental-webgl",Bk):n.getContext("webgl2",Bk)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Iv;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(Iv||(Iv={}));var zi;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(zi||(zi={}));var Gs;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Gs||(Gs={}));function g1(e,t){return[t,e]}function bTe(e,t){return e*t}function Wk(e){const t=Oe(e),n=Math.ceil(t/4);return __(n)}function xy(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function vTe(e,t){const[n,r]=xy(e,t);return n*r*4}function g3(e,t){const n=e;let r,s,a,i,o,l,u,c,d,p;return $e().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,p=n.FLOAT,l=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=t!=null?t.HALF_FLOAT_OES:null,p=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ct(e,t){const n=t();return $e().getBool("DEBUG")&&wTe(e),n}function wTe(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+CTe(e,t))}const kTe=596e-10,ITe=65504;function STe(e){return!!($e().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||kTe<Math.abs(e)&&Math.abs(e)<ITe)}function CTe(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Vk(e,t){return Ku(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function NTe(e,t){const n=Ku(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ct(e,()=>e.shaderSource(n,t)),ct(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function TTe(e,t){const n=Ku(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ct(e,()=>e.shaderSource(n,t)),ct(e,()=>e.compileShader(n)),$e().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw S9(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const $Te=/ERROR: [0-9]+:([0-9]+):/g;function S9(e,t){const n=$Te.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}const r=+n[1],s=e.split(`
`),a=s.length.toString().length+2,i=s.map((d,p)=>hg((p+1).toString(),a)+d);let o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${hg(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function ETe(e){return Ku(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function _Te(e,t){if(ct(e,()=>e.linkProgram(t)),!$e().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function _E(e,t){if(ct(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function ATe(e,t){const n=Ku(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ct(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),ct(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function RTe(e,t){const n=Ku(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ct(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),ct(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function DTe(e){return Ku(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function FTe(e,t){const n=$e().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){const r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function OTe(e){return Ku(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function LV(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return o===-1?!1:(ct(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),ct(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i)),ct(e,()=>e.enableVertexAttribArray(o)),!0)}function MTe(e,t,n){WTe(e,n),ct(e,()=>e.activeTexture(e.TEXTURE0+n)),ct(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function LTe(e,t,n){return Ku(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function PTe(e,t,n){return e.getUniformLocation(t,n)}function zTe(e,t,n,r){ct(e,()=>MTe(e,t,r)),ct(e,()=>e.uniform1i(n,r))}function AE(e,t,n){ct(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),ct(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function PV(e,t){ct(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),ct(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Uk(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+BTe(e,t))}function BTe(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Ku(e,t,n){const r=ct(e,()=>t());if(r==null)throw new Error(n);return r}function WTe(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){const s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Og(e,t=2){return Oe(e.slice(0,e.length-t))}function Mg(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Gk(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Og(e),...Mg(e)]),t}function VTe(e,t=!1){let n=$e().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=$e().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&$e().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,l)=>l>=e.length-2?GR(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=vd(e).newShape);let s=Oe(e),a=null;e.length<=1&&s<=n?a=[1,s]:e.length===2&&e[0]<=n&&e[1]<=n?a=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=a!=null&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(a==null||i)if(t){const o=Og(e);let l=2,u=2;e.length&&([l,u]=Mg(e)),s=o*(l/2)*(u/2),a=__(s).map(c=>c*2)}else a=__(s);return a}function jk(e){return e%2===0}function gI(e,t){if(e=e.slice(-2),t=t.slice(-2),Dn(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r||jk(n)&&jk(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&jk(e[0])&&jk(t[0])}let RE,DE;function UTe(e){if(RE==null){const t=il(e);RE=t.getParameter(t.MAX_TEXTURE_SIZE)}return RE}function GTe(e){if(DE==null){const t=il(e);DE=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,DE)}function jTe(e){if(e===0)return 0;let t;const n=il(e);return bo(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:bo(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function bo(e,t){return e.getExtension(t)!=null}function zV(e){try{if(il(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function HTe(e){if(e===0)return!1;const t=il(e);if(e===1){if(!bo(t,"OES_texture_float"))return!1}else if(!bo(t,"EXT_color_buffer_float"))return!1;return dA(t)}function qTe(e){if(e===0)return!1;const t=il(e);if(e===1){if(!bo(t,"OES_texture_float")||!bo(t,"WEBGL_color_buffer_float"))return!1}else{if(bo(t,"EXT_color_buffer_float"))return dA(t);const r="EXT_color_buffer_half_float";if(bo(t,r)){const s=t.getExtension(r);return KTe(t,s)}return!1}return dA(t)}function dA(e){const t=g3(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),i}function KTe(e,t){const n=g3(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}function XTe(e){return e!==2?!1:il(e).fenceSync!=null}function y1(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&Y(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const It=$e();It.registerFlag("HAS_WEBGL",()=>It.getNumber("WEBGL_VERSION")>0);It.registerFlag("WEBGL_VERSION",()=>zV(2)?2:zV(1)?1:0);It.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);It.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>It.get("WEBGL_VERSION")===2);It.registerFlag("WEBGL_CPU_FORWARD",()=>!0);It.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);It.registerFlag("WEBGL_PACK",()=>It.getBool("HAS_WEBGL"));It.registerFlag("WEBGL_PACK_NORMALIZATION",()=>It.getBool("WEBGL_PACK"));It.registerFlag("WEBGL_PACK_CLIP",()=>It.getBool("WEBGL_PACK"));It.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>It.getBool("WEBGL_PACK"));It.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>It.getBool("WEBGL_PACK"));It.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>It.getBool("WEBGL_PACK"));It.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>It.getBool("WEBGL_PACK"));It.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>It.getBool("WEBGL_PACK"));It.registerFlag("WEBGL_PACK_REDUCE",()=>It.getBool("WEBGL_PACK"));It.registerFlag("WEBGL_LAZILY_UNPACK",()=>It.getBool("WEBGL_PACK"));It.registerFlag("WEBGL_CONV_IM2COL",()=>It.getBool("WEBGL_PACK"));It.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>It.getBool("WEBGL_PACK"));It.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>UTe(It.getNumber("WEBGL_VERSION")));It.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>GTe(It.getNumber("WEBGL_VERSION")));It.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=It.getNumber("WEBGL_VERSION");return e===0?0:jTe(e)});It.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>It.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!vj());It.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>HTe(It.getNumber("WEBGL_VERSION")));It.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>It.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:It.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));It.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>qTe(It.getNumber("WEBGL_VERSION")));It.registerFlag("WEBGL_FENCE_API_ENABLED",()=>XTe(It.getNumber("WEBGL_VERSION")));It.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>It.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);It.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});It.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>vj()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});It.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);It.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);It.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);It.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);It.registerFlag("WEBGL_EXP_CONV",()=>!1);It.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>It.getBool("IS_TEST"));It.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);It.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);It.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);It.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Da(){let e,t,n,r,s,a,i,o,l,u;return $e().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=$e().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zh(e,t,n="index"){const r=_t(t);return r.map((s,a)=>{const i=`int ${e[a]} = ${n} / ${s}`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${s}`:`index -= ${e[a]} * ${s}`;return`${i}; ${o};`}).join("")}function LC(e,t,n="index"){const r=_t(t);return r.map((s,a)=>{const i=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${i}; ${o};`}).join("")}function YTe(e,t){const n=e.length,r=e.map(a=>`${t}[${a}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function ZTe(e,t,n="index"){const r=e.map((a,i)=>i),s=YTe(r,t);return s.map((a,i)=>{const o=`int ${e[i]} = ${n} / ${s[i]}`,l=i===s.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${s[i]}`:`index -= ${e[i]} * ${s[i]}`;return`${o}; ${l};`}).join("")}function y3(e){const t=_t(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function x3(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const C9=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:N9}=Wbe;function JTe(e,t,n){const r=[];if(e.forEach(h=>{const m=Oe(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?r.push(`uniform float ${h.name}${m>1?`[${m}]`:""};`):(r.push(`uniform sampler2D ${h.name};`),r.push(`uniform int offset${h.name};`)),n.enableShapeUniforms){const{uniformShape:g}=b3(n.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${h.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${h.name}Shape;`);break}r.push(`uniform ivec2 ${h.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(h=>{r.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});const s=r.join(`
`),a=e.map(h=>QTe(h,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=Da(),l=n$e(o);let u,c,d=a$e(o);return t.isPacked?(u=e$e(t.logicalShape,i,n.enableShapeUniforms),c=s$e(o)):(u=t$e(t.logicalShape,i,n.enableShapeUniforms),c=r$e(o)),n.packedInputs&&(d+=u$e),[d,l,c,s,u,a,n.userCode].join(`
`)}function by(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return w$e(e,t);case 1:return I$e(e,t);case 2:return C$e(e,t);case 3:return T$e(e,t);case 4:return E$e(e,t);case 5:return _$e(e);case 6:return A$e(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function T9(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return v$e(e);case 1:return k$e(e,t);case 2:return S$e(e,t);case 3:return N$e(e,t);default:return $$e(e,t)}}function QTe(e,t,n=!1,r){let s="";n?s+=T9(e,r):s+=by(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;return a.length<=i.length&&(n?s+=R$e(e,t):s+=D$e(e,t)),s}function e$e(e,t,n){switch(e.length){case 0:return $9();case 1:return c$e(e,t,n);case 2:return x$e(e,t,n);case 3:return p$e(e,t,n);default:return f$e(e,t,n)}}function t$e(e,t,n){switch(e.length){case 0:return $9();case 1:return d$e(e,t,n);case 2:return b$e(e,t,n);case 3:return h$e(e,t,n);case 4:return m$e(e,t,n);case 5:return g$e(e,t);case 6:return y$e(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function n$e(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function r$e(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function s$e(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function a$e(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${i$e}
    ${o$e}
    ${l$e}
  `}const i$e=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,o$e=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,l$e=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,u$e=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function $9(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function c$e(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function d$e(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function p$e(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function h$e(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${LC(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;const r=zh(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function f$e(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+o,l=`b${u}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${e.length}(${l});
    }
  `}function m$e(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${LC(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;const r=zh(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function g$e(e,t){const n=zh(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function y$e(e,t){const n=zh(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function x$e(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Dn(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function b$e(e,t,n){return Dn(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Bh(e){return`offset${e}`}function v$e(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Da();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function w$e(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(s===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=Bh(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[o,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function k$e(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=Da();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function I$e(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${vy(e)}
      }
    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(i===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=Bh(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function S$e(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],l=Da();if(a!=null&&Dn(n,a))return t?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function C$e(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(a!=null&&Dn(n,a)){if(t)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const p=a[0],h=a[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:i,keptDims:o}=vd(n),l=i;if(l.length<n.length){const p=wy(e,l),h=["row","col"];return`
      ${by(p,t)}
      float ${s}(int row, int col) {
        return ${s}(${ky(h,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${vy(e)}
      }
    `;const u=a[0],c=a[1],d=Bh(r);return c===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function N$e(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){const p=n.slice(1),h=[1,2],m=wy(e,p),g=["b","row","col"];return`
        ${T9(m,t)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${ky(g,h)});
        }
      `}const o=Da();if(t)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${d}, ${c}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function T$e(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=vd(n),u=o;if(u.length<n.length){const g=wy(e,u),y=["row","col","depth"];return`
        ${by(g,t)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${ky(y,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${i}, 1)));
        ${vy(e)}
      }
    `;const c=e.shapeInfo.texShape,d=c[0],p=c[1],h=e.shapeInfo.flatOffset;if(p===a&&h==null)return t?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(p===i&&h==null)return t?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;const m=Bh(r);return t?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${i} + depth + ${m};
        vec2 uv = uvFromFlat(${d}, ${p}, index);
        return sampleTexture(${r}, uv);
      }
  `}function $$e(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=Da();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(a[i-1]/2);let p=d*Math.ceil(a[i-2]/2),h="int b, int row, int col",m=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<i-1;g++)h=`int b${g}, `+h,p*=a[i-g-1],m=`b${g} * ${p} + `+m;return`
    vec4 ${r}(${h}) {
      int index = ${m};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${s.texture2D}(${n}, uv);
    }
  `}function E$e(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=vd(n);if(l.length<n.length){const v=wy(e,l),k=["row","col","depth","depth2"];return`
      ${by(v,t)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${ky(k,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${a}, 1)));
        ${vy(e)}
      }
    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1],m=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,y=`int stride0 = ${r}Shape[1] * stride1;`;if(h===o&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${m}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(h===a&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;const b=Bh(r);return t?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${p}, ${h}, index + ${b});
      return sampleTexture(${r}, uv);
    }
  `}function _$e(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=vd(t);if(l.length<t.length){const g=wy(e,l),y=["row","col","depth","depth2","depth3"];return`
      ${by(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${ky(y,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${a}, ${s})) +
          depth3;
        ${vy(e)}
      }
    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1];if(h===o&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(h===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const m=Bh(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${a} +
          depth2 * ${s} + depth3 + ${m};
      vec2 uv = uvFromFlat(${p}, ${h}, index);
      return sampleTexture(${n}, uv);
    }
  `}function A$e(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=vd(t);if(s.length<t.length){const y=wy(e,s),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${by(y)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${ky(b,a)});
      }
    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${vy(e)}
      }
    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],m=p[1];if(m===c&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===i&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;const g=Bh(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${g};
      vec2 uv = uvFromFlat(${h}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `}function vy(e){const t=e.name,n=Oe(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function R$e(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=N9(e.shapeInfo.logicalShape,t.logicalShape),l=Qn(i),u=i-a;let c;const d=["x","y","z","w","u","v"];a===0?c="":i<2&&o.length>=1?c="coords = 0;":c=o.map(v=>`coords.${d[v+u]} = 0;`).join(`
`);let p="";i<2&&a>0?p="coords":p=e.shapeInfo.logicalShape.map((v,k)=>`coords.${d[k+u]}`).join(", ");let h="return outputValue;";const g=Oe(e.shapeInfo.logicalShape)===1,b=Oe(t.logicalShape)===1;if(a===1&&!g&&!b)h=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!b)i===1?h=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:h=`
        return vec4(outputValue.x);
      `;else if(o.length){const v=a-2,k=a-1;o.indexOf(v)>-1&&o.indexOf(k)>-1?h="return vec4(outputValue.x);":o.indexOf(v)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(k)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${p});
      ${h}
    }
  `}function D$e(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&Dn(i,a))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const u=Qn(l),c=N9(e.shapeInfo.logicalShape,t.logicalShape),d=l-o;let p;const h=["x","y","z","w","u","v"];o===0?p="":l<2&&c.length>=1?p="coords = 0;":p=c.map(g=>`coords.${h[g+d]} = 0;`).join(`
`);let m="";return l<2&&o>0?m="coords":m=e.shapeInfo.logicalShape.map((g,y)=>`coords.${h[y+d]}`).join(", "),`
    float ${s}() {
      ${u} coords = getOutputCoords();
      ${p}
      return get${r}(${m});
    }
  `}function Qn(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function b3(e,t,n){const{newShape:r,keptDims:s}=vd(t),a=t.length,i=e&&a===3&&t[0]===1,o=i?t.slice(1):r,l=!e&&a>1&&!Dn(t,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:s}}function wy(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function ky(e,t){return t.map(n=>e[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F$e(e,t,n,r){const s=n.map((c,d)=>{const p={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(p.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:p}}),a=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=JTe(s,i,t),l=TTe(e.gl,o),u=e.createProgram(l);return $e().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},E9(e,t,u)))}function E9(e,t,n){const r=[],s=[];let a,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),$e().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const d of t.variableNames){const p={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(p.shape=e.getUniformLocation(n,`${d}Shape`,c),p.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),r.push(p)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const d of t.customUniforms)s.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function BV(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{const s=n.logicalShape,a=t[r],i=a.shape;if(!Dn(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&a.isUniform)return;const o=n.texShape,l=a.isUniform?null:a.texData.texShape;if(!Dn(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function O$e(e,t,n,r,s){t.program.enableShapeUniforms||(BV(t.inShapeInfos,n),BV([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),$e().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const u=n[l],{uniform:c,offset:d,shape:p,texShape:h}=t.variablesLocations[l];if(p){const{uniformShape:m}=b3(t.program.packedInputs,u.shape,u.texData.texShape);switch(m.length){case 1:e.gl.uniform1iv(p,new Int32Array(m));break;case 2:e.gl.uniform2iv(p,new Int32Array(m));break;case 3:e.gl.uniform3iv(p,new Int32Array(m));break;case 4:e.gl.uniform4iv(p,new Int32Array(m));break}}if(h&&e.gl.uniform2i(h,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(Oe(u.shape)<2)e.gl.uniform1f(c,u.uniformValues[0]);else{let m=u.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),e.gl.uniform1fv(c,m)}continue}u.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){const l=_t(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let l=0;l<t.program.customUniforms.length;++l){const u=t.program.customUniforms[l],c=t.customUniformLocations[l],d=s[l];if(u.type==="float")e.gl.uniform1fv(c,d);else if(u.type==="vec2")e.gl.uniform2fv(c,d);else if(u.type==="vec3")e.gl.uniform3fv(c,d);else if(u.type==="vec4")e.gl.uniform4fv(c,d);else if(u.type==="int")e.gl.uniform1iv(c,d);else if(u.type==="ivec2")e.gl.uniform2iv(c,d);else if(u.type==="ivec3")e.gl.uniform3iv(c,d);else if(u.type==="ivec4")e.gl.uniform4iv(c,d);else throw Error(`uniform type ${u.type} is not supported yet.`)}e.executeProgram()}function M$e(e,t,n){let r="";t.concat(n).forEach(i=>{const o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=b3(e.packedInputs,i.shape,l);let p="",h="",m="";if(c.length===1&&e.packedInputs){const S=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${S[0]>1}_${S[1]>1}`}else if(c.length===2&&!e.packedInputs)h=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){const S=_t(c);m=`${S[0]===l[1]}_${S[S.length-1]===l[1]}`}const g=i.shape.length,y=c.length===2&&Dn(i.shape,l),b=Oe(i.shape)===1,v=Eg(i.shape,n.shape),k=!e.packedInputs&&g===n.shape.length&&Dn(l,n.texData.texShape),I=e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${g}_${k}_${u?d:""}_${c.length}_${b}_${v}_${y}_${p}_${h}_${m}_${I}_${o}`}else{const l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${o}`}});const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${$e().getNumber("WEBGL_VERSION")}`,a}function da(e){return $e().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L$e{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Iv.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Da();this.outputShape=t,this.enableShapeUniforms=da(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?LC(["r","c","d"],t):zh(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P$e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Iv.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Da();this.outputShape=t,this.enableShapeUniforms=da(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?LC(["r","c","d"],t):zh(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z$e{constructor(t){this.variableNames=["A"],this.outTexUsage=zi.DOWNLOAD;const n=Da();this.outputShape=t,this.userCode=`
      ${C9}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B$e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=zi.DOWNLOAD;const n=Da();this.outputShape=t,this.userCode=`
      ${C9}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W$e={R:0,G:1,B:2,A:3};class WV{constructor(t,n=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Da();this.outputShape=t,this.enableShapeUniforms=da(this.outputShape.length);let a="result";n&&(a="floor(result * 255. + 0.5)");let i="";for(let o=0;o<r.length;o++){const l=r[o];i+=`
          if(offset == ${o}) {
            result = values[${W$e[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?x3():y3(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${i}
        }
        ${s.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V$e{constructor(t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Da();this.outputShape=t,this.enableShapeUniforms=da(this.outputShape.length);let s="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let o=0;o<=1;o++){const l=i*2+o;s+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?x3():y3(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${a};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U$e(e){const t=Da(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return NTe(e,n)}function G$e(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return ATe(e,t)}function j$e(e){const t=new Uint16Array([0,1,2,2,1,3]);return RTe(e,t)}function x1(e,t,n,r,s,a){FTe(t,n);const i=DTe(e),o=e.TEXTURE_2D;return ct(e,()=>e.bindTexture(o,i)),ct(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),ct(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),ct(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),ct(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),$e().getNumber("WEBGL_VERSION")===1?ct(e,()=>e.texImage2D(o,0,r,t,n,0,s,a,null)):ct(e,()=>e.texStorage2D(o,1,r,t,n)),ct(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function _9(e){return e.internalFormatFloat}function H$e(e,t,n,r){const[s,a]=g1(t,n);return x1(e,s,a,_9(r),r.textureFormatFloat,e.FLOAT)}function A9(e){return e.internalFormatHalfFloat}function q$e(e,t,n,r){const[s,a]=g1(t,n);return x1(e,s,a,A9(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function R9(e){return e.downloadTextureFormat}function K$e(e,t,n,r){const[s,a]=g1(t,n);return x1(e,s,a,R9(r),e.RGBA,e.UNSIGNED_BYTE)}function D9(e){return e.internalFormatPackedFloat}function X$e(e,t,n,r){const[s,a]=xy(t,n);return x1(e,s,a,D9(r),e.RGBA,e.FLOAT)}function F9(e){return e.internalFormatPackedHalfFloat}function Y$e(e,t,n,r){const[s,a]=xy(t,n);return x1(e,s,a,F9(r),e.RGBA,r.textureTypeHalfFloat)}function Z$e(e,t,n){return ct(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),LV(e,t,"clipSpacePos",n,3,20,0)&&LV(e,t,"uv",n,2,20,12)}function J$e(e,t,n,r,s,a){ct(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),$e().getNumber("WEBGL_VERSION")===2?ct(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):ct(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),ct(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function Q$e(e,t,n){ct(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?$e().getNumber("WEBGL_VERSION")===2?ct(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):ct(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):$e().getNumber("WEBGL_VERSION")===2?ct(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):ct(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),ct(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function eEe(e,t,n,r){const s=e.createBuffer();ct(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));const o=4*4*t*n;return ct(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ)),ct(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),ct(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function tEe(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function nEe(e,t,n,r){const[s,a]=g1(t,n),i=4,o=new Uint8Array(bTe(t*n,i));return ct(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function rEe(e,t,n,r,s,a,i,o){const l=e,u=new Float32Array(vTe(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function sEe(e,t,n){const r=new Float32Array(t*n*4);return ct(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FE{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=$e().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,gTe(n,t)):this.gl=il(n),t=this.gl,$e().getNumber("WEBGL_VERSION")===2){const a=t;this.createVertexArray=()=>ct(a,()=>a.createVertexArray()),this.bindVertexArray=i=>ct(a,()=>a.bindVertexArray(i)),this.deleteVertexArray=i=>ct(a,()=>a.deleteVertexArray(i)),this.getVertexArray=()=>ct(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(t!=null){const a=t.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ct(t,()=>a.createVertexArrayOES()),this.bindVertexArray=i=>ct(t,()=>a.bindVertexArrayOES(i)),this.deleteVertexArray=i=>ct(t,()=>a.deleteVertexArrayOES(i)),this.getVertexArray=()=>ct(t,()=>t.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),$e().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Vk(this.gl,a),bo(this.gl,i))this.textureHalfFloatExtension=Vk(this.gl,i);else if($e().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),bo(this.gl,s))this.colorBufferHalfFloatExtension=Vk(this.gl,s);else if($e().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",bo(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(bo(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=G$e(this.gl),this.indexBuffer=j$e(this.gl),this.framebuffer=OTe(this.gl),this.textureConfig=g3(this.gl,this.textureHalfFloatExtension)}get debug(){return $e().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;ct(t,()=>t.finish()),ct(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),ct(t,()=>t.deleteFramebuffer(this.framebuffer)),ct(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),ct(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),ct(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,n){return this.throwIfDisposed(),H$e(this.gl,t,n,this.textureConfig)}createFloat16MatrixTexture(t,n){return this.throwIfDisposed(),q$e(this.gl,t,n,this.textureConfig)}createUnsignedBytesMatrixTexture(t,n){return this.throwIfDisposed(),K$e(this.gl,t,n,this.textureConfig)}uploadPixelDataToTexture(t,n){this.throwIfDisposed(),Q$e(this.gl,t,n)}uploadDenseMatrixToTexture(t,n,r,s){this.throwIfDisposed(),J$e(this.gl,t,n,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,n){return this.throwIfDisposed(),Y$e(this.gl,t,n,this.textureConfig)}createPackedMatrixTexture(t,n){return this.throwIfDisposed(),X$e(this.gl,t,n,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(PV(this.gl,this.framebuffer),this.outputTexture=null),ct(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,n,r){return this.downloadMatrixDriver(t,()=>nEe(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,n,r,s,a,i){return rEe(this.gl,t,n,r,s,a,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,n){return tEe(this.gl,t,n)}createBufferFromTexture(t,n,r){this.bindTextureToFrameBuffer(t);const s=eEe(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let n,r;if($e().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,a=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const i=s.clientWaitSync(a,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},n=a}else $e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,$e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(t,n,r){return this.downloadMatrixDriver(t,()=>sEe(this.gl,n,r))}createProgram(t){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=U$e(n));const r=ETe(n);ct(n,()=>n.attachShader(r,this.vertexShader)),ct(n,()=>n.attachShader(r,t)),_Te(n,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&_E(n,s),s}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const n=this.gl;ct(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Z$e(n,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(ct(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&_E(this.gl,this.program),ct(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,n,r=!0){return this.throwIfDisposed(),r?LTe(this.gl,t,n):PTe(this.gl,t,n)}getAttributeLocation(t,n){return this.throwIfDisposed(),ct(this.gl,()=>this.gl.getAttribLocation(t,n))}getUniformLocationNoThrow(t,n){return this.throwIfDisposed(),this.gl.getUniformLocation(t,n)}setInputMatrixTexture(t,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),zTe(this.gl,t,n,r)}setOutputMatrixTexture(t,n,r){this.setOutputMatrixTextureDriver(t,r,n)}setOutputPackedMatrixTexture(t,n,r){this.throwIfDisposed();const[s,a]=xy(n,r);this.setOutputMatrixTextureDriver(t,s,a)}setOutputMatrixWriteRegion(t,n,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,n)}setOutputPackedMatrixWriteRegion(t,n,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&_E(this.gl,this.program),Uk(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ct(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ct(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Vk(this.gl,$e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if($e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),a=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,a),a}const t=this.getQueryTimerExtensionWebGL1(),n=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,n),n}endQuery(){if($e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await SW(()=>this.disposed||this.isQueryAvailable(t,$e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,$e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,n){if(n===0)return!0;if(n===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),a=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(n=>{this.addItemToPoll(()=>t.isFencePassed(),()=>n())})}pollItems(){const t=aEe(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=t;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,n){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in $e().platform&&(r=$e().platform.setTimeoutCustom.bind($e().platform)),SW(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),AE(this.gl,t,this.framebuffer),this.debug&&Uk(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(AE(this.gl,this.outputTexture,this.framebuffer),this.debug&&Uk(this.gl)):PV(this.gl,this.framebuffer)}downloadMatrixDriver(t,n){this.bindTextureToFrameBuffer(t);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,n,r){this.throwIfDisposed();const s=this.gl;AE(s,t,this.framebuffer),this.debug&&Uk(s),this.outputTexture=t,ct(s,()=>s.viewport(0,0,n,r)),ct(s,()=>s.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(t,n,r,s){this.throwIfDisposed(),ct(this.gl,()=>this.gl.scissor(t,n,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function aEe(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:iEe,bincountImpl:O9,bincountReduceImpl:oEe,bitwiseAndImpl:lEe,castImpl:uEe,ceilImpl:cEe,concatImpl:dEe,equalImpl:pEe,expImpl:hEe,expm1Impl:fEe,floorImpl:mEe,gatherNdImpl:gEe,gatherV2Impl:yEe,greaterImpl:xEe,greaterEqualImpl:bEe,lessImpl:vEe,lessEqualImpl:wEe,linSpaceImpl:kEe,logImpl:IEe,maxImpl:SEe,maximumImpl:CEe,minimumImpl:NEe,multiplyImpl:TEe,negImpl:$Ee,notEqualImpl:EEe,prodImpl:_Ee,raggedGatherImpl:AEe,raggedRangeImpl:REe,raggedTensorToTensorImpl:DEe,rangeImpl:FEe,rsqrtImpl:OEe,scatterImpl:MEe,sigmoidImpl:LEe,simpleAbsImpl:M9,sliceImpl:PEe,sparseFillEmptyRowsImpl:zEe,sparseReshapeImpl:BEe,sparseSegmentReductionImpl:L9,sqrtImpl:WEe,staticRegexReplaceImpl:VEe,stridedSliceImpl:UEe,stringNGramsImpl:GEe,stringSplitImpl:jEe,stringToHashBucketFastImpl:HEe,subImpl:qEe,tileImpl:KEe,topKImpl:XEe,transposeImpl:v3,uniqueImpl:YEe}=Qke;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P9(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Sa(e,t){return t===1?[e]:P9(e,t)}function ZEe(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JEe{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=da(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=Sa("rc",this.rank),r=Qn(this.rank),s=this.getOutOfBoundsCondition(n),a=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let a=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)a=`${t[t.length-1-i]},`+a;n.push(a)}return n}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let r=this.rank-2;r<this.rank;r++)n+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(n+="||");return n}getSetup(t){if(this.rank===1)return"";const n=t.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(t){const n=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z9{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=da(this.outputShape.length);let r="";for(let s=0;s<4;s++){let a="thisRC = rc;";s%2===1&&(a+="thisRC.z += 1;"),s>1&&(a+="thisRC.y += 1;"),r+=`
        ${a}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${QEe(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?x3():y3(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${r}

        setOutput(result);
      }
    `}}function QEe(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?ZTe(["r","c","d"],"inputShape"):zh(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e_e{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,n,r){const s=UV(n,r),a=GV(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const i=VV(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[a].pop();return this.usedTextures[a].push(l),l}let o;return s===Gs.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===Gs.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===Gs.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===Gs.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===Gs.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),o}releaseTexture(t,n,r,s){if(this.freeTextures==null)return;const a=UV(r,s),i=GV(n,a,s);i in this.freeTextures||(this.freeTextures[i]=[]);const o=VV(n,a,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=$e().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const u=this.usedTextures[i],c=u&&u.indexOf(t);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function t_e(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function VV(e,t,n,r,s){const a=n_e(t,r);let i;if(s){const[l,u]=xy(e[0],e[1]);i=l*u}else{const[l,u]=g1(e[0],e[1]);i=l*u}const o=t_e(n,a);return i*o}function n_e(e,t){switch(e){case Gs.PACKED_2X2_FLOAT32:return D9(t);case Gs.PACKED_2X2_FLOAT16:return F9(t);case Gs.UNPACKED_FLOAT32:return _9(t);case Gs.UNPACKED_FLOAT16:return A9(t);case Gs.PACKED_4X1_UNSIGNED_BYTE:return R9(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function r_e(e){return $e().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Gs.PACKED_2X2_FLOAT32:Gs.UNPACKED_FLOAT32:e?Gs.PACKED_2X2_FLOAT16:Gs.UNPACKED_FLOAT16}function UV(e,t){if(e===zi.UPLOAD)return Gs.PACKED_2X2_FLOAT32;if(e===zi.RENDER||e==null)return r_e(t);if(e===zi.DOWNLOAD||e===zi.PIXELS)return Gs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function GV(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pl{constructor(t,n){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=da(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const No="if (isnan(x)) return x;",s_e="return x;",jV="return abs(x);",a_e="return (x >= 0.0) ? x : (exp(x) - 1.0);",i_e=No+`
  return (x < 0.0) ? 0.0 : x;
`,o_e=No+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,_c="return x;",l_e="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u_e="return x;",c_e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,d_e=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,p_e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,h_e="return 1.0 / (1.0 + exp(-1.0 * x));";class Mc{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=da(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f_e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=da(this.outputShape.length);const n=t.length,r=Sa("rc",n),s=Qn(n),a=ZEe(n,r),i=r.slice(-2),o=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m_e=lH,g_e=1e-7,y_e=1e-4,Hk={};function x_e(e){return e in Hk||(Hk[e]={}),Hk[e]}const b_e=$e().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),v_e=600;function w_e(){return $e().global.screen==null?1024:$e().global.screen.height*$e().global.screen.width*window.devicePixelRatio*v_e/1024/1024}class PC extends UR{nextDataId(){return PC.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!$e().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof FE)n=t;else{const r=il($e().getNumber("WEBGL_VERSION"),t);n=new FE(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=il($e().getNumber("WEBGL_VERSION"));n=new FE(r),this.binaryCache=x_e($e().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new e_e(this.gpgpu),this.numMBBeforeWarning=w_e(),this.texData=new D5(this,$l())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,r,s,a,i){const o=this.makeTensorInfo(n,r),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[s,a]},l.texShape=[s,a];const u=Gk(n),c=new WV(u,!1,i),d=this.runWebGLProgram(c,[o],r,[[s,a]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(t,n,r){if(($e().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||$e().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:t,usage:zi.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){const n=this.texData.get(t);n.refCount--}}move(t,n,r,s,a){if($e().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:s,values:n,usage:zi.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const n=this.texData.get(t),{values:r,dtype:s,complexTensorInfos:a,slice:i,shape:o,isPacked:l}=n;if(i!=null){let p;l?p=new Mc(o,_c):p=new Pl(o,_c);const h=this.runWebGLProgram(p,[{dataId:t,shape:o,dtype:s}],s),m=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),m}if(r!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return r;const u=this.activeTimers!=null;let c;u&&(c=Wa());let d;if(s==="complex64"){const p=this.readSync(a.real.dataId),h=this.readSync(a.imag.dataId);d=zu(p,h)}else d=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=Wa()-c),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){const m=this.pendingRead.get(t);return new Promise(g=>m.push(g))}const n=this.texData.get(t),{values:r,shape:s,slice:a,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(a!=null){let m;l?m=new Mc(s,_c):m=new Pl(s,_c);const g=this.runWebGLProgram(m,[{dataId:t,shape:s,dtype:i}],i),y=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(r!=null)return this.convertAndCacheOnCPU(t);if($e().getBool("DEBUG")&&!$e().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&$e().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(i!=="complex64"&&$e().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);const m=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(m.texture.texture,...Wk(s))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(i==="complex64"){const m=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),g=m[0],y=m[1];d=zu(g,y)}else if(u==null)d=this.getValuesFromTexture(t);else{const m=Oe(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(u,m)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const m=this.gpgpu.gl;ct(m,()=>m.deleteBuffer(u))}const p=this.convertAndCacheOnCPU(t,d),h=this.pendingRead.get(t);return this.pendingRead.delete(t),h.forEach(m=>m(p)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&$l().removeDataId(t,this),this.pendingDeletes--),p}readToGPU(t,n={}){const r=this.texData.get(t),{values:s,shape:a,slice:i,dtype:o,isPacked:l,texture:u}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let h;l?h=new Mc(a,_c):h=new Pl(a,_c);const m=this.runWebGLProgram(h,[{dataId:t,shape:a,dtype:o}],o),g=this.readToGPU(m,n);return this.disposeIntermediateTensorInfo(m),g}if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(t,n.customTexShape),d=$l().makeTensorFromTensorInfo(c),p=this.texData.get(c.dataId);return Object.assign({tensorRef:d},p.texture)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const r=n.map(s=>Yc(s));return ln(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ln(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){const r=t[n];if(!STe(r))throw $e().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:n,dtype:r,isPacked:s}=this.texData.get(t),a=Oe(n);if($e().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(t),h=this.texData.get(p.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...Wk(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(p),m}const i=$e().getBool("WEBGL_PACK")&&s===!0,o=i?Gk(n):n,l=i?new B$e(o):new z$e(o),u=this.runWebGLProgram(l,[{shape:o,dtype:r,dataId:t}],"float32"),c=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return $e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,t();const a=Qp(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=Qp(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if($e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(a);o.kernelMs=ahe(l),o.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return $e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Wa(),endMs:null}}endTimer(t){return $e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=Wa(),t)}async getQueryTime(t){if($e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:n,dtype:r,texShape:s,usage:a,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,a,i)));const c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=b_e){return $e().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&Oe(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){Pi("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=t.dataSync();return m_e(t.shape,n)}packedUnaryOp(t,n,r){const s=new Mc(t.shape,n),a=this.compileAndRun(s,[t],r);return $l().makeTensorFromTensorInfo(a)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const s=M9(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,s)}if($e().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,jV,t.dtype);const n=new Pl(t.shape,jV),r=this.compileAndRun(n,[t]);return $l().makeTensorFromTensorInfo(r)}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&t0(r[0])){const a=r.map(i=>Uc(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:n}}makeOutput(t,n,r){return $l().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,r),this)}unpackTensor(t){const n=new f_e(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){const n=new JEe(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){const r=[Og(t.shape),...Mg(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},a=[Og(n),...Mg(n)],i=new z9(a,r),o=!0,l=[r],u=this.runWebGLProgram(i,[s],t.dtype,l,o);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(t,n){const r=this.texData.get(t),{isPacked:s,shape:a,dtype:i}=r;if(n!=null){const p=Oe(a),h=n[0]*n[1]*4;Y(p<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=Gk(a);let l;s?l=new P$e(o):l=new L$e(o);const u=!0,c=[n??Wk(o)],d=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,c,u,n);return{dtype:i,shape:a,dataId:d.dataId}}runWebGLProgram(t,n,r,s,a=!1,i){const o=this.makeTensorInfo(t.outputShape,r),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===Iv.DENSE){const b=i??Wk(t.outputShape);l.texShape=b.map(v=>v*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),Oe(o.shape)===0)return l.values=sa(o.dtype,0),o;const u=[],c=n.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let v=this.texData.get(b.dataId);if(v.texture==null){if(!t.packedInputs&&Oe(b.shape)<=$e().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:v.values};t.packedInputs&&(v.isPacked=!0,v.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!v.isPacked!=!!t.packedInputs)b=v.isPacked?this.unpackTensor(b):this.packTensor(b),u.push(b),v=this.texData.get(b.dataId);else if(v.isPacked&&!gI(v.shape,b.shape)){const k=b,I=b.shape;b.shape=v.shape,b=this.packedReshape(b,I),u.push(b),v=this.texData.get(b.dataId),k.shape=I}return{shape:b.shape,texData:v,isUniform:!1}});this.uploadToGPU(o.dataId);const d={shape:o.shape,texData:l,isUniform:!1},p=M$e(t,c,d),h=this.getAndSaveBinary(p,()=>F$e(this.gpgpu,t,c,d)),m=this.activeTimers!=null;let g;m&&(g=this.startTimer()),$e().get("ENGINE_COMPILE_ONLY")||O$e(this.gpgpu,h,c,d,s),u.forEach(b=>this.disposeIntermediateTensorInfo(b)),m&&(g=this.endTimer(g),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(g)}));const y=$e().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const b=Wa();b-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!$e().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&a===!1){const b=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),b}return o}compileAndRun(t,n,r,s,a=!1){return r=r||n[0].dtype,this.runWebGLProgram(t,n,r,s,a)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||($e().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Se(()=>{if(!$e().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=$e().getBool("DEBUG");$e().set("DEBUG",!1);const n=this.abs(Rn(1e-8)).dataSync()[0];if($e().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?g_e:y_e}uploadToGPU(t){const n=this.texData.get(t),{shape:r,dtype:s,values:a,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;const u=this.activeTimers!=null;let c;u&&(c=Wa());let d=n.texShape;if(d==null&&(d=VTe(r,l),n.texShape=d),a!=null){const p=Gk(r);let h,m=d[1],g=d[0];const y=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(l||!y)&&([m,g]=xy(d[0],d[1])),l?h=new V$e(p,y):h=new WV(p,y);const b=y?[g,m]:d,v=this.makeTensorInfo(b,s),k=this.texData.get(v.dataId);y?k.usage=zi.PIXELS:k.usage=zi.UPLOAD,k.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),m,g,a);const I=[[g,m]],N=this.runWebGLProgram(h,[v],s,I,!0),T=this.texData.get(N.dataId);n.texShape=T.texShape,n.isPacked=T.isPacked,n.usage=T.usage,$e().get("ENGINE_COMPILE_ONLY")?this.disposeData(N.dataId):(n.texture=T.texture,n.values=null,this.texData.delete(N.dataId)),this.disposeIntermediateTensorInfo(v),u&&(this.uploadWaitMs+=Wa()-c)}else{const p=this.acquireTexture(d,o,s,l);n.texture=p}}convertAndCacheOnCPU(t,n){const r=this.texData.get(t),{dtype:s}=r;return n!=null&&(r.values=k_e(n,s)),r.values}acquireTexture(t,n,r,s){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,s)}computeBytes(t,n){return t[0]*t[1]*H2(n)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(a){throw a}});t.push(r)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await NH(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(S9(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=E9(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=r,t.infLoc=s,t.nanLoc=a,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,r){t.channels=t.channels||"RGBA";const{texture:s,height:a,width:i,channels:o}=t,l=$l().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(s,n,r,a,i,o);return $l().makeTensorFromDataId(u,n,r,l)}}PC.nextDataId=0;function k_e(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){const n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */wj()&&Cj("webgl",()=>new PC,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w3=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class dh{constructor(t,n,r){this.variableNames=["A","B"],this.outputShape=Jt(n,r),this.enableShapeUniforms=da(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wh=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Iy{constructor(t,n,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Jt(n,r);const a=this.outputShape.length;this.enableShapeUniforms=da(a);let i="";if(s)if(a===0||Oe(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Qn(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Sa("coords",a);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Si(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const I_e={kernelName:k0,backendName:"webgl",kernelFunc:Si};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ed(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=Si({inputs:{x:r},backend:n}),l=Si({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const S_e={kernelName:rD,backendName:"webgl",kernelFunc:Ed};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B9="return (a < 0.) ? b * a : a;",W9=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function C_e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",wd(a,"float32")),o=$e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Iy(W9,s.shape,i.shape):new dh(B9,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}const N_e={kernelName:FS,backendName:"webgl",kernelFunc:C_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V9="return (a < 0.) ? b * a : a;",U9=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function T_e(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=$e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Iy(U9,r.shape,s.shape):new dh(V9,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}const $_e={kernelName:QS,backendName:"webgl",kernelFunc:T_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sy="if (isnan(x)) return x;";function wn({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,o=a,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){const d=o.texData.get(i.dataId),p=n(d.values,l);return o.makeTensorInfo(i.shape,l,p)}const u=$e().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let c;return u?c=new Mc(i.shape,t):c=new Pl(i.shape,e),o.runWebGLProgram(c,[i],l)}}function Zs({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{const{a:l,b:u}=i,c=o;if(r&&l.dtype==="complex64"){const m=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[y,b]=[[m.complexTensorInfos.real,g.complexTensorInfos.real],[m.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(k=>{const[I,S]=k,N={dataId:I.dataId,dtype:I.dtype,shape:l.shape},T={dataId:S.dataId,dtype:S.dtype,shape:u.shape},A=new dh(e,l.shape,u.shape);return c.runWebGLProgram(A,[N,T],ki(I.dtype,S.dtype))}),v=Ed({inputs:{real:y,imag:b},backend:c});return c.disposeIntermediateTensorInfo(y),c.disposeIntermediateTensorInfo(b),v}const d=a||ki(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&s!=null){const m=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,y=l.dtype==="string"?Bu(m):m,b=l.dtype==="string"?Bu(g):g,[v,k]=s(l.shape,u.shape,y,b,d),I=c.makeTensorInfo(k,d),S=c.texData.get(I.dataId);return S.values=v,I}const p=$e().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let h;return p?h=new Iy(t,l.shape,u.shape,n):h=new dh(e,l.shape,u.shape),c.runWebGLProgram(h,[l,u],d)}}function Sv(e,t=!1){if(e==="linear")return t?u_e:s_e;if(e==="relu")return t?d_e:i_e;if(e==="elu")return t?c_e:a_e;if(e==="relu6")return t?p_e:o_e;if(e==="prelu")return t?U9:V9;if(e==="leakyrelu")return t?W9:B9;if(e==="sigmoid")return t?h_e:l_e;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G9{constructor(t,n,r,s=!1,a=!1,i=!1,o=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=da(this.outputShape.length);const c=s?t[1]:t[2],d=Math.ceil(c/2),p=s?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",m=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",b="";o&&(l?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:u?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:y=`vec4 activation(vec4 x) {
          ${o}
        }`,b="result = activation(result);");const v=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let k="rc.x",I="rc.x";t[0]<n[0]?k=`imod(rc.x, ${t[0]})`:n[0]<t[0]&&(I=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${k};
        int batchB = ${I};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${m[0]} * ${g[0]});
          result += (${m[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${v}

        ${b}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HV={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class qV{constructor(t,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Jt(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KV="return a * b;";function k3(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=ki(r.dtype,s.dtype);if(r.dtype==="complex64"){const o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),u=new qV(HV.REAL,r.shape,s.shape),c=new qV(HV.IMAG,r.shape,s.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],p=n.runWebGLProgram(u,d,"float32"),h=n.runWebGLProgram(c,d,"float32"),m=Ed({inputs:{real:p,imag:h},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),m}if(n.shouldExecuteOnCPU([r,s])){const o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[u,c]=TEe(r.shape,s.shape,o.values,l.values,a),d=n.makeTensorInfo(c,a),p=n.texData.get(d.dataId);return p.values=u,d}let i;return $e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Iy(KV,r.shape,s.shape):i=new dh(KV,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const E_e={kernelName:A0,backendName:"webgl",kernelFunc:k3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function __e(e,t,n){const r=[Og(e.shape),...Mg(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[Og(t),...Mg(t)],i=new z9(a,r),o=!0,l=[r],u=n.runWebGLProgram(i,[s],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nt(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=Oe(s.shape),l=F5(a,o),u=Oe(l);Y(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return c.isPacked&&!gI(s.shape,l)&&!(c.texture!==null&&gI(c.shape,l))?__e(s,l,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const A_e={kernelName:tC,backendName:"webgl",kernelFunc:nt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XV{constructor(t,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:a,outSize:i}=t;this.outputShape=[s,i];const o=Math.floor(r/4)*4,l=r%4;let u="sumValue += dot(values, ones);";if(n!=null){const d=1/n;u=`sumValue += dot(values * ${Ng(d)?d.toPrecision(2):d}, ones);`}let c="";a%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R_e{constructor(t,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:a,outSize:i}=t;this.outputShape=[s,i];let o="0.0",l="";n==="prod"?o="1.0":n==="min"?(o="1.0 / 1e-20",l="min"):n==="max"&&(o="-1.0 / 1e-20",l="max");let u=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?u="sumValue":n==="prod"?u="prodValue":n==="all"?u="allValue":n==="any"&&(u="anyValue");const c=Math.floor(r/4)*4,d=r%4;let p=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";n==="all"?(o="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):n==="any"&&(o="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let m="";a%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D_e(e){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const n=t.length?t[t.length-1].outSize:e[1],r=kC(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function Vh(e,t,n,r){const s=D_e(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:l,outSize:u}=s[i];let c,d;n==="mean"?c=i===0?new XV({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new XV({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):c=new R_e({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=a,a=r.runWebGLProgram(c,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F_e{constructor(t,n){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[n[i]];this.outputShape=r,this.rank=r.length;const s=Qn(this.rank),a=O_e(n);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}function O_e(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M_e{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let c=0;c<r.length;c++)r[c]=t[n[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Qn(this.rank),a=P9("rc",this.rank),i=new Array(this.rank);for(let c=0;c<n.length;c++)i[n[c]]=a[c];const o=`vec2(${i.slice(-2).join()})`,l=`++${a[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zC(e,t,n){const r=$e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new M_e(e.shape,t):new F_e(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L_e(e,t,n,r){const s=t,a=e.shape.length,i=un(s,e.shape);let o=i;const l=_r(o,a),u=l!=null;let c=e;u&&(c=zC(e,l,r),o=zr(o.length,a)),Ys("sum",o,a);const[d,p]=Os(c.shape,o);let h=d;n&&(h=Jr(d,i));const m=Oe(p),y=Oe(e.shape)/m,b=nt({inputs:{x:c},attrs:{shape:[y,m]},backend:r}),v=LD(e.dtype),k=Vh(b,v,"sum",r),I=nt({inputs:{x:k},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(k),u&&r.disposeIntermediateTensorInfo(c),I}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BC(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return L_e(s,a,i,n)}const P_e={kernelName:oC,backendName:"webgl",kernelFunc:BC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ea(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=s.shape[a[c]];let u;if(i.shouldExecuteOnCPU([s])){const d=i.texData.get(s.dataId).values,p=v3(d,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype);const h=i.texData.get(u.dataId);h.values=p}else u=zC(s,a,i);return u}const z_e={kernelName:fg,backendName:"webgl",kernelFunc:Ea};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j9=1e3;function yI({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const u=e.shape.length,c=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],p=r?t.shape[c-1]:t.shape[c-2],h=n?e.shape[u-1]:e.shape[u-2],m=r?t.shape[c-2]:t.shape[c-1],g=e.shape.slice(0,-2),y=t.shape.slice(0,-2),b=Oe(g),v=Oe(y),I=Jt(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,m]);Y(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);const S=n?[b,d,h]:[b,h,d],N=r?[v,m,p]:[v,p,m],T=nt({inputs:{x:e},backend:s,attrs:{shape:S}}),A=nt({inputs:{x:t},backend:s,attrs:{shape:N}}),R=[T,A],D=Math.max(b,v),$=n?T.shape[1]:T.shape[2],_=a!=null,L=i!=null,z=l==="leakyrelu",W=l!=null?Sv(l,!0):null,G=_||L||z||W!=null;let q;if((h===1||m===1)&&$>j9&&G===!1){let j=T,H=A;n&&(j=Ea({inputs:{x:T},backend:s,attrs:{perm:[0,2,1]}}),R.push(j)),r&&(H=Ea({inputs:{x:A},backend:s,attrs:{perm:[0,2,1]}}),R.push(H));const P=m!==1,X=m===1;let Q=j;P&&(Q=nt({inputs:{x:j},backend:s,attrs:{shape:[D,$,1]}}),R.push(Q));const re=m===1?2:1;let le=H;X&&(le=nt({inputs:{x:H},backend:s,attrs:{shape:[D,1,$]}}),R.push(le));const ke=k3({inputs:{a:Q,b:le},backend:s});q=BC({inputs:{x:ke},backend:s,attrs:{axis:re,keepDims:!0}}),R.push(ke)}else{const j=ki(e.dtype,t.dtype),H=new G9(S,N,[D,h,m],n,r,_,W,L,z),P=[T,A];if(a!=null&&P.push(a),L&&P.push(i),z){const X=s.makeTensorInfo([],"float32",wd(o,"float32"));P.push(X),R.push(X)}q=s.runWebGLProgram(H,P,j)}const B=nt({inputs:{x:q},backend:s,attrs:{shape:I}});R.push(q);for(const j of R)s.disposeIntermediateTensorInfo(j);return B}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B_e(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return yI({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}const W_e={kernelName:q2,backendName:"webgl",kernelFunc:B_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YV="return abs(x);";function V_e(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const a=n.texData.get(r.dataId),i=M9(a.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return $e().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Mc(r.shape,YV):s=new Pl(r.shape,YV),n.runWebGLProgram(s,[r],r.dtype)}const U_e={kernelName:fS,backendName:"webgl",kernelFunc:V_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G_e=No+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,j_e=wn({opSnippet:G_e}),H_e={kernelName:n0,backendName:"webgl",kernelFunc:j_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q_e=No+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,K_e=wn({opSnippet:q_e}),X_e={kernelName:r0,backendName:"webgl",kernelFunc:K_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZV="return a + b;",Y_e=Zs({opSnippet:ZV,packedOpSnippet:ZV,supportsComplex:!0,cpuKernelImpl:iEe}),Z_e={kernelName:cy,backendName:"webgl",kernelFunc:Y_e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class J_e{constructor(t,n){this.outputShape=[],this.outputShape=t,this.variableNames=n.map((a,i)=>`T${i}`);const r=[];this.variableNames.forEach(a=>{r.push(`float v${a} = get${a}AtOutCoords();`)});const s=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q_e{constructor(t,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=n.map((a,i)=>`T${i}`);const r=[];this.variableNames.forEach(a=>{r.push(`vec4 v${a} = get${a}AtOutCoords();`)});const s=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S2(e){const{inputs:t,backend:n}=e,r=t;if(r.length===1)return Si({inputs:{x:r[0]},backend:n});if(r.length>$e().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),u=S2({inputs:r.slice(0,l),backend:n}),c=S2({inputs:r.slice(l),backend:n});return S2({inputs:[u,c],backend:n})}const s=r.map(l=>l.dtype).reduce((l,u)=>ki(l,u)),a=r.map(l=>l.shape),o=$e().getBool("WEBGL_PACK")?new Q_e(r[0].shape,a):new J_e(r[0].shape,a);return n.runWebGLProgram(o,r,s)}const eAe={kernelName:YR,backendName:"webgl",kernelFunc:S2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tAe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=un(a,s.shape);let u=l;const c=_r(u,o);let d=s;c!=null&&(d=Ea({inputs:{x:s},backend:n,attrs:{perm:c}}),u=zr(u.length,o)),Ys("all",u,o);const[p,h]=Os(d.shape,u),m=Oe(h),g=nt({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=Vh(g,g.dtype,"all",n);let b;if(i){const v=Jr(p,l);b=nt({inputs:{x:y},backend:n,attrs:{shape:v}})}else b=nt({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),c!=null&&n.disposeIntermediateTensorInfo(d),b}const nAe={kernelName:ZR,backendName:"webgl",kernelFunc:tAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rAe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=un(a,s.shape);let u=l;const c=_r(u,o);let d=s;c!=null&&(d=Ea({inputs:{x:s},backend:n,attrs:{perm:c}}),u=zr(u.length,o)),Ys("any",u,o);const[p,h]=Os(d.shape,u),m=Oe(h),g=nt({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=Vh(g,g.dtype,"any",n);let b;if(i){const v=Jr(p,l);b=nt({inputs:{x:y},backend:n,attrs:{shape:v}})}else b=nt({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),c!=null&&n.disposeIntermediateTensorInfo(d),b}const sAe={kernelName:JR,backendName:"webgl",kernelFunc:rAe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aAe{constructor(t,n,r){this.variableNames=["A"];const{windowSize:s,batchSize:a,outSize:i}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[a,i];const o=n==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iAe{constructor(t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Y(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const a=t[t.length-1],i=Math.ceil(a/n);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,u=Qn(l),c=Sa("coords",l);let d,p;if(i===1){p=l+1;const A=Qn(p);d=`
        ${A} sourceLocR = ${A}(${c.join()}, 0);
        ++${c[l-1]};
        ${A} sourceLocG = ${A}(${c.join()}, 0);
        ++${c[l-2]};
        ${A} sourceLocA = ${A}(${c.join()}, 0);
        --${c[l-1]};
        ${A} sourceLocB = ${A}(${c.join()}, 0);
        --${c[l-2]};`}else p=l,d=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const h=["x","y","z","w","u","v"].slice(0,p),m="."+h[p-1],g=h.map(A=>"int "+A),y=Sa("sourceLocR",p-1).concat("inIdx.r"),b=Sa("sourceLocG",p-1).concat("inIdx.g"),v=Sa("sourceLocB",p-1).concat("inIdx.b"),k=Sa("sourceLocA",p-1).concat("inIdx.a"),I=r==="max"?"greaterThan":"lessThan",S=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${k.join()})));`,N=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${v.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${k.join()}) : 0.)`,T=s?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${T}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${o[l-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${N};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${S}
          vec4 candidate = ${N};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${I}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H9(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];r!=null&&(s=r.shape[0],a=r.shape[1]);const i=kC(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new aAe(o,n,r==null),u=[t];r!=null&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const d=H9(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function q9(e,t,n,r=null){const s=r!=null?r.shape:t.shape,a=s[s.length-1],i=kC(a),o=new iAe(s,i,n,r==null),l=r==null?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){const c=q9(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}return u}function K9(e,t,n,r){const s=[n];if(Ys("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!$e().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const a=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked;let l=t;o&&(l=e.unpackTensor(t),a.push(l));const[u,c]=Os(l.shape,s),d=Oe(c),p=nt({inputs:{x:l},backend:e,attrs:{shape:[-1,d]}});a.push(p);const h=H9(e,p,r);a.push(h);const m=nt({inputs:{x:h},backend:e,attrs:{shape:u}});return a.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}return q9(e,t,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oAe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=un(a,s.shape);const o=_r(i,s.shape.length);let l=s;const u=[];o!=null&&(l=Ea({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=zr(i.length,l.shape.length)),Ys("argMax",[i[0]],l.shape.length);const c=K9(n,l,i[0],"max");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const lAe={kernelName:mS,backendName:"webgl",kernelFunc:oAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uAe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=un(a,s.shape);const o=_r(i,s.shape.length);let l=s;const u=[];o!=null&&(l=Ea({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=zr(i.length,l.shape.length)),Ys("argMin",[i[0]],l.shape.length);const c=K9(n,l,i[0],"min");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const cAe={kernelName:gS,backendName:"webgl",kernelFunc:uAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dAe=No+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,pAe=wn({opSnippet:dAe}),hAe={kernelName:s0,backendName:"webgl",kernelFunc:pAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fAe=No+"return log(x + sqrt(x * x + 1.0));",mAe=wn({opSnippet:fAe}),gAe={kernelName:a0,backendName:"webgl",kernelFunc:mAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yAe=No+`
  return atan(x);
`,xAe=wn({opSnippet:yAe}),bAe={kernelName:i0,backendName:"webgl",kernelFunc:xAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vAe=w3+`
  return atan(a, b);
`,wAe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Wh+`
  return result;
`,kAe=Zs({opSnippet:vAe,packedOpSnippet:wAe}),IAe={kernelName:l0,backendName:"webgl",kernelFunc:kAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SAe=No+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,CAe=wn({opSnippet:SAe}),NAe={kernelName:o0,backendName:"webgl",kernelFunc:CAe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cv{constructor(t,n,r,s=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,d=t.effectiveFilterHeight,p=t.effectiveFilterWidth,h=t.padInfo.top,m=t.padInfo.left;this.outputShape=t.outShape;const g=n==="avg",y=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,b=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let v="0.0";if(g||(v="-1.0 / 1e-20"),r){const A=">=";this.userCode=`
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${h}, ${m});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${A} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?a?y:b:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const k="max";let I=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(I="avgValue / max(count, 1.0)");const S=Math.floor(i/4)*4,N=i%4,T=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${h}, ${m});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${S}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${T}
          }

          int xC = xCCorner + ${S};
          if (${N===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${N===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${N===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${T}
          }
        }
        setOutput(${I});
      }
    `}}class I3{constructor(t,n,r,s=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,d=t.dilationHeight,p=t.dilationWidth,h=t.effectiveFilterDepth,m=t.effectiveFilterHeight,g=t.effectiveFilterWidth,y=t.padInfo.front,b=t.padInfo.top,v=t.padInfo.left;this.outputShape=t.outShape;const k=n==="avg";let I="0.0";if(k||(I="-1.0 / 1e-20"),r){const D=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${l}, ${u});
        const ivec3 pads = ivec3(${y}, ${b}, ${v});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${m};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${D} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?a?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${m} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let N=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(N="avgValue / max(count, 1.0)");const T=Math.floor(i/4)*4,A=i%4,R=`
      if (${k}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${l}, ${u});
      const ivec3 pads = ivec3(${y}, ${b}, ${v});
      const float initializationValue = ${I};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${I});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${T}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${R}
            }

            int xC = xCCorner + ${T};
            if (${A===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${A===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${A===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${R}
            }
          }
        }
        setOutput(${N});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TAe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;y1(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Y(ua(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=So(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&Dn(c.inShape,c.outShape))return Si({inputs:{x:s},backend:n});const d=new Cv(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}const $Ae={kernelName:yS,backendName:"webgl",kernelFunc:TAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EAe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],d=Hu(s.shape,a,i,c,o,l,u),p=new I3(d,"avg",!1);return n.runWebGLProgram(p,[s],"float32")}const _Ae={kernelName:xS,backendName:"webgl",kernelFunc:EAe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AAe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,a=t.strideWidth,i=t.dilationHeight,o=t.dilationWidth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=l-1-t.padInfo.top,d=u-1-t.padInfo.left,p=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${d});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class RAe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterDepth,r=t.filterHeight,s=t.filterWidth,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,h=t.effectiveFilterWidth,m=d-1-t.padInfo.front,g=p-1-t.padInfo.top,y=h-1-t.padInfo.left,b=1/(n*r*s);this.userCode=`
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DAe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],p=Hu(i.shape,o,l,d,u,c),h=new RAe(p);return n.runWebGLProgram(h,[s],i.dtype)}const FAe={kernelName:eD,backendName:"webgl",kernelFunc:DAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OAe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;y1([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=So(i.shape,o,l,1,u),d=new AAe(c);return n.runWebGLProgram(d,[s],i.dtype)}const MAe={kernelName:QR,backendName:"webgl",kernelFunc:OAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LAe(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return yI({a:s,b:a,transposeA:i,transposeB:o,backend:n})}const PAe={kernelName:bS,backendName:"webgl",kernelFunc:LAe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zAe{constructor(t,n,r,s,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],Jt(t,n),Jt(t,r);let o="0.0";s!=null&&(Jt(t,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";a!=null&&(Jt(t,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BAe{constructor(t,n,r,s,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Jt(t,n),Jt(t,r);let o="vec4(0.0)";s!=null&&(Jt(t,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";a!=null&&(Jt(t,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WAe=({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:o}=e;Y(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Y(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Y(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const u=[r,s,a];let c=null;i!=null&&(c=i.shape,u.push(i));let d=null;o!=null&&(d=o.shape,u.push(o));const p=$e().getBool("WEBGL_PACK_NORMALIZATION")?new BAe(r.shape,s.shape,a.shape,c,d,l):new zAe(r.shape,s.shape,a.shape,c,d,l);return t.runWebGLProgram(p,u,u[0].dtype)},VAe={kernelName:AS,backendName:"webgl",kernelFunc:WAe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UAe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const n=Qn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=GAe(this.rank);let s;const a=t.map((i,o)=>`sourceLoc.${pA[o]} = start[${o}] + coords.${pA[o]};`);s=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const pA=["x","y","z","w","u","v"];function GAe(e){if(e===1)return"sourceLoc";if(e<=6)return pA.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jAe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Qn(this.rank),r=Sa("coords",this.rank),s=Sa("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${a})`,o=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${i};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${n}(${t.map((c,d)=>`start[${d}]`).join()});`:t.map((c,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HAe(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=xF(t,_t(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}function Cy(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=wC(s,a,i);if(mF(s,o,l),Oe(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){const d=n.texData.get(s.dataId),p=PEe(d.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,p)}const{isPacked:u}=n.texData.get(s.dataId),c=yF(s.shape,o,l);if(u||!c){const d=$e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jAe(l):new UAe(l),p=[o];return n.runWebGLProgram(d,[s],s.dtype,p)}return n.uploadToGPU(s.dataId),HAe(s,o,l,n)}const qAe={kernelName:iC,backendName:"webgl",kernelFunc:Cy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KAe=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;Y(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((v,k)=>v*k),l=s1(s.shape,a,o),u=a1(l.length,a.length),c=i1(s.shape,a,o),d=IF(i,a.length),p=SF(c,i,a.length),h=[],m=nt({inputs:{x:s},backend:n,attrs:{shape:l}}),g=Ea({inputs:{x:m},backend:n,attrs:{perm:u}}),y=nt({inputs:{x:g},backend:n,attrs:{shape:c}}),b=Cy({inputs:{x:y},backend:n,attrs:{begin:d,size:p}});return h.push(m),h.push(g),h.push(y),h.forEach(v=>n.disposeIntermediateTensorInfo(v)),b},XAe={kernelName:vS,backendName:"webgl",kernelFunc:KAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YAe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=O9(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}const ZAe={kernelName:tD,backendName:"webgl",kernelFunc:YAe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JAe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,QAe=`
  return float(int(a.r) & int(b.r));
`;function eRe(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=$e().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=$e().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||i===1){const l=n.texData.get(r.dataId).values,u=n.texData.get(s.dataId).values,[c,d]=lEe(r.shape,s.shape,l,u,r.dtype),p=n.makeTensorInfo(d,r.dtype),h=n.texData.get(p.dataId);return h.values=c,p}let o;return a?o=new Iy(JAe,r.shape,s.shape,!1):o=new dh(QAe,r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}const tRe={kernelName:nD,backendName:"webgl",kernelFunc:eRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nRe(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=Jt(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const rRe={kernelName:B5,backendName:"webgl",kernelFunc:nRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sRe="return float(a != b);",X9=Zs({opSnippet:sRe,cpuKernelImpl:EEe,dtype:"bool"}),aRe={kernelName:KS,backendName:"webgl",kernelFunc:X9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b1(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return Si({inputs:{x:s.complexTensorInfos.real},backend:n})}const iRe={kernelName:TD,backendName:"webgl",kernelFunc:b1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oRe="return float(int(x));";function lRe(e,t){const n=new Pl(e.shape,oRe),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hA(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return Si({inputs:{x:s},backend:n});const i=Es(s.shape),o=hA({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Ed({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(s.dtype==="complex64"){const i=b1({inputs:{input:s},backend:n}),o=hA({inputs:{x:i},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(i),o}if(!O5(s.dtype,a)){const i=Si({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(n.shouldExecuteOnCPU([s])){const i=n.texData.get(s.dataId).values,[o,l,u]=uEe(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}if(a==="int32")return lRe(s,n);if(a==="bool"){const i=n.makeTensorInfo([],"bool",sa("bool",1)),l=X9({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}const uRe={kernelName:u0,backendName:"webgl",kernelFunc:hA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JV="return ceil(x);",cRe=wn({opSnippet:JV,packedOpSnippet:JV,cpuKernelImpl:cEe}),dRe={kernelName:c0,backendName:"webgl",kernelFunc:cRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pRe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hRe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;$e().getBool("WEBGL_PACK_CLIP")?o=new hRe(s.shape):o=new pRe(s.shape);const l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}const mRe={kernelName:d0,backendName:"webgl",kernelFunc:fRe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gRe{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QV(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function yRe(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new gRe(r.shape),i=[QV(r,s.complexTensorInfos.real),QV(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}const xRe={kernelName:wS,backendName:"webgl",kernelFunc:yRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bRe{constructor(t){this.outputShape=[],this.outputShape=Gl(t,1),this.variableNames=t.map((i,o)=>`T${o}`);const n=new Array(t.length-1);n[0]=t[0][1];for(let i=1;i<n.length;i++)n[i]=n[i-1]+t[i][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<n.length;i++){const o=n[i-1];r.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${o}));`)}const s=n.length,a=n[n.length-1];r.push(`else setOutput(getT${s}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vRe{constructor(t,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Gl(t,n);const r=this.outputShape,s=r.length,a=Qn(s),i=Sa("coords",s),o=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((g,y)=>`T${y}`);const l=new Array(t.length-1);l[0]=t[0][n];for(let g=1;g<l.length;g++)l[g]=l[g-1]+t[g][n];const u=o[n],c=o.slice(-2),d=o.join();let p=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${c.join()}));
        }`;for(let g=1;g<l.length;g++){const y=l[g-1];p+=`
        if (${u} < ${l[g]}  && ${u} >= ${l[g-1]}) {
          return getChannel(
            getT${g}(${qk(o,u,y)}),
            vec2(${qk(c,u,y)}));
        }`}const h=l.length,m=l[l.length-1];p+=`
        return getChannel(
          getT${h}(${qk(o,u,m)}),
          vec2(${qk(c,u,m)}));`,this.userCode=`
      float getValue(${o.map(g=>"int "+g)}) {
        ${p}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[s-1]} = ${i[s-1]} + 1;
        if (${i[s-1]} < ${r[s-1]}) {
          result.g = getValue(${i});
        }

        ${i[s-2]} = ${i[s-2]} + 1;
        if (${i[s-2]} < ${r[s-2]}) {
          result.a = getValue(${i});
        }

        ${i[s-1]} = ${i[s-1]} - 1;
        if (${i[s-2]} < ${r[s-2]} &&
            ${i[s-1]} < ${r[s-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function qk(e,t,n){const r=e.indexOf(t);return e.map((a,i)=>i===r?`${a} - ${n}`:a).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WC(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return Si({inputs:{x:s.complexTensorInfos.imag},backend:n})}const wRe={kernelName:bD,backendName:"webgl",kernelFunc:WC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jb(e,t,n){const r=e[0].dtype;if(r==="complex64"){const h=e.map(v=>b1({inputs:{input:v},backend:n})),m=e.map(v=>WC({inputs:{input:v},backend:n})),g=jb(h,t,n),y=jb(m,t,n),b=Ed({inputs:{real:g,imag:y},backend:n});return h.forEach(v=>n.disposeIntermediateTensorInfo(v)),m.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),b}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){const h=e.map(I=>{const N=[-1,Oe(I.shape.slice(t))];return nt({inputs:{x:I},backend:n,attrs:{shape:N}})}),m=h.map(I=>({vals:n.readSync(I.dataId),shape:I.shape})),g=Gl(h.map(I=>I.shape),1),y=h[0].shape[0]===1,b=dEe(m,g,r,y),v=Gl(e.map(I=>I.shape),t),k=n.makeTensorInfo(v,r,b);return h.forEach(I=>n.disposeIntermediateTensorInfo(I)),k}const a=e.filter(h=>Oe(h.shape)>0),i=$e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){const h=i?new Pl(e[0].shape,_c):new Mc(e[0].shape,_c);return n.runWebGLProgram(h,e,r)}const o=$e().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const h=[];for(let g=0;g<a.length;g+=o){const y=a.slice(g,g+o);h.push(jb(y,t,n))}const m=jb(h,t,n);for(const g of h)n.disposeIntermediateTensorInfo(g);return m}if(i){const h=new vRe(a.map(m=>m.shape),t);return n.runWebGLProgram(h,a,r)}const{tensors2D:l,outShape:u}=kRe(a,t,n),c=new bRe(l.map(h=>h.shape)),d=n.runWebGLProgram(c,l,r);l.forEach(h=>n.disposeIntermediateTensorInfo(h));const p=nt({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),p}function kRe(e,t,n){const r=Gl(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>nt({inputs:{x:a},attrs:{shape:[-1,Oe(a.shape.slice(t))]},backend:n})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y9(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=un(s,t[0].shape)[0],i=t.map(u=>u.shape);vF(i,a);const o=Gl(t.map(u=>u.shape),a);if(Oe(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter(u=>Oe(u.shape)>0);return l.length===1?Si({inputs:{x:l[0]},backend:n}):jb(l,a,n)}const IRe={kernelName:kS,backendName:"webgl",kernelFunc:Y9};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z9{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,o=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,d=t.dilationWidth,p=t.filterHeight,h=t.filterWidth,m=Math.floor(t.inChannels/4)*4,g=t.inChannels%4,y=t.dataFormat==="channelsLast",b=y?1:2,v=y?2:3,k=y?3:1;let I="",S="";r&&(s?I=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?I=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:I=`
          float activation(float x) {
            ${r}
          }
        `,S="result = activation(result);");const N=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${I}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${k}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${v}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${m}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${m}) *
                    getW(wR, wC, ${m}, d2);
              } else {
                dotProd +=
                    getX(batch, ${m}, xR, xC) *
                    getW(wR, wC, ${m}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2),
                getW(wR, wC, ${m} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1),
                  getX(batch, xR, xC, ${m} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC),
                  getX(batch, ${m} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${N}
        ${S}
        setOutput(result);
      }
    `}}class SRe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const n=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,d=t.filterDepth,p=t.filterHeight,h=t.filterWidth,m=Math.floor(t.inChannels/4)*4,g=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${i}, ${o});
      const ivec3 pads = ivec3(${n}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${m}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${m}) *
                  getW(wF, wR, wC, ${m}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1),
                  getX(batch, xF, xR, xC, ${m} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2),
                  getW(wF, wR, wC, ${m} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class J9{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=da(this.outputShape.length);const i=t.padInfo.left,o=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,d=c;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<c;y++)p+=`
           vec4 xTexelC${y*2};
           int xTexelC${y*2}Ready;
           vec4 xTexelC${y*2+1};
           int xTexelC${y*2+1}Ready;
           vec4 xC${y};`;p+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let y=0;y<c;y++)p+=`
           xTexelC${y*2} = vec4(0.0);
           xTexelC${y*2}Ready = 0;
           xTexelC${y*2+1} = vec4(0.0);
           xTexelC${y*2+1}Ready = 0;
           xC${y} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let y=0;y<(d+1)/2;y++){const b=y*2;if(p+=`
           xC = xCCorner + ${b*l};
           `,o===1){if(b<c&&(i%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,l===1&&b>0?p+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<c)){const v=i%2===0?GR(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${v};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,l>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:p+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):v===1?p+=`
                     xC${b+1} = xTexelC${b};
                     `:p+=`
                     xCOffset = xC + ${v};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<c&&(i%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<c&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<c&&(p+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<c&&(p+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<c&&(p+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let h="",m="";r&&(s?h=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:a?h=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:h=`vec4 activation(vec4 x) {
           ${r}
         }`,m="result = activation(result);");const g=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${h}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${m}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CRe{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=da(this.outputShape.length);const{dataFormat:r}=n,s=Da(),a=r==="channelsLast",i=a?1:2,o=a?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)u+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xI(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function Q9({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],p=n.outChannels,h=n.dataFormat==="channelsLast",m=!1,g=!1;let y;const b=[];if(a!=null){const I=xI(a.shape,h);I!=null&&(a=nt({inputs:{x:a},backend:r,attrs:{shape:I}}),b.push(a))}if(s!=null){const I=xI(s.shape,h);I!=null&&(s=nt({inputs:{x:s},backend:r,attrs:{shape:I}}),b.push(s))}if(!((d===1||p===1)&&c>j9)&&u.isPacked&&h&&u.texture!=null&&l[2]%2!==0&&Dn(u.shape.slice(-3),l.slice(-3))){const I=l[0]*l[1]*(l[2]+1),S={dataId:e.dataId,shape:[1,I,n.inChannels],dtype:e.dtype},N=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Y(gI(u.shape,S.shape),()=>`packed reshape ${u.shape} to ${S.shape} isn't free`);const T=nt({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});b.push(T);const A=yI({a:S,b:T,backend:r,transposeA:m,transposeB:g,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),R=r.texData.get(A.dataId);Y(R.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=N,R.shape=n.outShape,y=Si({inputs:{x:A},backend:r}),y.shape=n.outShape,b.push(A)}else{const I=n.outHeight*n.outWidth,S=nt({inputs:{x:e},backend:r,attrs:{shape:h?[n.batchSize,I,n.inChannels]:[n.batchSize,n.inChannels,I]}}),N=nt({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),T=yI({a:h?S:N,b:h?N:S,transposeA:!h,transposeB:g,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});y=nt({inputs:{x:T},backend:r,attrs:{shape:n.outShape}}),b.push(S),b.push(N),b.push(T)}for(const I of b)r.disposeIntermediateTensorInfo(I);return y}function eK({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:p,dataFormat:h}=n,m=h==="channelsLast",g=l*u*c,y=p*d,b=[n.batchSize,g,y],v=!0,k=!1,I=[];if(a!=null){const B=xI(a.shape,m);B!=null&&(a=nt({inputs:{x:a},backend:r,attrs:{shape:B}}),I.push(a))}if(s!=null){const B=xI(s.shape,m);B!=null&&(s=nt({inputs:{x:s},backend:r,attrs:{shape:B}}),I.push(s))}const S=nt({inputs:{x:t},backend:r,attrs:{shape:[1,g,Oe(t.shape)/g]}});I.push(S);const N=new CRe(b,n),T=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],A=r.runWebGLProgram(N,[e],"float32",T),R=nt({inputs:{x:A},backend:r,attrs:{shape:b}});I.push(A),I.push(R);const D=s!=null,$=a!=null,_=o==="leakyrelu",L=o?Sv(o,!0):null,z=new G9(m?R.shape:S.shape,m?S.shape:R.shape,m?[n.batchSize,y,n.outChannels]:[n.batchSize,n.outChannels,y],v,k,D,L,$,_),W=m?[R,S]:[S,R];if(s&&W.push(s),$&&W.push(a),_){const B=r.makeTensorInfo([],"float32",wd(i,"float32"));W.push(B),I.push(B)}const G=r.runWebGLProgram(z,W,"float32"),q=nt({inputs:{x:G},backend:r,attrs:{shape:n.outShape}});I.push(G);for(const B of I)r.disposeIntermediateTensorInfo(B);return q}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=qu(l),p=Xs(s.shape,a.shape,i,u,o,c,!1,d);let h;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))h=Q9({x:s,filter:a,convInfo:p,backend:n});else if(p.strideWidth<=2&&d==="channelsLast"&&$e().getBool("WEBGL_EXP_CONV")){const g=new J9(p),y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];h=n.runWebGLProgram(g,[s,a],"float32",y)}else if($e().getBool("WEBGL_CONV_IM2COL"))h=eK({x:s,filter:a,convInfo:p,backend:n});else{const g=new Z9(p);h=n.runWebGLProgram(g,[s,a],"float32")}const m=nt({inputs:{x:h},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(h),m}const TRe={kernelName:IS,backendName:"webgl",kernelFunc:NRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Re{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,r=t.strideWidth,s=t.padInfo.top,a=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class ERe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,a=t.strideWidth,i=t.dataFormat==="channelsLast",o=n-1-t.padInfo.top,l=r-1-t.padInfo.left,u=i?1:2,c=i?2:3,d=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class _Re{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideDepth,r=t.strideHeight,s=t.strideWidth,a=t.padInfo.front,i=t.padInfo.top,o=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${a};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${o};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class ARe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterDepth,r=t.filterHeight,s=t.filterWidth,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,l=n-1-t.padInfo.front,u=r-1-t.padInfo.top,c=s-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=qu(l),p=Xs(s.shape,c,i,1,o,u,!1,d),h=new $Re(p);return n.runWebGLProgram(h,[s,a],"float32")}const DRe={kernelName:sD,backendName:"webgl",kernelFunc:RRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FRe{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=da(this.outputShape.length);const n=t.filterHeight,r=t.filterWidth,s=n-1-t.padInfo.top,a=r-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ORe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=qu(u),p=Xs(i,a.shape,o,1,l,c,!1,d);if($e().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const h=[[p.strideHeight,p.strideWidth]],m=new FRe(p);return n.runWebGLProgram(m,[s,a],"float32",h)}else{const h=new ERe(p);return n.runWebGLProgram(h,[s,a],"float32")}}const MRe={kernelName:SS,backendName:"webgl",kernelFunc:ORe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=kd(s.shape,a.shape,i,l,o),c=new SRe(u);return n.runWebGLProgram(c,[s,a],"float32")}const PRe={kernelName:CS,backendName:"webgl",kernelFunc:LRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=kd(s.shape,l,i,1,o),c=new _Re(u);return n.runWebGLProgram(c,[s,a],"float32")}const BRe={kernelName:aD,backendName:"webgl",kernelFunc:zRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WRe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=kd(l,a.shape,o,1,i),c=new ARe(u);return n.runWebGLProgram(c,[s,a],"float32")}const VRe={kernelName:iD,backendName:"webgl",kernelFunc:WRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const URe=Sy+`
  return cos(x);
`,GRe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Wh}
  return result;
`,jRe=wn({opSnippet:URe,packedOpSnippet:GRe}),HRe={kernelName:p0,backendName:"webgl",kernelFunc:jRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qRe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,KRe=wn({opSnippet:qRe}),XRe={kernelName:h0,backendName:"webgl",kernelFunc:KRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YRe{constructor(t,n,r,s,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,o,l,u]=t,[c]=n,[d,p]=r;this.outputShape=[c,d,p,u];const h=s==="bilinear"?1:0,[m,g]=[`${o-1}.0`,`${l-1}.0`],[y,b,v]=d>1?[`${(o-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[k,I,S]=p>1?[`${(l-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${k});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${I};

        float in_y = ${v};
        if( in_y < 0.0 || in_y > ${m} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${S};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZRe=e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new YRe(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")},JRe={kernelName:lD,backendName:"webgl",kernelFunc:ZRe};var Nv;(function(e){e.Prod="*",e.Sum="+"})(Nv||(Nv={}));class eU{constructor(t,n,r,s){this.op=t,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,i=this.op===Nv.Prod?"1.0":"0.0",o=r?i:`getX(${tU(a,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";r?(u=s?`end != ${l-1}`:"end != 0",c=s?"end + 1":"end - 1"):(u=s?`end + pow2 < ${l}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Qn(a)} coords = getOutputCoords();
        int end = ${nU(a,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${nU(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${tU(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function tU(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function nU(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tK(e,t,n,r,s,a){const i=t.shape.length,o=_r([r],i);let l=t;o!=null&&(l=Ea({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=zr(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=Si({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(c))-1;p++){const h=new eU(e,l.shape,!1,a),m=[[p]],g=d;d=n.runWebGLProgram(h,[d],d.dtype,m),n.disposeIntermediateTensorInfo(g)}if(s){const p=new eU(e,l.shape,s,a),h=d;d=n.runWebGLProgram(p,[d],d.dtype),n.disposeIntermediateTensorInfo(h)}if(o!=null){const p=Id(o),h=Ea({inputs:{x:d},backend:n,attrs:{perm:p}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),h}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return tK(Nv.Prod,s,n,a,i,o)}const eDe={kernelName:oD,backendName:"webgl",kernelFunc:QRe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tDe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return tK(Nv.Sum,s,n,a,i,o)}const nDe={kernelName:NS,backendName:"webgl",kernelFunc:tDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rDe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){const l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=O9(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){const l=n.bufferSync(s),u=n.bufferSync(a),c=oEe(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const sDe={kernelName:uD,backendName:"webgl",kernelFunc:rDe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aDe{constructor(t,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iDe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],u=i==="NHWC"?s.shape[2]:s.shape[3],c=i==="NHWC"?s.shape[3]:s.shape[1],d=l*a,p=u*a,h=c/(a*a),m=i==="NHWC"?[o,d,p,h]:[o,h,d,p],g=new aDe(m,a,i);return n.runWebGLProgram(g,[s],s.dtype)}const oDe={kernelName:cD,backendName:"webgl",kernelFunc:iDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nK{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=da(this.outputShape.length);const i=t.filterHeight,o=t.filterWidth,l=t.outChannels/t.inChannels;let u="",c="";r&&(s?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:u=`
          float activation(float x) {
            ${r}
          }
        `,c="result = activation(result);");const d=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rK{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=da(this.outputShape.length);const i=t.outChannels/t.inChannels,o=t.padInfo.left,l=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,d=t.filterWidth,p=d;let h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<d;b++)h+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;h+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let b=0;b<d;b++)h+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(p+1)/2;b++){const v=b*2;if(h+=`
          xC = xCCorner + ${v*u};
          `,l===1){if(v<d&&(o%2===1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }
              `,u===1&&v>0?h+=`
                xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                  } else {
                    xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xC${v} = xTexelC${v};
                `,v+1<d)){const k=o%2===0?GR(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${k};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                    xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${v+1}.zw = vec2(0.0);
                    }
                    xTexelC${v+1}Ready = 1;
                  }
                  `,u>1?h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                    } else {
                     xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                    }
                    `:h+=`
                    xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                    `):k===1?h+=`
                    xC${v+1} = xTexelC${v};
                    `:h+=`
                    xCOffset = xC + ${k};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                      xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${v+1}.zw = vec2(0.0);
                      }
                      xTexelC${v+1}Ready = 1;
                    }

                    xC${v+1} = xTexelC${v+1};
                    `}}else v<d&&(o%2===1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.0);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
              `,v+1<d&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(
                  xTexelC${v}.xy, xTexelC${v+1}.xy);
              `,v+1<d&&(h+=`
                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                `)));v<d&&(h+=`
            wTexel = getW(r, ${v}, d1, q);
            dotProd += xC${v} * vec4(wTexel.xz, wTexel.xz);
          `,v+1<d&&(h+=`
              wTexel = getW(r, ${v+1}, d1, q);
              dotProd += xC${v+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let m="",g="";r&&(s?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:m=`vec4 activation(vec4 x) {
          ${r}
        }`,g="result = activation(result);");const y=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${m}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lDe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;c==null&&(c=[1,1]),Y(ua(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=Xs(s.shape,a.shape,i,c,o,u,!0);let p;$e().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?p=new rK(d):p=new nK(d);const h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(p,[s,a],"float32",h)}const uDe={kernelName:TS,backendName:"webgl",kernelFunc:lDe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cDe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,r=t.strideWidth,s=t.padInfo.top,a=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class dDe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,a=t.strideWidth,i=n-1-t.padInfo.top,o=r-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pDe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=Xs(s.shape,c,i,o,l,u,!0),p=new cDe(d);return n.runWebGLProgram(p,[s,a],"float32")}const hDe={kernelName:dD,backendName:"webgl",kernelFunc:pDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fDe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=Xs(c,a.shape,i,o,l,u,!0),p=new dDe(d);return n.runWebGLProgram(p,[s,a],"float32")}const mDe={kernelName:pD,backendName:"webgl",kernelFunc:fDe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gDe{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yDe(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=Oe(r.shape),i=nt({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new gDe(a),l=n.runWebGLProgram(o,[i],i.dtype),u=nt({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}const xDe={kernelName:W5,backendName:"webgl",kernelFunc:yDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bDe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:n,inWidth:r,padInfo:s,strideHeight:a,strideWidth:i,filterHeight:o,filterWidth:l,dilationHeight:u,dilationWidth:c}=t,{top:d,left:p}=s;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${i});
      const ivec2 pads = ivec2(${d}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vDe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=Q0(s.shape,a.shape,i,o,"NHWC",l);let c;const d=new bDe(u);c=n.runWebGLProgram(d,[s,a],"float32");const p=nt({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),p}const wDe={kernelName:$S,backendName:"webgl",kernelFunc:vDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kDe(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=RF(s,a.length);FF(i.length,l,a);const{path:u,steps:c}=OF(o,l),d=c.length;let p=null,h=i.length;const m=[];for(let g=0;g<d;++g){for(const y of c[g]){const{permutationIndices:b,expandDims:v}=DF(h,l[y]);let k;MF(b)?k=a[y]:(k=Ea({inputs:{x:a[y]},backend:n,attrs:{perm:b}}),m.push(k));const I=k.shape.slice();for(let S=0;S<v.length;++S)I.splice(v[S],0,1);Dn(k.shape,I)||(k=nt({inputs:{x:k},backend:n,attrs:{shape:I}}),m.push(k)),p===null?p=k:(p=k3({inputs:{a:k,b:p},backend:n}),m.push(p))}g<d-1&&(u[g]>=0&&(p=BC({inputs:{x:p},backend:n,attrs:{axis:u[g]-(i.length-h),keepDims:!1}}),m.push(p)),h--)}for(const g of m)g!==p&&n.disposeIntermediateTensorInfo(g);return p}const IDe={kernelName:hD,backendName:"webgl",kernelFunc:kDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SDe="return (x >= 0.0) ? x : (exp(x) - 1.0);",CDe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,NDe=wn({opSnippet:SDe,packedOpSnippet:CDe}),TDe={kernelName:m0,backendName:"webgl",kernelFunc:NDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $De="return (b >= 0.0) ? a : a * (b + 1.0);",EDe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,_De=e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=$e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Iy(EDe,r.shape,s.shape):new dh($De,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)},ADe={kernelName:fD,backendName:"webgl",kernelFunc:_De};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RDe=`
  return vec4(equal(a, b));
`,DDe="return float(a == b);",FDe=Zs({opSnippet:DDe,packedOpSnippet:RDe,dtype:"bool",cpuKernelImpl:pEe}),ODe={kernelName:ES,backendName:"webgl",kernelFunc:FDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MDe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${CF};
  float a1 = ${NF};
  float a2 = ${TF};
  float a3 = ${$F};
  float a4 = ${EF};
  float a5 = ${_F};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,LDe=wn({opSnippet:MDe}),PDe={kernelName:g0,backendName:"webgl",kernelFunc:LDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zDe=Sy+`
  return exp(x);
`,BDe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,sK=wn({opSnippet:zDe,packedOpSnippet:BDe,cpuKernelImpl:hEe,dtype:"float32"}),WDe={kernelName:y0,backendName:"webgl",kernelFunc:sK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fA(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(Y(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),nt({inputs:{x:a},backend:r,attrs:{shape:o}})}const VDe={kernelName:_S,backendName:"webgl",kernelFunc:fA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rU="return exp(x) - 1.0;",UDe=wn({opSnippet:rU,packedOpSnippet:rU,cpuKernelImpl:fEe}),GDe={kernelName:x0,backendName:"webgl",kernelFunc:UDe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sU{constructor(t,n,r){this.variableNames=["real","imag"];const s=n[1];this.outputShape=n;const a=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let o;if(t==="real")o="return real * expR - imag * expI;";else if(t==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aK(e,t,n){const r=n.texData.get(e.dataId),s=Oe(e.shape),a=e.shape[e.shape.length-1],i=s/a,o=nt({inputs:{x:e},backend:n,attrs:{shape:[i,a]}}),l=o.shape,u=new sU("real",l,t),c=new sU("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],p=n.runWebGLProgram(u,d,"float32"),h=n.runWebGLProgram(c,d,"float32"),m=Ed({inputs:{real:p,imag:h},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h);const g=nt({inputs:{x:m},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(m),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jDe(e){const{inputs:t,backend:n}=e,{input:r}=t;return aK(r,!1,n)}const HDe={kernelName:mD,backendName:"webgl",kernelFunc:jDe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qDe{constructor(t,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v1(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||ly(s),a==="string"){const i=Mr(a,Oe(r));return i.fill(s),t.makeTensorInfo(r,a,i)}else{const i=new qDe(r,s),o=[[s]];return t.runWebGLProgram(i,[],a,o)}}const KDe={kernelName:gD,backendName:"webgl",kernelFunc:v1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XDe{constructor(t){this.variableNames=["Image"],this.outputShape=[];const n=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YDe={kernelName:yD,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new XDe(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aU="return floor(x);",ZDe=wn({opSnippet:aU,packedOpSnippet:aU,cpuKernelImpl:mEe}),JDe={kernelName:b0,backendName:"webgl",kernelFunc:ZDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QDe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,eFe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,tFe=Zs({opSnippet:QDe,packedOpSnippet:eFe,dtype:"int32"}),nFe={kernelName:v0,backendName:"webgl",kernelFunc:tFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rFe{constructor(t){this.variableNames=["A"];const n=Da(),[r,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sFe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Da(),[r,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aFe={kernelName:M_,backendName:"webgl",kernelFunc:iFe};let Qm,OE=$e().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function iFe(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,a];if(o||i){const g=$e().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Qm==null||g!==OE)&&(OE=g,Qm=document.createElement("canvas").getContext("2d",{willReadFrequently:OE})),Qm.canvas.width=l,Qm.canvas.height=u,Qm.drawImage(s,0,0,l,u),s=Qm.canvas}const p=n.makeTensorInfo(c,"int32");n.texData.get(p.dataId).usage=zi.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),s);const h=$e().getBool("WEBGL_PACK")?new sFe(d):new rFe(d),m=n.runWebGLProgram(h,[p],"int32");return n.disposeData(p.dataId),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oFe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=r,g=qu(c),y=Xs(s.shape,a.shape,l,d,u,p,!1,g);let b;const v=[],k=i!=null,I=o!=null,S=h==="leakyrelu",N=()=>{const A=[s,a],R=(D,$)=>{if($==="NCHW"&&D.shape.length===1&&D.shape[0]!==1){const _=nt({inputs:{x:D},backend:n,attrs:{shape:[D.shape[0],1,1]}});return v.push(_),_}return D};if(k&&A.push(R(i,c)),I&&A.push(R(o,c)),S){const D=n.makeTensorInfo([],"float32",wd(m,"float32"));A.push(D),v.push(D)}return A};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))b=Q9({x:s,filter:a,convInfo:y,backend:n,bias:i,activation:h,preluActivationWeights:o,leakyreluAlpha:m});else if(y.strideWidth<=2&&g==="channelsLast"&&$e().getBool("WEBGL_EXP_CONV")){const A=h?Sv(h,!0):null,R=new J9(y,k,A,I,S),D=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],$=N();b=n.runWebGLProgram(R,$,"float32",D)}else if($e().getBool("WEBGL_CONV_IM2COL"))b=eK({x:s,filter:a,convInfo:y,backend:n,bias:i,activation:h,preluActivationWeights:o,leakyreluAlpha:m});else{const A=h?Sv(h,!1):null,R=new Z9(y,k,A,I,S),D=N();b=n.runWebGLProgram(R,D,"float32")}const T=nt({inputs:{x:b},backend:n,attrs:{shape:y.outShape}});return v.push(b),v.forEach(A=>n.disposeIntermediateTensorInfo(A)),T}const lFe={kernelName:K2,backendName:"webgl",kernelFunc:oFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uFe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:h}=r,m=[];let g=c;g==null&&(g=[1,1]),Y(ua(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const y=Xs(s.shape,a.shape,l,g,u,d,!0),b=$e().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,v=p?Sv(p,b):null,k=[s,a],I=i!=null,S=o!=null,N=p==="leakyrelu";if(I&&k.push(i),S&&k.push(o),N){const D=n.makeTensorInfo([],"float32",wd(h,"float32"));k.push(D),m.push(D)}let T;b?T=new rK(y,I,v,S,N):T=new nK(y,I,v,S,N);const A=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],R=n.runWebGLProgram(T,k,"float32",A);return m.forEach(D=>n.disposeIntermediateTensorInfo(D)),R}const cFe={kernelName:ij,backendName:"webgl",kernelFunc:uFe};class dFe{constructor(t,n,r,s){this.sliceDim=t,this.strides=n,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const a=Qn(r.length);let i=`
    int index;`;for(let o=0;o<this.sliceDim;o++)i+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pFe(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=Oe(r.shape),[l,u,c,d]=fF(r,s),p=nt({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),h=nt({inputs:{x:r},backend:n,attrs:{shape:[Oe(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const b=n.readSync(s.dataId),v=n.bufferSync(r),k=gEe(b,v,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,k.values)}const m=new dFe(i,d,[u,c],r.shape),g=n.runWebGLProgram(m,[h,p],h.dtype),y=nt({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),y}const hFe={kernelName:V5,backendName:"webgl",kernelFunc:pFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fFe{constructor(t,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=Qn(this.rank),s=mFe(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}}function mFe(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iK(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=un(i,s.shape)[0];if($e().get("DEBUG")){const v=n.readSync(a.dataId),k=s.shape[l];for(let I=0;I<v.length;++I){const S=v[I];Y(S<=k-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${k-1}]`)}}const u=PF(s,a,l,o),c=Oe(a.shape),d=[],p=nt({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),h=nt({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(p),d.push(h);const m=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||s.dtype==="string"){const v=n.bufferSync(h),k=n.bufferSync(p),I=yEe(k,v,m);return d.forEach(S=>n.disposeIntermediateTensorInfo(S)),n.makeTensorInfo(u.outputShape,I.dtype,I.values)}const g=new fFe(p.shape,m),y=n.runWebGLProgram(g,[p,h],p.dtype);d.push(y);const b=nt({inputs:{x:y},backend:n,attrs:{shape:u.outputShape}});return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),b}const gFe={kernelName:RS,backendName:"webgl",kernelFunc:iK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yFe="return float(a > b);",xFe=`
  return vec4(greaterThan(a, b));
`,bFe=Zs({opSnippet:yFe,packedOpSnippet:xFe,cpuKernelImpl:xEe,dtype:"bool"}),vFe={kernelName:DS,backendName:"webgl",kernelFunc:bFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wFe="return float(a >= b);",kFe=`
  return vec4(greaterThanEqual(a, b));
`,IFe=Zs({opSnippet:wFe,packedOpSnippet:kFe,dtype:"bool",cpuKernelImpl:bEe}),SFe={kernelName:w0,backendName:"webgl",kernelFunc:IFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CFe(e){const{inputs:t,backend:n}=e,{input:r}=t;return aK(r,!0,n)}const NFe={kernelName:xD,backendName:"webgl",kernelFunc:CFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TFe="return float(!isnan(x) && !isinf(x));",$Fe=wn({opSnippet:TFe,dtype:"bool"}),EFe={kernelName:I0,backendName:"webgl",kernelFunc:$Fe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Fe="return float(isinf(x));",AFe=wn({opSnippet:_Fe,dtype:"bool"}),RFe={kernelName:S0,backendName:"webgl",kernelFunc:AFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DFe="return float(isnan(x));",FFe=wn({opSnippet:DFe,dtype:"bool"}),OFe={kernelName:C0,backendName:"webgl",kernelFunc:FFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MFe="return float(a < b);",LFe=`
  return vec4(lessThan(a, b));
`,PFe=Zs({opSnippet:MFe,packedOpSnippet:LFe,cpuKernelImpl:vEe,dtype:"bool"}),zFe={kernelName:OS,backendName:"webgl",kernelFunc:PFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BFe="return float(a <= b);",WFe=`
  return vec4(lessThanEqual(a, b));
`,VFe=Zs({opSnippet:BFe,packedOpSnippet:WFe,cpuKernelImpl:wEe,dtype:"bool"}),UFe={kernelName:MS,backendName:"webgl",kernelFunc:VFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GFe(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=kEe(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}const jFe={kernelName:U5,backendName:"webgl",kernelFunc:GFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HFe=Sy+`
  return x < 0.0 ? 0./0. : log(x);
`,qFe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,KFe=wn({opSnippet:HFe,packedOpSnippet:qFe,cpuKernelImpl:IEe}),XFe={kernelName:N0,backendName:"webgl",kernelFunc:KFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YFe=Sy+`
  return log(1.0 + x);
`,ZFe=wn({opSnippet:YFe}),JFe={kernelName:T0,backendName:"webgl",kernelFunc:ZFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QFe="return float(a >= 1.0 && b >= 1.0);",e3e=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,t3e=Zs({opSnippet:QFe,packedOpSnippet:e3e,dtype:"bool"}),n3e={kernelName:LS,backendName:"webgl",kernelFunc:t3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r3e="return float(!(x >= 1.0));",s3e=wn({opSnippet:r3e}),a3e={kernelName:PS,backendName:"webgl",kernelFunc:s3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i3e="return float(a >= 1.0 || b >= 1.0);",o3e=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,l3e=Zs({opSnippet:i3e,packedOpSnippet:o3e,dtype:"bool"}),u3e={kernelName:zS,backendName:"webgl",kernelFunc:l3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c3e{constructor(t,n,r,s,a){this.variableNames=["x"],this.outputShape=[];const i=n,o=t[3]-1;this.outputShape=t;let l;const u=`float(${r}) + float(${s}) * sum`;a===.5?l=`inversesqrt(${u})`:a===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d3e{constructor(t,n,r,s,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,o=t[3]-1;this.outputShape=t;let l;const u=`float(${r}) + float(${s}) * sum`;a===.5?l=`inversesqrt(${u})`:a===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p3e=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=$e().getBool("WEBGL_PACK_NORMALIZATION")?new d3e(s.shape,a,i,o,l):new c3e(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)},h3e={kernelName:BS,backendName:"webgl",kernelFunc:p3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f3e{constructor(t,n,r,s,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=n,this.bias=r,this.alpha=s,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m3e=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new f3e(s.shape,o,l,u,c);return n.runWebGLProgram(d,[s,a,i],s.dtype)},g3e={kernelName:vD,backendName:"webgl",kernelFunc:m3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y3e(e,t,n,r){const s=Oe(t),i=Oe(e.shape)/s,o=nt({inputs:{x:e},attrs:{shape:[i,s]},backend:r}),l=Vh(o,e.dtype,"max",r),u=nt({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oK(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=un(a,s.shape);let u=l;const c=_r(u,o),d=c!=null,p=n.shouldExecuteOnCPU([s]);let h=s;if(d){if(p){const k=n.texData.get(h.dataId).values,I=new Array(o);for(let T=0;T<I.length;T++)I[T]=s.shape[c[T]];const S=v3(k,s.shape,s.dtype,c,I);h=n.makeTensorInfo(I,s.dtype);const N=n.texData.get(h.dataId);N.values=S}else h=zC(s,c,n);u=zr(u.length,o)}Ys("max",u,o);const[m,g]=Os(h.shape,u);let y=m;i&&(y=Jr(m,l));let b;if(p){const k=n.texData.get(h.dataId).values,I=SEe(k,Oe(g),y,s.dtype);b=n.makeTensorInfo(y,s.dtype);const S=n.texData.get(b.dataId);S.values=I}else b=y3e(h,g,y,n);return d&&n.disposeIntermediateTensorInfo(h),b}const x3e={kernelName:WS,backendName:"webgl",kernelFunc:oK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b3e=w3+`
  return max(a, b);
`,v3e=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Wh+`
  return result;
`,w3e=Zs({opSnippet:b3e,packedOpSnippet:v3e,cpuKernelImpl:CEe}),k3e={kernelName:$0,backendName:"webgl",kernelFunc:w3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;y1(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Y(ua(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=So(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&Dn(c.inShape,c.outShape))return Si({inputs:{x:s},backend:n});const d=new Cv(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}const S3e={kernelName:VS,backendName:"webgl",kernelFunc:I3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C3e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],d=Hu(s.shape,a,i,c,o,u,l),p=new I3(d,"max",!1);return n.runWebGLProgram(p,[s],s.dtype)}const N3e={kernelName:US,backendName:"webgl",kernelFunc:C3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T3e{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideHeight,r=t.strideWidth,s=t.dilationHeight,a=t.effectiveFilterHeight,i=t.effectiveFilterWidth,o=a-1-t.padInfo.top,l=i-1-t.padInfo.left,u=a*i-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class $3e{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideDepth,r=t.strideHeight,s=t.strideWidth,a=t.dilationDepth,i=t.dilationHeight,o=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,d=l-1-t.padInfo.front,p=u-1-t.padInfo.top,h=c-1-t.padInfo.left,m=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${p}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${m} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E3e(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],p=Hu(i.shape,o,l,d,u,c),h=new I3(p,"max",!0),m=n.runWebGLProgram(h,[i],i.dtype),g=new $3e(p),y=n.runWebGLProgram(g,[s,m],i.dtype);return n.disposeIntermediateTensorInfo(m),y}const _3e={kernelName:kD,backendName:"webgl",kernelFunc:E3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A3e(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;y1([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,p=So(o.shape,l,u,1,c,d),h=!0,m=new Cv(p,"max",h),g=n.runWebGLProgram(m,[o],o.dtype),y=new T3e(p),b=n.runWebGLProgram(y,[s,g],o.dtype);return n.disposeIntermediateTensorInfo(g),b}const R3e={kernelName:wD,backendName:"webgl",kernelFunc:A3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D3e(e,t,n,r){let s=new Cv(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");s=new Cv(n,"max",!0,!0,t);const i=r.runWebGLProgram(s,[e],"float32");return[a,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F3e={kernelName:G5,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;Y(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];Y(ua(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=So(r.shape,s,a,u,i),[d,p]=D3e(r,o,c,l);return[d,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O3e(e,t,n,r){const s=Oe(t),i=Oe(e.shape)/s,o=nt({inputs:{x:e},attrs:{shape:[i,s]},backend:r}),l=Vh(o,"float32","mean",r),u=nt({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M3e={kernelName:GS,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,l=un(a,r.shape);let u=l;const c=_r(u,o),d=c!=null,p=i.shouldExecuteOnCPU([r]),h=[];let m=r;if(d){if(p){const I=i.texData.get(m.dataId).values,S=new Array(o);for(let A=0;A<S.length;A++)S[A]=r.shape[c[A]];const N=v3(I,r.shape,r.dtype,c,S);m=i.makeTensorInfo(S,r.dtype);const T=i.texData.get(m.dataId);T.values=N}else m=zC(r,c,i);h.push(m),u=zr(u.length,o)}Ys("sum",u,o);const[g,y]=Os(m.shape,u);let b=g;s&&(b=Jr(g,l));const v=O3e(m,y,b,i);for(const k of h)i.disposeIntermediateTensorInfo(k);return v}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L3e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=un(a,s.shape);let u=l;const c=_r(u,o);let d=s;c!=null&&(d=Ea({inputs:{x:s},backend:n,attrs:{perm:c}}),u=zr(u.length,s.shape.length)),Ys("min",u,o);const[p,h]=Os(d.shape,u),m=Oe(h),g=nt({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=Vh(g,g.dtype,"min",n);let b;if(i){const v=Jr(p,l);b=nt({inputs:{x:y},backend:n,attrs:{shape:v}})}else b=nt({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),c!=null&&n.disposeIntermediateTensorInfo(d),b}const P3e={kernelName:jS,backendName:"webgl",kernelFunc:L3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z3e=w3+`
  return min(a, b);
`,B3e=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Wh+`
  return result;
`,W3e=Zs({opSnippet:z3e,packedOpSnippet:B3e,cpuKernelImpl:NEe}),V3e={kernelName:E0,backendName:"webgl",kernelFunc:W3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U3e{constructor(t,n,r){this.variableNames=["x"],this.outputShape=n.map((c,d)=>c[0]+t[d]+c[1]);const s=t.length,a=Qn(s),i=n.map(c=>c[0]).join(","),o=n.map((c,d)=>c[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G3e{constructor(t,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((m,g)=>m[0]+t[g]+m[1]);const s=t.length,a=Qn(s),i=n.map(m=>m[0]).join(","),o=n.map((m,g)=>m[0]+t[g]).join(","),l=Sa("rc",s),u=Sa("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${u.slice(-2).join()})`,p=r==="reflect"?0:1;let h="";if(s===1){const m=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;h=`
        ${a} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${u.join()}), ${d});
        ${l[s-1]} += 1;
        if(${c}) {
          ${m}
          result[1] = getChannel(getX(${u.join()}), ${d});
        }
      `}else{const m=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;h=`
        ${a} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${u.join()}), ${d});
        ${l[s-1]} += 1;
        if(${c}) {
          ${m}
          result[1] = getChannel(getX(${u.join()}), ${d});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${m}
          result[2] = getChannel(getX(${u.join()}), ${d});
          ${l[s-1]} += 1;
          if(${c}) {
            ${m}
            result[3] = getChannel(getX(${u.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j3e=({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:a}=n,i=$e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new G3e(r.shape,s,a):new U3e(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)},H3e={kernelName:HS,backendName:"webgl",kernelFunc:j3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q3e=`if (b == 0.0) return NAN;
  return mod(a, b);`,K3e=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Wh+`
  return result;
`,X3e=Zs({opSnippet:q3e,packedOpSnippet:K3e}),Y3e={kernelName:_0,backendName:"webgl",kernelFunc:X3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z3e{constructor(t,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J3e=`
if (a == b) {
  return 1.0;
};
return a / b;`,Q3e=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,lK=Zs({opSnippet:J3e,packedOpSnippet:Q3e,checkOutOfBounds:!0}),eOe={kernelName:f0,backendName:"webgl",kernelFunc:lK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iU="return a - b;",uK=Zs({opSnippet:iU,packedOpSnippet:iU,supportsComplex:!0,cpuKernelImpl:qEe}),tOe={kernelName:H0,backendName:"webgl",kernelFunc:uK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cK(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=un([a],s.shape),o=oK({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=Jr(o.shape,i),u=nt({inputs:{x:o},backend:n,attrs:{shape:l}}),c=uK({inputs:{a:s,b:u},backend:n}),d=sK({inputs:{x:c},backend:n}),p=BC({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),h=nt({inputs:{x:p},backend:n,attrs:{shape:l}}),m=lK({inputs:{a:d,b:h},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),m}const nOe={kernelName:cC,backendName:"webgl",kernelFunc:cK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rOe(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:cK({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new Z3e(u,c,a),p=[[i]],h=n.runWebGLProgram(d,[l],"int32",p);return o||n.disposeIntermediateTensorInfo(l),h}const sOe={kernelName:j5,backendName:"webgl",kernelFunc:rOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aOe=No+`
  return -x;
`,iOe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function oOe(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const a=n.texData.get(r.dataId),[i,o]=$Ee(a.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let s;return $e().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Mc(r.shape,iOe):s=new Pl(r.shape,aOe),n.runWebGLProgram(s,[r],r.dtype)}const lOe={kernelName:qS,backendName:"webgl",kernelFunc:oOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uOe=uF;function cOe(e){Pi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=uOe(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const dOe={kernelName:ID,backendName:"webgl",kernelFunc:cOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pOe=cF;function hOe(e){Pi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),{selectedIndices:p,validOutputs:h}=pOe(c,d,i,o,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}const fOe={kernelName:SD,backendName:"webgl",kernelFunc:hOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mOe=dF;function gOe(e){Pi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),p=i,h=o,m=l,g=u,{selectedIndices:y,selectedScores:b}=mOe(c,d,p,h,m,g);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const yOe={kernelName:CD,backendName:"webgl",kernelFunc:gOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xOe{constructor(t,n,r,s){this.variableNames=["indices"],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bOe=e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=Oe(s.shape),c=new xOe(u,i,o,l),d=nt({inputs:{x:s},backend:n,attrs:{shape:[u]}}),p=n.runWebGLProgram(c,[d],a);n.disposeIntermediateTensorInfo(d);const h=[...s.shape,i],m=nt({inputs:{x:p},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(p),m},vOe={kernelName:YS,backendName:"webgl",kernelFunc:bOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bI(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){const s=b1({inputs:{input:r},backend:n}),a=bI({inputs:{x:s},backend:n}),i=WC({inputs:{input:r},backend:n}),o=bI({inputs:{x:i},backend:n}),l=Ed({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return v1({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const wOe={kernelName:hC,backendName:"webgl",kernelFunc:bI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dK(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=b1({inputs:{input:r},backend:n}),a=dK({inputs:{x:s},backend:n}),i=WC({inputs:{input:r},backend:n}),o=bI({inputs:{x:i},backend:n}),l=Ed({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return v1({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const kOe={kernelName:XS,backendName:"webgl",kernelFunc:dK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IOe(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return fA({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(c=>{jR(a,c.shape,"All tensors passed to stack must have matching shapes"),Y(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=t.map(c=>{const d=fA({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=Y9({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const SOe={kernelName:ZS,backendName:"webgl",kernelFunc:IOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class COe{constructor(t,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((u,c)=>u[0]+t[c]+u[1]);const s=t.length,a=Qn(s),i=n.map(u=>u[0]).join(","),o=n.map((u,c)=>u[0]+t[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NOe{constructor(t,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((g,y)=>g[0]+t[y]+g[1]);const s=t.length,a=Qn(s),i=n.map(g=>g[0]).join(","),o=n.map((g,y)=>g[0]+t[y]).join(","),l=Sa("rc",s),u=Sa("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${u.slice(-2).join()})`,p=[`${a} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${c}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${c}) {`],h=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let m="";for(let g=0,y=s===1?2:4;g<y;g++)m+=`
        ${p[g]}
        if (${h}) {
          result[${g}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${g}] = getChannel(getX(${u.join()}), ${d});
        }
      `;m+=s===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pK=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(Oe(s.shape)===0){const u=a.map((c,d)=>c[0]+s.shape[d]+c[1]);return v1({backend:n,attrs:{shape:u,value:i,dtype:s.dtype}})}const o=$e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new NOe(s.shape,a,i):new COe(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},TOe={kernelName:JS,backendName:"webgl",kernelFunc:pK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Oe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,EOe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Wh+`
  return result;
`,_Oe=Zs({opSnippet:$Oe,packedOpSnippet:EOe}),AOe={kernelName:R0,backendName:"webgl",kernelFunc:_Oe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ROe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=un(a,s.shape);let c=u;const d=_r(c,o);let p=s;d!=null&&(p=Ea({inputs:{x:s},backend:n,attrs:{perm:d}}),c=zr(c.length,o),l.push(p)),Ys("prod",c,o);let h;if(n.shouldExecuteOnCPU([p])){const m=n.texData.get(p.dataId).values,{outVals:g,outShape:y,outDtype:b}=_Ee(p.shape,p.dtype,m,c);h=n.makeTensorInfo(y,b,g)}else{const[m,g]=Os(p.shape,c),y=Oe(g),b=nt({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),v=LD(s.dtype),k=Vh(b,v,"prod",n);h=nt({inputs:{x:k},backend:n,attrs:{shape:m}}),l.push(b),l.push(k)}if(i){l.push(h);const m=Jr(h.shape,u);h=nt({inputs:{x:h},backend:n,attrs:{shape:m}})}return l.forEach(m=>n.disposeIntermediateTensorInfo(m)),h}const DOe={kernelName:eC,backendName:"webgl",kernelFunc:ROe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FOe(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map(b=>n.readSync(b.dataId)),u=s.map(b=>b.shape),c=n.readSync(a.dataId),d=n.readSync(i.dataId),[p,h,m]=AEe(l,u,c,a.shape,a.dtype,d,i.shape,o),g=p.map(b=>n.makeTensorInfo([b.length],"int32",b)),y=n.makeTensorInfo(m,a.dtype,h);return g.concat([y])}const OOe={kernelName:H5,backendName:"webgl",kernelFunc:FOe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MOe(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=REe(i,r.shape,r.dtype,o,s.shape,l,a.shape),d=n.makeTensorInfo([u.length],"int32",u),p=n.makeTensorInfo([c.length],r.dtype,c);return[d,p]}const LOe={kernelName:q5,backendName:"webgl",kernelFunc:MOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function POe(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),d=n.readSync(i.dataId),p=o.map(y=>n.readSync(y.dataId)),h=o.map(y=>y.shape),[m,g]=DEe(u,s.shape,c,a.shape,a.dtype,d,i.shape,p,h,l);return n.makeTensorInfo(m,a.dtype,g)}const zOe={kernelName:K5,backendName:"webgl",kernelFunc:POe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hK=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=FEe(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},BOe={kernelName:ND,backendName:"webgl",kernelFunc:hK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WOe="return 1.0 / x;",VOe=wn({opSnippet:WOe}),UOe={kernelName:D0,backendName:"webgl",kernelFunc:VOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GOe=No+`
  return (x < 0.0) ? 0.0 : x;
`,jOe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,HOe=wn({opSnippet:GOe,packedOpSnippet:jOe}),qOe={kernelName:F0,backendName:"webgl",kernelFunc:HOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KOe=No+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,XOe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,YOe=wn({opSnippet:KOe,packedOpSnippet:XOe}),ZOe={kernelName:O0,backendName:"webgl",kernelFunc:YOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JOe{constructor(t,n,r,s,a){this.variableNames=["A"],this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r];let p;a?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QOe{constructor(t,n,r,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r];let p;a?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eMe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=$e().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new QOe(s.shape,l,u,a,i):new JOe(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}const tMe={kernelName:rC,backendName:"webgl",kernelFunc:eMe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nMe{constructor(t,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,a]=n,[,i,o]=t,l=[r&&i>1?s-1:s,r&&o>1?a-1:a],u=[r&&i>1?i-1:i,r&&o>1?o-1:o],c=l[0]/u[0],d=l[1]/u[1],p=1/c,h=1/d,m=Math.ceil(p)*2+2,g=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${h});

        const int winHeight = int(${m});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rMe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new nMe(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const sMe={kernelName:ED,backendName:"webgl",kernelFunc:rMe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aMe{constructor(t,n,r,s,a){this.variableNames=["A"],this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r],p=s?"0.5":"0.0";let h;a?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iMe{constructor(t,n,r,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r],p=s?"0.5":"0.0";let h;a?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oMe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=$e().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new iMe(s.shape,l,u,a,i):new aMe(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}const lMe={kernelName:nC,backendName:"webgl",kernelFunc:oMe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uMe{constructor(t,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,a]=n,[,i,o]=t,l=[r&&i>1?s-1:s,r&&o>1?a-1:a],u=[r&&i>1?i-1:i,r&&o>1?o-1:o],c=l[0]/u[0],d=l[1]/u[1],p=1/c,h=1/d,m=Math.ceil(p)*2+2,g=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${h});

        const int winHeight = int(${m});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cMe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new uMe(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const dMe={kernelName:$D,backendName:"webgl",kernelFunc:cMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pMe{constructor(t,n){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const s=o=>n.indexOf(o)!==-1&&t[o]!==1?`${t[o]} - coords[${o}] - 1`:`coords[${o}]`,a=t.map((o,l)=>s(l)).join(","),i=Qn(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hMe{constructor(t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=Sa("rc",r),a=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,o=Qn(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${a}){
            result.g = ${u(s.slice())};
          }
          if(${i}) {
            result.b = ${c(s.slice())};
            if(${a}) {
              result.a = ${d(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(m){return p(m)}function u(m){return m[r-1]="("+m[r-1]+" + 1)",p(m)}function c(m){return m[r-2]="("+m[r-2]+" + 1)",p(m)}function d(m){return m[r-1]="("+m[r-1]+" + 1)",m[r-2]="("+m[r-2]+" + 1)",p(m)}function p(m){const g=t.map((v,k)=>h(k,m)),y=g.join(","),b=g.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${b}))`}function h(m,g){return n.indexOf(m)!==-1&&t[m]!==1?`${t[m]} - ${g[m]} - 1`:`${g[m]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fMe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=un(a,s.shape);if(i===0)return Si({inputs:{x:s},backend:n});const l=$e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hMe(s.shape,o):new pMe(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}const mMe={kernelName:sC,backendName:"webgl",kernelFunc:fMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gMe{constructor(t,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let a="";typeof n=="number"?a=`float outputValue = ${n.toFixed(2)};`:a=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yMe={kernelName:MD,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=new gMe(r.shape,a),[u,c]=kF(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(l,[r],r.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xMe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,bMe=wn({opSnippet:xMe}),vMe={kernelName:M0,backendName:"webgl",kernelFunc:bMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wMe="return inversesqrt(x);",kMe=wn({opSnippet:wMe,cpuKernelImpl:OEe}),IMe={kernelName:L0,backendName:"webgl",kernelFunc:kMe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S3{constructor(t,n,r,s,a,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const u=Qn(a.length),c=Qn(i.length);let d="";r===1?d="i":r===2&&(d="i, j");const p=`getIndices(${d})`;let h="";s===1?h="i":s===2&&(h="i, coords[1]");const m=`getUpdates(${h})`;let g="";l&&(g="coords[0], coords[1]");const y=`getDefaultValue(${g})`,b=n>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${b};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${m};
              found = true;
            }
          }
          setOutput(mix(${y}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SMe{constructor(t,n,r,s,a,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const u=Qn(a.length),c=Qn(i.length);let d="";r===1?d="i":r===2&&(d="i, j");const p=`getIndices(${d})`;let h="";s===1?h="i":s===2&&(h="i, coords[1]");const m=`getUpdates(${h})`;let g="";l&&(g="coords[0], coords[1]");const y=`getDefaultValue(${g})`,b=n>1?"strides[j]":"strides",v=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${b};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${v};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${m};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${y}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CMe(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Mh(a,s,i),p=[d/u,u];if(d===0)return n.makeTensorInfo(i,s.dtype);const h=nt({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),m=nt({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let y;$e().getBool("WEBGL_PACK")?y=new SMe(l,o,h.shape.length,m.shape.length,c,p):y=new S3(l,o,h.shape.length,m.shape.length,c,p);const b=n.runWebGLProgram(y,[m,h,g],m.dtype),v=nt({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),v}const NMe={kernelName:X5,backendName:"webgl",kernelFunc:CMe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TMe{constructor(t,n,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const a="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,o=$e().getNumber("WEBGL_VERSION")===2?a:i,l=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Me(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new TMe(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}const EMe={kernelName:Z5,backendName:"webgl",kernelFunc:$Me};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Me{constructor(t,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let s,a;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)a="resRC",s="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<n.length;c++)u.push(`${o[c]}`),c<t&&l.push(`${o[c]}`);s=l.join(),a=u.join()}const i=Qn(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AMe(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new _Me(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],ki(s.dtype,a.dtype))}const RMe={kernelName:aC,backendName:"webgl",kernelFunc:AMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DMe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${IC};
  float scale = ${SC};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,FMe=wn({opSnippet:DMe}),OMe={kernelName:P0,backendName:"webgl",kernelFunc:FMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MMe=Sy+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,LMe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,PMe=wn({opSnippet:MMe,packedOpSnippet:LMe,cpuKernelImpl:LEe}),zMe={kernelName:V0,backendName:"webgl",kernelFunc:PMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BMe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,WMe=wn({opSnippet:BMe}),VMe={kernelName:W0,backendName:"webgl",kernelFunc:WMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UMe=Sy+`
  return sin(x);
`,GMe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Wh}
  return result;
`,jMe=wn({opSnippet:UMe,packedOpSnippet:GMe}),HMe={kernelName:z0,backendName:"webgl",kernelFunc:jMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qMe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,KMe=wn({opSnippet:qMe}),XMe={kernelName:B0,backendName:"webgl",kernelFunc:KMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YMe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,ZMe=wn({opSnippet:YMe}),JMe={kernelName:U0,backendName:"webgl",kernelFunc:ZMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QMe=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;Y(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((b,v)=>b*v),l=[[0,0]];l.push(...i);for(let b=1+a.length;b<s.shape.length;++b)l.push([0,0]);const u=[],c=pK({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=s1(c.shape,a,o,!1),p=a1(d.length,a.length,!1),h=i1(c.shape,a,o,!1),m=nt({inputs:{x:c},backend:n,attrs:{shape:d}}),g=Ea({inputs:{x:m},backend:n,attrs:{perm:p}}),y=nt({inputs:{x:g},backend:n,attrs:{shape:h}});return u.push(c),u.push(m),u.push(g),u.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},eLe={kernelName:lC,backendName:"webgl",kernelFunc:QMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tLe(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[d,p,h,m,g]=zEe(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(p,r.dtype,d),n.makeTensorInfo([p[0]],s.dtype,h),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(y=>Number(y)))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}const nLe={kernelName:J5,backendName:"webgl",kernelFunc:tLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rLe(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,d]=BEe(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const sLe={kernelName:Q5,backendName:"webgl",kernelFunc:rLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aLe(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=L9(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}const iLe={kernelName:ej,backendName:"webgl",kernelFunc:aLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oLe(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=L9(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}const lLe={kernelName:tj,backendName:"webgl",kernelFunc:oLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uLe(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=Mh(a,s,o),h=!1;if(a.dtype==="string"){const b=n.bufferSync(s),v=n.bufferSync(a),k=Yc(n.readSync(i.dataId)[0]),I=MEe(b,v,o,p,c,u,l,d,k,h);return n.makeTensorInfo(o,I.dtype,I.values)}const m=new S3(u,l,s.shape.length,a.shape.length,d,[p,1],h),g=n.runWebGLProgram(m,[a,s,i],a.dtype),y=nt({inputs:{x:g},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(g),y}const cLe={kernelName:nj,backendName:"webgl",kernelFunc:uLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dLe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=un(i,s.shape)[0],l=LF(s,a,o),u=s.shape.length,c=new Array(u).fill(0),d=s.shape.slice();return l.map(p=>{const h=[...d];h[o]=p;const m=Cy({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});return c[o]+=p,m})}const pLe={kernelName:uC,backendName:"webgl",kernelFunc:dLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oU="return sqrt(x);",hLe=wn({opSnippet:oU,packedOpSnippet:oU,cpuKernelImpl:WEe}),fLe={kernelName:G0,backendName:"webgl",kernelFunc:hLe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mLe="return x * x;",gLe=wn({opSnippet:mLe}),yLe={kernelName:_D,backendName:"webgl",kernelFunc:gLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lU="return (a - b) * (a - b);",xLe=Zs({opSnippet:lU,packedOpSnippet:lU}),bLe={kernelName:j0,backendName:"webgl",kernelFunc:xLe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vLe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const a=n.readSync(s.dataId),i=Bu(a),o=VEe(i,"string",r);return n.makeTensorInfo(s.shape,"string",o)}const wLe={kernelName:AD,backendName:"webgl",kernelFunc:vLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kLe({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=No+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new Pl(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}const ILe={kernelName:Y0,backendName:"webgl",kernelFunc:kLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SLe{constructor(t,n,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,a=Qn(r.length),i=Qn(r.length);let o="";if(s===1)o="coords * strides + begin";else{let l=0;o=r.map((u,c)=>(l++,r.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${t});
      ${a} strides = ${a}(${n});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CLe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=r,{finalShapeSparse:h,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:k,strides:I}=bF(s.shape,a,i,o,l,u,c,d,p);let S;if(g)S=nt({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){Y(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const T=gF(v,k,I),A=Cy({inputs:{x:s},backend:n,attrs:{begin:v,size:T}});S=nt({inputs:{x:A},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(A)}else if(n.shouldExecuteOnCPU([s])){const A=n.readSync(s.dataId),R=ln(s.shape,s.dtype,A),D=UEe(h,R,I,v);S=n.makeTensorInfo(m,s.dtype,D.values)}else{const A=new SLe(v,I,h);S=n.runWebGLProgram(A,[s],s.dtype)}const N=nt({inputs:{x:S},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(S),N}const NLe={kernelName:RD,backendName:"webgl",kernelFunc:CLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TLe(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,p=n.readSync(c.dataId),h=n.readSync(d.dataId),[m,g]=GEe(p,h,s,a,i,o,l,u);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(d.shape,"int32",g)]}const $Le={kernelName:rj,backendName:"webgl",kernelFunc:TLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ELe(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=jEe(o,l,s),p=c.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const _Le={kernelName:sj,backendName:"webgl",kernelFunc:ELe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ALe(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=HEe(i,s);return n.makeTensorInfo(a.shape,"int32",o)}const RLe={kernelName:aj,backendName:"webgl",kernelFunc:ALe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DLe="return tan(x);",FLe=wn({opSnippet:DLe}),OLe={kernelName:q0,backendName:"webgl",kernelFunc:FLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MLe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,LLe=wn({opSnippet:MLe}),PLe={kernelName:K0,backendName:"webgl",kernelFunc:LLe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zLe(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Mh(i,a,s.shape),p=[d/u,u];if(d===0)return n.makeTensorInfo(s.shape,a.dtype);const h=nt({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),m=nt({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),g=nt({inputs:{x:s},backend:n,attrs:{shape:p}}),y=new S3(l,o,h.shape.length,m.shape.length,c,p,!1,!0),b=n.runWebGLProgram(y,[m,h,g],g.dtype),v=nt({inputs:{x:b},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),v}const BLe={kernelName:Y5,backendName:"webgl",kernelFunc:zLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WLe{constructor(t,n){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[i]*n[i];this.outputShape=r,this.rank=r.length;const s=Qn(this.rank),a=VLe(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function VLe(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fK(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if(s.dtype==="string"||s.shape.length>5){const l=n.readSync(s.dataId),u=s.dtype==="string"?l.map(p=>Yc(p)):l,c=ln(s.shape,s.dtype,u),d=KEe(c,a);return n.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new WLe(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const ULe={kernelName:X0,backendName:"webgl",kernelFunc:fK};class GLe{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class jLe{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gp(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function uU(e){let t=1;for(;t<e;)t*=2;return t}function HLe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=$e().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=$e().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){const D=n.readSync(s.dataId),[$,_]=XEe(D,u,s.dtype,a,i);return[n.makeTensorInfo($.shape,$.dtype,$.values),n.makeTensorInfo(_.shape,_.dtype,_.values)]}if(a===0)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[s,v1({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(s.dataId),p=d!==null&&d.isPacked,h=p?n.unpackTensor(s):s,g=Oe(u)/c,y=nt({inputs:{x:h},attrs:{shape:[g,c]},backend:n});p&&gp(n,h);const b=uU(a),v=uU(c);let k=null;const I=()=>k===null?[y,y]:[y,k],S=(D,$,_)=>{const L=I(),z=new GLe(_),G=[[c],[k===null?1:0],[Number.NEGATIVE_INFINITY],[D],[$]],q=k;k=n.runWebGLProgram(z,L,"int32",G),gp(n,q)};for(let D=1;D<b;D*=2){const $=D*2;for(let _=D;_>=1;_/=2)S($,_,[g,v])}for(let D=v;D>b;D/=2){const $=I(),_=new jLe([g,D/2]),z=[[c],[k===null?1:0],[b]],W=k;k=n.runWebGLProgram(_,$,"int32",z),gp(n,W);const G=b/2,q=G*2;for(let B=G;B>=1;B/=2)S(q,B,k.shape)}let N=k;k=Cy({inputs:{x:k},backend:n,attrs:{begin:0,size:[g,a]}}),gp(n,N);let T=iK({inputs:{x:y,indices:k},backend:n,attrs:{axis:1,batchDims:1}});gp(n,y);const A=u.slice(0,-1);A.push(a),N=k,k=nt({inputs:{x:k},attrs:{shape:A},backend:n}),gp(n,N);const R=T;return T=nt({inputs:{x:T},attrs:{shape:A},backend:n}),gp(n,R),[T,k]}const qLe={kernelName:DD,backendName:"webgl",kernelFunc:HLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KLe{constructor(t,n,r,s,a,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const o=r==="nearest"?1:2;let l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${t}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XLe(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,p,h]=s.shape,[m,g]=u??[d,p],y=[c,m,g,h],b=new KLe(d,p,i,o,l,y);return n.runWebGLProgram(b,[s,a],"float32")}const YLe={kernelName:FD,backendName:"webgl",kernelFunc:XLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZLe(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;y1(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=YEe(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}const JLe={kernelName:OD,backendName:"webgl",kernelFunc:ZLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QLe(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let g=0;g<o;g++)g!==a&&(u[c++]=i.shape[g]);const d=[],p=new Array(o).fill(0),h=i.shape.slice();h[a]=1;const m=new Array(l);for(let g=0;g<m.length;g++){p[a]=g;const y=Cy({inputs:{x:i},backend:n,attrs:{begin:p,size:h}}),b=nt({inputs:{x:y},backend:n,attrs:{shape:u}});m[g]=b,d.push(y)}return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const ePe={kernelName:dC,backendName:"webgl",kernelFunc:QLe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tPe{constructor(t,n){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,a=t.inSize,i=t.numSegments,o=i*Math.ceil(a/r);this.outputShape=[s,o];const l="0.0",u="sumValue",c=Math.floor(r/4)*4,d=r%4,p=`
        sumValue += dot(values, segFilter);
    `;let h="";a%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let m="";a%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${m}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nPe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[];let u=0;const c=_r([u],o);let d=s;c!=null&&(d=Ea({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(d),u=zr(1,o)[0]);const p=XH(d.shape,u,i),h=Oe([d.shape[u]]),m=nt({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}});l.push(m);const g=LD(s.dtype),y=(I,S,N,T,A)=>{const R=I.shape[0],D=I.shape[1],$=KH(D,A),_={windowSize:$,inSize:D,batchSize:R,numSegments:A},L=new tPe(_,S),z=n.compileAndRun(L,[I,N],T);if(l.push(z),z.shape[1]===A)return z;const W=hK({backend:n,attrs:{start:0,stop:A,step:1,dtype:"float32"}}),G=fK({inputs:{x:W},backend:n,attrs:{reps:[D/$]}});return l.push(W),l.push(G),y(z,S,G,T,A)},b=y(m,"unsortedSegmentSum",a,g,i),v=nt({inputs:{x:b},backend:n,attrs:{shape:p}});let k=v;if(c!=null){l.push(v);const I=Id(c);k=Ea({inputs:{x:k},backend:n,attrs:{perm:I}})}return l.forEach(I=>n.disposeIntermediateTensorInfo(I)),k}const rPe={kernelName:pC,backendName:"webgl",kernelFunc:nPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sPe=[W_e,U_e,H_e,X_e,Z_e,eAe,nAe,sAe,lAe,cAe,hAe,gAe,bAe,IAe,NAe,$Ae,_Ae,FAe,MAe,PAe,VAe,XAe,ZAe,tRe,rRe,uRe,dRe,mRe,S_e,xRe,IRe,TRe,DRe,MRe,PRe,BRe,VRe,HRe,XRe,JRe,eDe,nDe,sDe,oDe,uDe,hDe,mDe,xDe,wDe,IDe,TDe,ADe,ODe,PDe,WDe,VDe,GDe,HDe,KDe,YDe,JDe,nFe,aFe,lFe,cFe,hFe,gFe,vFe,SFe,I_e,NFe,wRe,EFe,RFe,OFe,N_e,zFe,UFe,jFe,XFe,JFe,n3e,a3e,u3e,h3e,g3e,x3e,k3e,S3e,N3e,_3e,R3e,F3e,M3e,P3e,V3e,H3e,Y3e,sOe,E_e,lOe,dOe,fOe,yOe,aRe,vOe,kOe,SOe,TOe,AOe,$_e,DOe,OOe,LOe,zOe,BOe,iRe,eOe,UOe,qOe,ZOe,A_e,tMe,sMe,lMe,dMe,mMe,yMe,vMe,IMe,NMe,EMe,RMe,OMe,zMe,VMe,HMe,XMe,qAe,nOe,JMe,eLe,nLe,sLe,iLe,lLe,cLe,pLe,fLe,yLe,bLe,wLe,ILe,NLe,$Le,_Le,RLe,tOe,P_e,OLe,PLe,BLe,ULe,qLe,YLe,z_e,JLe,ePe,rPe,wOe];for(const e of sPe)oj(e);var aPe=Object.defineProperty,iPe=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),C3=(e,t)=>{for(var n in t)aPe(e,n,{get:t[n],enumerable:!0})},oPe={};C3(oPe,{Abs:()=>Ty,Acos:()=>Gh,Acosh:()=>jh,AdadeltaOptimizer:()=>jO,AdagradOptimizer:()=>HO,AdamOptimizer:()=>qO,AdamaxOptimizer:()=>KO,Add:()=>Ad,AddN:()=>Hh,All:()=>$y,Any:()=>Ey,ArgMax:()=>_y,ArgMin:()=>Ay,Asin:()=>qh,Asinh:()=>Kh,Atan:()=>Xh,Atan2:()=>Zh,Atanh:()=>Yh,AvgPool:()=>Jh,AvgPool3D:()=>Ry,AvgPool3DGrad:()=>S1,AvgPoolGrad:()=>I1,BackendWasm:()=>Ire,BatchMatMul:()=>Qh,BatchToSpaceND:()=>Dy,Bincount:()=>Fy,BitwiseAnd:()=>Oy,BroadcastArgs:()=>C1,BroadcastTo:()=>EK,Callback:()=>kJ,CallbackList:()=>mZ,Cast:()=>ef,Ceil:()=>tf,ClipByValue:()=>Rd,Complex:()=>HC,ComplexAbs:()=>N1,Concat:()=>My,Conv2D:()=>nf,Conv2DBackpropFilter:()=>qC,Conv2DBackpropInput:()=>rf,Conv3D:()=>sf,Conv3DBackpropFilterV2:()=>Ly,Conv3DBackpropInputV2:()=>Py,Cos:()=>af,Cosh:()=>of,CropAndResize:()=>By,Cumprod:()=>zy,Cumsum:()=>lf,CustomCallback:()=>yZ,DataStorage:()=>UC,DenseBincount:()=>T1,DepthToSpace:()=>Wy,DepthwiseConv2dNative:()=>uf,DepthwiseConv2dNativeBackpropFilter:()=>KC,DepthwiseConv2dNativeBackpropInput:()=>XC,Diag:()=>$1,Dilation2D:()=>cf,Dilation2DBackpropFilter:()=>zg,Dilation2DBackpropInput:()=>Pg,Draw:()=>YC,ENV:()=>_3,EarlyStopping:()=>IJ,Einsum:()=>ZC,Elu:()=>pf,EluGrad:()=>Vy,Environment:()=>TK,Equal:()=>Uy,Erf:()=>hf,Exp:()=>ff,ExpandDims:()=>Gy,Expm1:()=>mf,FFT:()=>JC,Fill:()=>E1,FlipLeftRight:()=>jy,Floor:()=>gf,FloorDiv:()=>yf,FromPixels:()=>II,FusedBatchNorm:()=>xf,FusedConv2D:()=>hh,FusedDepthwiseConv2D:()=>fh,GPGPUContext:()=>R2,GatherNd:()=>qy,GatherV2:()=>Hy,GraphModel:()=>FL,Greater:()=>Ky,GreaterEqual:()=>bf,History:()=>gZ,IFFT:()=>QC,Identity:()=>vf,Imag:()=>eN,InputSpec:()=>Kr,IsFinite:()=>wf,IsInf:()=>kf,IsNan:()=>If,KernelBackend:()=>w1,LRN:()=>Tf,LRNGrad:()=>tx,LayerVariable:()=>oZ,LayersModel:()=>Du,LeakyRelu:()=>Sf,Less:()=>Xy,LessEqual:()=>Yy,LinSpace:()=>Zy,Log:()=>Cf,Log1p:()=>Nf,LogSoftmax:()=>AK,LogicalAnd:()=>Jy,LogicalNot:()=>Qy,LogicalOr:()=>ex,LogicalXor:()=>_K,LowerBound:()=>JPe,MathBackendCPU:()=>LL,MathBackendWebGL:()=>dP,MatrixBandPart:()=>QPe,Max:()=>$f,MaxPool:()=>_f,MaxPool3D:()=>nx,MaxPool3DGrad:()=>A1,MaxPoolGrad:()=>_1,MaxPoolWithArgmax:()=>R1,Maximum:()=>Ef,Mean:()=>Af,Min:()=>Rf,Minimum:()=>Df,MirrorPad:()=>Ff,Mod:()=>Of,MomentumOptimizer:()=>XO,Multinomial:()=>rx,Multiply:()=>Mf,Neg:()=>sx,NonMaxSuppressionV3:()=>ix,NonMaxSuppressionV4:()=>ox,NonMaxSuppressionV5:()=>lx,NotEqual:()=>ax,OP_SCOPE_SUFFIX:()=>O3,OneHot:()=>Lf,OnesLike:()=>ux,Optimizer:()=>ec,OptimizerConstructors:()=>BY,Pack:()=>cx,PadV2:()=>Pf,Pool:()=>e4e,Pow:()=>zf,Prelu:()=>Bf,Prod:()=>Wf,RMSPropOptimizer:()=>YO,RNN:()=>tc,RaggedGather:()=>tN,RaggedRange:()=>nN,RaggedTensorToTensor:()=>rN,Range:()=>D1,Rank:()=>yA,Real:()=>sN,RealDiv:()=>df,Reciprocal:()=>Vf,Reduction:()=>Ca,Relu:()=>Uf,Relu6:()=>Hf,Reshape:()=>dx,ResizeBilinear:()=>jf,ResizeBilinearGrad:()=>hx,ResizeNearestNeighbor:()=>Gf,ResizeNearestNeighborGrad:()=>px,Reverse:()=>qf,RotateWithOffset:()=>$x,Round:()=>Kf,Rsqrt:()=>Xf,SGDOptimizer:()=>BN,ScatterNd:()=>fx,SearchSorted:()=>gx,Select:()=>yx,Selu:()=>Yf,Sequential:()=>QN,Sigmoid:()=>em,Sign:()=>Qf,Sin:()=>Zf,Sinh:()=>Jf,Slice:()=>xx,Softmax:()=>sm,Softplus:()=>tm,SpaceToBatchND:()=>bx,SparseFillEmptyRows:()=>F1,SparseReshape:()=>wx,SparseSegmentMean:()=>O1,SparseSegmentSum:()=>M1,SparseToDense:()=>kx,SplitV:()=>vx,Sqrt:()=>nm,Square:()=>L1,SquaredDifference:()=>am,StaticRegexReplace:()=>P1,Step:()=>Fd,StridedSlice:()=>Ix,StringNGrams:()=>z1,StringSplit:()=>B1,StringToHashBucketFast:()=>W1,Sub:()=>im,Sum:()=>rm,SymbolicTensor:()=>ul,Tan:()=>om,Tanh:()=>lm,Tensor:()=>Zt,TensorBuffer:()=>Xr,TensorScatterUpdate:()=>mx,Tile:()=>Dd,TopK:()=>Sx,Transform:()=>Cx,Transpose:()=>Ru,Unique:()=>V1,Unpack:()=>Nx,UnsortedSegmentSum:()=>U1,UpperBound:()=>t4e,Variable:()=>mh,ZerosLike:()=>Tx,_FusedMatMul:()=>ph,abs:()=>Hr,acos:()=>B3,acosh:()=>W3,add:()=>Ae,addN:()=>aX,all:()=>uN,any:()=>Rv,argMax:()=>bh,argMin:()=>V3,asin:()=>U3,asinh:()=>G3,atan:()=>j3,atan2:()=>H3,atanh:()=>q3,avgPool:()=>Zu,avgPool3d:()=>X3,backend:()=>M3,backend_util:()=>V,basicLSTMCell:()=>uX,batchNorm:()=>um,batchNorm2d:()=>Y3,batchNorm3d:()=>Z3,batchNorm4d:()=>J3,batchToSpaceND:()=>Y1,bincount:()=>Q3,bitwiseAnd:()=>cX,booleanMaskAsync:()=>QX,broadcastArgs:()=>dX,broadcastTo:()=>Gp,broadcast_util:()=>Ex,browser:()=>uw,buffer:()=>tn,callbacks:()=>Y9e,cast:()=>Ke,ceil:()=>eO,clipByValue:()=>oa,clone:()=>ql,complex:()=>Wu,concat:()=>Jn,concat1d:()=>tO,concat2d:()=>nO,concat3d:()=>rO,concat4d:()=>sO,constraints:()=>dZ,conv1d:()=>cN,conv2d:()=>_a,conv2dTranspose:()=>dN,conv3d:()=>iO,conv3dTranspose:()=>oO,copyRegisteredKernels:()=>a4e,cos:()=>Z1,cosh:()=>pN,cosineWindow:()=>ON,cumprod:()=>Ov,cumsum:()=>hN,customGrad:()=>su,data:()=>qJ,denseBincount:()=>NI,deprecationWarn:()=>jK,depthToSpace:()=>lO,depthwiseConv2d:()=>cm,deregisterOp:()=>Q9e,device_util:()=>q1,diag:()=>hX,dilation2d:()=>uO,disableDeprecationWarnings:()=>O4e,dispose:()=>qt,disposeVariables:()=>M4e,div:()=>ht,divNoNan:()=>cO,dot:()=>dO,dropout:()=>BO,einsum:()=>$p,elu:()=>_x,enableDebugMode:()=>F4e,enableProdMode:()=>D4e,enclosingPowerOfTwo:()=>WO,engine:()=>fo,ensureShape:()=>mX,env:()=>xe,equal:()=>Ci,erf:()=>fN,euclideanNorm:()=>fO,exp:()=>la,expandDims:()=>$s,expm1:()=>mO,eye:()=>mN,fft:()=>ow,fill:()=>wi,findBackend:()=>V4e,findBackendFactory:()=>U4e,floor:()=>Rx,floorDiv:()=>lN,forceHalfFloat:()=>yte,fused:()=>qg,gather:()=>Dx,gatherND:()=>rY,gather_util:()=>QO,getBackend:()=>HK,getGradient:()=>mA,getKernel:()=>Ev,getKernelsForBackend:()=>SI,getThreadsCount:()=>avt,gpgpu_util:()=>Kee,grad:()=>wWe,grads:()=>kWe,greater:()=>Ma,greaterEqual:()=>Ju,ifft:()=>Hg,imag:()=>J1,image:()=>Bi,inTopKAsync:()=>sY,initializers:()=>pZ,input:()=>AZ,io:()=>qs,irfft:()=>$N,isFinite:()=>gO,isInf:()=>yO,isNaN:()=>xO,keep:()=>cs,kernel_impls:()=>du,layers:()=>hZ,leakyRelu:()=>Q1,less:()=>Vg,lessEqual:()=>Md,linalg:()=>GO,linspace:()=>vX,loadGraphModel:()=>aXe,loadGraphModelSync:()=>iXe,loadLayersModel:()=>j7e,localResponseNormalization:()=>bO,log:()=>Ni,log1p:()=>ew,logSigmoid:()=>vO,logSoftmax:()=>yN,logSumExp:()=>tw,logicalAnd:()=>Io,logicalNot:()=>nw,logicalOr:()=>xN,logicalXor:()=>wO,losses:()=>gY,lowerBound:()=>kX,matMul:()=>Qt,math:()=>TY,max:()=>Hi,maxPool:()=>Ss,maxPool3d:()=>kO,maxPoolWithArgmax:()=>IX,maximum:()=>cu,mean:()=>Sr,memory:()=>SA,meshgrid:()=>SX,metrics:()=>bJ,min:()=>Wg,minimum:()=>ld,mirrorPad:()=>IO,mod:()=>SO,model:()=>K7e,models:()=>vJ,moments:()=>rw,movingAverage:()=>eY,mul:()=>oe,multiRNNCell:()=>CX,multinomial:()=>NX,neg:()=>or,nextFrame:()=>eM,norm:()=>Ax,notEqual:()=>kh,oneHot:()=>Ug,ones:()=>Ha,onesLike:()=>Ti,op:()=>ie,outerProduct:()=>TX,pad:()=>ml,pad1d:()=>$X,pad2d:()=>EX,pad3d:()=>_X,pad4d:()=>AX,pool:()=>CO,pow:()=>ru,prelu:()=>aw,print:()=>z3,prod:()=>NO,profile:()=>L4e,raggedGather:()=>RX,raggedRange:()=>DX,raggedTensorToTensor:()=>FX,rand:()=>OX,randomGamma:()=>zX,randomNormal:()=>vN,randomStandardNormal:()=>BX,randomUniform:()=>Ld,randomUniformInt:()=>WX,range:()=>Ih,ready:()=>B4e,real:()=>Gg,reciprocal:()=>AO,registerBackend:()=>oN,registerCallbackConstructor:()=>Y7e,registerGradient:()=>RK,registerKernel:()=>G1,registerOp:()=>J9e,regularizers:()=>wJ,relu:()=>Un,relu6:()=>wN,removeBackend:()=>W4e,reshape:()=>ue,reverse:()=>Yi,reverse1d:()=>VX,reverse2d:()=>UX,reverse3d:()=>GX,reverse4d:()=>jX,rfft:()=>lw,round:()=>kN,rsqrt:()=>IN,scalar:()=>Tt,scatterND:()=>tY,scatter_util:()=>AN,searchSorted:()=>bN,selu:()=>SN,separableConv2d:()=>Fx,sequential:()=>X7e,serialization:()=>Pe,setBackend:()=>z4e,setPlatform:()=>G4e,setThreadsCount:()=>svt,setWasmPath:()=>nvt,setWasmPaths:()=>rvt,setWebGLContext:()=>xee,setdiff1dAsync:()=>HX,shared:()=>PL,sigmoid:()=>vo,sign:()=>RO,signal:()=>mY,sin:()=>CN,sinh:()=>NN,slice:()=>hn,slice1d:()=>iw,slice2d:()=>TN,slice3d:()=>Ox,slice4d:()=>jg,slice_util:()=>fs,softmax:()=>Pd,softplus:()=>dm,spaceToBatchND:()=>sw,sparse:()=>yY,sparseToDense:()=>nY,spectral:()=>fY,split:()=>Xa,sqrt:()=>Ds,square:()=>Zn,squaredDifference:()=>EN,squeeze:()=>zd,stack:()=>Yr,step:()=>pm,stridedSlice:()=>DO,string:()=>xY,sub:()=>at,sum:()=>yt,sumOutType:()=>iN,tan:()=>FO,tanh:()=>od,tensor:()=>$a,tensor1d:()=>Ln,tensor2d:()=>Kl,tensor3d:()=>_N,tensor4d:()=>ud,tensor5d:()=>qX,tensor6d:()=>KX,tensorScatterUpdate:()=>YX,tensor_util:()=>Jo,test_util:()=>MX,tidy:()=>ce,tile:()=>xi,time:()=>P4e,topk:()=>MO,train:()=>wp,transpose:()=>en,truncatedNormal:()=>DN,unique:()=>LO,unregisterGradient:()=>s4e,unregisterKernel:()=>r4e,unsortedSegmentSum:()=>FN,unstack:()=>Fr,upcastType:()=>Ki,upperBound:()=>ZX,util:()=>O,valueAndGrad:()=>IWe,valueAndGrads:()=>SWe,variable:()=>PO,variableGrads:()=>wX,version:()=>pvt,version_converter:()=>lXe,version_core:()=>KGe,version_cpu:()=>uZe,version_layers:()=>IM,version_wasm:()=>ivt,version_webgl:()=>eat,webgl:()=>tat,webgl_util:()=>yee,where:()=>Rs,whereAsync:()=>zO,zeros:()=>Cr,zerosLike:()=>gn});var lPe=Object.create,N3=Object.defineProperty,uPe=Object.getOwnPropertyDescriptor,cPe=Object.getOwnPropertyNames,dPe=Object.getPrototypeOf,pPe=Object.prototype.hasOwnProperty,es=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Kt=(e,t)=>{for(var n in t)N3(e,n,{get:t[n],enumerable:!0})},hPe=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of cPe(t))!pPe.call(e,s)&&s!==n&&N3(e,s,{get:()=>t[s],enumerable:!(r=uPe(t,s))||r.enumerable});return e},_d=(e,t,n)=>(n=e!=null?lPe(dPe(e)):{},hPe(!e||!e.__esModule?N3(n,"default",{value:e,enumerable:!0}):n,e)),fPe=es((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(_,L,z){this.low=_|0,this.high=L|0,this.unsigned=!!z}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function s(_){return(_&&_.__isLong__)===!0}r.isLong=s;var a={},i={};function o(_,L){var z,W,G;return L?(_>>>=0,(G=0<=_&&_<256)&&(W=i[_],W)?W:(z=u(_,(_|0)<0?-1:0,!0),G&&(i[_]=z),z)):(_|=0,(G=-128<=_&&_<128)&&(W=a[_],W)?W:(z=u(_,_<0?-1:0,!1),G&&(a[_]=z),z))}r.fromInt=o;function l(_,L){if(isNaN(_))return L?I:k;if(L){if(_<0)return I;if(_>=y)return R}else{if(_<=-9223372036854776e3)return D;if(_+1>=b)return A}return _<0?l(-_,L).neg():u(_%g|0,_/g|0,L)}r.fromNumber=l;function u(_,L,z){return new r(_,L,z)}r.fromBits=u;var c=Math.pow;function d(_,L,z){if(_.length===0)throw Error("empty string");if(_==="NaN"||_==="Infinity"||_==="+Infinity"||_==="-Infinity")return k;if(typeof L=="number"?(z=L,L=!1):L=!!L,z=z||10,z<2||36<z)throw RangeError("radix");var W;if((W=_.indexOf("-"))>0)throw Error("interior hyphen");if(W===0)return d(_.substring(1),L,z).neg();for(var G=l(c(z,8)),q=k,B=0;B<_.length;B+=8){var j=Math.min(8,_.length-B),H=parseInt(_.substring(B,B+j),z);if(j<8){var P=l(c(z,j));q=q.mul(P).add(l(H))}else q=q.mul(G),q=q.add(l(H))}return q.unsigned=L,q}r.fromString=d;function p(_,L){return typeof _=="number"?l(_,L):typeof _=="string"?d(_,L):u(_.low,_.high,typeof L=="boolean"?L:_.unsigned)}r.fromValue=p;var h=65536,m=1<<24,g=h*h,y=g*g,b=y/2,v=o(m),k=o(0);r.ZERO=k;var I=o(0,!0);r.UZERO=I;var S=o(1);r.ONE=S;var N=o(1,!0);r.UONE=N;var T=o(-1);r.NEG_ONE=T;var A=u(-1,2147483647,!1);r.MAX_VALUE=A;var R=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=R;var D=u(0,-2147483648,!1);r.MIN_VALUE=D;var $=r.prototype;$.toInt=function(){return this.unsigned?this.low>>>0:this.low},$.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},$.toString=function(_){if(_=_||10,_<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(D)){var L=l(_),z=this.div(L),W=z.mul(L).sub(this);return z.toString(_)+W.toInt().toString(_)}else return"-"+this.neg().toString(_);for(var G=l(c(_,6),this.unsigned),q=this,B="";;){var j=q.div(G),H=q.sub(j.mul(G)).toInt()>>>0,P=H.toString(_);if(q=j,q.isZero())return P+B;for(;P.length<6;)P="0"+P;B=""+P+B}},$.getHighBits=function(){return this.high},$.getHighBitsUnsigned=function(){return this.high>>>0},$.getLowBits=function(){return this.low},$.getLowBitsUnsigned=function(){return this.low>>>0},$.getNumBitsAbs=function(){if(this.isNegative())return this.eq(D)?64:this.neg().getNumBitsAbs();for(var _=this.high!=0?this.high:this.low,L=31;L>0&&!(_&1<<L);L--);return this.high!=0?L+33:L+1},$.isZero=function(){return this.high===0&&this.low===0},$.eqz=$.isZero,$.isNegative=function(){return!this.unsigned&&this.high<0},$.isPositive=function(){return this.unsigned||this.high>=0},$.isOdd=function(){return(this.low&1)===1},$.isEven=function(){return(this.low&1)===0},$.equals=function(_){return s(_)||(_=p(_)),this.unsigned!==_.unsigned&&this.high>>>31===1&&_.high>>>31===1?!1:this.high===_.high&&this.low===_.low},$.eq=$.equals,$.notEquals=function(_){return!this.eq(_)},$.neq=$.notEquals,$.ne=$.notEquals,$.lessThan=function(_){return this.comp(_)<0},$.lt=$.lessThan,$.lessThanOrEqual=function(_){return this.comp(_)<=0},$.lte=$.lessThanOrEqual,$.le=$.lessThanOrEqual,$.greaterThan=function(_){return this.comp(_)>0},$.gt=$.greaterThan,$.greaterThanOrEqual=function(_){return this.comp(_)>=0},$.gte=$.greaterThanOrEqual,$.ge=$.greaterThanOrEqual,$.compare=function(_){if(s(_)||(_=p(_)),this.eq(_))return 0;var L=this.isNegative(),z=_.isNegative();return L&&!z?-1:!L&&z?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},$.comp=$.compare,$.negate=function(){return!this.unsigned&&this.eq(D)?D:this.not().add(S)},$.neg=$.negate,$.add=function(_){s(_)||(_=p(_));var L=this.high>>>16,z=this.high&65535,W=this.low>>>16,G=this.low&65535,q=_.high>>>16,B=_.high&65535,j=_.low>>>16,H=_.low&65535,P=0,X=0,Q=0,re=0;return re+=G+H,Q+=re>>>16,re&=65535,Q+=W+j,X+=Q>>>16,Q&=65535,X+=z+B,P+=X>>>16,X&=65535,P+=L+q,P&=65535,u(Q<<16|re,P<<16|X,this.unsigned)},$.subtract=function(_){return s(_)||(_=p(_)),this.add(_.neg())},$.sub=$.subtract,$.multiply=function(_){if(this.isZero())return k;if(s(_)||(_=p(_)),n){var L=n.mul(this.low,this.high,_.low,_.high);return u(L,n.get_high(),this.unsigned)}if(_.isZero())return k;if(this.eq(D))return _.isOdd()?D:k;if(_.eq(D))return this.isOdd()?D:k;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(v)&&_.lt(v))return l(this.toNumber()*_.toNumber(),this.unsigned);var z=this.high>>>16,W=this.high&65535,G=this.low>>>16,q=this.low&65535,B=_.high>>>16,j=_.high&65535,H=_.low>>>16,P=_.low&65535,X=0,Q=0,re=0,le=0;return le+=q*P,re+=le>>>16,le&=65535,re+=G*P,Q+=re>>>16,re&=65535,re+=q*H,Q+=re>>>16,re&=65535,Q+=W*P,X+=Q>>>16,Q&=65535,Q+=G*H,X+=Q>>>16,Q&=65535,Q+=q*j,X+=Q>>>16,Q&=65535,X+=z*P+W*H+G*j+q*B,X&=65535,u(re<<16|le,X<<16|Q,this.unsigned)},$.mul=$.multiply,$.divide=function(_){if(s(_)||(_=p(_)),_.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&_.low===-1&&_.high===-1)return this;var L=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,_.low,_.high);return u(L,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?I:k;var z,W,G;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return I;if(_.gt(this.shru(1)))return N;G=I}else{if(this.eq(D)){if(_.eq(S)||_.eq(T))return D;if(_.eq(D))return S;var q=this.shr(1);return z=q.div(_).shl(1),z.eq(k)?_.isNegative()?S:T:(W=this.sub(_.mul(z)),G=z.add(W.div(_)),G)}else if(_.eq(D))return this.unsigned?I:k;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();G=k}for(W=this;W.gte(_);){z=Math.max(1,Math.floor(W.toNumber()/_.toNumber()));for(var B=Math.ceil(Math.log(z)/Math.LN2),j=B<=48?1:c(2,B-48),H=l(z),P=H.mul(_);P.isNegative()||P.gt(W);)z-=j,H=l(z,this.unsigned),P=H.mul(_);H.isZero()&&(H=S),G=G.add(H),W=W.sub(P)}return G},$.div=$.divide,$.modulo=function(_){if(s(_)||(_=p(_)),n){var L=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,_.low,_.high);return u(L,n.get_high(),this.unsigned)}return this.sub(this.div(_).mul(_))},$.mod=$.modulo,$.rem=$.modulo,$.not=function(){return u(~this.low,~this.high,this.unsigned)},$.and=function(_){return s(_)||(_=p(_)),u(this.low&_.low,this.high&_.high,this.unsigned)},$.or=function(_){return s(_)||(_=p(_)),u(this.low|_.low,this.high|_.high,this.unsigned)},$.xor=function(_){return s(_)||(_=p(_)),u(this.low^_.low,this.high^_.high,this.unsigned)},$.shiftLeft=function(_){return s(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?u(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):u(0,this.low<<_-32,this.unsigned)},$.shl=$.shiftLeft,$.shiftRight=function(_){return s(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?u(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):u(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},$.shr=$.shiftRight,$.shiftRightUnsigned=function(_){if(s(_)&&(_=_.toInt()),_&=63,_===0)return this;var L=this.high;if(_<32){var z=this.low;return u(z>>>_|L<<32-_,L>>>_,this.unsigned)}else return _===32?u(L,0,this.unsigned):u(L>>>_-32,0,this.unsigned)},$.shru=$.shiftRightUnsigned,$.shr_u=$.shiftRightUnsigned,$.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},$.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},$.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},$.toBytesLE=function(){var _=this.high,L=this.low;return[L&255,L>>>8&255,L>>>16&255,L>>>24,_&255,_>>>8&255,_>>>16&255,_>>>24]},$.toBytesBE=function(){var _=this.high,L=this.low;return[_>>>24,_>>>16&255,_>>>8&255,_&255,L>>>24,L>>>16&255,L>>>8&255,L&255]},r.fromBytes=function(_,L,z){return z?r.fromBytesLE(_,L):r.fromBytesBE(_,L)},r.fromBytesLE=function(_,L){return new r(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,L)},r.fromBytesBE=function(_,L){return new r(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],L)}}),mPe=es(()=>{}),gPe=es(()=>{}),yPe=es((e,t)=>{(function(n,r,s){function a(u){var c=this,d=l();c.next=function(){var p=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=p-(c.c=p|0)},c.c=1,c.s0=d(" "),c.s1=d(" "),c.s2=d(" "),c.s0-=d(u),c.s0<0&&(c.s0+=1),c.s1-=d(u),c.s1<0&&(c.s1+=1),c.s2-=d(u),c.s2<0&&(c.s2+=1),d=null}function i(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function o(u,c){var d=new a(u),p=c&&c.state,h=d.next;return h.int32=function(){return d.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,p&&(typeof p=="object"&&i(p,d),h.state=function(){return i(d,{})}),h}function l(){var u=4022871197,c=function(d){d=String(d);for(var p=0;p<d.length;p++){u+=d.charCodeAt(p);var h=.02519603282416938*u;u=h>>>0,h-=u,h*=u,u=h>>>0,h-=u,u+=h*4294967296}return(u>>>0)*23283064365386963e-26};return c}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),xPe=es((e,t)=>{(function(n,r,s){function a(l){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var p=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^p^p>>>8},l===(l|0)?u.x=l:c+=l;for(var d=0;d<c.length+64;d++)u.x^=c.charCodeAt(d)|0,u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function o(l,u){var c=new a(l),d=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var h=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(h+m)/(1<<21);while(g===0);return g},p.int32=c.next,p.quick=p,d&&(typeof d=="object"&&i(d,c),p.state=function(){return i(c,{})}),p}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),bPe=es((e,t)=>{(function(n,r,s){function a(l){var u=this,c="";u.next=function(){var p=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(p^p<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(l|0)?u.x=l:c+=l;for(var d=0;d<c.length+64;d++)u.x^=c.charCodeAt(d)|0,d==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function o(l,u){var c=new a(l),d=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var h=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(h+m)/(1<<21);while(g===0);return g},p.int32=c.next,p.quick=p,d&&(typeof d=="object"&&i(d,c),p.state=function(){return i(c,{})}),p}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),vPe=es((e,t)=>{(function(n,r,s){function a(l){var u=this;u.next=function(){var d=u.x,p=u.i,h,m;return h=d[p],h^=h>>>7,m=h^h<<24,h=d[p+1&7],m^=h^h>>>10,h=d[p+3&7],m^=h^h>>>3,h=d[p+4&7],m^=h^h<<7,h=d[p+7&7],h=h^h<<13,m^=h^h<<9,d[p]=m,u.i=p+1&7,m};function c(d,p){var h,m=[];if(p===(p|0))m[0]=p;else for(p=""+p,h=0;h<p.length;++h)m[h&7]=m[h&7]<<15^p.charCodeAt(h)+m[h+1&7]<<13;for(;m.length<8;)m.push(0);for(h=0;h<8&&m[h]===0;++h);for(h==8?m[7]=-1:m[h],d.x=m,d.i=0,h=256;h>0;--h)d.next()}c(u,l)}function i(l,u){return u.x=l.x.slice(),u.i=l.i,u}function o(l,u){l==null&&(l=+new Date);var c=new a(l),d=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var h=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(h+m)/(1<<21);while(g===0);return g},p.int32=c.next,p.quick=p,d&&(d.x&&i(d,c),p.state=function(){return i(c,{})}),p}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),wPe=es((e,t)=>{(function(n,r,s){function a(l){var u=this;u.next=function(){var d=u.w,p=u.X,h=u.i,m,g;return u.w=d=d+1640531527|0,g=p[h+34&127],m=p[h=h+1&127],g^=g<<13,m^=m<<17,g^=g>>>15,m^=m>>>12,g=p[h]=g^m,u.i=h,g+(d^d>>>16)|0};function c(d,p){var h,m,g,y,b,v=[],k=128;for(p===(p|0)?(m=p,p=null):(p=p+"\0",m=0,k=Math.max(k,p.length)),g=0,y=-32;y<k;++y)p&&(m^=p.charCodeAt((y+32)%p.length)),y===0&&(b=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,y>=0&&(b=b+1640531527|0,h=v[y&127]^=m+b,g=h==0?g+1:0);for(g>=128&&(v[(p&&p.length||0)&127]=-1),g=127,y=4*128;y>0;--y)m=v[g+34&127],h=v[g=g+1&127],m^=m<<13,h^=h<<17,m^=m>>>15,h^=h>>>12,v[g]=m^h;d.w=b,d.X=v,d.i=g}c(u,l)}function i(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function o(l,u){l==null&&(l=+new Date);var c=new a(l),d=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var h=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(h+m)/(1<<21);while(g===0);return g},p.int32=c.next,p.quick=p,d&&(d.X&&i(d,c),p.state=function(){return i(c,{})}),p}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),kPe=es((e,t)=>{(function(n,r,s){function a(l){var u=this,c="";u.next=function(){var p=u.b,h=u.c,m=u.d,g=u.a;return p=p<<25^p>>>7^h,h=h-m|0,m=m<<24^m>>>8^g,g=g-p|0,u.b=p=p<<20^p>>>12^h,u.c=h=h-m|0,u.d=m<<16^h>>>16^g,u.a=g-p|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=l|0):c+=l;for(var d=0;d<c.length+20;d++)u.b^=c.charCodeAt(d)|0,u.next()}function i(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function o(l,u){var c=new a(l),d=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var h=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(h+m)/(1<<21);while(g===0);return g},p.int32=c.next,p.quick=p,d&&(typeof d=="object"&&i(d,c),p.state=function(){return i(c,{})}),p}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),IPe=es(()=>{}),SPe=es((e,t)=>{(function(n,r,s){var a=256,i=6,o=52,l="random",u=s.pow(a,i),c=s.pow(2,o),d=c*2,p=a-1,h;function m(S,N,T){var A=[];N=N==!0?{entropy:!0}:N||{};var R=v(b(N.entropy?[S,I(r)]:S??k(),3),A),D=new g(A),$=function(){for(var _=D.g(i),L=u,z=0;_<c;)_=(_+z)*a,L*=a,z=D.g(1);for(;_>=d;)_/=2,L/=2,z>>>=1;return(_+z)/L};return $.int32=function(){return D.g(4)|0},$.quick=function(){return D.g(4)/4294967296},$.double=$,v(I(D.S),r),(N.pass||T||function(_,L,z,W){return W&&(W.S&&y(W,D),_.state=function(){return y(D,{})}),z?(s[l]=_,L):_})($,R,"global"in N?N.global:this==s,N.state)}function g(S){var N,T=S.length,A=this,R=0,D=A.i=A.j=0,$=A.S=[];for(T||(S=[T++]);R<a;)$[R]=R++;for(R=0;R<a;R++)$[R]=$[D=p&D+S[R%T]+(N=$[R])],$[D]=N;(A.g=function(_){for(var L,z=0,W=A.i,G=A.j,q=A.S;_--;)L=q[W=p&W+1],z=z*a+q[p&(q[W]=q[G=p&G+L])+(q[G]=L)];return A.i=W,A.j=G,z})(a)}function y(S,N){return N.i=S.i,N.j=S.j,N.S=S.S.slice(),N}function b(S,N){var T=[],A=typeof S,R;if(N&&A=="object")for(R in S)try{T.push(b(S[R],N-1))}catch{}return T.length?T:A=="string"?S:S+"\0"}function v(S,N){for(var T=S+"",A,R=0;R<T.length;)N[p&R]=p&(A^=N[p&R]*19)+T.charCodeAt(R++);return I(N)}function k(){try{var S;return h&&(S=h.randomBytes)?S=S(a):(S=new Uint8Array(a),(n.crypto||n.msCrypto).getRandomValues(S)),I(S)}catch{var N=n.navigator,T=N&&N.plugins;return[+new Date,n,T,n.screen,I(r)]}}function I(S){return String.fromCharCode.apply(0,S)}if(v(s.random(),r),typeof t=="object"&&t.exports){t.exports=m;try{h=IPe()}catch{}}else typeof define=="function"&&define.amd?define(function(){return m}):s["seed"+l]=m})(typeof self<"u"?self:e,[],Math)}),VC=es((e,t)=>{var n=yPe(),r=xPe(),s=bPe(),a=vPe(),i=wPe(),o=kPe(),l=SPe();l.alea=n,l.xor128=r,l.xorwow=s,l.xorshift7=a,l.xor4096=i,l.tychei=o,t.exports=l}),mK=es(()=>{}),T3=es(()=>{}),gK=es(()=>{}),CPe=es(()=>{}),NPe=es(()=>{}),TPe=es(()=>{}),$Pe=es((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(s){s=s||{};function a(){return B.buffer!=we&&ft(B.buffer),_e}function i(){return B.buffer!=we&&ft(B.buffer),Le}function o(){return B.buffer!=we&&ft(B.buffer),Be}function l(){return B.buffer!=we&&ft(B.buffer),Ze}function u(){return B.buffer!=we&&ft(B.buffer),ut}var c=typeof s<"u"?s:{},d,p;c.ready=new Promise(function(te,Ie){d=te,p=Ie});var h;typeof process<"u"&&process.listeners&&(h={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var m=Object.assign({},c),g=(te,Ie)=>{throw Ie},y=typeof window=="object",b=typeof importScripts=="function",v=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",k=c.ENVIRONMENT_IS_PTHREAD||!1,I="";function S(te){return c.locateFile?c.locateFile(te,I):I+te}var N,T,A;function R(te){te instanceof ns||W("exiting due to exception: "+te)}if(v){var D=T3(),$=gK();b?I=$.dirname(I)+"/":I=__dirname+"/",N=(Ie,je)=>(Ie=pn(Ie)?new URL(Ie):$.normalize(Ie),D.readFileSync(Ie,je?void 0:"utf8")),A=Ie=>{var je=N(Ie,!0);return je.buffer||(je=new Uint8Array(je)),je},T=(Ie,je,Mt)=>{Ie=pn(Ie)?new URL(Ie):$.normalize(Ie),D.readFile(Ie,function(jt,Gt){jt?Mt(jt):je(Gt.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(Ie){if(!(Ie instanceof ns))throw Ie}),process.on("unhandledRejection",function(Ie){throw Ie}),g=(Ie,je)=>{if(Et())throw process.exitCode=Ie,je;R(je),process.exit(Ie)},c.inspect=function(){return"[Emscripten Module object]"};let te;try{te=CPe()}catch(Ie){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Ie}global.Worker=te.Worker}else(y||b)&&(b?I=self.location.href:typeof document<"u"&&document.currentScript&&(I=document.currentScript.src),typeof r<"u"&&r&&(I=r),I.indexOf("blob:")!==0?I=I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):I="",v||(N=te=>{var Ie=new XMLHttpRequest;return Ie.open("GET",te,!1),Ie.send(null),Ie.responseText},b&&(A=te=>{var Ie=new XMLHttpRequest;return Ie.open("GET",te,!1),Ie.responseType="arraybuffer",Ie.send(null),new Uint8Array(Ie.response)}),T=(te,Ie,je)=>{var Mt=new XMLHttpRequest;Mt.open("GET",te,!0),Mt.responseType="arraybuffer",Mt.onload=()=>{if(Mt.status==200||Mt.status==0&&Mt.response){Ie(Mt.response);return}je()},Mt.onerror=je,Mt.send(null)}));v&&typeof performance>"u"&&(global.performance=NPe().performance);var _=console.log.bind(console),L=console.warn.bind(console);v&&(_=te=>D.writeSync(1,te+`
`),L=te=>D.writeSync(2,te+`
`));var z=c.print||_,W=c.printErr||L;Object.assign(c,m),m=null,c.arguments&&c.arguments,c.thisProgram&&c.thisProgram,c.quit&&(g=c.quit);var G;c.wasmBinary&&(G=c.wasmBinary);var q=c.noExitRuntime||!0;typeof WebAssembly!="object"&&zn("no native wasm support detected");var B,j,H=!1,P;function X(te,Ie){te||zn(Ie)}var Q=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function re(te,Ie,je){Ie>>>=0;for(var Mt=Ie+je,jt=Ie;te[jt]&&!(jt>=Mt);)++jt;if(jt-Ie>16&&te.buffer&&Q)return Q.decode(te.buffer instanceof SharedArrayBuffer?te.slice(Ie,jt):te.subarray(Ie,jt));for(var Gt="";Ie<jt;){var pt=te[Ie++];if(!(pt&128)){Gt+=String.fromCharCode(pt);continue}var Nt=te[Ie++]&63;if((pt&224)==192){Gt+=String.fromCharCode((pt&31)<<6|Nt);continue}var Xn=te[Ie++]&63;if((pt&240)==224?pt=(pt&15)<<12|Nt<<6|Xn:pt=(pt&7)<<18|Nt<<12|Xn<<6|te[Ie++]&63,pt<65536)Gt+=String.fromCharCode(pt);else{var fa=pt-65536;Gt+=String.fromCharCode(55296|fa>>10,56320|fa&1023)}}return Gt}function le(te,Ie){return te>>>=0,te?re(i(),te,Ie):""}function ke(te,Ie,je,Mt){if(je>>>=0,!(Mt>0))return 0;for(var jt=je,Gt=je+Mt-1,pt=0;pt<te.length;++pt){var Nt=te.charCodeAt(pt);if(Nt>=55296&&Nt<=57343){var Xn=te.charCodeAt(++pt);Nt=65536+((Nt&1023)<<10)|Xn&1023}if(Nt<=127){if(je>=Gt)break;Ie[je++>>>0]=Nt}else if(Nt<=2047){if(je+1>=Gt)break;Ie[je++>>>0]=192|Nt>>6,Ie[je++>>>0]=128|Nt&63}else if(Nt<=65535){if(je+2>=Gt)break;Ie[je++>>>0]=224|Nt>>12,Ie[je++>>>0]=128|Nt>>6&63,Ie[je++>>>0]=128|Nt&63}else{if(je+3>=Gt)break;Ie[je++>>>0]=240|Nt>>18,Ie[je++>>>0]=128|Nt>>12&63,Ie[je++>>>0]=128|Nt>>6&63,Ie[je++>>>0]=128|Nt&63}}return Ie[je>>>0]=0,je-jt}function Ne(te,Ie,je){return ke(te,i(),Ie,je)}var we,_e,Le,Be,Ze,ut;k&&(we=c.buffer);function ft(te){we=te,c.HEAP8=_e=new Int8Array(te),c.HEAP16=new Int16Array(te),c.HEAP32=Be=new Int32Array(te),c.HEAPU8=Le=new Uint8Array(te),c.HEAPU16=new Uint16Array(te),c.HEAPU32=Ze=new Uint32Array(te),c.HEAPF32=new Float32Array(te),c.HEAPF64=ut=new Float64Array(te)}var et=c.INITIAL_MEMORY||16777216;if(k)B=c.wasmMemory,we=c.buffer;else if(c.wasmMemory)B=c.wasmMemory;else if(B=new WebAssembly.Memory({initial:et/65536,maximum:65536,shared:!0}),!(B.buffer instanceof SharedArrayBuffer))throw W("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&W("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");B&&(we=B.buffer),et=we.byteLength,ft(we);var Qe,ot=[],gt=[],At=[];function Et(){return q}function dn(){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)Ve(c.preRun.shift());We(ot)}function Xt(){!k&&We(gt)}function In(){if(!k){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)Rt(c.postRun.shift());We(At)}}function Ve(te){ot.unshift(te)}function tt(te){gt.unshift(te)}function Rt(te){At.unshift(te)}var Dt=0,Ut=null;function Pn(te){Dt++,c.monitorRunDependencies&&c.monitorRunDependencies(Dt)}function dr(te){if(Dt--,c.monitorRunDependencies&&c.monitorRunDependencies(Dt),Dt==0&&Ut){var Ie=Ut;Ut=null,Ie()}}function zn(te){c.onAbort&&c.onAbort(te),te="Aborted("+te+")",W(te),H=!0,P=1,te+=". Build with -sASSERTIONS for more info.";var Ie=new WebAssembly.RuntimeError(te);throw p(Ie),Ie}var Gr="data:application/octet-stream;base64,";function Sn(te){return te.startsWith(Gr)}function pn(te){return te.startsWith("file://")}var Fn;Fn="tfjs-backend-wasm-threaded-simd.wasm",Sn(Fn)||(Fn=S(Fn));function Ls(te){try{if(te==Fn&&G)return new Uint8Array(G);if(A)return A(te);throw"both async and sync fetching of the wasm failed"}catch(Ie){zn(Ie)}}function vs(){if(!G&&(y||b)){if(typeof fetch=="function"&&!pn(Fn))return fetch(Fn,{credentials:"same-origin"}).then(function(te){if(!te.ok)throw"failed to load wasm binary file at '"+Fn+"'";return te.arrayBuffer()}).catch(function(){return Ls(Fn)});if(T)return new Promise(function(te,Ie){T(Fn,function(je){te(new Uint8Array(je))},Ie)})}return Promise.resolve().then(function(){return Ls(Fn)})}function Ps(){var te={env:Sm,wasi_snapshot_preview1:Sm};function Ie(pt,Nt){var Xn=pt.exports;if(c.asm=Xn,fr(c.asm._emscripten_tls_init),Qe=c.asm.__indirect_function_table,tt(c.asm.__wasm_call_ctors),j=Nt,!k){var fa=Je.unusedWorkers.length;Je.unusedWorkers.forEach(function(Ao){Je.loadWasmModuleToWorker(Ao,function(){--fa||dr()})})}}k||Pn();function je(pt){Ie(pt.instance,pt.module)}function Mt(pt){return vs().then(function(Nt){return WebAssembly.instantiate(Nt,te)}).then(function(Nt){return Nt}).then(pt,function(Nt){W("failed to asynchronously prepare wasm: "+Nt),zn(Nt)})}function jt(){return!G&&typeof WebAssembly.instantiateStreaming=="function"&&!Sn(Fn)&&!pn(Fn)&&!v&&typeof fetch=="function"?fetch(Fn,{credentials:"same-origin"}).then(function(pt){var Nt=WebAssembly.instantiateStreaming(pt,te);return Nt.then(je,function(Xn){return W("wasm streaming compile failed: "+Xn),W("falling back to ArrayBuffer instantiation"),Mt(je)})}):Mt(je)}if(c.instantiateWasm)try{var Gt=c.instantiateWasm(te,Ie);return Gt}catch(pt){W("Module.instantiateWasm callback failed with error: "+pt),p(pt)}return jt().catch(p),{}}var Qs={};function ns(te){this.name="ExitStatus",this.message="Program terminated with exit("+te+")",this.status=te}function rs(te){var Ie=Je.pthreads[te];delete Je.pthreads[te],Ie.terminate(),Nm(te),Je.runningWorkers.splice(Je.runningWorkers.indexOf(Ie),1),Ie.pthread_ptr=0}function ea(te){var Ie=Je.pthreads[te];Ie.postMessage({cmd:"cancel"})}function Pa(te){var Ie=Je.pthreads[te];X(Ie),Je.returnWorkerToPool(Ie)}function qn(te){var Ie=Je.getNewWorker();if(!Ie)return 6;Je.runningWorkers.push(Ie),Je.pthreads[te.pthread_ptr]=Ie,Ie.pthread_ptr=te.pthread_ptr;var je={cmd:"run",start_routine:te.startRoutine,arg:te.arg,pthread_ptr:te.pthread_ptr};return Ie.runPthread=()=>{v&&Ie.ref(),Ie.postMessage(je,te.transferList),delete Ie.runPthread},Ie.loaded&&Ie.runPthread(),0}function ss(te){if(k)return fu(1,1,te);P=te,Et()||(Je.terminateAllThreads(),c.onExit&&c.onExit(te),H=!0),g(te,new ns(te))}function ye(te,Ie){if(P=te,!Ie&&k)throw Xe(te),"unwind";ss(te)}var Me=ye;function dt(te){if(te instanceof ns||te=="unwind")return P;g(1,te)}var Je={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){k?Je.initWorker():Je.initMainThread()},initMainThread:function(){for(var te=8;te--;)Je.allocateUnusedWorker()},initWorker:function(){q=!1},setExitStatus:function(te){P=te},terminateAllThreads:function(){for(var te of Object.values(Je.pthreads))Je.returnWorkerToPool(te);for(var te of Je.unusedWorkers)te.terminate();Je.unusedWorkers=[]},returnWorkerToPool:function(te){var Ie=te.pthread_ptr;delete Je.pthreads[Ie],Je.unusedWorkers.push(te),Je.runningWorkers.splice(Je.runningWorkers.indexOf(te),1),te.pthread_ptr=0,v&&te.unref(),Nm(Ie)},receiveObjectTransfer:function(te){},threadInitTLS:function(){Je.tlsInitFunctions.forEach(te=>te())},loadWasmModuleToWorker:function(te,Ie){te.onmessage=Gt=>{var pt=Gt.data,Nt=pt.cmd;if(te.pthread_ptr&&(Je.currentProxiedOperationCallerThread=te.pthread_ptr),pt.targetThread&&pt.targetThread!=yl()){var Xn=Je.pthreads[pt.targetThread];Xn?Xn.postMessage(pt,pt.transferList):W('Internal error! Worker sent a message "'+Nt+'" to target pthread '+pt.targetThread+", but that thread no longer exists!"),Je.currentProxiedOperationCallerThread=void 0;return}Nt==="processProxyingQueue"?rc(pt.queue):Nt==="spawnThread"?qn(pt):Nt==="cleanupThread"?Pa(pt.thread):Nt==="killThread"?rs(pt.thread):Nt==="cancelThread"?ea(pt.thread):Nt==="loaded"?(te.loaded=!0,v&&te.unref(),Ie&&Ie(te),te.runPthread&&te.runPthread()):Nt==="print"?z("Thread "+pt.threadId+": "+pt.text):Nt==="printErr"?W("Thread "+pt.threadId+": "+pt.text):Nt==="alert"?alert("Thread "+pt.threadId+": "+pt.text):pt.target==="setimmediate"?te.postMessage(pt):Nt==="callHandler"?c[pt.handler](...pt.args):Nt&&W("worker sent an unknown command "+Nt),Je.currentProxiedOperationCallerThread=void 0},te.onerror=Gt=>{var pt="worker sent an error!";throw W(pt+" "+Gt.filename+":"+Gt.lineno+": "+Gt.message),Gt},v&&(te.on("message",function(Gt){te.onmessage({data:Gt})}),te.on("error",function(Gt){te.onerror(Gt)}),te.on("detachedExit",function(){}));var je=[],Mt=["onExit","onAbort","print","printErr"];for(var jt of Mt)c.hasOwnProperty(jt)&&je.push(jt);te.postMessage({cmd:"load",handlers:je,urlOrBlob:c.mainScriptUrlOrBlob||r,wasmMemory:B,wasmModule:j})},allocateUnusedWorker:function(){var te,Ie=S("tfjs-backend-wasm-threaded-simd.worker.js");te=new Worker(Ie),Je.unusedWorkers.push(te)},getNewWorker:function(){return Je.unusedWorkers.length==0&&(Je.allocateUnusedWorker(),Je.loadWasmModuleToWorker(Je.unusedWorkers[0])),Je.unusedWorkers.pop()}};c.PThread=Je;function We(te){for(;te.length>0;)te.shift()(c)}function it(){var te=yl(),Ie=o()[te+52>>>2],je=o()[te+56>>>2],Mt=Ie-je;Tm(Ie,Mt),Qd(Ie)}c.establishStackSpace=it;function Xe(te){if(k)return fu(2,0,te);try{Me(te)}catch(Ie){dt(Ie)}}var bt=[];function Yt(te){var Ie=bt[te];return Ie||(te>=bt.length&&(bt.length=te+1),bt[te]=Ie=Qe.get(te)),Ie}function Kn(te,Ie){var je=Yt(te)(Ie);Et()?Je.setExitStatus(je):Jx(je)}c.invokeEntryPoint=Kn;function fr(te){Je.tlsInitFunctions.push(te)}function kr(te){_w(te,!b,1,!y),Je.threadInitTLS()}function as(te){k?postMessage({cmd:"cleanupThread",thread:te}):Pa(te)}function On(te,Ie,je,Mt){return k?fu(3,1,te,Ie,je,Mt):mr(te,Ie,je,Mt)}function mr(te,Ie,je,Mt){if(typeof SharedArrayBuffer>"u")return W("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var jt=[],Gt=0;if(k&&(jt.length===0||Gt))return On(te,Ie,je,Mt);var pt={startRoutine:je,pthread_ptr:te,arg:Mt,transferList:jt};return k?(pt.cmd="spawnThread",postMessage(pt,jt),0):qn(pt)}function zs(){return 65536}var hu=!0;function qd(){return hu}function rc(te){Atomics.store(o(),te>>2,1),yl()&&En(te),Atomics.compareExchange(o(),te>>2,1,0)}c.executeNotifiedProxyingQueue=rc;function Kd(te,Ie,je,Mt){if(te==Ie)setTimeout(()=>rc(Mt));else if(k)postMessage({targetThread:te,cmd:"processProxyingQueue",queue:Mt});else{var jt=Je.pthreads[te];if(!jt)return;jt.postMessage({cmd:"processProxyingQueue",queue:Mt})}return 1}function Xd(te,Ie,je){return-1}function Yd(){zn("")}function fn(te){fn.shown||(fn.shown={}),fn.shown[te]||(fn.shown[te]=1,v&&(te="warning: "+te),W(te))}function _i(){v||b||fn("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function Zd(){return Date.now()}function Bn(){return 4294901760}function Yx(){return Bn()}var _o;v?_o=()=>{var te=process.hrtime();return te[0]*1e3+te[1]/1e6}:_o=()=>performance.timeOrigin+performance.now();function Nw(te,Ie,je){i().copyWithin(te>>>0,Ie>>>0,Ie+je>>>0)}function wm(){return v?TPe().cpus().length:navigator.hardwareConcurrency}function xT(te){var Ie=$m(),je=te();return Qd(Ie),je}function fu(te,Ie){var je=arguments.length-2,Mt=arguments;return xT(()=>{for(var jt=je,Gt=ep(jt*8),pt=Gt>>3,Nt=0;Nt<je;Nt++){var Xn=Mt[2+Nt];u()[pt+Nt>>>0]=Xn}return Cm(te,jt,Gt,Ie)})}var sc=[];function eo(te,Ie,je){sc.length=Ie;for(var Mt=je>>3,jt=0;jt<Ie;jt++)sc[jt]=u()[Mt+jt>>>0];var Gt=te<0,pt=Gt?Qs[-te-1]:Ew[te];return pt.apply(null,sc)}function bT(te){try{return B.grow(te-we.byteLength+65535>>>16),ft(B.buffer),1}catch{}}function Ai(te){var Ie=i().length;if(te=te>>>0,te<=Ie)return!1;var je=Bn();if(te>je)return!1;let Mt=(Xn,fa)=>Xn+(fa-Xn%fa)%fa;for(var jt=1;jt<=4;jt*=2){var Gt=Ie*(1+.2/jt);Gt=Math.min(Gt,te+100663296);var pt=Math.min(je,Mt(Math.max(te,Gt),65536)),Nt=bT(pt);if(Nt)return!0}return!1}function vT(){throw"unwind"}function Tw(te){return k?fu(4,1,te):52}function $w(te,Ie,je,Mt,jt){return k?fu(5,1,te,Ie,je,Mt,jt):70}var km=[null,[],[]];function Im(te,Ie){var je=km[te];Ie===0||Ie===10?((te===1?z:W)(re(je,0)),je.length=0):je.push(Ie)}function ac(te,Ie,je,Mt){if(k)return fu(6,1,te,Ie,je,Mt);for(var jt=0,Gt=0;Gt<je;Gt++){var pt=l()[Ie>>>2],Nt=l()[Ie+4>>>2];Ie+=8;for(var Xn=0;Xn<Nt;Xn++)Im(te,i()[pt+Xn>>>0]);jt+=Nt}return l()[Mt>>>2]=jt,0}function Jd(te){var Ie=c["_"+te];return Ie}function wT(te,Ie){a().set(te,Ie>>>0)}function kT(te,Ie,je,Mt,jt){var Gt={string:Bs=>{var uc=0;if(Bs!=null&&Bs!==0){var Aw=(Bs.length<<2)+1;uc=ep(Aw),Ne(Bs,uc,Aw)}return uc},array:Bs=>{var uc=ep(Bs.length);return wT(Bs,uc),uc}};function pt(Bs){return Ie==="string"?le(Bs):Ie==="boolean"?!!Bs:Bs}var Nt=Jd(te),Xn=[],fa=0;if(Mt)for(var Ao=0;Ao<Mt.length;Ao++){var oc=Gt[je[Ao]];oc?(fa===0&&(fa=$m()),Xn[Ao]=oc(Mt[Ao])):Xn[Ao]=Mt[Ao]}var mu=Nt.apply(null,Xn);function lc(Bs){return fa!==0&&Qd(fa),pt(Bs)}return mu=lc(mu),mu}function Zx(te,Ie,je,Mt){je=je||[];var jt=je.every(pt=>pt==="number"||pt==="boolean"),Gt=Ie!=="string";return Gt&&jt&&!Mt?Jd(te):function(){return kT(te,Ie,je,arguments)}}Je.init();var Ew=[null,ss,Xe,On,Tw,$w,ac],Sm={__emscripten_init_main_thread_js:kr,__emscripten_thread_cleanup:as,__pthread_create_js:mr,_emscripten_default_pthread_stack_size:zs,_emscripten_get_now_is_monotonic:qd,_emscripten_notify_task_queue:Kd,_emscripten_set_offscreencanvas_size:Xd,abort:Yd,emscripten_check_blocking_allowed:_i,emscripten_date_now:Zd,emscripten_get_heap_max:Yx,emscripten_get_now:_o,emscripten_memcpy_big:Nw,emscripten_num_logical_cores:wm,emscripten_receive_on_main_thread_js:eo,emscripten_resize_heap:Ai,emscripten_unwind_to_js_event_loop:vT,exit:Me,fd_close:Tw,fd_seek:$w,fd_write:ac,memory:B||c.wasmMemory};Ps(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Acos=function(){return(c._Acos=c.asm.Acos).apply(null,arguments)},c._Acosh=function(){return(c._Acosh=c.asm.Acosh).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._ArgMin=function(){return(c._ArgMin=c.asm.ArgMin).apply(null,arguments)},c._Asin=function(){return(c._Asin=c.asm.Asin).apply(null,arguments)},c._Asinh=function(){return(c._Asinh=c.asm.Asinh).apply(null,arguments)},c._Atan=function(){return(c._Atan=c.asm.Atan).apply(null,arguments)},c._Atan2=function(){return(c._Atan2=c.asm.Atan2).apply(null,arguments)},c._Atanh=function(){return(c._Atanh=c.asm.Atanh).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._AvgPool3D=function(){return(c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},c._AvgPool3DGrad=function(){return(c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},c._AvgPoolGrad=function(){return(c._AvgPoolGrad=c.asm.AvgPoolGrad).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Bincount=function(){return(c._Bincount=c.asm.Bincount).apply(null,arguments)},c._BitwiseAnd=function(){return(c._BitwiseAnd=c.asm.BitwiseAnd).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Conv3D=function(){return(c._Conv3D=c.asm.Conv3D).apply(null,arguments)},c._Conv3DBackpropFilterV2=function(){return(c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},c._Conv3DBackpropInputV2=function(){return(c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DenseBincount=function(){return(c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Diag=function(){return(c._Diag=c.asm.Diag).apply(null,arguments)},c._Dilation2D=function(){return(c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},c._Dilation2DBackpropFilter=function(){return(c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},c._Dilation2DBackpropInput=function(){return(c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._EluGrad=function(){return(c._EluGrad=c.asm.EluGrad).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Erf=function(){return(c._Erf=c.asm.Erf).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._Expm1=function(){return(c._Expm1=c.asm.Expm1).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._IsFinite=function(){return(c._IsFinite=c.asm.IsFinite).apply(null,arguments)},c._IsInf=function(){return(c._IsInf=c.asm.IsInf).apply(null,arguments)},c._IsNan=function(){return(c._IsNan=c.asm.IsNan).apply(null,arguments)},c._LRN=function(){return(c._LRN=c.asm.LRN).apply(null,arguments)},c._LRNGrad=function(){return(c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._LinSpace=function(){return(c._LinSpace=c.asm.LinSpace).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._Log1p=function(){return(c._Log1p=c.asm.Log1p).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._MaxPool3D=function(){return(c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},c._MaxPool3DGrad=function(){return(c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},c._MaxPoolGrad=function(){return(c._MaxPoolGrad=c.asm.MaxPoolGrad).apply(null,arguments)},c._MaxPoolWithArgmax=function(){return(c._MaxPoolWithArgmax=c.asm.MaxPoolWithArgmax).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Mod=function(){return(c._Mod=c.asm.Mod).apply(null,arguments)},c._Multinomial=function(){return(c._Multinomial=c.asm.Multinomial).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Reciprocal=function(){return(c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeBilinearGrad=function(){return(c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._ResizeNearestNeighborGrad=function(){return(c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SearchSorted=function(){return(c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Selu=function(){return(c._Selu=c.asm.Selu).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sign=function(){return(c._Sign=c.asm.Sign).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Sinh=function(){return(c._Sinh=c.asm.Sinh).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._Softplus=function(){return(c._Softplus=c.asm.Softplus).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._SparseToDense=function(){return(c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._TensorScatterUpdate=function(){return(c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(c._malloc=c.asm.malloc).apply(null,arguments)},c._free=function(){return(c._free=c.asm.free).apply(null,arguments)},c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)};var yl=c._pthread_self=function(){return(yl=c._pthread_self=c.asm.pthread_self).apply(null,arguments)};c.___errno_location=function(){return(c.___errno_location=c.asm.__errno_location).apply(null,arguments)};var _w=c.__emscripten_thread_init=function(){return(_w=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)};c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c._emscripten_main_thread_process_queued_calls=function(){return(c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var Cm=c._emscripten_run_in_main_runtime_thread_js=function(){return(Cm=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};c._emscripten_dispatch_to_thread_=function(){return(c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var En=c.__emscripten_proxy_execute_task_queue=function(){return(En=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},Nm=c.__emscripten_thread_free_data=function(){return(Nm=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},Jx=c.__emscripten_thread_exit=function(){return(Jx=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},Tm=c._emscripten_stack_set_limits=function(){return(Tm=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},$m=c.stackSave=function(){return($m=c.stackSave=c.asm.stackSave).apply(null,arguments)},Qd=c.stackRestore=function(){return(Qd=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},ep=c.stackAlloc=function(){return(ep=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)};c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)},c.keepRuntimeAlive=Et,c.wasmMemory=B,c.cwrap=Zx,c.ExitStatus=ns,c.PThread=Je;var ic;Ut=function te(){ic||tp(),ic||(Ut=te)};function tp(te){if(Dt>0)return;if(k){d(c),Xt(),startWorker(c);return}if(dn(),Dt>0)return;function Ie(){ic||(ic=!0,c.calledRun=!0,!H&&(Xt(),d(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),In()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),Ie()},1)):Ie()}if(c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();tp();var Ri;h&&(Ri={uncaughtException:process.listeners("uncaughtException").filter(function(te){return!h.uncaughtException.indexOf(te)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(te){return!h.unhandledRejection.indexOf(te)>-1})});var Di;if(typeof WasmBackendModule<"u")Di=WasmBackendModule;else if(typeof s<"u")Di=s;else throw new Error("Could not find wasm module in post.js");if(Ri){var xl=Di._dispose;Di._dispose=function(){xl(),Ri.uncaughtException.forEach(function(te){process.removeListener("uncaughtException",te)}),Ri.unhandledRejection.forEach(function(te){process.removeListener("unhandledRejection",te)})}}return s.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),EPe=es((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),_Pe=es((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(s){s=s||{};var a=typeof s<"u"?s:{},i,o;a.ready=new Promise(function(ye,Me){i=ye,o=Me});var l;typeof process<"u"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var u=Object.assign({},a),c=typeof window=="object",d=typeof importScripts=="function",p=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",h="";function m(ye){return a.locateFile?a.locateFile(ye,h):h+ye}var g,y,b;if(p){var v=T3(),k=gK();d?h=k.dirname(h)+"/":h=__dirname+"/",g=(ye,Me)=>(ye=et(ye)?new URL(ye):k.normalize(ye),v.readFileSync(ye,Me?void 0:"utf8")),b=ye=>{var Me=g(ye,!0);return Me.buffer||(Me=new Uint8Array(Me)),Me},y=(ye,Me,dt)=>{ye=et(ye)?new URL(ye):k.normalize(ye),v.readFile(ye,function(Je,We){Je?dt(Je):Me(We.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(ye){if(!(ye instanceof Et))throw ye}),process.on("unhandledRejection",function(ye){throw ye}),a.inspect=function(){return"[Emscripten Module object]"}}else(c||d)&&(d?h=self.location.href:typeof document<"u"&&document.currentScript&&(h=document.currentScript.src),r&&(h=r),h.indexOf("blob:")!==0?h=h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):h="",g=ye=>{var Me=new XMLHttpRequest;return Me.open("GET",ye,!1),Me.send(null),Me.responseText},d&&(b=ye=>{var Me=new XMLHttpRequest;return Me.open("GET",ye,!1),Me.responseType="arraybuffer",Me.send(null),new Uint8Array(Me.response)}),y=(ye,Me,dt)=>{var Je=new XMLHttpRequest;Je.open("GET",ye,!0),Je.responseType="arraybuffer",Je.onload=()=>{if(Je.status==200||Je.status==0&&Je.response){Me(Je.response);return}dt()},Je.onerror=dt,Je.send(null)});var I=a.print||console.log.bind(console),S=a.printErr||console.warn.bind(console);Object.assign(a,u),u=null,a.arguments&&a.arguments,a.thisProgram&&a.thisProgram,a.quit&&a.quit;var N;a.wasmBinary&&(N=a.wasmBinary),a.noExitRuntime,typeof WebAssembly!="object"&&Ze("no native wasm support detected");var T,A=!1,R=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function D(ye,Me,dt){Me>>>=0;for(var Je=Me+dt,We=Me;ye[We]&&!(We>=Je);)++We;if(We-Me>16&&ye.buffer&&R)return R.decode(ye.subarray(Me,We));for(var it="";Me<We;){var Xe=ye[Me++];if(!(Xe&128)){it+=String.fromCharCode(Xe);continue}var bt=ye[Me++]&63;if((Xe&224)==192){it+=String.fromCharCode((Xe&31)<<6|bt);continue}var Yt=ye[Me++]&63;if((Xe&240)==224?Xe=(Xe&15)<<12|bt<<6|Yt:Xe=(Xe&7)<<18|bt<<12|Yt<<6|ye[Me++]&63,Xe<65536)it+=String.fromCharCode(Xe);else{var Kn=Xe-65536;it+=String.fromCharCode(55296|Kn>>10,56320|Kn&1023)}}return it}function $(ye,Me){return ye>>>=0,ye?D(G,ye,Me):""}function _(ye,Me,dt,Je){if(dt>>>=0,!(Je>0))return 0;for(var We=dt,it=dt+Je-1,Xe=0;Xe<ye.length;++Xe){var bt=ye.charCodeAt(Xe);if(bt>=55296&&bt<=57343){var Yt=ye.charCodeAt(++Xe);bt=65536+((bt&1023)<<10)|Yt&1023}if(bt<=127){if(dt>=it)break;Me[dt++>>>0]=bt}else if(bt<=2047){if(dt+1>=it)break;Me[dt++>>>0]=192|bt>>6,Me[dt++>>>0]=128|bt&63}else if(bt<=65535){if(dt+2>=it)break;Me[dt++>>>0]=224|bt>>12,Me[dt++>>>0]=128|bt>>6&63,Me[dt++>>>0]=128|bt&63}else{if(dt+3>=it)break;Me[dt++>>>0]=240|bt>>18,Me[dt++>>>0]=128|bt>>12&63,Me[dt++>>>0]=128|bt>>6&63,Me[dt++>>>0]=128|bt&63}}return Me[dt>>>0]=0,dt-We}function L(ye,Me,dt){return _(ye,G,Me,dt)}var z,W,G,q;function B(ye){z=ye,a.HEAP8=W=new Int8Array(ye),a.HEAP16=new Int16Array(ye),a.HEAP32=new Int32Array(ye),a.HEAPU8=G=new Uint8Array(ye),a.HEAPU16=new Uint16Array(ye),a.HEAPU32=q=new Uint32Array(ye),a.HEAPF32=new Float32Array(ye),a.HEAPF64=new Float64Array(ye)}a.INITIAL_MEMORY;var j=[],H=[],P=[];function X(){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)le(a.preRun.shift());dn(j)}function Q(){dn(H)}function re(){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;)Ne(a.postRun.shift());dn(P)}function le(ye){j.unshift(ye)}function ke(ye){H.unshift(ye)}function Ne(ye){P.unshift(ye)}var we=0,_e=null;function Le(ye){we++,a.monitorRunDependencies&&a.monitorRunDependencies(we)}function Be(ye){if(we--,a.monitorRunDependencies&&a.monitorRunDependencies(we),we==0&&_e){var Me=_e;_e=null,Me()}}function Ze(ye){a.onAbort&&a.onAbort(ye),ye="Aborted("+ye+")",S(ye),A=!0,ye+=". Build with -sASSERTIONS for more info.";var Me=new WebAssembly.RuntimeError(ye);throw o(Me),Me}var ut="data:application/octet-stream;base64,";function ft(ye){return ye.startsWith(ut)}function et(ye){return ye.startsWith("file://")}var Qe;Qe="tfjs-backend-wasm.wasm",ft(Qe)||(Qe=m(Qe));function ot(ye){try{if(ye==Qe&&N)return new Uint8Array(N);if(b)return b(ye);throw"both async and sync fetching of the wasm failed"}catch(Me){Ze(Me)}}function gt(){if(!N&&(c||d)){if(typeof fetch=="function"&&!et(Qe))return fetch(Qe,{credentials:"same-origin"}).then(function(ye){if(!ye.ok)throw"failed to load wasm binary file at '"+Qe+"'";return ye.arrayBuffer()}).catch(function(){return ot(Qe)});if(y)return new Promise(function(ye,Me){y(Qe,function(dt){ye(new Uint8Array(dt))},Me)})}return Promise.resolve().then(function(){return ot(Qe)})}function At(){var ye={env:vs,wasi_snapshot_preview1:vs};function Me(Xe,bt){var Yt=Xe.exports;a.asm=Yt,T=a.asm.memory,B(T.buffer),a.asm.__indirect_function_table,ke(a.asm.__wasm_call_ctors),Be()}Le();function dt(Xe){Me(Xe.instance)}function Je(Xe){return gt().then(function(bt){return WebAssembly.instantiate(bt,ye)}).then(function(bt){return bt}).then(Xe,function(bt){S("failed to asynchronously prepare wasm: "+bt),Ze(bt)})}function We(){return!N&&typeof WebAssembly.instantiateStreaming=="function"&&!ft(Qe)&&!et(Qe)&&!p&&typeof fetch=="function"?fetch(Qe,{credentials:"same-origin"}).then(function(Xe){var bt=WebAssembly.instantiateStreaming(Xe,ye);return bt.then(dt,function(Yt){return S("wasm streaming compile failed: "+Yt),S("falling back to ArrayBuffer instantiation"),Je(dt)})}):Je(dt)}if(a.instantiateWasm)try{var it=a.instantiateWasm(ye,Me);return it}catch(Xe){S("Module.instantiateWasm callback failed with error: "+Xe),o(Xe)}return We().catch(o),{}}function Et(ye){this.name="ExitStatus",this.message="Program terminated with exit("+ye+")",this.status=ye}function dn(ye){for(;ye.length>0;)ye.shift()(a)}function Xt(){Ze("")}function In(){return 4294901760}function Ve(){return In()}function tt(ye,Me,dt){G.copyWithin(ye>>>0,Me>>>0,Me+dt>>>0)}function Rt(ye){try{return T.grow(ye-z.byteLength+65535>>>16),B(T.buffer),1}catch{}}function Dt(ye){var Me=G.length;ye=ye>>>0;var dt=In();if(ye>dt)return!1;let Je=(Yt,Kn)=>Yt+(Kn-Yt%Kn)%Kn;for(var We=1;We<=4;We*=2){var it=Me*(1+.2/We);it=Math.min(it,ye+100663296);var Xe=Math.min(dt,Je(Math.max(ye,it),65536)),bt=Rt(Xe);if(bt)return!0}return!1}function Ut(ye){return 52}function Pn(ye,Me,dt,Je,We){return 70}var dr=[null,[],[]];function zn(ye,Me){var dt=dr[ye];Me===0||Me===10?((ye===1?I:S)(D(dt,0)),dt.length=0):dt.push(Me)}function Gr(ye,Me,dt,Je){for(var We=0,it=0;it<dt;it++){var Xe=q[Me>>>2],bt=q[Me+4>>>2];Me+=8;for(var Yt=0;Yt<bt;Yt++)zn(ye,G[Xe+Yt>>>0]);We+=bt}return q[Je>>>2]=We,0}function Sn(ye){var Me=a["_"+ye];return Me}function pn(ye,Me){W.set(ye,Me>>>0)}function Fn(ye,Me,dt,Je,We){var it={string:mr=>{var zs=0;if(mr!=null&&mr!==0){var hu=(mr.length<<2)+1;zs=ns(hu),L(mr,zs,hu)}return zs},array:mr=>{var zs=ns(mr.length);return pn(mr,zs),zs}};function Xe(mr){return Me==="string"?$(mr):Me==="boolean"?!!mr:mr}var bt=Sn(ye),Yt=[],Kn=0;if(Je)for(var fr=0;fr<Je.length;fr++){var kr=it[dt[fr]];kr?(Kn===0&&(Kn=Ps()),Yt[fr]=kr(Je[fr])):Yt[fr]=Je[fr]}var as=bt.apply(null,Yt);function On(mr){return Kn!==0&&Qs(Kn),Xe(mr)}return as=On(as),as}function Ls(ye,Me,dt,Je){dt=dt||[];var We=dt.every(Xe=>Xe==="number"||Xe==="boolean"),it=Me!=="string";return it&&We&&!Je?Sn(ye):function(){return Fn(ye,Me,dt,arguments)}}var vs={abort:Xt,emscripten_get_heap_max:Ve,emscripten_memcpy_big:tt,emscripten_resize_heap:Dt,fd_close:Ut,fd_seek:Pn,fd_write:Gr};At(),a.___wasm_call_ctors=function(){return(a.___wasm_call_ctors=a.asm.__wasm_call_ctors).apply(null,arguments)},a._init=function(){return(a._init=a.asm.init).apply(null,arguments)},a._init_with_threads_count=function(){return(a._init_with_threads_count=a.asm.init_with_threads_count).apply(null,arguments)},a._get_threads_count=function(){return(a._get_threads_count=a.asm.get_threads_count).apply(null,arguments)},a._register_tensor=function(){return(a._register_tensor=a.asm.register_tensor).apply(null,arguments)},a._dispose_data=function(){return(a._dispose_data=a.asm.dispose_data).apply(null,arguments)},a._dispose=function(){return(a._dispose=a.asm.dispose).apply(null,arguments)},a._Abs=function(){return(a._Abs=a.asm.Abs).apply(null,arguments)},a._Acos=function(){return(a._Acos=a.asm.Acos).apply(null,arguments)},a._Acosh=function(){return(a._Acosh=a.asm.Acosh).apply(null,arguments)},a._Add=function(){return(a._Add=a.asm.Add).apply(null,arguments)},a._AddN=function(){return(a._AddN=a.asm.AddN).apply(null,arguments)},a._All=function(){return(a._All=a.asm.All).apply(null,arguments)},a._Any=function(){return(a._Any=a.asm.Any).apply(null,arguments)},a._ArgMax=function(){return(a._ArgMax=a.asm.ArgMax).apply(null,arguments)},a._ArgMin=function(){return(a._ArgMin=a.asm.ArgMin).apply(null,arguments)},a._Asin=function(){return(a._Asin=a.asm.Asin).apply(null,arguments)},a._Asinh=function(){return(a._Asinh=a.asm.Asinh).apply(null,arguments)},a._Atan=function(){return(a._Atan=a.asm.Atan).apply(null,arguments)},a._Atan2=function(){return(a._Atan2=a.asm.Atan2).apply(null,arguments)},a._Atanh=function(){return(a._Atanh=a.asm.Atanh).apply(null,arguments)},a._AvgPool=function(){return(a._AvgPool=a.asm.AvgPool).apply(null,arguments)},a._AvgPool3D=function(){return(a._AvgPool3D=a.asm.AvgPool3D).apply(null,arguments)},a._AvgPool3DGrad=function(){return(a._AvgPool3DGrad=a.asm.AvgPool3DGrad).apply(null,arguments)},a._AvgPoolGrad=function(){return(a._AvgPoolGrad=a.asm.AvgPoolGrad).apply(null,arguments)},a._BatchMatMul=function(){return(a._BatchMatMul=a.asm.BatchMatMul).apply(null,arguments)},a._Bincount=function(){return(a._Bincount=a.asm.Bincount).apply(null,arguments)},a._BitwiseAnd=function(){return(a._BitwiseAnd=a.asm.BitwiseAnd).apply(null,arguments)},a._Ceil=function(){return(a._Ceil=a.asm.Ceil).apply(null,arguments)},a._ClipByValue=function(){return(a._ClipByValue=a.asm.ClipByValue).apply(null,arguments)},a._Conv2D=function(){return(a._Conv2D=a.asm.Conv2D).apply(null,arguments)},a._Conv2DBackpropInput=function(){return(a._Conv2DBackpropInput=a.asm.Conv2DBackpropInput).apply(null,arguments)},a._Conv3D=function(){return(a._Conv3D=a.asm.Conv3D).apply(null,arguments)},a._Conv3DBackpropFilterV2=function(){return(a._Conv3DBackpropFilterV2=a.asm.Conv3DBackpropFilterV2).apply(null,arguments)},a._Conv3DBackpropInputV2=function(){return(a._Conv3DBackpropInputV2=a.asm.Conv3DBackpropInputV2).apply(null,arguments)},a._Cos=function(){return(a._Cos=a.asm.Cos).apply(null,arguments)},a._Cosh=function(){return(a._Cosh=a.asm.Cosh).apply(null,arguments)},a._CropAndResize=function(){return(a._CropAndResize=a.asm.CropAndResize).apply(null,arguments)},a._Cumprod=function(){return(a._Cumprod=a.asm.Cumprod).apply(null,arguments)},a._Cumsum=function(){return(a._Cumsum=a.asm.Cumsum).apply(null,arguments)},a._DenseBincount=function(){return(a._DenseBincount=a.asm.DenseBincount).apply(null,arguments)},a._DepthToSpace=function(){return(a._DepthToSpace=a.asm.DepthToSpace).apply(null,arguments)},a._DepthwiseConv2dNative=function(){return(a._DepthwiseConv2dNative=a.asm.DepthwiseConv2dNative).apply(null,arguments)},a._Diag=function(){return(a._Diag=a.asm.Diag).apply(null,arguments)},a._Dilation2D=function(){return(a._Dilation2D=a.asm.Dilation2D).apply(null,arguments)},a._Dilation2DBackpropFilter=function(){return(a._Dilation2DBackpropFilter=a.asm.Dilation2DBackpropFilter).apply(null,arguments)},a._Dilation2DBackpropInput=function(){return(a._Dilation2DBackpropInput=a.asm.Dilation2DBackpropInput).apply(null,arguments)},a._Elu=function(){return(a._Elu=a.asm.Elu).apply(null,arguments)},a._EluGrad=function(){return(a._EluGrad=a.asm.EluGrad).apply(null,arguments)},a._Equal=function(){return(a._Equal=a.asm.Equal).apply(null,arguments)},a._Erf=function(){return(a._Erf=a.asm.Erf).apply(null,arguments)},a._Exp=function(){return(a._Exp=a.asm.Exp).apply(null,arguments)},a._Expm1=function(){return(a._Expm1=a.asm.Expm1).apply(null,arguments)},a._FlipLeftRight=function(){return(a._FlipLeftRight=a.asm.FlipLeftRight).apply(null,arguments)},a._Floor=function(){return(a._Floor=a.asm.Floor).apply(null,arguments)},a._FloorDiv=function(){return(a._FloorDiv=a.asm.FloorDiv).apply(null,arguments)},a._FusedBatchNorm=function(){return(a._FusedBatchNorm=a.asm.FusedBatchNorm).apply(null,arguments)},a._FusedConv2D=function(){return(a._FusedConv2D=a.asm.FusedConv2D).apply(null,arguments)},a._FusedDepthwiseConv2D=function(){return(a._FusedDepthwiseConv2D=a.asm.FusedDepthwiseConv2D).apply(null,arguments)},a._Gather=function(){return(a._Gather=a.asm.Gather).apply(null,arguments)},a._GatherNd=function(){return(a._GatherNd=a.asm.GatherNd).apply(null,arguments)},a._Greater=function(){return(a._Greater=a.asm.Greater).apply(null,arguments)},a._GreaterEqual=function(){return(a._GreaterEqual=a.asm.GreaterEqual).apply(null,arguments)},a._IsFinite=function(){return(a._IsFinite=a.asm.IsFinite).apply(null,arguments)},a._IsInf=function(){return(a._IsInf=a.asm.IsInf).apply(null,arguments)},a._IsNan=function(){return(a._IsNan=a.asm.IsNan).apply(null,arguments)},a._LRN=function(){return(a._LRN=a.asm.LRN).apply(null,arguments)},a._LRNGrad=function(){return(a._LRNGrad=a.asm.LRNGrad).apply(null,arguments)},a._LeakyRelu=function(){return(a._LeakyRelu=a.asm.LeakyRelu).apply(null,arguments)},a._Less=function(){return(a._Less=a.asm.Less).apply(null,arguments)},a._LessEqual=function(){return(a._LessEqual=a.asm.LessEqual).apply(null,arguments)},a._LinSpace=function(){return(a._LinSpace=a.asm.LinSpace).apply(null,arguments)},a._Log=function(){return(a._Log=a.asm.Log).apply(null,arguments)},a._Log1p=function(){return(a._Log1p=a.asm.Log1p).apply(null,arguments)},a._LogicalAnd=function(){return(a._LogicalAnd=a.asm.LogicalAnd).apply(null,arguments)},a._LogicalNot=function(){return(a._LogicalNot=a.asm.LogicalNot).apply(null,arguments)},a._LogicalOr=function(){return(a._LogicalOr=a.asm.LogicalOr).apply(null,arguments)},a._LogicalXor=function(){return(a._LogicalXor=a.asm.LogicalXor).apply(null,arguments)},a._Max=function(){return(a._Max=a.asm.Max).apply(null,arguments)},a._MaxPool=function(){return(a._MaxPool=a.asm.MaxPool).apply(null,arguments)},a._MaxPool3D=function(){return(a._MaxPool3D=a.asm.MaxPool3D).apply(null,arguments)},a._MaxPool3DGrad=function(){return(a._MaxPool3DGrad=a.asm.MaxPool3DGrad).apply(null,arguments)},a._MaxPoolGrad=function(){return(a._MaxPoolGrad=a.asm.MaxPoolGrad).apply(null,arguments)},a._MaxPoolWithArgmax=function(){return(a._MaxPoolWithArgmax=a.asm.MaxPoolWithArgmax).apply(null,arguments)},a._Maximum=function(){return(a._Maximum=a.asm.Maximum).apply(null,arguments)},a._Mean=function(){return(a._Mean=a.asm.Mean).apply(null,arguments)},a._Min=function(){return(a._Min=a.asm.Min).apply(null,arguments)},a._Minimum=function(){return(a._Minimum=a.asm.Minimum).apply(null,arguments)},a._MirrorPad=function(){return(a._MirrorPad=a.asm.MirrorPad).apply(null,arguments)},a._Mod=function(){return(a._Mod=a.asm.Mod).apply(null,arguments)},a._Multinomial=function(){return(a._Multinomial=a.asm.Multinomial).apply(null,arguments)},a._Multiply=function(){return(a._Multiply=a.asm.Multiply).apply(null,arguments)},a._Neg=function(){return(a._Neg=a.asm.Neg).apply(null,arguments)},a._NonMaxSuppressionV3=function(){return(a._NonMaxSuppressionV3=a.asm.NonMaxSuppressionV3).apply(null,arguments)},a._NonMaxSuppressionV4=function(){return(a._NonMaxSuppressionV4=a.asm.NonMaxSuppressionV4).apply(null,arguments)},a._NonMaxSuppressionV5=function(){return(a._NonMaxSuppressionV5=a.asm.NonMaxSuppressionV5).apply(null,arguments)},a._NotEqual=function(){return(a._NotEqual=a.asm.NotEqual).apply(null,arguments)},a._OneHot=function(){return(a._OneHot=a.asm.OneHot).apply(null,arguments)},a._PadV2=function(){return(a._PadV2=a.asm.PadV2).apply(null,arguments)},a._Pow=function(){return(a._Pow=a.asm.Pow).apply(null,arguments)},a._Prelu=function(){return(a._Prelu=a.asm.Prelu).apply(null,arguments)},a._Prod=function(){return(a._Prod=a.asm.Prod).apply(null,arguments)},a._RealDiv=function(){return(a._RealDiv=a.asm.RealDiv).apply(null,arguments)},a._Reciprocal=function(){return(a._Reciprocal=a.asm.Reciprocal).apply(null,arguments)},a._Relu=function(){return(a._Relu=a.asm.Relu).apply(null,arguments)},a._Relu6=function(){return(a._Relu6=a.asm.Relu6).apply(null,arguments)},a._ResizeBilinear=function(){return(a._ResizeBilinear=a.asm.ResizeBilinear).apply(null,arguments)},a._ResizeBilinearGrad=function(){return(a._ResizeBilinearGrad=a.asm.ResizeBilinearGrad).apply(null,arguments)},a._ResizeNearestNeighbor=function(){return(a._ResizeNearestNeighbor=a.asm.ResizeNearestNeighbor).apply(null,arguments)},a._ResizeNearestNeighborGrad=function(){return(a._ResizeNearestNeighborGrad=a.asm.ResizeNearestNeighborGrad).apply(null,arguments)},a._Reverse=function(){return(a._Reverse=a.asm.Reverse).apply(null,arguments)},a._RotateWithOffset=function(){return(a._RotateWithOffset=a.asm.RotateWithOffset).apply(null,arguments)},a._Round=function(){return(a._Round=a.asm.Round).apply(null,arguments)},a._Rsqrt=function(){return(a._Rsqrt=a.asm.Rsqrt).apply(null,arguments)},a._ScatterNd=function(){return(a._ScatterNd=a.asm.ScatterNd).apply(null,arguments)},a._SearchSorted=function(){return(a._SearchSorted=a.asm.SearchSorted).apply(null,arguments)},a._SelectV2=function(){return(a._SelectV2=a.asm.SelectV2).apply(null,arguments)},a._Selu=function(){return(a._Selu=a.asm.Selu).apply(null,arguments)},a._Sigmoid=function(){return(a._Sigmoid=a.asm.Sigmoid).apply(null,arguments)},a._Sign=function(){return(a._Sign=a.asm.Sign).apply(null,arguments)},a._Sin=function(){return(a._Sin=a.asm.Sin).apply(null,arguments)},a._Sinh=function(){return(a._Sinh=a.asm.Sinh).apply(null,arguments)},a._Softmax=function(){return(a._Softmax=a.asm.Softmax).apply(null,arguments)},a._Softplus=function(){return(a._Softplus=a.asm.Softplus).apply(null,arguments)},a._SparseFillEmptyRows=function(){return(a._SparseFillEmptyRows=a.asm.SparseFillEmptyRows).apply(null,arguments)},a._SparseReshape=function(){return(a._SparseReshape=a.asm.SparseReshape).apply(null,arguments)},a._SparseSegmentReduction=function(){return(a._SparseSegmentReduction=a.asm.SparseSegmentReduction).apply(null,arguments)},a._SparseToDense=function(){return(a._SparseToDense=a.asm.SparseToDense).apply(null,arguments)},a._Sqrt=function(){return(a._Sqrt=a.asm.Sqrt).apply(null,arguments)},a._Square=function(){return(a._Square=a.asm.Square).apply(null,arguments)},a._SquaredDifference=function(){return(a._SquaredDifference=a.asm.SquaredDifference).apply(null,arguments)},a._Step=function(){return(a._Step=a.asm.Step).apply(null,arguments)},a._StridedSlice=function(){return(a._StridedSlice=a.asm.StridedSlice).apply(null,arguments)},a._Sub=function(){return(a._Sub=a.asm.Sub).apply(null,arguments)},a._Sum=function(){return(a._Sum=a.asm.Sum).apply(null,arguments)},a._Tan=function(){return(a._Tan=a.asm.Tan).apply(null,arguments)},a._Tanh=function(){return(a._Tanh=a.asm.Tanh).apply(null,arguments)},a._TensorScatterUpdate=function(){return(a._TensorScatterUpdate=a.asm.TensorScatterUpdate).apply(null,arguments)},a._Tile=function(){return(a._Tile=a.asm.Tile).apply(null,arguments)},a._TopK=function(){return(a._TopK=a.asm.TopK).apply(null,arguments)},a._Transform=function(){return(a._Transform=a.asm.Transform).apply(null,arguments)},a._Transpose=function(){return(a._Transpose=a.asm.Transpose).apply(null,arguments)},a.__FusedMatMul=function(){return(a.__FusedMatMul=a.asm._FusedMatMul).apply(null,arguments)},a._malloc=function(){return(a._malloc=a.asm.malloc).apply(null,arguments)},a._free=function(){return(a._free=a.asm.free).apply(null,arguments)},a.___errno_location=function(){return(a.___errno_location=a.asm.__errno_location).apply(null,arguments)};var Ps=a.stackSave=function(){return(Ps=a.stackSave=a.asm.stackSave).apply(null,arguments)},Qs=a.stackRestore=function(){return(Qs=a.stackRestore=a.asm.stackRestore).apply(null,arguments)},ns=a.stackAlloc=function(){return(ns=a.stackAlloc=a.asm.stackAlloc).apply(null,arguments)};a.dynCall_iijjiiii=function(){return(a.dynCall_iijjiiii=a.asm.dynCall_iijjiiii).apply(null,arguments)},a.dynCall_jiji=function(){return(a.dynCall_jiji=a.asm.dynCall_jiji).apply(null,arguments)},a.cwrap=Ls;var rs;_e=function ye(){rs||ea(),rs||(_e=ye)};function ea(ye){if(we>0||(X(),we>0))return;function Me(){rs||(rs=!0,a.calledRun=!0,!A&&(Q(),i(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),re()))}a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),Me()},1)):Me()}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();ea();var Pa;l&&(Pa={uncaughtException:process.listeners("uncaughtException").filter(function(ye){return!l.uncaughtException.indexOf(ye)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(ye){return!l.unhandledRejection.indexOf(ye)>-1})});var qn;if(typeof s<"u")qn=s;else if(typeof WasmBackendModuleThreadedSimd<"u")qn=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Pa){var ss=qn._dispose;qn._dispose=function(){ss(),Pa.uncaughtException.forEach(function(ye){process.removeListener("uncaughtException",ye)}),Pa.unhandledRejection.forEach(function(ye){process.removeListener("unhandledRejection",ye)})}}return s.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),UC=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},w1=class{refCount(e){return di("refCount")}incRef(e){return di("incRef")}timerAvailable(){return!0}time(e){return di("time")}read(e){return di("read")}readSync(e){return di("readSync")}readToGPU(e,t){return di("readToGPU")}numDataIds(){return di("numDataIds")}disposeData(e,t){return di("disposeData")}write(e,t,n){return di("write")}move(e,t,n,r,s){return di("move")}createTensorFromGPUData(e,t,n){return di("createTensorFromGPUData")}memory(){return di("memory")}floatPrecision(){return di("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return di("dispose")}};function di(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function yK(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,vI(e,t,n)}function APe(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,vI(e,n,r),vI(t,n,r)}function Tv(e,t,n){return Math.max(e,Math.min(t,n))}function RPe(e){return e%2===0?e:e+1}function vI(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function DPe(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function FPe(e,t){let n=Math.random();return t*n+(1-n)*e}function OPe(e,t){let n=0;for(let r=0;r<e.length;r++){let s=Number(e[r])-Number(t[r]);n+=s*s}return n}function Z(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function Fa(e,t,n=""){Z(Xu(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Uh(e){Z(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Gn(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function MPe(e){return e.length===0}function xK(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function Xu(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Lg(e){return e%1===0}function LPe(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function PPe(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function zPe(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return yK(t),t}function sv(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function BPe(e,t=s=>0,n,r){return new Promise((s,a)=>{let i=0,o=()=>{if(e()){s();return}i++;let l=t(i);if(n!=null&&i>=n){a();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function WPe(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(e[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let s=e.slice();return s[r]=t/n,s}function To(e,t){let n=t.length;return e=e==null?t.map((r,s)=>s):[].concat(e),Z(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),Z(e.every(r=>Lg(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function bK(e,t){let n=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||s?null:To(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(a!=null){if(a[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(a[i]==null||a[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function vK(e,t){return $3(e,t)}function $3(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function wK(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function kK(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function VPe(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function wI(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function IK(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Lc(e){return typeof e=="string"||e instanceof String}function SK(e){return typeof e=="boolean"}function CK(e){return typeof e=="number"}function k1(e){return Array.isArray(e)?k1(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":CK(e)?"float32":Lc(e)?"string":SK(e)?"bool":"float32"}function nd(e){return!!(e&&e.constructor&&e.call&&e.apply)}function kI(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Ny(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function NK(e,t,n,r=!1){let s=new Array;if(t.length===1){let a=t[0]*(r?2:1);for(let i=0;i<a;i++)s[i]=n[e+i]}else{let a=t[0],i=t.slice(1),o=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<a;l++)s[l]=NK(e+l*o,i,n,r)}return s}function xg(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return NK(0,e,t,n)}function UPe(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function E3(e,t){let n=GC(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function GC(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function GPe(e,t){let n=e.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return xg(e,new Float32Array(n));if(t==="int32")return xg(e,new Int32Array(n));if(t==="bool")return xg(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Ei(e){e.forEach(t=>{Z(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function jPe(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function HPe(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function jC(e){return e&&e.then&&typeof e.then=="function"}var cU="tfjsflags",TK=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=qPe,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let r=this.urlFlags[e];xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(jC(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);cU in e&&e[cU].split(",").forEach(t=>{let[n,r]=t.split(":");this.urlFlags[n]=XPe(n,r)})}};function qPe(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(KPe(t,r[0],r[1]),r.join("="))),t}function KPe(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function XPe(e,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function xe(){return _3}var _3=null;function YPe(e){_3=e}var ME;function $K(){if(ME==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");ME=e}return ME}function ZPe(){let e=$K();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function A3(e,t){let n=ZPe();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var Ty="Abs",Gh="Acos",jh="Acosh",Ad="Add",Hh="AddN",$y="All",Ey="Any",_y="ArgMax",Ay="ArgMin",qh="Asin",Kh="Asinh",Xh="Atan",Yh="Atanh",Zh="Atan2",Jh="AvgPool",I1="AvgPoolGrad",Ry="AvgPool3D",S1="AvgPool3DGrad",Qh="BatchMatMul",Dy="BatchToSpaceND",Fy="Bincount",Oy="BitwiseAnd",EK="BroadcastTo",C1="BroadcastArgs",ef="Cast",tf="Ceil",Rd="ClipByValue",HC="Complex",N1="ComplexAbs",My="Concat",nf="Conv2D",qC="Conv2DBackpropFilter",rf="Conv2DBackpropInput",sf="Conv3D",Ly="Conv3DBackpropFilterV2",Py="Conv3DBackpropInputV2",af="Cos",of="Cosh",zy="Cumprod",lf="Cumsum",By="CropAndResize",T1="DenseBincount",Wy="DepthToSpace",uf="DepthwiseConv2dNative",KC="DepthwiseConv2dNativeBackpropFilter",XC="DepthwiseConv2dNativeBackpropInput",$1="Diag",cf="Dilation2D",Pg="Dilation2DBackpropInput",zg="Dilation2DBackpropFilter",YC="Draw",df="RealDiv",ZC="Einsum",pf="Elu",Vy="EluGrad",hf="Erf",Uy="Equal",ff="Exp",Gy="ExpandDims",mf="Expm1",JC="FFT",E1="Fill",jy="FlipLeftRight",gf="Floor",yf="FloorDiv",xf="FusedBatchNorm",Hy="GatherV2",qy="GatherNd",Ky="Greater",bf="GreaterEqual",vf="Identity",QC="IFFT",eN="Imag",wf="IsFinite",kf="IsInf",If="IsNan",Sf="LeakyRelu",Xy="Less",Yy="LessEqual",Zy="LinSpace",Cf="Log",Nf="Log1p",Jy="LogicalAnd",Qy="LogicalNot",ex="LogicalOr",_K="LogicalXor",AK="LogSoftmax",JPe="LowerBound",Tf="LRN",tx="LRNGrad",QPe="MatrixBandPart",$f="Max",Ef="Maximum",_f="MaxPool",_1="MaxPoolGrad",nx="MaxPool3D",A1="MaxPool3DGrad",R1="MaxPoolWithArgmax",Af="Mean",Rf="Min",Df="Minimum",Ff="MirrorPad",Of="Mod",rx="Multinomial",Mf="Multiply",sx="Neg",ax="NotEqual",ix="NonMaxSuppressionV3",ox="NonMaxSuppressionV4",lx="NonMaxSuppressionV5",ux="OnesLike",Lf="OneHot",cx="Pack",Pf="PadV2",e4e="Pool",zf="Pow",Bf="Prelu",Wf="Prod",tN="RaggedGather",nN="RaggedRange",rN="RaggedTensorToTensor",D1="Range",sN="Real",Vf="Reciprocal",Uf="Relu",dx="Reshape",Gf="ResizeNearestNeighbor",px="ResizeNearestNeighborGrad",jf="ResizeBilinear",hx="ResizeBilinearGrad",Hf="Relu6",qf="Reverse",Kf="Round",Xf="Rsqrt",fx="ScatterNd",mx="TensorScatterUpdate",gx="SearchSorted",yx="Select",Yf="Selu",xx="Slice",Zf="Sin",Jf="Sinh",Qf="Sign",em="Sigmoid",tm="Softplus",nm="Sqrt",rm="Sum",bx="SpaceToBatchND",vx="SplitV",sm="Softmax",F1="SparseFillEmptyRows",wx="SparseReshape",O1="SparseSegmentMean",M1="SparseSegmentSum",kx="SparseToDense",am="SquaredDifference",L1="Square",P1="StaticRegexReplace",Ix="StridedSlice",z1="StringNGrams",B1="StringSplit",W1="StringToHashBucketFast",im="Sub",om="Tan",lm="Tanh",Dd="Tile",Sx="TopK",Cx="Transform",Ru="Transpose",V1="Unique",Nx="Unpack",U1="UnsortedSegmentSum",t4e="UpperBound",Tx="ZerosLike",Fd="Step",II="FromPixels",$x="RotateWithOffset",ph="_FusedMatMul",hh="FusedConv2D",fh="FusedDepthwiseConv2D";function Dc(...e){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(...e)}function n4e(...e){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.log(...e)}var Bg=A3("kernelRegistry",()=>new Map),$v=A3("gradRegistry",()=>new Map);function Ev(e,t){let n=R3(e,t);return Bg.get(n)}function mA(e){return $v.get(e)}function SI(e){let t=Bg.entries(),n=[];for(;;){let{done:r,value:s}=t.next();if(r)break;let[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function G1(e){let{kernelName:t,backendName:n}=e,r=R3(t,n);Bg.has(r)&&Dc(`The kernel '${t}' for backend '${n}' is already registered`),Bg.set(r,e)}function RK(e){let{kernelName:t}=e;$v.has(t)&&xe().getBool("DEBUG")&&Dc(`Overriding the gradient for '${t}'`),$v.set(t,e)}function r4e(e,t){let n=R3(e,t);if(!Bg.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Bg.delete(n)}function s4e(e){if(!$v.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);$v.delete(e)}function a4e(e,t){SI(e).forEach(n=>{let r=Object.assign({},n,{backendName:t});G1(r)})}function R3(e,t){return`${t}_${e}`}var O={};Kt(O,{arraysEqual:()=>Xu,arraysEqualWithNull:()=>xK,assert:()=>Z,assertNonNegativeIntegerDimensions:()=>Ei,assertNonNull:()=>Uh,assertShapesMatch:()=>Fa,bytesFromStringArray:()=>IK,bytesPerElement:()=>wI,checkConversionForErrors:()=>wK,clamp:()=>Tv,computeStrides:()=>Ny,convertBackendValuesAndArrayBuffer:()=>UPe,createScalarValue:()=>d4e,createShuffledIndices:()=>zPe,decodeString:()=>CI,distSquared:()=>OPe,encodeString:()=>H1,fetch:()=>h4e,fingerPrint64:()=>c4e,flatten:()=>rd,getArrayFromDType:()=>$3,getTypedArrayFromDType:()=>vK,hasEncodingLoss:()=>VPe,hexToLong:()=>j1,indexToLoc:()=>HPe,inferDtype:()=>k1,inferFromImplicitShape:()=>WPe,isBoolean:()=>SK,isFunction:()=>nd,isInt:()=>Lg,isNumber:()=>CK,isPromise:()=>jC,isScalarShape:()=>MPe,isString:()=>Lc,isTypedArray:()=>Ts,isValidDtype:()=>kK,locToIndex:()=>jPe,makeOnesTypedArray:()=>E3,makeZerosNestedTypedArray:()=>GPe,makeZerosTypedArray:()=>GC,nearestDivisor:()=>kI,nearestLargerEven:()=>RPe,now:()=>_v,parseAxisParam:()=>To,randUniform:()=>FPe,repeatedTry:()=>BPe,rightPad:()=>sv,shuffle:()=>yK,shuffleCombo:()=>APe,sizeFromShape:()=>Gn,sizeToSquarishShape:()=>PPe,squeezeShape:()=>bK,sum:()=>DPe,swap:()=>vI,tanh:()=>LPe,toNestedArray:()=>xg,toTypedArray:()=>aN});function DK(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var dU=_d(fPe()),Tp=dU.default||dU;function j1(e){return Tp.fromString(e,!0,16)}var FK=j1("c3a5c85c97cb3127"),vp=j1("b492b66fbe98f273"),ka=j1("9ae16a3b2f90404f");function gA(e){return e.xor(e.shru(47))}function OK(e,t,n){let r=e.slice(t,t+n);return Tp.fromBytes(Array.from(r),!0,!0)}function ir(e,t){return OK(e,t,8)}function pU(e,t){return OK(e,t,4)}function Ns(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Hc(e,t,n=j1("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function i4e(e,t,n,r,s,a){s=s.add(e),a=Ns(a.add(s).add(r),21);let i=s;return s=s.add(t),s=s.add(n),a=a.add(Ns(s,44)),[s.add(r),a.add(i)]}function Kk(e,t,n,r){return i4e(ir(e,t),ir(e,t+8),ir(e,t+16),ir(e,t+24),n,r)}function o4e(e,t=e.length){if(t>=8){let n=ka.add(t*2),r=ir(e,0).add(ka),s=ir(e,t-8),a=Ns(s,37).mul(n).add(r),i=Ns(r,25).add(s).mul(n);return Hc(a,i,n)}if(t>=4){let n=ka.add(t*2),r=pU(e,0);return Hc(r.shl(3).add(t),pU(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],s=e[t-1],a=n+(r<<8),i=t+(s<<2);return gA(ka.mul(a).xor(FK.mul(i))).mul(ka)}return ka}function l4e(e,t=e.length){let n=ka.add(t*2),r=ir(e,0).mul(vp),s=ir(e,8),a=ir(e,t-8).mul(n),i=ir(e,t-16).mul(ka);return Hc(Ns(r.add(s),43).add(Ns(a,30)).add(i),r.add(Ns(s.add(ka),18)).add(a),n)}function u4e(e,t=e.length){let n=ka.add(t*2),r=ir(e,0).mul(ka),s=ir(e,8),a=ir(e,t-8).mul(n),i=ir(e,t-16).mul(ka),o=Ns(r.add(s),43).add(Ns(a,30)).add(i),l=Hc(o,r.add(Ns(s.add(ka),18)).add(a),n),u=ir(e,16).mul(n),c=ir(e,24),d=o.add(ir(e,t-32)).mul(n),p=l.add(ir(e,t-24)).mul(n);return Hc(Ns(u.add(c),43).add(Ns(d,30)).add(p),u.add(Ns(c.add(r),18)).add(d),n)}function c4e(e,t=e.length){let n=Tp.fromNumber(81,!0);if(t<=32)return t<=16?o4e(e,t):l4e(e,t);if(t<=64)return u4e(e,t);let r=n,s=n.mul(vp).add(113),a=gA(s.mul(ka).add(113)).mul(ka),i=[Tp.UZERO,Tp.UZERO],o=[Tp.UZERO,Tp.UZERO];r=r.mul(ka).add(ir(e,0));let l=0,u=(t-1>>6)*64,c=u+(t-1&63)-63;do r=Ns(r.add(s).add(i[0]).add(ir(e,l+8)),37).mul(vp),s=Ns(s.add(i[1]).add(ir(e,l+48)),42).mul(vp),r=r.xor(o[1]),s=s.add(i[0]).add(ir(e,l+40)),a=Ns(a.add(o[0]),33).mul(vp),i=Kk(e,l,i[1].mul(vp),r.add(o[0])),o=Kk(e,l+32,a.add(o[1]),s.add(ir(e,l+16))),[a,r]=[r,a],l+=64;while(l!==u);let d=vp.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Ns(r.add(s).add(i[0]).add(ir(e,l+8)),37).mul(d),s=Ns(s.add(i[1]).add(ir(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(ir(e,l+40))),a=Ns(a.add(o[0]),33).mul(d),i=Kk(e,l,i[1].mul(d),r.add(o[0])),o=Kk(e,l+32,a.add(o[1]),s.add(ir(e,l+16))),[a,r]=[r,a],Hc(Hc(i[0],o[0],d).add(gA(s).mul(FK)).add(a),Hc(i[1],o[1],d).add(r),d)}function d4e(e,t){return t==="string"?H1(e):aN([e],t)}function p4e(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function aN(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=rd(e)),xe().getBool("DEBUG")&&wK(e,t),p4e(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function _v(){return xe().platform.now()}function h4e(e,t){return xe().platform.fetch(e,t)}function H1(e,t="utf-8"){return t=t||"utf-8",xe().platform.encode(e,t)}function CI(e,t="utf-8"){return t=t||"utf-8",xe().platform.decode(e,t)}function Ts(e){return xe().platform.isTypedArray!=null?xe().platform.isTypedArray(e):DK(e)}function rd(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||jC(e)||e==null||Ts(e)&&n)t.push(e);else if(Array.isArray(e)||Ts(e))for(let r=0;r<e.length;++r)rd(e[r],t,n);else{let r=-1;for(let s of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)rd(e[s],t,n)}return t}var f4e=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new g4e)}profileKernel(e,t,n){let r,s=()=>{r=n()},a,i=_v();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let o of r)o.dataSync();a=Promise.resolve({kernelMs:_v()-i})}if(xe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let l=r[o];l.data().then(u=>{m4e(u,l.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(o=>o.kernelMs),extraInfo:a.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach(i=>{Promise.all([i.data(),r,a]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],s,o[2])})})}};function m4e(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}var g4e=class{logKernelProfile(e,t,n,r,s,a){let i=typeof r=="number"?sv(`${r}ms`,9):r.error,o=sv(e,25),l=t.rank,u=t.size,c=sv(t.shape.toString(),14),d="";for(let p in s){let h=s[p];if(h!=null){let m=h.shape||t.shape,g=m.length;d+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${c}	%c${u}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function y4e(e,t,n){let r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let u=e[l],c=u.inputs;for(let d in c){let p=c[d],h=!1;for(let m=0;m<t.length;m++)if(r[p.id]){u.outputs.forEach(g=>r[g.id]=!0),h=!0,s[u.id]=!0;break}if(h)break}}let a={};a[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let u=e[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(a[u.outputs[d].id]){for(let p in c)a[c[p].id]=!0,i[u.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let u=e[l];if(s[u.id]&&i[u.id]){let c={};for(let p in u.inputs){let h=u.inputs[p];r[h.id]&&(c[p]=h)}let d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,o.push(d)}}return o}function x4e(e,t,n,r){for(let s=t.length-1;s>=0;s--){let a=t[s],i=[];if(a.outputs.forEach(l=>{let u=e[l.id];u!=null?i.push(u):i.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);let o=a.gradient(i);for(let l in a.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let u=n(()=>o[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=a.inputs[l];if(!Xu(u.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=u;else{let d=e[c.id];e[c.id]=r(d,u),d.dispose()}}}}var hU=20,Fb=3,LE=7;function b4e(e,t,n,r){let s=Ny(t),a=v4e(e,t,n,s),i=t.length,o=C2(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join(`
`)),l.join(`
`)}function v4e(e,t,n,r){let s=Gn(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l=n==="complex64"?qb(e):e;if(o>1)for(let u=0;u<s/a;u++){let c=u*a;for(let d=0;d<a;d++)i[d]=Math.max(i[d],Hb(l[c+d],0,n).length)}return i}function Hb(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(LE))} + ${parseFloat(e[1].toFixed(LE))}j`:Lc(e)?r=`'${e}'`:n==="bool"?r=MK(e):r=parseFloat(e.toFixed(LE)).toString(),sv(r,t)}function MK(e){return e===0?"false":"true"}function C2(e,t,n,r,s,a=!0){let i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){let g=qb(e);return[Hb(g[0],0,n)]}return n==="bool"?[MK(e[0])]:[e[0].toString()]}if(l===1){if(o>hU){let g=Fb*i,y=Array.from(e.slice(0,g)),b=Array.from(e.slice((o-Fb)*i,o*i));return n==="complex64"&&(y=qb(y),b=qb(b)),["["+y.map((v,k)=>Hb(v,s[k],n)).join(", ")+", ..., "+b.map((v,k)=>Hb(v,s[o-Fb+k],n)).join(", ")+"]"]}return["["+(n==="complex64"?qb(e):Array.from(e)).map((g,y)=>Hb(g,s[y],n)).join(", ")+"]"]}let u=t.slice(1),c=r.slice(1),d=r[0]*i,p=[];if(o>hU){for(let g=0;g<Fb;g++){let y=g*d,b=y+d;p.push(...C2(e.slice(y,b),u,n,c,s,!1))}p.push("...");for(let g=o-Fb;g<o;g++){let y=g*d,b=y+d;p.push(...C2(e.slice(y,b),u,n,c,s,g===o-1))}}else for(let g=0;g<o;g++){let y=g*d,b=y+d;p.push(...C2(e.slice(y,b),u,n,c,s,g===o-1))}let h=l===2?",":"";p[0]="["+(o>0?p[0]+h:"");for(let g=1;g<p.length-1;g++)p[g]=" "+p[g]+h;let m=`,
`;for(let g=2;g<l;g++)m+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":m),p}function qb(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Xr=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Gn(e),n!=null){let r=n.length;Z(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||$3(t,this.size),this.strides=Ny(e)}set(e,...t){t.length===0&&(t=[0]),Z(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ho().makeTensor(this.values,this.shape,this.dtype)}},Ho=null,og=null;function w4e(e){Ho=e}function k4e(e){og=e}var Zt=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Gn(e),this.strides=Ny(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return og.buffer(this.shape,this.dtype,e)}bufferSync(){return og.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return xg(this.shape,e,this.dtype==="complex64")}arraySync(){return xg(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=Ho().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>CI(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ho().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Ho().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>CI(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await Ho().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ho().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return og.print(this,e)}clone(){return this.throwIfDisposed(),og.clone(this)}toString(e=!1){let t=this.dataSync();return b4e(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),og.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Ho().makeVariable(this,e,t,n)}};Object.defineProperty(Zt,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function De(){return A3("Tensor",()=>Zt)}De();var mh=class extends Zt{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Xu(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ho().disposeTensor(this),this.dataId=e.dataId,Ho().incRef(this,null)}dispose(){Ho().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(mh,Symbol.hasInstance,{value:e=>e instanceof Zt&&e.assign!=null&&e.assign instanceof Function});var Jo={};Kt(Jo,{assertTypesMatch:()=>zK,getTensorsInContainer:()=>D3,isTensorInList:()=>S4e,makeTypesMatch:()=>Er});var yA;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(yA||(yA={}));var xA;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(xA||(xA={}));var bA;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(bA||(bA={}));var vA;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(vA||(vA={}));var wA;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(wA||(wA={}));var I4e={float32:vA,int32:xA,bool:bA,complex64:wA};function Ki(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return I4e[e][t]}function iN(e){return Ki(e,"int32")}function LK(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function PK(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Er(e,t){if(e.dtype===t.dtype)return[e,t];let n=Ki(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function zK(e,t){Z(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function S4e(e,t){return t.some(n=>n.id===e.id)}function D3(e){let t=[];return BK(e,t,new Set),t}function BK(e,t,n){if(e==null)return;if(e instanceof Zt){t.push(e);return}if(!C4e(e))return;let r=e;for(let s in r){let a=r[s];n.has(a)||(n.add(a),BK(a,t,n))}}function C4e(e){return Array.isArray(e)||typeof e=="object"}function PE(e){return e.kernelName!=null}var fU=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},F3=class kA{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new fU}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(Dc(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:r}=this.initializeBackend(t);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new f4e(this.backendInstance),!0}setupRegisteredKernels(){SI(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){SI(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let r=n.factory();if(r&&!(r instanceof w1)&&typeof r.then=="function"){let s=++this.pendingBackendInitId,a=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Dc(`Initialization of backend ${t} failed`),Dc(i.stack||i.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return Dc(`Initialization of backend ${t} failed`),Dc(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let r=this.state.tensorInfo.get(n),s=r.backend,a=this.readSync(n),i=s.refCount(n);s.disposeData(n,!0),r.backend=t,t.move(n,a,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let r=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,n,r){t();try{let s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return kA.nextTensorId++}nextVariableId(){return kA.nextVariableId++}clone(t){let n=se.runKernel(vf,{x:t}),r={x:t},s=i=>({x:()=>{let o="float32",l={x:i},u={dtype:o};return se.runKernel(ef,l,u)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,a,{}),n}runKernel(t,n,r){if(this.backendName==null&&this.backend,Ev(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){let s=this.backend.numDataIds(),a=0;r.forEach(l=>{a+=l.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=s-n-a-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,r=[],s=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l,u=PE(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(PE(t)){let{kernelName:m,inputs:g,attrs:y}=t;this.backendName==null&&this.backend;let b=Ev(m,this.backendName);Z(b!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),o=()=>{let v=this.backend.numDataIds();l=b.kernelFunc({inputs:g,attrs:y,backend:this.backend});let k=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,v,k);let I=k.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(s){let S=this.getTensorsForGradient(m,g,I);r=this.saveTensorsForBackwardMode(S)}return I}}else{let{forwardFunc:m}=t,g=y=>{s&&(r=y.map(b=>this.keep(this.clone(b))))};o=()=>{let y=this.backend.numDataIds();l=this.tidy(()=>m(this.backend,g));let b=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,b),b}}let{inputs:c,attrs:d}=t,p=PE(t)?null:t.backwardsFunc,h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(h=this.profiler.profileKernel(u,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),n=h.outputs)}),s&&this.addTapeNode(u,c,n,p,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(m=>c[m]!=null?c[m].shape:null),outputShapes:n.map(m=>m.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,r){let s=mA(t);if(s!=null){let a=s.inputsToSave||[],i=s.outputsToSave||[],o;s.saveAllInputs?(Z(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(u=>n[u])):o=a.map(u=>n[u]);let l=r.filter((u,c)=>i[c]);return o.concat(l)}return[]}makeTensor(t,n,r,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=t;r==="string"&&Lc(t[0])&&(a=t.map(l=>H1(l)));let i=s.write(a,n,r),o=new Zt(n,r,i,this.nextTensorId());if(this.trackTensor(o,s),r==="string"){let l=this.state.tensorInfo.get(i),u=IK(a);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(t,n,r,s){r=r||"float32";let a={dataId:t,shape:n,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(t,n){let{dataId:r,shape:s,dtype:a}=t,i=new Zt(s,a,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));let a=new mh(t,n,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*wI(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof mh||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let r=t.size*wI(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,r,s,a,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:a},l=mA(t);l!=null&&(s=l.gradFunc),s!=null&&(o.gradient=u=>(u=u.map((c,d)=>{if(c==null){let p=r[d],h=GC(p.size,p.dtype);return this.makeTensor(h,p.shape,p.dtype)}return c}),s(u.length>1?u:u[0],a,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=D3(t),r=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){let i=this.state.activeScope.track[a];!i.kept&&!r.has(i.id)&&i.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(t,n,r,s=!1){if(Z(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));Z(a instanceof Zt,()=>"The result y returned by f() must be a tensor.");let i=y4e(this.state.activeTape,n,a);if(!s&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[a.id]=r??N4e(a.shape),x4e(o,i,u=>this.tidy(u),T4e);let l=n.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let c of u.saved)c.dispose()}),this.state.activeTape=null),{value:a,grads:l}})}customGrad(t){return Z(nd(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{Z(n.every(o=>o instanceof Zt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r,s={};n.forEach((o,l)=>{s[l]=o});let a=(o,l)=>(r=t(...n,l),Z(r.value instanceof Zt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Z(nd(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(o,l)=>{let u=r.gradFunc(o,l),c=Array.isArray(u)?u:[u];Z(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Z(c.every(p=>p instanceof Zt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let d={};return c.forEach((p,h)=>{d[h]=()=>p}),d};return this.runKernelFunc({forwardFunc:a,backwardsFunc:i,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=_v(),r=await this.backend.time(t);return r.wallMs=_v()-n,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new fU;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};F3.nextTensorId=0;F3.nextVariableId=0;function N4e(e){let t=E3(Gn(e),"float32");return se.makeTensor(t,e,"float32")}function WK(){let e=$K();if(e._tfengine==null){let t=new TK(e);e._tfengine=new F3(t)}return YPe(e._tfengine.ENV),w4e(()=>e._tfengine),e._tfengine}var se=WK();function T4e(e,t){let n={a:e,b:t};return se.runKernel(Ad,n)}var q1={};Kt(q1,{isBrowser:()=>VK,isMobile:()=>_4e,mockIsMobile:()=>E4e});function $4e(){return typeof navigator<"u"&&navigator!=null}var IA;function E4e(e){IA=e}function _4e(e){if(IA!==void 0)return IA;if(e||$4e()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function VK(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Qa=xe();Qa.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Qa.registerFlag("IS_BROWSER",()=>VK());Qa.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Qa.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Qa.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Qa.registerFlag("PROD",()=>!1);Qa.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Qa.getBool("DEBUG"));Qa.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Qa.registerFlag("IS_TEST",()=>!1);Qa.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Qa.getBool("DEBUG"));Qa.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Qa.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Qa.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function nu(e,t){let n=e;if(Ts(e))return t==="string"?[]:[e.length];if(LK(e)){let s=e.channels||"RGBA";return[e.height,e.width*s.length]}else if(PK(e))return[e.buffer.size/(t==null?4:wI(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||Ts(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&xe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&UK(e,r,[]),r}function UK(e,t,n){if(n=n||[],!Array.isArray(e)&&!Ts(e)){Z(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}Z(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Z(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let s=0;s<e.length;++s)UK(e[s],r,n.concat(s))}function mU(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function K(e,t,n,r="numeric"){if(e instanceof De())return mU(r,e.dtype,t,n),e;let s=k1(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),mU(r,s,t,n),e==null||!Ts(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let a=nu(e,s);!Ts(e)&&!Array.isArray(e)&&(e=[e]);let i=s!=="string"?aN(e,s):rd(e,[],!0);return se.makeTensor(i,a,s)}function Av(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((s,a)=>K(s,`${t}[${a}]`,n,r))}var O3="__op";function ie(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+O3;let s=(...a)=>{se.startScope(n);try{let i=r(...a);return jC(i)&&console.error("Cannot return a Promise inside of tidy."),se.endScope(i),i}catch(i){throw se.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}function A4e(e,t){let n=K(e,"real","complex"),r=K(t,"imag","complex");Fa(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let s={real:n,imag:r};return se.runKernel(HC,s)}var Wu=ie({complex_:A4e});function Od(e,t,n,r){if(r==null)r=k1(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(PK(e)||LK(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return se.backend.createTensorFromGPUData(e,t||n,r)}if(!Ts(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Ei(t);let s=Gn(t),a=Gn(n);Z(s===a,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${a}`);for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1?o!==Gn(t.slice(i)):!0;Z(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!Ts(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?aN(e,r):rd(e,[],!0),se.makeTensor(e,t,r)}function $a(e,t,n){let r=nu(e,n);return Od(e,t,r,n)}var gh={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Yu=class GK{static join(t){return new GK(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(r=>Ts(r)?r.buffer:r),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let r=0;r<t.length;r++){let s=t[r];r!==t.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let a=n+s.byteLength;this.shards.push({buffer:s,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let r=this.findShardForByte(t);if(r===-1)throw new Error(`Could not find start shard for byte ${t}`);let s=n-t,a=new ArrayBuffer(s),i=new Uint8Array(a),o=0;for(let l=r;l<this.shards.length;l++){let u=this.shards[l],c=t+o-u.start,d=o,p=Math.min(n,u.end)-u.start,h=new Uint8Array(u.buffer,c,p-c);if(i.set(h,d),o+=h.length,n<u.end)break}return a}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(s){return t<s.start?-1:t>=s.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=R4e(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function R4e(e,t){let n=0,r=e.length;for(;n<=r;){let s=Math.floor((r-n)/2)+n,a=t(e[s]);if(a===0)return s;a<0?r=s:n=s+1}return-1}function D4e(){xe().set("PROD",!0)}function F4e(){xe().set("DEBUG",!0)}function O4e(){xe().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function jK(e){xe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function M4e(){se.disposeVariables()}function fo(){return se}function SA(){return se.memory()}function L4e(e){return se.profile(e)}function ce(e,t){return se.tidy(e,t)}function qt(e){D3(e).forEach(t=>t.dispose())}function cs(e){return se.keep(e)}function P4e(e){return se.time(e)}function z4e(e){return se.setBackend(e)}function B4e(){return se.ready()}function HK(){return se.backendName}function W4e(e){se.removeBackend(e)}function V4e(e){return se.findBackend(e)}function U4e(e){return se.findBackendFactory(e)}function oN(e,t,n=1){return se.registerBackend(e,t,n)}function M3(){return se.backend}function G4e(e,t){xe().setPlatform(e,t)}var sd=4;async function j4e(e,t){let n=[],r=[],s=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<s.length;++i){let o=s[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let c=new Promise(async d=>{let p=await l.bytes(),h=p.reduce((y,b)=>y+b.length,0)+sd*p.length,m=new Uint8Array(h),g=0;for(let y=0;y<p.length;y++){let b=p[y],v=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(v,g),g+=sd,m.set(b,g),g+=b.length}d(m)});r.push(c)}else r.push(l.data());t!=null&&(u.group=t),n.push(u)}let a=await Promise.all(r);return{data:K4e(a),specs:n}}function qK(e,t){let n=new Yu(e),r={},s=0;for(let a of t){let i=H4e(a,(o,l)=>n.slice(s+o,s+l));r[a.name]=KK(a,n.slice(s,s+i)),s+=i}return r}function H4e(e,t){let n=Gn(e.shape),r;if("quantization"in e){let s=e.quantization;r=gh[s.dtype]}else if(e.dtype==="string"){let s=0;for(let a=0;a<n;a++)s+=sd+new Uint32Array(t(s,s+sd))[0];return s}else r=gh[e.dtype];return n*r}async function q4e(e,t){let n=Gn(e.shape),r;if("quantization"in e){let s=e.quantization;r=gh[s.dtype]}else if(e.dtype==="string"){let s=0;for(let a=0;a<n;a++)s+=sd+new Uint32Array(await t(s,s+sd))[0];return s}else r=gh[e.dtype];return n*r}function KK(e,t){let n=e.name,r=e.dtype,s=e.shape,a=Gn(s),i,o=0;if("quantization"in e){let l=e.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let u=gh[l.dtype],c=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(c.length);for(let d=0;d<c.length;d++){let p=c[d];i[d]=p*l.scale+l.min}}else if(l.dtype==="float16")i=tze()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let d=0;d<c.length;d++){let p=c[d];i[d]=Math.round(p*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=a*u}else if(r==="string"){let l=Gn(e.shape);i=[];for(let u=0;u<l;u++){let c=new Uint32Array(t.slice(o,o+sd))[0];o+=sd;let d=new Uint8Array(t.slice(o,o+c));i.push(d),o+=c}}else{let l=gh[r];if(r==="float32")i=new Float32Array(t);else if(r==="int32")i=new Int32Array(t);else if(r==="bool")i=new Uint8Array(t);else if(r==="complex64"){i=new Float32Array(t);let u=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let m=0;m<u.length;m++)u[m]=i[m*2],c[m]=i[m*2+1];let d=$a(u,s,"float32"),p=$a(c,s,"float32"),h=Wu(d,p);return d.dispose(),p.dispose(),h}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=a*l}return $a(i,s,r)}async function gU(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:s,value:a}=await e.read();if(s&&a==null){let o=n-r.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(r.length+a.byteLength);i.set(r,0),i.set(new Uint8Array(a),r.length),r=i}return r.buffer}async function XK(e,t){let n={},r=e.getReader(),s=new ArrayBuffer(0);for(let a of t){let i=await q4e(a,async(u,c)=>(s=await gU(r,s,c),s.slice(u,c)));s=await gU(r,s,i);let o=s.slice(0,i);s=s.slice(i);let l=KK(a,o);if(n[a.name]=l,HK()==="webgpu"){let u=M3();"uploadToGPU"in u&&Gn(l.shape)>=xe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return n}function K4e(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});let r=new Uint8Array(t),s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}var L3=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function yU(e){return L3?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function X4e(e){if(L3)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function Y4e(e){if(L3){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function Z4e(e){return Yu.join(e)}function xU(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function YK(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function ZK(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function P3(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),ZK(e,n,r)}function K1(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:yU(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:yU(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new Yu(e.weightData).byteLength}}function CA(e){let t=[];for(let n of e)t.push(...n.weights);return t}function J4e(){let e=n=>{let r=n<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function Q4e(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function eze(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function tze(){let e=J4e(),t=Q4e(),n=eze();return r=>{let s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){let o=r[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];a[i]=l}return new Float32Array(s)}}var Xi=class Wo{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Wo.instance==null&&(Wo.instance=new Wo),Wo.instance}static registerSaveRouter(t){Wo.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Wo.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Wo.getHandlers(t,"save")}static getLoadHandlers(t,n){return Wo.getHandlers(t,"load",n)}static getHandlers(t,n,r){let s=[];return(n==="load"?Wo.getInstance().loadRouters:Wo.getInstance().saveRouters).forEach(a=>{let i=a(t,r);i!==null&&s.push(i)}),s}},nze=e=>Xi.registerSaveRouter(e),rze=e=>Xi.registerLoadRouter(e),sze=e=>Xi.getSaveHandlers(e),aze=(e,t)=>Xi.getLoadHandlers(e,t),NA="tensorflowjs",TA=1,Op="models_store",Pc="model_info_store";function JK(){if(!xe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function $A(e){let t=e.result;t.createObjectStore(Op,{keyPath:"modelPath"}),t.createObjectStore(Pc,{keyPath:"modelPath"})}var yh=class{constructor(e){if(this.indexedDB=JK(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{let s=this.indexedDB.open(NA,TA);s.onupgradeneeded=()=>$A(s),s.onsuccess=()=>{let a=s.result;if(t==null){let i=a.transaction(Op,"readonly"),o=i.objectStore(Op).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(a.close(),r(o.error)),i.oncomplete=()=>a.close()}else{t.weightData=Yu.join(t.weightData);let i=K1(t),o=a.transaction(Pc,"readwrite"),l=o.objectStore(Pc),u;try{u=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(d){return r(d)}let c;u.onsuccess=()=>{c=a.transaction(Op,"readwrite");let d=c.objectStore(Op),p;try{p=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(h){return r(h)}p.onsuccess=()=>n({modelArtifactsInfo:i}),p.onerror=h=>{l=o.objectStore(Pc);let m=l.delete(this.modelPath);m.onsuccess=()=>(a.close(),r(p.error)),m.onerror=g=>(a.close(),r(p.error))}},u.onerror=d=>(a.close(),r(u.error)),o.oncomplete=()=>{c==null?a.close():c.oncomplete=()=>a.close()}}},s.onerror=a=>r(s.error)})}};yh.URL_SCHEME="indexeddb://";var QK=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(yh.URL_SCHEME)?ize(e.slice(yh.URL_SCHEME.length)):null;Xi.registerSaveRouter(QK);Xi.registerLoadRouter(QK);function ize(e){return new yh(e)}function oze(e){return e.startsWith(yh.URL_SCHEME)?e.slice(yh.URL_SCHEME.length):e}var lze=class{constructor(){this.indexedDB=JK()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(NA,TA);n.onupgradeneeded=()=>$A(n),n.onsuccess=()=>{let r=n.result,s=r.transaction(Pc,"readonly"),a=s.objectStore(Pc).getAll();a.onsuccess=()=>{let i={};for(let o of a.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},a.onerror=i=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=oze(e),new Promise((t,n)=>{let r=this.indexedDB.open(NA,TA);r.onupgradeneeded=()=>$A(r),r.onsuccess=()=>{let s=r.result,a=s.transaction(Pc,"readwrite"),i=a.objectStore(Pc),o=i.get(e),l;o.onsuccess=()=>{if(o.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let u=i.delete(e),c=()=>{l=s.transaction(Op,"readwrite");let d=l.objectStore(Op).delete(e);d.onsuccess=()=>t(o.result.modelArtifactsInfo),d.onerror=p=>n(o.error)};u.onsuccess=c,u.onerror=d=>(c(),s.close(),n(o.error))}},o.onerror=u=>(s.close(),n(o.error)),a.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},r.onerror=s=>n(r.error)})}},Eu="/",lg="tensorflowjs_models",eX="info",uze="model_topology",cze="weight_specs",dze="weight_data",pze="model_metadata";function tX(e){return{info:[lg,e,eX].join(Eu),topology:[lg,e,uze].join(Eu),weightSpecs:[lg,e,cze].join(Eu),weightData:[lg,e,dze].join(Eu),modelMetadata:[lg,e,pze].join(Eu)}}function nX(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function hze(e){let t=e.split(Eu);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Eu)}function fze(e){return e.startsWith(xh.URL_SCHEME)?e.slice(xh.URL_SCHEME.length):e}var xh=class{constructor(e){if(!xe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=tX(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=K1(e),s=Yu.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,X4e(s));let a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw nX(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let i=JSON.parse(s);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Y4e(a),t}};xh.URL_SCHEME="localstorage://";var rX=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(xh.URL_SCHEME)?mze(e.slice(xh.URL_SCHEME.length)):null;Xi.registerSaveRouter(rX);Xi.registerLoadRouter(rX);function mze(e){return new xh(e)}var gze=class{constructor(){Z(xe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Z(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=lg+Eu,n=Eu+eX;for(let r=0;r<this.LS.length;++r){let s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){let a=hze(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=fze(e);let t=tX(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return nX(t),n}},bg="://",ad=class Tc{constructor(){this.managers={}}static getInstance(){return Tc.instance==null&&(Tc.instance=new Tc),Tc.instance}static registerManager(t,n){Z(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(bg)&&(t=t.slice(0,t.indexOf(bg))),Z(t.length>0,()=>"scheme must not be an empty string.");let r=Tc.getInstance();Z(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){let n=Tc.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(Tc.getInstance().managers)}};function N2(e){if(e.indexOf(bg)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ad.getSchemes().join(",")}`);return{scheme:e.split(bg)[0],path:e.split(bg)[1]}}async function sX(e,t,n=!1){Z(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=Xi.getLoadHandlers(e);Z(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),Z(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let s=r[0],a=Xi.getSaveHandlers(t);Z(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),Z(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let i=a[0],o=N2(e).scheme,l=N2(e).path,u=o===N2(e).scheme,c=await s.load();n&&u&&await ad.getManager(o).removeModel(l);let d=await i.save(c);return n&&!u&&await ad.getManager(o).removeModel(l),d.modelArtifactsInfo}async function yze(){let e=ad.getSchemes(),t={};for(let n of e){let r=await ad.getManager(n).listModels();for(let s in r){let a=n+bg+s;t[a]=r[s]}}return t}async function xze(e){let t=N2(e);return ad.getManager(t.scheme).removeModel(t.path)}async function bze(e,t){return sX(e,t,!1)}async function vze(e,t){return sX(e,t,!0)}var wze=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!xe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let r=this.functionRefs[n.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return DK(e)}};if(xe().get("IS_BROWSER")){xe().setPlatform("browser",new wze);try{ad.registerManager(xh.URL_SCHEME,new gze)}catch{}try{ad.registerManager(yh.URL_SCHEME,new lze)}catch{}}var kze={importFetch:()=>mPe()},zE,Ize=class{constructor(){this.util=gPe(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return xe().global.fetch!=null?xe().global.fetch(e,t):(zE==null&&(zE=kze.importFetch()),zE(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};xe().get("IS_NODE")&&!xe().get("IS_BROWSER")&&xe().setPlatform("node",new Ize);function tn(e,t="float32",n){return t=t||"float32",Ei(e),new Xr(e,t,n)}function Sze(e,t){let n=K(e,"x","cast");if(!kK(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},s={dtype:t};return se.runKernel(ef,r,s)}var Ke=ie({cast_:Sze});function Cze(e){let t={x:K(e,"x","clone","string_or_numeric")};return se.runKernel(vf,t)}var ql=ie({clone_:Cze});function z3(e,t=!1){console.log(e.toString(t))}WK();var Nze={buffer:tn,cast:Ke,clone:ql,print:z3};k4e(Nze);function Tze(e,t){let n=K(e,"a","add"),r=K(t,"b","add");[n,r]=Er(n,r);let s={a:n,b:r};return se.runKernel(Ad,s)}var Ae=ie({add_:Tze});function $ze(e,t){let n=K(e,"a","floorDiv"),r=K(t,"b","floorDiv");[n,r]=Er(n,r);let s={a:n,b:r};return se.runKernel(yf,s)}var lN=ie({floorDiv_:$ze});function Eze(e,t){let n=K(e,"a","div"),r=K(t,"b","div");if([n,r]=Er(n,r),n.dtype==="int32"&&r.dtype==="int32")return lN(n,r);let s={a:n,b:r},a={};return se.runKernel(df,s,a)}var ht=ie({div_:Eze});function _ze(e,t){let n=K(e,"a","mul"),r=K(t,"b","mul");[n,r]=Er(n,r);let s={a:n,b:r};return se.runKernel(Mf,s)}var oe=ie({mul_:_ze});function Aze(e){let t=K(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return se.runKernel(N1,n)}else{let n={x:t};return se.runKernel(Ty,n)}}var Hr=ie({abs_:Aze});function Rze(e){let t={x:K(e,"x","acos")};return se.runKernel(Gh,t)}var B3=ie({acos_:Rze});function Dze(e){let t={x:K(e,"x","acosh")};return se.runKernel(jh,t)}var W3=ie({acosh_:Dze});function Fze(e){Z(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),Z(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((s,a)=>K(s,`tensors${a}`,"addN")),n=t[0];t.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!Xu(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return se.runKernel(Hh,r)}var aX=ie({addN_:Fze});function Oze(e,t=null,n=!1){let r={x:K(e,"x","all","bool")},s={axis:t,keepDims:n};return se.runKernel($y,r,s)}var uN=ie({all_:Oze});function Mze(e,t=null,n=!1){let r={x:K(e,"x","any","bool")},s={axis:t,keepDims:n};return se.runKernel(Ey,r,s)}var Rv=ie({any_:Mze});function Lze(e,t=0){let n={x:K(e,"x","argMax")},r={axis:t};return se.runKernel(_y,n,r)}var bh=ie({argMax_:Lze});function Pze(e,t=0){let n={x:K(e,"x","argMin")},r={axis:t};return se.runKernel(Ay,n,r)}var V3=ie({argMin_:Pze});function zze(e){let t={x:K(e,"x","asin")};return se.runKernel(qh,t)}var U3=ie({asin_:zze});function Bze(e){let t={x:K(e,"x","asinh")};return se.runKernel(Kh,t)}var G3=ie({asinh_:Bze});function Wze(e){let t={x:K(e,"x","atan")};return se.runKernel(Xh,t)}var j3=ie({atan_:Wze});function Vze(e,t){let n=K(e,"a","atan2"),r=K(t,"b","atan2");[n,r]=Er(n,r);let s={a:n,b:r};return se.runKernel(Zh,s)}var H3=ie({atan2_:Vze});function Uze(e){let t={x:K(e,"x","atanh")};return se.runKernel(Yh,t)}var q3=ie({atanh_:Uze});function Gze(e,t,n,r,s="NHWC",a){let i=e[3],o=[...t,i],l=lX(s);return X1(e,o,n,a,r,null,null,l)}function iX(e,t,n,r,s,a,i="channelsLast"){let[o,l]=Dv(t),u;if(i==="channelsLast")u=[o,l,e[3],e[3]];else if(i==="channelsFirst")u=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return X1(e,u,n,r,s,a,!1,i)}function jze(e,t,n,r,s,a,i="NDHWC"){let[o,l,u]=EA(t),c,d;if(i==="NDHWC")d="channelsLast",c=[o,l,u,e[4],e[4]];else if(i==="NCDHW")d="channelsFirst",c=[o,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return oX(e,c,n,r,s,!1,d,a)}function X1(e,t,n,r,s,a,i=!1,o="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,d]=e;else if(o==="channelsFirst")[l,d,u,c]=e;else throw new Error(`Unknown dataFormat ${o}`);let[p,h,,m]=t,[g,y]=Dv(n),[b,v]=Dv(r),k=vg(p,b),I=vg(h,v),{padInfo:S,outHeight:N,outWidth:T}=Kze(s,u,c,g,y,k,I,a,o),A=i?m*d:m,R;return o==="channelsFirst"?R=[l,A,N,T]:o==="channelsLast"&&(R=[l,N,T,A]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:N,outWidth:T,outChannels:A,padInfo:S,strideHeight:g,strideWidth:y,filterHeight:p,filterWidth:h,effectiveFilterHeight:k,effectiveFilterWidth:I,dilationHeight:b,dilationWidth:v,inShape:e,outShape:R,filterShape:t}}function oX(e,t,n,r,s,a=!1,i="channelsLast",o){let[l,u,c,d,p]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,d,p]=e;else if(i==="channelsFirst")[l,p,u,c,d]=e;else throw new Error(`Unknown dataFormat ${i}`);let[h,m,g,,y]=t,[b,v,k]=EA(n),[I,S,N]=EA(r),T=vg(h,I),A=vg(m,S),R=vg(g,N),{padInfo:D,outDepth:$,outHeight:_,outWidth:L}=Xze(s,u,c,d,b,v,k,T,A,R,o),z=a?y*p:y,W;return i==="channelsFirst"?W=[l,z,$,_,L]:i==="channelsLast"&&(W=[l,$,_,L,z]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:p,outDepth:$,outHeight:_,outWidth:L,outChannels:z,padInfo:D,strideDepth:b,strideHeight:v,strideWidth:k,filterDepth:h,filterHeight:m,filterWidth:g,effectiveFilterDepth:T,effectiveFilterHeight:A,effectiveFilterWidth:R,dilationDepth:I,dilationHeight:S,dilationWidth:N,inShape:e,outShape:W,filterShape:t}}function Hze(e,t,n,r,s){r==null&&(r=K3(e,t,n));let a=e[0],i=e[1],o=Fv((a-t+2*r)/n+1,s),l=Fv((i-t+2*r)/n+1,s);return[o,l]}function qze(e,t,n,r,s,a){s==null&&(s=K3(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=Fv((e[o]-t[o]+2*s)/r[o]+1,a));return i}function K3(e,t,n,r=1){let s=vg(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function Dv(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function EA(e){return typeof e=="number"?[e,e,e]:e}function vg(e,t){return t<=1?e:e+(e-1)*(t-1)}function Kze(e,t,n,r,s,a,i,o,l){let u,c,d;if(typeof e=="number"){u={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let p=Hze([t,n],a,r,e,o);c=p[0],d=p[1]}else if(e==="same"){c=Math.ceil(t/r),d=Math.ceil(n/s);let p=Math.max(0,(c-1)*r+a-t),h=Math.max(0,(d-1)*s+i-n),m=Math.floor(p/2),g=p-m,y=Math.floor(h/2),b=h-y;u={top:m,bottom:g,left:y,right:b,type:"SAME"}}else if(e==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),d=Math.ceil((n-i+1)/s);else if(typeof e=="object"){let p=l==="channelsLast"?e[1][0]:e[2][0],h=l==="channelsLast"?e[1][1]:e[2][1],m=l==="channelsLast"?e[2][0]:e[3][0],g=l==="channelsLast"?e[2][1]:e[3][1];u={top:p,bottom:h,left:m,right:g,type:p===0&&h===0&&m===0&&g===0?"VALID":"EXPLICIT"},c=Fv((t-a+p+h)/r+1,o),d=Fv((n-i+m+g)/s+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:c,outWidth:d}}function Xze(e,t,n,r,s,a,i,o,l,u,c){let d,p,h,m;if(e==="valid"&&(e=0),typeof e=="number"){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let g=qze([t,n,r,1],[o,l,u],1,[s,a,i],e,c);p=g[0],h=g[1],m=g[2]}else if(e==="same"){p=Math.ceil(t/s),h=Math.ceil(n/a),m=Math.ceil(r/i);let g=(p-1)*s+o-t,y=(h-1)*a+l-n,b=(m-1)*i+u-r,v=Math.floor(g/2),k=g-v,I=Math.floor(y/2),S=y-I,N=Math.floor(b/2),T=b-N;d={top:I,bottom:S,left:N,right:T,front:v,back:k,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:p,outHeight:h,outWidth:m}}function Fv(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function id(e){let[t,n,r]=Dv(e);return t===1&&n===1&&r===1}function uu(e,t){return id(e)||id(t)}function vh(e){return Dv(e).every(t=>t>0)}function lX(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Oa(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")Z(Lg(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(s=>{Z(Lg(s),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function Yze(e,t){let n={x:K(e,"x","reshape","string_or_numeric")},r={shape:t};return se.runKernel(dx,n,r)}var ue=ie({reshape_:Yze});function Zze(e,t,n,r,s){let a=K(e,"x","avgPool","float32"),i=1;Z(uu(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=a,l=!1;a.rank===3&&(l=!0,o=ue(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Z(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Oa("avgPool",r,s);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=se.runKernel(Jh,u,c);return d=Ke(d,a.dtype),l?ue(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Zu=ie({avgPool_:Zze});function Jze(e,t,n,r,s,a="NDHWC"){let i=K(e,"x","avgPool3d","float32"),o=i,l=!1;i.rank===4&&(l=!0,o=ue(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Z(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),Z(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Z(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Oa("avgPool3d",r,s);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=se.runKernel(Ry,u,c);return d=Ke(d,o.dtype),l?ue(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var X3=ie({avgPool3d_:Jze});function Qze(e,t=0){Z(e.length>=1,()=>"Pass at least one tensor to concat");let n=Av(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return ql(n[0]);let r=n,s={axis:t};return se.runKernel(My,r,s)}var Jn=ie({concat_:Qze});function eBe(e,t,n=!1,r=!1){let s=K(e,"a","matMul"),a=K(t,"b","matMul");[s,a]=Er(s,a);let i={a:s,b:a},o={transposeA:n,transposeB:r};return se.runKernel(Qh,i,o)}var Qt=ie({matMul_:eBe});function tBe(e){let t={x:K(e,"x","sigmoid","float32")};return se.runKernel(em,t)}var vo=ie({sigmoid_:tBe});function nBe(e,t,n){let r=K(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let s={x:r},a={begin:t,size:n};return se.runKernel(xx,s,a)}var hn=ie({slice_:nBe});function rBe(e){let t={x:K(e,"x","tanh","float32")};return se.runKernel(lm,t)}var od=ie({tanh_:rBe});function sBe(e,t,n,r,s,a){let i=K(e,"forgetBias","basicLSTMCell"),o=K(t,"lstmKernel","basicLSTMCell"),l=K(n,"lstmBias","basicLSTMCell"),u=K(r,"data","basicLSTMCell"),c=K(s,"c","basicLSTMCell"),d=K(a,"h","basicLSTMCell"),p=Jn([u,d],1),h=Qt(p,o),m=Ae(h,l),g=m.shape[0],y=m.shape[1]/4,b=[g,y],v=hn(m,[0,0],b),k=hn(m,[0,y],b),I=hn(m,[0,y*2],b),S=hn(m,[0,y*3],b),N=Ae(oe(vo(v),od(k)),oe(c,vo(Ae(i,I)))),T=oe(od(N),vo(S));return[N,T]}var uX=ie({basicLSTMCell_:sBe});function aBe(e,t,n){let r=K(e,"x","batchToSpaceND"),s=t.reduce((o,l)=>o*l);Z(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),Z(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Z(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);let a={x:r},i={blockShape:t,crops:n};return se.runKernel(Dy,a,i)}var Y1=ie({batchToSpaceND_:aBe});function iBe(e){let t;return e.rank===0||e.rank===1?t=ue(e,[1,1,1,e.size]):e.rank===2?t=ue(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=ue(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function oBe(e,t,n,r,s,a){a==null&&(a=.001);let i=K(e,"x","batchNorm"),o=K(t,"mean","batchNorm"),l=K(n,"variance","batchNorm"),u;s!=null&&(u=K(s,"scale","batchNorm"));let c;r!=null&&(c=K(r,"offset","batchNorm")),Z(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Z(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Z(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:iBe(i),scale:u,offset:c,mean:o,variance:l},p={varianceEpsilon:a},h=se.runKernel(xf,d,p);return ue(h,i.shape)}var um=ie({batchNorm_:oBe});function lBe(e,t,n,r,s,a){let i=K(e,"x","batchNorm"),o=K(t,"mean","batchNorm"),l=K(n,"variance","batchNorm"),u;s!=null&&(u=K(s,"scale","batchNorm"));let c;return r!=null&&(c=K(r,"offset","batchNorm")),Z(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),Z(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),Z(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&Z(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&Z(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),um(i,o,l,c,u,a)}var Y3=ie({batchNorm2d_:lBe});function uBe(e,t,n,r,s,a){let i=K(e,"x","batchNorm"),o=K(t,"mean","batchNorm"),l=K(n,"variance","batchNorm"),u;s!=null&&(u=K(s,"scale","batchNorm"));let c;return r!=null&&(c=K(r,"offset","batchNorm")),Z(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),Z(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),Z(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&Z(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&Z(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),um(i,o,l,c,u,a)}var Z3=ie({batchNorm3d_:uBe});function cBe(e,t,n,r,s,a){let i=K(e,"x","batchNorm"),o=K(t,"mean","batchNorm"),l=K(n,"variance","batchNorm"),u;s!=null&&(u=K(s,"scale","batchNorm"));let c;return r!=null&&(c=K(r,"offset","batchNorm")),Z(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),Z(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),Z(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&Z(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&Z(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),um(i,o,l,c,u,a)}var J3=ie({batchNorm4d_:cBe});function dBe(e,t,n){let r=K(e,"x","bincount"),s=K(t,"weights","bincount");Z(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),Z(n>=0,()=>`size must be non-negative, but got ${n}.`),Z(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);let a={x:r,weights:s},i={size:n};return se.runKernel(Fy,a,i)}var Q3=ie({bincount_:dBe});function pBe(e,t){let n=K(e,"x","bitwiseAnd"),r=K(t,"y","bitwiseAnd");if(!Xu(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let s={a:n,b:r};return se.runKernel(Oy,s)}var cX=ie({bitwiseAnd_:pBe});function hBe(e,t){let n=K(e,"s0","broadcastArgs","int32"),r=K(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let s={s0:n,s1:r};return se.runKernel(C1,s)}var dX=ie({broadcastArgs_:hBe});function fBe(e,t){let n=K(e,"broadcastTo","x"),r=n.shape;if(Ei(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=ue(n,l)}let s=n.shape,a=Array.from(t);for(let l=t.length-1;l>=0;l--)if(s[l]===t[l])a[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(a.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return ql(n);let i={x:n},o={reps:a};return se.runKernel(Dd,i,o)}var Gp=ie({broadcastTo_:fBe});function mBe(e){let t={x:K(e,"x","ceil","float32")};return se.runKernel(tf,t)}var eO=ie({ceil_:mBe});function wi(e,t,n){Ei(e),n=n||k1(t);let r={shape:e,value:t,dtype:n};return se.runKernel(E1,{},r)}function gBe(e,t,n){let r=K(e,"x","clipByValue");if(Z(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return wi(r.shape,t,r.dtype);let s={x:r},a={clipValueMin:t,clipValueMax:n};return se.runKernel(Rd,s,a)}var oa=ie({clipByValue_:gBe});function yBe(e){return Jn(e,0)}var tO=ie({concat1d_:yBe});function xBe(e,t){return Jn(e,t)}var nO=ie({concat2d_:xBe});function bBe(e,t){return Jn(e,t)}var rO=ie({concat3d_:bBe});function vBe(e,t){return Jn(e,t)}var sO=ie({concat4d_:vBe});function wBe(e,t,n,r,s="NHWC",a=[1,1],i){let o=K(e,"x","conv2d","float32"),l=K(t,"filter","conv2d","float32"),u=o,c=!1;o.rank===3&&(c=!0,u=ue(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Z(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),Z(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Oa("conv2d",r,i);let d=s==="NHWC"?u.shape[3]:u.shape[1];Z(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),Z(uu(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Z(vh(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),Z(vh(n),()=>"Error in conv2D: Strides should be larger than 0.");let p={x:u,filter:l},h={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},m=se.runKernel(nf,p,h);return c?ue(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var _a=ie({conv2d_:wBe});function kBe(e,t,n,r,s="NWC",a=1,i){let o=K(e,"x","conv1d"),l=K(t,"filter","conv1d"),u=o,c=!1;o.rank===2&&(c=!0,u=ue(o,[1,o.shape[0],o.shape[1]])),Z(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),Z(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Oa("conv1d",r,i),Z(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),Z(uu(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),Z(vh(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),Z(vh(n),()=>"Error in conv1D: Stride should be larger than 0."),Z(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);let d=ue(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=ue(u,[u.shape[0],1,u.shape[1],u.shape[2]]),h=_a(p,d,[1,n],r,"NHWC",[1,a],i);return c?ue(h,[h.shape[2],h.shape[3]]):ue(h,[h.shape[0],h.shape[2],h.shape[3]])}var cN=ie({conv1d_:kBe});function IBe(e,t,n,r,s,a="NHWC",i){Z(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;t.rank===3&&(u=!0,l=ue(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Z(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),Z(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),Z(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let c=a==="NHWC"?o[3]:o[1],d=a==="NHWC"?l.shape[3]:l.shape[1];Z(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),Z(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),Oa("conv2dDerInput",s,i);let p={dy:l,filter:n},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},m=se.runKernel(rf,p,h);return u?ue(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var aO=ie({conv2DBackpropInput_:IBe});function SBe(e,t,n,r,s,a){let i=K(e,"x","conv2dTranspose"),o=K(t,"filter","conv2dTranspose");return aO(n,i,o,r,s,"NHWC",a)}var dN=ie({conv2dTranspose_:SBe});function CBe(e,t,n,r,s="NDHWC",a=[1,1,1]){let i=K(e,"x","conv3d"),o=K(t,"filter","conv3d"),l=i,u=!1;i.rank===4&&(u=!0,l=ue(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Z(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),Z(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),Z(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),Z(uu(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Z(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),Z(vh(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),Z(vh(n),()=>"Error in conv3D: Strides should be larger than 0.");let c={x:l,filter:o},d={strides:n,pad:r,dataFormat:s,dilations:a},p=se.runKernel(sf,c,d);return u?ue(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var iO=ie({conv3d_:CBe});function NBe(e,t,n,r,s){Z(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,i=t,o=!1;t.rank===4&&(o=!0,i=ue(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);let l=a[4],u=i.shape[4];Z(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),Z(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),Z(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),Z(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),Z(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);let c={dy:i,filter:n},d={pad:s,strides:r,inputShape:a},p=se.runKernel(Py,c,d);return o?ue(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var pX=ie({conv3DBackpropInput_:NBe});function TBe(e,t,n,r,s){let a=K(e,"x","conv3dTranspose"),i=K(t,"filter","conv3dTranspose");return pX(n,a,i,r,s)}var oO=ie({conv3dTranspose_:TBe});function $Be(e){let t={x:K(e,"x","cos","float32")};return se.runKernel(af,t)}var Z1=ie({cos_:$Be});function EBe(e){let t={x:K(e,"x","cosh","float32")};return se.runKernel(of,t)}var pN=ie({cosh_:EBe});function _Be(e,t=0,n=!1,r=!1){let s={x:K(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return se.runKernel(zy,s,a)}var Ov=ie({cumprod_:_Be});function ABe(e,t=0,n=!1,r=!1){let s={x:K(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return se.runKernel(lf,s,a)}var hN=ie({cumsum_:ABe});function RBe(e,t,n,r=!1){let s=K(e,"x","denseBincount"),a=K(t,"weights","denseBincount");Z(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),Z(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),Z(n>=0,()=>`size must be non-negative, but got ${n}.`),Z(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);let i={x:s,weights:a},o={size:n,binaryOutput:r};return se.runKernel(T1,i,o)}var NI=ie({denseBincount_:RBe});function DBe(e,t,n="NHWC"){let r=K(e,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];Z(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),Z(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),Z(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${r.shape}`),Z(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);let o={x:r},l={blockSize:t,dataFormat:n};return se.runKernel(Wy,o,l)}var lO=ie({depthToSpace_:DBe});function FBe(e,t,n,r,s="NHWC",a=[1,1],i){let o=K(e,"x","depthwiseConv2d","float32"),l=K(t,"filter","depthwiseConv2d","float32"),u=o,c=!1;o.rank===3&&(c=!0,u=ue(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Z(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),Z(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let d=s==="NHWC"?u.shape[3]:u.shape[1];Z(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Oa("depthwiseConv2d",r,i);let p={x:u,filter:l},h={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},m=se.runKernel(uf,p,h);return c?ue(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var cm=ie({depthwiseConv2d_:FBe});function OBe(e){let t={x:K(e,"x","diag")};return se.runKernel($1,t)}var hX=ie({diag_:OBe});function MBe(e,t,n,r,s=[1,1],a="NHWC"){let i=K(e,"x","dilation2d"),o=K(t,"filter","dilation2d");Z(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),Z(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),Z(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=i,u=!1;i.rank===3&&(l=ue(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Z(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let c={x:l,filter:o},d={strides:n,pad:r,dilations:s},p=se.runKernel(cf,c,d);return u?ue(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var uO=ie({dilation2d_:MBe}),Ex={};Kt(Ex,{assertAndGetBroadcastShape:()=>er,getBroadcastDims:()=>fX,getReductionAxes:()=>Qr});function fX(e,t){let n=e.length,r=[];for(let s=0;s<n;s++){let a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&i===1&&r.unshift(a)}return r}function Qr(e,t){let n=[];for(let r=0;r<t.length;r++){let s=e[e.length-r-1],a=t.length-r-1,i=t[a];(s==null||s===1&&i>1)&&n.unshift(a)}return n}function er(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];a==null&&(a=1);let i=t[t.length-s-1];if(i==null&&(i=1),a===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=a;else if(a!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else r[n-s-1]=a}return r}function LBe(e,t){let n=K(e,"a","equal","string_or_numeric"),r=K(t,"b","equal","string_or_numeric");[n,r]=Er(n,r),er(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(Uy,s)}var Ci=ie({equal_:LBe});function PBe(e,t,n){let r=K(t,"a","where"),s=K(n,"b","where"),a=K(e,"condition","where","bool"),i=er(er(a.shape,r.shape),s.shape),o=Gp(a,i),l=Gp(r,i),u=Gp(s,i),c={condition:o,t:l,e:u};return se.runKernel(yx,c)}var Rs=ie({where_:PBe});function zBe(e){let t={x:K(e,"x","zerosLike")};return se.runKernel(Tx,t)}var gn=ie({zerosLike_:zBe});function BBe(e,t){let n=K(e,"a","div"),r=K(t,"b","div");[n,r]=Er(n,r);let s=ht(n,r),a=gn(s),i=Ci(r,a);return Rs(i,a,s)}var cO=ie({divNoNan_:BBe});function WBe(e,t){let n=K(e,"t1","dot"),r=K(t,"t2","dot");Z((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(Z(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){let i=ue(n,[1,-1]),o=ue(r,[-1,1]),l=Qt(i,o);return ue(l,[])}else if(n.rank===1&&r.rank===2){let i=ue(n,[1,-1]),o=ue(r,[r.shape[0],r.shape[1]]),l=Qt(i,o);return ue(l,[l.size])}else if(n.rank===2&&r.rank===1){let i=ue(r,[-1,1]),o=Qt(n,i);return ue(o,[o.size])}else{let i=ue(r,[r.shape[0],r.shape[1]]);return Qt(n,i)}}var dO=ie({dot_:WBe});function VBe(e,...t){let n=t.map((s,a)=>K(s,`tensors${a}`,"einsum")),r={equation:e};return se.runKernel(ZC,n,r)}var $p=ie({einsum_:VBe});function UBe(e){let t={x:K(e,"x","elu","float32")};return se.runKernel(pf,t)}var _x=ie({elu_:UBe});function GBe(e,t){let n=K(e,"x","ensureShape","string_or_numeric");if(!xK(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var mX=ie({ensureShape_:GBe});function jBe(e){let t=K(e,"x","erf");Z(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Ke(t,"float32"));let n={x:t};return se.runKernel(hf,n)}var fN=ie({erf_:jBe});function pO(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function gX(e,t,n){let r=e.length+t.length,s=[],a=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?s.push(e[a++]):s.push(t[i++]);return s}function yX(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);let s=t.map(a=>e[a]);return[n,s]}function wh(e,t){let n=t.map(r=>1);return gX(e,n,t)}function HBe(e,t,n){Z(pO(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function xX(e,t){if(pO(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function hO(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function qBe(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function KBe(e,t=null,n=!1){let r={x:K(e,"x","max")},s={reductionIndices:t,keepDims:n};return se.runKernel($f,r,s)}var Hi=ie({max_:KBe});function XBe(e,t=null,n=!1){let r={x:K(e,"x","min")},s={axis:t,keepDims:n};return se.runKernel(Rf,r,s)}var Wg=ie({min_:XBe});function YBe(e,t){let n=K(e,"base","pow"),r=K(t,"exp","pow");[n,r]=Er(n,r);let s={a:n,b:r};return se.runKernel(zf,s)}var ru=ie({pow_:YBe});function Tt(e,t){if((Ts(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Ts(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Od(e,[],[],t)}function ZBe(e){let t={x:K(e,"x","sqrt","float32")};return se.runKernel(nm,t)}var Ds=ie({sqrt_:ZBe});function JBe(e){let t=K(e,"x","square"),n={};return se.runKernel("Square",{x:t},n)}var Zn=ie({square_:JBe});function QBe(e,t=null,n=!1){let r=K(e,"x","sum");r.dtype==="bool"&&(r=Ke(r,"int32"));let s={x:r},a={axis:t,keepDims:n};return se.runKernel(rm,s,a)}var yt=ie({sum_:QBe});function eWe(e,t="euclidean",n=null,r=!1){e=K(e,"x","norm");let s=bX(e,t,n),a=s.shape;if(r){let i=To(n,e.shape);a=wh(s.shape,i)}return ue(s,a)}function bX(e,t,n=null){if(e.rank===0)return Hr(e);if(e.rank!==1&&n===null)return bX(ue(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return yt(Hr(e),n);if(t===1/0)return Hi(Hr(e),n);if(t===-1/0)return Wg(Hr(e),n);if(t==="euclidean"||t===2)return Ds(yt(ru(Hr(e),Tt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Hi(yt(Hr(e),n[0]),n[1]-1);if(t===1/0)return Hi(yt(Hr(e),n[1]),n[0]);if(t===-1/0)return Wg(yt(Hr(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return Ds(yt(Zn(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var Ax=ie({norm_:eWe});function tWe(e,t=null,n=!1){return Ax(e,"euclidean",t,n)}var fO=ie({euclideanNorm_:tWe});function nWe(e){let t={x:K(e,"x","exp")};return se.runKernel(ff,t)}var la=ie({exp_:nWe});function rWe(e,t=0){let n=K(e,"x","expandDims","string_or_numeric");Z(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},s={dim:t};return se.runKernel(Gy,r,s)}var $s=ie({expandDims_:rWe});function sWe(e){let t={x:K(e,"x","expm1")};return se.runKernel(mf,t)}var mO=ie({expm1_:sWe});function aWe(e,t){let n=K(e,"x","tile","string_or_numeric");Z(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},s={reps:t};return se.runKernel(Dd,r,s)}var xi=ie({tile_:aWe});function iWe(e,t,n,r="float32"){t==null&&(t=e);let s=tn([e,t],r),a=e<=t?e:t;for(let o=0;o<a;++o)s.set(1,o,o);let i=ue(s.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return xi($s(i,0),[n[0],1,1]);if(n.length===2)return xi($s($s(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return xi($s($s($s(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var mN=ie({eye_:iWe});function oWe(e){let t={x:K(e,"x","floor","float32")};return se.runKernel(gf,t)}var Rx=ie({floor_:oWe});function lWe(e,t,n=0,r=0){let s=K(e,"x","gather"),a=K(t,"indices","gather","int32"),i={x:s,indices:a},o={axis:n,batchDims:r};return se.runKernel(Hy,i,o)}var Dx=ie({gather_:lWe});function uWe(e,t){let n=K(e,"a","greater","string_or_numeric"),r=K(t,"b","greater","string_or_numeric");[n,r]=Er(n,r),er(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(Ky,s)}var Ma=ie({greater_:uWe});function cWe(e,t){let n=K(e,"a","greaterEqual","string_or_numeric"),r=K(t,"b","greaterEqual","string_or_numeric");[n,r]=Er(n,r),er(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(bf,s)}var Ju=ie({greaterEqual_:cWe});function dWe(e){let t={input:K(e,"input","imag")};return se.runKernel(eN,t)}var J1=ie({imag_:dWe});function pWe(e){let t={x:K(e,"x","isFinite")};return se.runKernel(wf,t)}var gO=ie({isFinite_:pWe});function hWe(e){let t={x:K(e,"x","isInf")};return se.runKernel(kf,t)}var yO=ie({isInf_:hWe});function fWe(e){let t={x:K(e,"x","isNaN")};return se.runKernel(If,t)}var xO=ie({isNaN_:fWe});function mWe(e,t=.2){let n={x:K(e,"x","leakyRelu")},r={alpha:t};return se.runKernel(Sf,n,r)}var Q1=ie({leakyRelu_:mWe});function gWe(e,t){let n=K(e,"a","less","string_or_numeric"),r=K(t,"b","less","string_or_numeric");[n,r]=Er(n,r),er(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(Xy,s)}var Vg=ie({less_:gWe});function yWe(e,t){let n=K(e,"a","lessEqual","string_or_numeric"),r=K(t,"b","lessEqual","string_or_numeric");[n,r]=Er(n,r),er(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(Yy,s)}var Md=ie({lessEqual_:yWe});function vX(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return se.runKernel(Zy,{},r)}function xWe(e,t=5,n=1,r=1,s=.5){let a=K(e,"x","localResponseNormalization");Z(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),Z(Lg(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=a,o=!1;a.rank===3&&(o=!0,i=ue(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:s},c=se.runKernel(Tf,l,u);return o?ue(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var bO=ie({localResponseNormalization_:xWe});function bWe(e){let t={x:K(e,"x","log","float32")};return se.runKernel(Cf,t)}var Ni=ie({log_:bWe});function vWe(e){let t={x:K(e,"x","log1p")};return se.runKernel(Nf,t)}var ew=ie({log1p_:vWe});function wWe(e){return Z(nd(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=K(t,"x","tf.grad","string_or_numeric"),s=n!=null?K(n,"dy","tf.grad"):null;return se.tidy(()=>{let{value:a,grads:i}=se.gradients(()=>e(r),[r],s);return s!=null&&Fa(a.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),gN(i),i[0]})}}function kWe(e){return Z(nd(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{Z(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=Av(t,"args","tf.grads","string_or_numeric"),s=n!=null?K(n,"dy","tf.grads"):null;return se.tidy(()=>{let{value:a,grads:i}=se.gradients(()=>e(...r),r,s);return s!=null&&Fa(a.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),gN(i),i})}}function IWe(e){return Z(nd(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{Z(t instanceof Zt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),Z(n==null||n instanceof Zt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:s}=se.gradients(()=>e(t),[t],n);return gN(r),{grad:r[0],value:s}}}function SWe(e){return Z(nd(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{Z(Array.isArray(t)&&t.every(s=>s instanceof Zt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),Z(n==null||n instanceof Zt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=se.gradients(()=>e(...t),t,n);return n!=null&&Fa(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),gN(r.grads),r}}function wX(e,t){Z(nd(e),()=>"The f passed in variableGrads(f) must be a function"),Z(t==null||Array.isArray(t)&&t.every(u=>u instanceof mh),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let u in se.registeredVariables)t.push(se.registeredVariables[u])}let r=n?t.filter(u=>!u.trainable):null,s=t.length;t=t.filter(u=>u.trainable),Z(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);let a=!0,{value:i,grads:o}=se.gradients(e,t,null,a);Z(o.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Z(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((u,c)=>{o[c]!=null&&(l[u.name]=o[c])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:i,grads:l}}function su(e){return se.customGrad(e)}function gN(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function CWe(e){let t={x:K(e,"x","neg")};return se.runKernel(sx,t)}var or=ie({neg_:CWe});function NWe(e){let t={x:K(e,"x","softplus")};return se.runKernel(tm,t)}var dm=ie({softplus_:NWe});function TWe(e){let t=K(e,"x","logSigmoid");return su(n=>({value:or(dm(or(n))),gradFunc:r=>oe(r,vo(or(n)))}))(t)}var vO=ie({logSigmoid_:TWe});function $We(e,t){let n=K(e,"a","sub"),r=K(t,"b","sub");[n,r]=Er(n,r);let s={a:n,b:r};return se.runKernel(im,s)}var at=ie({sub_:$We});function EWe(e,t=-1){let n=K(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return su((r,s)=>{let a=Hi(r,t,!0),i=at(r,a),o=at(Ke(i,"float32"),Ni(yt(la(i),t,!0)));return s([o]),{value:o,gradFunc:(l,u)=>{let[c]=u,d=!0,p=la(c);return at(l,oe(yt(l,t,d),p))}}})(n)}var yN=ie({logSoftmax_:EWe});function _We(e,t=null,n=!1){let r=K(e,"x","logSumExp"),s=To(t,r.shape),a=Hi(r,s,!0),i=at(r,a),o=la(i),l=yt(o,s),u=Ni(l),c=Ae(ue(a,u.shape),u);if(n){let d=wh(c.shape,s);return ue(c,d)}return c}var tw=ie({logSumExp_:_We});function AWe(e,t){let n=K(e,"a","logicalAnd","bool"),r=K(t,"b","logicalAnd","bool");er(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(Jy,s)}var Io=ie({logicalAnd_:AWe});function RWe(e){let t={x:K(e,"x","logicalNot","bool")};return se.runKernel(Qy,t)}var nw=ie({logicalNot_:RWe});function DWe(e,t){let n=K(e,"a","logicalOr","bool"),r=K(t,"b","logicalOr","bool");er(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(ex,s)}var xN=ie({logicalOr_:DWe});function FWe(e,t){let n=K(e,"a","logicalXor","bool"),r=K(t,"b","logicalXor","bool");return er(n.shape,r.shape),Io(xN(e,t),nw(Io(e,t)))}var wO=ie({logicalXor_:FWe}),Xk=2147483648;function OWe(e,t,n="left"){let r=K(e,"sortedSequence","searchSorted"),s=K(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=ue(r,[-1,a]),l=ue(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Gn(l.shape)>=Xk)throw new Error(`values tensor size must less than ${Xk}`);if(o.shape[1]>=Xk)throw new Error(`trailing dim_size must less than ${Xk} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},c={side:n};return se.runKernel(gx,u,c)}var bN=ie({searchSorted_:OWe});function kX(e,t){return bN(e,t,"left")}function MWe(e,t,n,r,s){let a=K(e,"x","maxPool"),i=1,o=a,l=!1;a.rank===3&&(l=!0,o=ue(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Z(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),Z(uu(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Oa("maxPool",r,s);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=se.runKernel(_f,u,c);return l?ue(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Ss=ie({maxPool_:MWe});function LWe(e,t=[1,1,1],n,r,s,a="NDHWC"){let i=K(e,"x","maxPool3d"),o=i,l=!1;i.rank===4&&(l=!0,o=ue(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Z(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),Z(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Oa("maxPool3d",r,s);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=se.runKernel(nx,u,c);return l?ue(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var kO=ie({maxPool3d_:LWe});function PWe(e,t,n,r,s=!1){let a={x:K(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=se.runKernel(R1,a,i);return{result:o[0],indexes:o[1]}}var IX=ie({maxPoolWithArgmax_:PWe});function zWe(e,t){let n=K(e,"a","maximum"),r=K(t,"b","maximum");[n,r]=Er(n,r),n.dtype==="bool"&&(n=Ke(n,"int32"),r=Ke(r,"int32")),er(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(Ef,s)}var cu=ie({maximum_:zWe});function BWe(e,t=null,n=!1){let r={x:K(e,"x","mean")},s={axis:t,keepDims:n};return se.runKernel(Af,r,s)}var Sr=ie({mean_:BWe});function Cr(e,t="float32"){if(Ei(e),t==="complex64"){let r=Cr(e,"float32"),s=Cr(e,"float32");return Wu(r,s)}let n=GC(Gn(e),t);return se.makeTensor(n,e,t)}function Ha(e,t="float32"){if(Ei(e),t==="complex64"){let r=Ha(e,"float32"),s=Cr(e,"float32");return Wu(r,s)}let n=E3(Gn(e),t);return se.makeTensor(n,e,t)}function SX(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=K(e,"x","meshgrid",e instanceof Zt?e.dtype:"float32");if(t===void 0)return[r];let s=K(t,"y","meshgrid",t instanceof Zt?t.dtype:"float32"),a=Gn(r.shape),i=Gn(s.shape);return n==="xy"?(r=ue(r,[1,-1]),s=ue(s,[-1,1]),[Qt(Ha([i,1],r.dtype),r),Qt(s,Ha([1,a],s.dtype))]):(r=ue(r,[-1,1]),s=ue(s,[1,-1]),[Qt(r,Ha([1,i],r.dtype)),Qt(Ha([a,1],s.dtype),s)])}function WWe(e,t){let n=K(e,"a","minimum"),r=K(t,"b","minimum");[n,r]=Er(n,r),n.dtype==="bool"&&(n=Ke(n,"int32"),r=Ke(r,"int32")),er(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(Df,s)}var ld=ie({minimum_:WWe});function VWe(e,t,n){Z(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=K(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Z(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let s=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)Z(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Z(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`);let a={paddings:t,mode:n},i={x:r};return se.runKernel(Ff,i,a)}var IO=ie({mirrorPad_:VWe});function UWe(e,t){let n=K(e,"a","mod"),r=K(t,"b","mod");[n,r]=Er(n,r);let s={a:n,b:r};return se.runKernel(Of,s)}var SO=ie({mod_:UWe});function GWe(e,t=null,n=!1){e=K(e,"x","moments");let r=To(t,e.shape),s=Sr(e,r,n),a=s.shape;n||(a=wh(s.shape,r));let i=Zn(at(Ke(e,"float32"),ue(s,a))),o=Sr(i,r,n);return{mean:s,variance:o}}var rw=ie({moments_:GWe});function jWe(e,t,n,r){let s=K(t,"data","multiRNNCell"),a=Av(n,"c","multiRNNCell"),i=Av(r,"h","multiRNNCell"),o=s,l=[];for(let d=0;d<e.length;d++){let p=e[d](o,a[d],i[d]);l.push(p[0]),l.push(p[1]),o=p[1]}let u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}var CX=ie({multiRNNCell_:jWe});function HWe(e,t,n,r=!1){let s=K(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?ue(s,[1,-1]):s},l={numSamples:t,seed:n,normalized:r},u=se.runKernel(rx,o,l);return i===1?ue(u,[u.size]):u}var NX=ie({multinomial_:HWe});function qWe(e,t){let n=K(e,"a","notEqual","string_or_numeric"),r=K(t,"b","notEqual","string_or_numeric");[n,r]=Er(n,r),er(n.shape,r.shape);let s={a:n,b:r};return se.runKernel(ax,s)}var kh=ie({notEqual_:qWe});function KWe(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let a={indices:K(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return se.runKernel(Lf,a,i)}var Ug=ie({oneHot_:KWe});function XWe(e){let t={x:K(e,"x","onesLike")};return se.runKernel(ux,t)}var Ti=ie({onesLike_:XWe});function YWe(e,t){let n=K(e,"v1","outerProduct"),r=K(t,"v2","outerProduct");Z(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let s=ue(n,[-1,1]),a=ue(r,[1,-1]);return Qt(s,a)}var TX=ie({outerProduct_:YWe});function ZWe(e,t,n=0){let r=K(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let s={paddings:t,constantValue:n},a={x:r};return se.runKernel(Pf,a,s)}var ml=ie({pad_:ZWe});function JWe(e,t,n=0){return Z(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),ml(e,[t],n)}var $X=ie({pad1d_:JWe});function QWe(e,t,n=0){return Z(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ml(e,t,n)}var EX=ie({pad2d_:QWe});function eVe(e,t,n=0){return Z(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ml(e,t,n)}var _X=ie({pad3d_:eVe});function tVe(e,t,n=0){return Z(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ml(e,t,n)}var AX=ie({pad4d_:tVe});function nVe(e,t,n){let r=K(e,"x","spaceToBatchND");Z(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),Z(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Z(r.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let s={x:r},a={blockShape:t,paddings:n};return se.runKernel(bx,s,a)}var sw=ie({spaceToBatchND_:nVe});function rVe(e,t,n,r,s,a,i){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");let o=K(e,"x","maxPool"),l=o,u=!1;o.rank===3&&(u=!0,l=ue(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Z(uu(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);let c=iX(l.shape,t,a,s,r),d=[c.dilationHeight,c.dilationWidth],p;r==="same"?p=aVe([c.filterHeight,c.filterWidth],d):p=[[0,0],[0,0]];let h=d[0]===1&&d[1]===1,[m,g]=sVe([c.inHeight,c.inWidth],d,p),y=h?r:"valid",b=h?l:sw(l,d,m),v=(n==="avg"?()=>Zu(b,t,a,y,i):()=>Ss(b,t,a,y,i))(),k=h?v:Y1(v,d,g);return u?ue(k,[k.shape[1],k.shape[2],k.shape[3]]):k}function sVe(e,t,n){let r=n.map(c=>c[0]),s=n.map(c=>c[1]),a=e.concat(r,s),i=t.map((c,d)=>(c-a[d]%c)%c),o=s.map((c,d)=>c+i[d]),l=t.map((c,d)=>[r[d],o[d]]),u=t.map((c,d)=>[0,i[d]]);return[l,u]}function aVe(e,t){let n=e.map((a,i)=>a+(a-1)*(t[i]-1)).map(a=>a-1),r=n.map(a=>Math.floor(a/2)),s=n.map((a,i)=>a-r[i]);return n.map((a,i)=>[r[i],s[i]])}var CO=ie({pool_:rVe});function iVe(e,t){let n=K(e,"x","prelu"),r=K(t,"alpha","prelu"),s={x:n,alpha:r};return se.runKernel(Bf,s)}var aw=ie({prelu_:iVe});function oVe(e,t=null,n=!1){let r=K(e,"x","prod");r.dtype==="bool"&&(r=Ke(r,"int32"));let s={x:r},a={axis:t,keepDims:n};return se.runKernel(Wf,s,a)}var NO=ie({prod_:oVe});function lVe(e,t,n,r){let s=e.map((c,d)=>K(c,`tensors${d}`,"raggedGather","int32")),a=K(t,"paramsDenseValues","raggedGather"),i=K(n,"indices","raggedGather","int32"),o={paramsNestedSplits:s,paramsDenseValues:a,indices:i},l={outputRaggedRank:r},u=se.runKernel(tN,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var RX=ie({raggedGather_:lVe});function uVe(e,t,n){let r=K(e,"starts","raggedRange"),s=K(t,"limits","raggedRange",r.dtype),a=K(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:s,deltas:a},o=se.runKernel(nN,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var DX=ie({raggedRange_:uVe});function cVe(e,t,n,r,s){let a=K(e,"shape","raggedTensorToTensor","int32"),i=K(t,"values","raggedTensorToTensor"),o=K(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((d,p)=>K(d,`tensors${p}`,"raggedTensorToTensor","int32")),u={shape:a,values:i,defaultValue:o,rowPartitionTensors:l},c={rowPartitionTypes:s};return se.runKernel(rN,u,c)}var FX=ie({raggedTensorToTensor_:cVe});function dVe(e,t,n){Ei(e);let r=Gn(e),s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<r;a++)s[a]=t();return se.makeTensor(s,e,n)}var OX=ie({rand_:dVe}),TO=_d(VC()),MX={};Kt(MX,{TEST_EPSILON_FLOAT16:()=>LX,createVideoElement:()=>bVe,encodeStrings:()=>PX,expectArrayBuffersEqual:()=>xVe,expectArraysClose:()=>hVe,expectArraysEqual:()=>mVe,expectNumbersClose:()=>gVe,expectPromiseToFail:()=>fVe,expectValuesInRange:()=>yVe,play:()=>vVe,testEpsilon:()=>$O});var pVe=.001,LX=.1;function hVe(e,t,n){return n==null&&(n=$O()),_A(e,t,(r,s)=>EO(r,s,n))}function $O(){return se.backend.floatPrecision()===32?pVe:LX}function _A(e,t,n){let r=!0;if((Ts(e)||Ts(t))&&(r=!1),Ts(e)&&Ts(t)&&(r=!0),r){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=nu(e),o=nu(t);if(!Xu(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let s=Ts(e)?e:rd(e),a=Ts(t)?t:rd(t);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.
Actual:   ${s}.
Expected: ${a}.`);for(let i=0;i<a.length;++i){let o=s[i],l=a[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.
Actual:   ${s}.
Expected: ${a}.`)}typeof expect<"u"&&expect().nothing()}function fVe(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function mVe(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Lc(e)||Lc(e[0])||Lc(t)||Lc(t[0])?_A(e,n,(r,s)=>r==s):_A(e,t,(r,s)=>EO(r,s,0))}function gVe(e,t,n){if(n==null&&(n=$O()),!EO(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function EO(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function yVe(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function xVe(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let s=0;s<r.length;s++)if(n[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${n[s]} instead`)}function PX(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?PX(n):e[t]=H1(n)}return e}function bVe(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",r=>n(t)),t.load()})}async function vVe(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var _O=class{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=s||Math.random();this.random=TO.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,s,a;do r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s;while(a>=1||a===0);let i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},wVe=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let s=r||Math.random();this.randu=TO.alea(s.toString()),this.randn=new _O(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},kVe=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=TO.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function IVe(e,t,n=1,r="float32",s){if(Ei(e),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let a=new wVe(t,n,r,s),i=tn(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}var zX=ie({randomGamma_:IVe});function SVe(e,t=0,n=1,r,s){if(Ei(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let a=new _O(t,n,r,!1,s),i=tn(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}var vN=ie({randomNormal_:SVe});function CVe(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return vN(e,0,1,t,n)}var BX=ie({randomStandardNormal_:CVe});function NVe(e,t=0,n=1,r="float32",s){Ei(e);let a=tn(e,r),i=new kVe(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}var Ld=ie({randomUniform_:NVe});function TVe(e,t,n,r){return Ld(e,t,n,"int32",r)}var WX=ie({randomUniformInt_:TVe});function Ih(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let s={start:e,stop:t,step:n,dtype:r};return se.runKernel(D1,{},s)}function $Ve(e){let t={input:K(e,"input","real")};return se.runKernel(sN,t)}var Gg=ie({real_:$Ve});function EVe(e){let t={x:K(e,"x","reciprocal")};return se.runKernel(Vf,t)}var AO=ie({reciprocal_:EVe});function _Ve(e){let t={x:K(e,"x","relu")};return se.runKernel(Uf,t)}var Un=ie({relu_:_Ve});function AVe(e){let t={x:K(e,"x","relu6")};return se.runKernel(Hf,t)}var wN=ie({relu6_:AVe});function RVe(e,t){let n={x:K(e,"x","reverse")},r={dims:t};return se.runKernel(qf,n,r)}var Yi=ie({reverse_:RVe});function DVe(e){let t=K(e,"x","reverse");return Z(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Yi(t,0)}var VX=ie({reverse1d_:DVe});function FVe(e,t){let n=K(e,"x","reverse");return Z(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Yi(n,t)}var UX=ie({reverse2d_:FVe});function OVe(e,t){let n=K(e,"x","reverse");return Z(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Yi(n,t)}var GX=ie({reverse3d_:OVe});function MVe(e,t){let n=K(e,"x","reverse");return Z(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Yi(n,t)}var jX=ie({reverse4d_:MVe});function LVe(e){let t={x:K(e,"x","round")};return se.runKernel(Kf,t)}var kN=ie({round_:LVe});function PVe(e){let t={x:K(e,"x","rsqrt","float32")};return se.runKernel(Xf,t)}var IN=ie({rsqrt_:PVe});function zVe(e){let t={x:K(e,"x","selu")};return se.runKernel(Yf,t)}var SN=ie({selu_:zVe});function BVe(e,t,n,r,s,a=[1,1],i="NHWC"){let o=K(e,"x","separableConv2d"),l=K(t,"depthwiseFilter","separableConv2d"),u=K(n,"pointwiseFilter","separableConv2d"),c=o,d=!1;if(o.rank===3&&(d=!0,c=ue(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Z(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),Z(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),Z(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),Z(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),Z(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let p=l.shape[2],h=l.shape[3];Z(u.shape[2]===p*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*h}, but got ${u.shape[2]}.`);let m=cm(c,l,r,s,i,a),g=_a(m,u,1,"valid",i);return d?ue(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var Fx=ie({separableConv2d_:BVe});async function WVe(e,t){let n=K(e,"x","setdiff1d"),r=K(t,"y","setdiff1d");Z(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),Z(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),Z(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let s=await n.data(),a=await r.data(),i=new Set(a),o=0;for(let c=0;c<s.length;c++)i.has(s[c])||o++;let l=new Xr([o],n.dtype),u=new Xr([o],"int32");for(let c=0,d=0;c<s.length;c++)i.has(s[c])||(l.values[d]=s[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]}var HX=WVe;function VVe(e){let t={x:K(e,"x","sign")};return se.runKernel(Qf,t)}var RO=ie({sign_:VVe});function UVe(e){let t={x:K(e,"x","sin","float32")};return se.runKernel(Zf,t)}var CN=ie({sin_:UVe});function GVe(e){let t={x:K(e,"x","sinh")};return se.runKernel(Jf,t)}var NN=ie({sinh_:GVe});function jVe(e,t,n){let r=K(e,"x","slice1d");return Z(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),hn(r,[t],[n])}var iw=ie({slice1d_:jVe});function HVe(e,t,n){let r=K(e,"x","slice2d");return Z(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),hn(r,t,n)}var TN=ie({slice2d_:HVe});function qVe(e,t,n){let r=K(e,"x","slice3d");return Z(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),hn(r,t,n)}var Ox=ie({slice3d_:qVe});function KVe(e,t,n){let r=K(e,"x","slice4d");return Z(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),hn(r,t,n)}var jg=ie({slice4d_:KVe});function XVe(e,t=-1){let n=K(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},s={dim:t};return se.runKernel(sm,r,s)}var Pd=ie({softmax_:XVe});function YVe(e){Z(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return se.runKernel(JC,t)}var ow=ie({fft_:YVe});function ZVe(e){Z(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return se.runKernel(QC,t)}var Hg=ie({ifft_:ZVe});function JVe(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let s=ue(e,[n,t]);r=Hg(s)}else{let s=[n,2*(t-1)],a=ue(Gg(e),[n,t]),i=ue(J1(e),[n,t]),o=Yi(hn(a,[0,1],[n,t-2]),1),l=oe(Yi(hn(i,[0,1],[n,t-2]),1),Tt(-1)),u=Jn([a,o],1),c=Jn([i,l],1),d=ue(Wu(u,c),[s[0],s[1]]);r=Hg(d)}if(r=Gg(r),e.rank===3&&e.shape[0]!==0){let s=r,a=e.shape[0];r=ue(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}var $N=ie({irfft_:JVe});function QVe(e,t,n=0){let r={x:K(e,"x","split")},s={numOrSizeSplits:t,axis:n};return se.runKernel(vx,r,s)}var Xa=ie({split_:QVe});function eUe(e,t){Z(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,s;if(t!=null&&t<n){let m=e.shape.map(y=>0),g=e.shape.map(y=>y);g[e.shape.length-1]=t,s=hn(e,m,g),n=t}else if(t!=null&&t>n){let m=e.shape.map(g=>g);m[e.shape.length-1]=t-n,s=Jn([e,Cr(m)],e.shape.length-1),n=t}else s=e;let a=gn(s),i=ue(Wu(s,a),[r,n]),o=ow(i),l=Math.floor(n/2)+1,u=Gg(o),c=J1(o),d=Xa(u,[l,n-l],u.shape.length-1),p=Xa(c,[l,n-l],c.shape.length-1),h=s.shape.slice();return h[s.shape.length-1]=l,ue(Wu(d[0],p[0]),h)}var lw=ie({rfft_:eUe});function tUe(e,t){let n=K(e,"a","squaredDifference"),r=K(t,"b","squaredDifference");[n,r]=Er(n,r),er(n.shape,r.shape);let s={a:n,b:r},a={};return se.runKernel(am,s,a)}var EN=ie({squaredDifference_:tUe});function nUe(e,t){let n=K(e,"x","squeeze","string_or_numeric");return ue(n,bK(n.shape,t).newShape)}var zd=ie({squeeze_:nUe});function rUe(e,t=0){let n=Av(e,"tensors","stack","string_or_numeric");Z(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Z(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,s={axis:t};return se.runKernel(cx,r,s)}var Yr=ie({stack_:rUe});function sUe(e,t=0){let n={x:K(e,"x","step")},r={alpha:t};return se.runKernel(Fd,n,r)}var pm=ie({step_:sUe});function aUe(e,t,n,r,s=0,a=0,i=0,o=0,l=0){let u={x:K(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return se.runKernel(Ix,u,c)}var DO=ie({stridedSlice_:aUe});function iUe(e){let t={x:K(e,"x","tan","float32")};return se.runKernel(om,t)}var FO=ie({tan_:iUe});function Ln(e,t){Uh(e);let n=nu(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Od(e,null,n,t)}function Kl(e,t,n){if(Uh(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=nu(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Od(e,t,r,n)}function _N(e,t,n){if(Uh(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=nu(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Od(e,t,r,n)}function ud(e,t,n){if(Uh(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=nu(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Od(e,t,r,n)}function qX(e,t,n){if(Uh(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=nu(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Od(e,t,r,n)}function KX(e,t,n){if(Uh(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=nu(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,Od(e,t,r,n)}var AN={};Kt(AN,{calculateShapes:()=>XX,validateInput:()=>RN,validateUpdateShape:()=>OO});function OO(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+` update.rank != ${s+e.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function RN(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}OO(n,t,e)}function XX(e,t,n){let r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length,i=1;for(let d=s;d<a;++d)i*=n[d];let o=s<1?1:s,l=Gn(t.shape)/o,u=[...Ny(n.slice(0,s)),1],c=Gn(n);return{sliceRank:s,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}function oUe(e,t,n){let r=K(e,"tensor","tensorScatterupdate"),s=K(t,"indices","tensorScatterupdate","int32"),a=K(n,"updates","tensorScatterupdate");if(RN(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);let i={tensor:r,indices:s,updates:a},o={};return se.runKernel(mx,i,o)}var YX=ie({tensorScatterUpdate_:oUe});function lUe(e,t=1,n=!0){let r=K(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);let a={x:r},i={k:t,sorted:n},[o,l]=se.runKernel(Sx,a,i);return{values:o,indices:l}}var MO=ie({topk_:lUe});function uUe(e,t=0,n=1,r,s){if(Ei(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let a=new _O(t,n,r,!0,s),i=tn(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}var DN=ie({truncatedNormal_:uUe});function cUe(e,t=0){let n=K(e,"x","unique","string_or_numeric");Z(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},s={axis:t},[a,i]=se.runKernel(V1,r,s);return{values:a,indices:i}}var LO=ie({unique_:cUe});function dUe(e,t,n){let r=K(e,"x","unsortedSegmentSum"),s=K(t,"segmentIds","unsortedSegmentSum","int32");Z(Lg(n),()=>"numSegments must be of dtype int");let a={x:r,segmentIds:s},i={numSegments:n};return se.runKernel(U1,a,i)}var FN=ie({unsortedSegmentSum_:dUe});function pUe(e,t=0){let n=K(e,"x","unstack","string_or_numeric");Z(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},s={axis:t};return se.runKernel(Nx,r,s)}var Fr=ie({unstack_:pUe});function ZX(e,t){return bN(e,t,"right")}function PO(e,t=!0,n,r){return se.makeVariable(e,t,n,r)}function JX(e,t){let n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);let r=tn(e,"int32"),s=tn([n.length,e.length],"int32");for(let a=0;a<n.length;a++){let i=r.indexToLoc(n[a]),o=a*e.length;s.values.set(i,o)}return s.toTensor()}async function hUe(e){let t=K(e,"condition","whereAsync","bool"),n=await t.data(),r=JX(t.shape,n);return e!==t&&t.dispose(),r}var zO=hUe;async function fUe(e,t,n){let r=K(e,"tensor","boolMask"),s=K(t,"mask","boolMask","bool"),a=n??0,i=s.rank,o=r.shape;Z(i>0,()=>"mask cannot be scalar"),Fa(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=a;g<a+i;g++)l*=o[g];let u=o.slice(0,a).concat([l],o.slice(a+i)),c=ue(r,u),d=ue(s,[-1]),p=await zO(d),h=zd(p,[1]),m=Dx(c,h,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),h.dispose(),c.dispose(),d.dispose(),p.dispose(),m}var QX=fUe;function mUe(e,t,n){let r=K(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),Z(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{Z(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let s={x:r},a={perm:t};return r.dtype==="complex64"?ce(()=>{let i=Gg(r),o=J1(r);return i=se.runKernel(Ru,{x:i},a),o=se.runKernel(Ru,{x:o},a),n&&(o=or(o)),Wu(i,o)}):se.runKernel(Ru,s,a)}var en=ie({transpose_:mUe});function gUe(e,t,n,r,s=!0){let a=K(e,"v","movingAverage"),i=K(t,"x","movingAverage"),o=K(n,"decay","movingAverage");zK(a,i),Z(Xu(a.shape,i.shape),()=>"Shape mismatch in v and x");let l=Tt(1),u=at(l,o),c=oe(at(i,a),u);if(s){Z(r!=null,()=>"When using zeroDebias: true, step is required.");let d=K(r,"step","movingAverage");c=ht(c,at(l,ru(o,d)))}return Ae(a,c)}var eY=ie({movingAverage_:gUe});function yUe(e,t,n){Ei(n);let r=K(e,"indices","scatterND","int32"),s=K(t,"updates","scatterND");RN(s,r,n);let a={indices:r,updates:s},i={shape:n};return se.runKernel(fx,a,i)}var tY=ie({scatterND_:yUe});function xUe(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function bUe(e,t,n,r=0){Ei(n);let s=K(e,"sparseIndices","sparseToDense","int32"),a=K(t,"sparseValues","sparseToDense","string_or_numeric"),i=K(r,"defaultValue","sparseToDense",a.dtype);xUe(s,a,n,i);let o={sparseIndices:s,sparseValues:a,defaultValue:i},l={outputShape:n};return se.runKernel(kx,o,l)}var nY=ie({sparseToDense_:bUe});function vUe(e,t){let n=K(t,"indices","gatherND","int32"),r={params:K(e,"x","gatherND","string_or_numeric"),indices:n};return se.runKernel(qy,r)}var rY=ie({gatherND_:vUe});function wUe(e,t){if(t==null)return e.shape.slice();if(Xu(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function kUe(e,t,n,r){let s=K(e,"x","dropout");if(Z(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),Z(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Zt?s.clone():s;let a=wUe(s,n),i=1-t,o=ht(Rx(Ae(Ld(a,0,1,"float32",r),i)),i);return oe(s,o)}var BO=ie({dropout_:kUe});function WO(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function ON(e,t,n){let r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){let i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return Ln(s,"float32")}async function IUe(e,t,n=1){let r=K(e,"predictions","inTopK"),s=K(t,"targets","inTopK");Z(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),Z(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Fa(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let a=r.shape[r.shape.length-1];Z(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);let i=await r.data(),o=await s.data(),[l,u]=[i.length/a,a],c=vK("bool",l);for(let d=0;d<l;d++){let p=d*u,h=i.subarray(p,p+u),m=[];for(let g=0;g<h.length;g++)m.push({value:h[g],index:g});m.sort((g,y)=>y.value-g.value),c[d]=0;for(let g=0;g<n;g++)if(m[g].index===o[d]){c[d]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),$a(c,s.shape,"bool")}var sY=IUe,qg={};Kt(qg,{conv2d:()=>NUe,depthwiseConv2d:()=>_Ue,matMul:()=>RUe});function SUe(e,t,n,r,s,a="NHWC",i){let o=e;e.rank===3&&(o=ue(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=ue(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Z(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),Z(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),Z(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let u=a==="NHWC"?o.shape[3]:o.shape[1],c=a==="NHWC"?l.shape[3]:l.shape[1];Z(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),Z(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Oa("conv2dDerFilter",s,i);let d={x:o,dy:l},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return se.runKernel(qC,d,p)}var VO=ie({conv2DBackpropFilter_:SUe});function MN(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return oe(e,pm(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function LN(e,t){let n=t,r=Qr(e.shape,t.shape);return r.length>0&&(n=yt(n,r)),ue(n,e.shape)}function PN(e,t,n,r){if(t==="linear")return e;if(t==="relu")return Un(e);if(t==="elu")return _x(e);if(t==="relu6")return wN(e);if(t==="prelu")return aw(e,n);if(t==="leakyrelu")return Q1(e,r);if(t==="sigmoid")return vo(e);throw new Error(`Unknown fused activation ${t}.`)}var zN=(e,t)=>!(e>0)||t==="linear";function CUe({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",zN(se.state.gradientDepth,l)===!1){Z(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=_a(e,t,n,r,s,a,i);return o!=null&&(N=Ae(N,o)),PN(N,l,u,c)}let d=K(e,"x","conv2d","float32"),p=K(t,"filter","conv2d","float32"),h=d,m=!1;d.rank===3&&(m=!0,h=ue(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Z(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),Z(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),Oa("fused conv2d",r,i);let g=s==="NHWC"?h.shape[3]:h.shape[1];Z(p.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`),Z(uu(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let y=X1(h.shape,p.shape,n,a,r,i),b;o!=null&&(b=K(o,"bias","fused conv2d"),[b]=Er(b,d),s==="NHWC"?er(y.outShape,b.shape):(Z(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),Z(b.shape.length===0||b.shape[0]===y.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let v;if(u!=null){let N=u.shape;if(Z(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)Z(N[0]===1||N[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${y.outChannels}).`);else if(N.length===3)try{er(N,y.outShape)}catch{let A=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(A)}v=K(u,"prelu weights","fused conv2d")}let k=(N,T)=>{Z(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);let[A,R,D,$]=T,_=MN(N,D,l);Z(id(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let L=aO(R.shape,_,A,n,r),z=VO(R,_,A.shape,n,r),W=[L,z];if($!=null){let G=LN($,_);W.push(G)}return W},I={x:h,filter:p,bias:b,preluActivationWeights:v},S={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?su((N,T,A)=>{let R=se.runKernel(hh,I,S);return A([T,N,R]),m&&(R=ue(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:k}})(h,p):su((N,T,A,R)=>{let D=se.runKernel(hh,I,S);return R([T,N,D,A]),m&&(D=ue(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:k}})(h,p,b)}var NUe=ie({fusedConv2d_:CUe});function TUe(e,t,n,r,s,a=[1,1],i){let o=e;e.rank===3&&(o=ue(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=ue(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return se.runKernel(KC,u,c)}var aY=ie({depthwiseConv2dNativeBackpropFilter_:TUe});function $Ue(e,t,n,r,s,a=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=ue(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},d=se.runKernel(XC,u,c);return l?ue(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var iY=ie({depthwiseConv2dNativeBackpropInput_:$Ue});function EUe({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(zN(se.state.gradientDepth,l)===!1){let S=cm(e,t,n,r,s,a,i);return o!=null&&(S=Ae(S,o)),PN(S,l,u,c)}let d=K(e,"x","depthwiseConv2d","float32"),p=K(t,"filter","depthwiseConv2d","float32"),h=d,m=!1;d.rank===3&&(m=!0,h=ue(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Z(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),Z(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),Z(h.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),a==null&&(a=[1,1]),Z(uu(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Oa("fused depthwiseConv2d",r,i);let g=X1(h.shape,p.shape,n,a,r,i,!0),y;o!=null&&(y=K(o,"bias","fused conv2d"),[y]=Er(y,d),er(g.outShape,y.shape));let b;u!=null&&(b=K(u,"prelu weights","fused depthwiseConv2d"));let v=(S,N)=>{Z(id(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[T,A,R,D]=N,$=MN(S,R,l),_=iY(A.shape,$,T,n,r,a,i),L=aY(A,$,T.shape,n,r,a,i);if(D!=null){let z=LN(y,$);return[_,L,z]}return[_,L]},k={x:h,filter:p,bias:y,preluActivationWeights:b},I={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?su((S,N,T)=>{let A=se.runKernel(fh,k,I);return T([N,S,A]),m&&(A=ue(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:v}})(h,p):su((S,N,T,A)=>{let R=se.runKernel(fh,k,I);return A([N,S,R,T]),m&&(R=ue(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:v}})(h,p,y)}var _Ue=ie({fusedDepthwiseConv2d_:EUe});function AUe({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(zN(se.state.gradientDepth,a)===!1){let D=Qt(e,t,n,r);return s!=null&&(D=Ae(D,s)),PN(D,a,i,o)}let l=K(e,"a","fused matMul"),u=K(t,"b","fused matMul");[l,u]=Er(l,u);let c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),g=u.shape.slice(0,-2),y=Gn(m),b=Gn(g);Z(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);let v=er(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,h]),k=n?ue(l,[y,c,p]):ue(l,[y,p,c]),I=r?ue(u,[b,h,d]):ue(u,[b,d,h]),S;s!=null&&(S=K(s,"bias","fused matMul"),[S]=Er(S,l),er(v,S.shape));let N;i!=null&&(N=K(i,"prelu weights","fused matMul"));let T=(D,$)=>{let[_,L,z,W]=$,G=MN(ue(D,z.shape),z,a),q,B;if(!n&&!r?(q=Qt(G,L,!1,!0),B=Qt(_,G,!0,!1)):!n&&r?(q=Qt(G,L,!1,!1),B=Qt(G,_,!0,!1)):n&&!r?(q=Qt(L,G,!1,!0),B=Qt(_,G,!1,!1)):(q=Qt(L,G,!0,!0),B=Qt(G,_,!0,!0)),s!=null){let j=LN(W,G);return[q,B,j]}else return[q,B]},A={a:k,b:I,bias:S,preluActivationWeights:N},R={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};return s==null?su((D,$,_)=>{let L=se.runKernel(ph,A,R);return _([D,$,L]),{value:ue(L,v),gradFunc:T}})(k,I):su((D,$,_,L)=>{let z=se.runKernel(ph,A,R);return L([D,$,z,_]),{value:ue(z,v),gradFunc:T}})(k,I,S)}var RUe=ie({fusedMatMul_:AUe});function DUe(e){return ON(e,.54,.46)}var FUe=ie({hammingWindow_:DUe});function OUe(e){return ON(e,.5,.5)}var oY=ie({hannWindow_:OUe});function MUe(e,t,n,r=!1,s=0){let a=0,i=[];for(;a+t<=e.size;)i.push(hn(e,a,t)),a+=n;if(r)for(;a<e.size;){let o=a+t-e.size,l=Jn([hn(e,a,t-o),wi([o],s)]);i.push(l),a+=n}return i.length===0?Kl([],[0,t]):ue(Jn(i),[i.length,t])}var lY=ie({frame_:MUe});function LUe(e,t,n,r,s=oY){r==null&&(r=WO(t));let a=lY(e,t,n),i=oe(a,s(t));return lw(i,r)}var PUe=ie({stft_:LUe});function zUe(e,t,n,r,s="bilinear",a=0){let i=K(e,"image","cropAndResize"),o=K(t,"boxes","cropAndResize","float32"),l=K(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Z(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),Z(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),Z(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),Z(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),Z(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),Z(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);let c={image:i,boxes:o,boxInd:l},d={method:s,extrapolationValue:a,cropSize:r};return se.runKernel(By,c,d)}var BUe=ie({cropAndResize_:zUe});function WUe(e){let t=K(e,"image","flipLeftRight","float32");Z(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return se.runKernel(jy,n,{})}var VUe=ie({flipLeftRight_:WUe});function UUe(e){let t=K(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Z(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),Z(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,xi(t,s)}var GUe=ie({grayscaleToRGB_:UUe});function jUe(e){let t=K(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Z(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),Z(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let s=t.dtype,a=Ke(t,"float32"),i=Ln([.2989,.587,.114]),o;switch(t.rank){case 2:o=$p("ij,j->i",a,i);break;case 3:o=$p("ijk,k->ij",a,i);break;case 4:o=$p("ijkl,l->ijk",a,i);break;case 5:o=$p("ijklm,m->ijkl",a,i);break;case 6:o=$p("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=$s(o,-1),Ke(o,s)}var HUe=ie({rgbToGrayscale_:jUe});function qUe(e,t,n=0,r=.5){let s=K(e,"image","rotateWithOffset","float32");Z(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);let a={image:s},i={radians:t,fillValue:n,center:r};return se.runKernel($x,a,i)}var KUe=ie({rotateWithOffset_:qUe});function Mx(e,t,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);let i=e.shape[0];return n=Math.min(n,i),Z(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),Z(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),Z(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),Z(t.rank===1,()=>"scores must be a 1D tensor"),Z(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),Z(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}function XUe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let a=K(e,"boxes","nonMaxSuppression","float32"),i=K(t,"scores","nonMaxSuppression","float32"),o=Mx(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return se.runKernel(ix,{boxes:a,scores:i},l)}var YUe=ie({nonMaxSuppression_:XUe});function ZUe(e,t,n){let r=JUe(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function JUe(e,t,n){return e6e(e,t,n||QUe)}function QUe(e,t){return e>t?1:e<t?-1:0}function e6e(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);let o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}function uY(e,t,n,r,s){return UO(e,t,n,r,s,0)}function cY(e,t,n,r,s,a){return UO(e,t,n,r,s,0,!1,a,!0)}function dY(e,t,n,r,s,a){return UO(e,t,n,r,s,a,!0)}function UO(e,t,n,r,s,a,i=!1,o=!1,l=!1){let u=[];for(let y=0;y<t.length;y++)t[y]>s&&u.push({score:t[y],boxIndex:y,suppressBeginIndex:0});u.sort(bU);let c=a>0?-.5/a:0,d=[],p=[];for(;d.length<n&&u.length>0;){let y=u.pop(),{score:b,boxIndex:v,suppressBeginIndex:k}=y;if(b<s)break;let I=!1;for(let S=d.length-1;S>=k;--S){let N=t6e(e,v,d[S]);if(N>=r){I=!0;break}if(y.score=y.score*n6e(r,c,N),y.score<=s)break}y.suppressBeginIndex=d.length,I||(y.score===b?(d.push(v),p.push(y.score)):y.score>s&&ZUe(u,y,bU))}let h=d.length,m=n-h;o&&m>0&&(d.push(...new Array(m).fill(0)),p.push(...new Array(m).fill(0)));let g={selectedIndices:d};return i&&(g.selectedScores=p),l&&(g.validOutputs=h),g}function t6e(e,t,n){let r=e.subarray(t*4,t*4+4),s=e.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),h=(o-a)*(l-i),m=(d-u)*(p-c);if(h<=0||m<=0)return 0;let g=Math.max(a,u),y=Math.max(i,c),b=Math.min(o,d),v=Math.min(l,p),k=Math.max(b-g,0)*Math.max(v-y,0);return k/(h+m-k)}function n6e(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function bU(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function r6e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let a=K(e,"boxes","nonMaxSuppressionAsync"),i=K(t,"scores","nonMaxSuppressionAsync"),o=Mx(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;let l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=uY(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),Ln(d,"int32")}var s6e=r6e;function a6e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){let i=K(e,"boxes","nonMaxSuppression"),o=K(t,"scores","nonMaxSuppression"),l=Mx(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;let u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},d=se.runKernel(lx,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}var i6e=ie({nonMaxSuppressionWithScore_:a6e});async function o6e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){let i=K(e,"boxes","nonMaxSuppressionAsync"),o=K(t,"scores","nonMaxSuppressionAsync"),l=Mx(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:p,selectedScores:h}=dY(c,d,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Ln(p,"int32"),selectedScores:Ln(h)}}var l6e=o6e;function u6e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){let i=K(e,"boxes","nonMaxSuppression"),o=K(t,"scores","nonMaxSuppression"),l=Mx(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,p={boxes:i,scores:o},h={maxOutputSize:u,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:a},m=se.runKernel(ox,p,h);return{selectedIndices:m[0],validOutputs:m[1]}}var c6e=ie({nonMaxSuppressionPadded_:u6e});async function d6e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){let i=K(e,"boxes","nonMaxSuppressionAsync"),o=K(t,"scores","nonMaxSuppressionAsync"),l=Mx(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[p,h]=await Promise.all([i.data(),o.data()]),{selectedIndices:m,validOutputs:g}=cY(p,h,u,c,d,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Ln(m,"int32"),validOutputs:Tt(g,"int32")}}var p6e=d6e;function h6e(e,t,n=!1,r=!1){let s=K(e,"images","resizeBilinear");Z(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),Z(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Z(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=ue(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=se.runKernel(jf,o,l);return i?ue(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var pY=ie({resizeBilinear_:h6e});function f6e(e,t,n=!1,r=!1){let s=K(e,"images","resizeNearestNeighbor");Z(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),Z(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Z(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),Z(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=ue(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=se.runKernel(Gf,o,l);return i?ue(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var hY=ie({resizeNearestNeighbor_:f6e});function m6e(e,t="binary",n=!1,r=.5){let s=K(e,"image","threshold"),a=.2989,i=.587,o=.114,l=s.shape[0]*s.shape[1],u=oe(Ln([r]),255),c,d,p,h;if(Z(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),Z(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),Z(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),Z(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),s.shape[2]===3){[c,d,p]=Xa(s,[1,1,1],-1);let g=oe(c,a),y=oe(d,i),b=oe(p,o);h=Ae(Ae(g,y),b)}else h=e;if(t==="otsu"){let g=Q3(Ke(kN(h),"int32"),$a([]),256);u=g6e(g,l)}let m=n?Md(h,u):Ma(h,u);return Ke(oe(m,255),"int32")}function g6e(e,t){let n=Ln([-1]),r=Ln([0]),s=Ln([0]),a,i,o,l,u,c;for(let d=0;d<e.size-1;d++){a=hn(e,0,d+1),i=hn(e,d+1),u=ht(yt(a),t),c=ht(yt(i),t);let p=yt(oe(a,Ih(0,a.size)));o=ht(p,yt(a));let h=wi(i.shape,a.size),m=Ae(Ih(0,i.size),h),g=oe(i,m);l=ht(yt(g),yt(i));let y=at(o,l),b=at(o,l),v=oe(u,c);s=oe(oe(v,y),b);let k=Ma(s,r);r=Rs(k,s,r),n=Rs(k,Ln([d]),n)}return n}var y6e=ie({threshold_:m6e});function x6e(e,t,n="nearest",r="constant",s=0,a){let i=K(e,"image","transform","float32"),o=K(t,"transforms","transform","float32");Z(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),Z(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Z(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);let l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return se.runKernel(Cx,l,u)}var b6e=ie({transform_:x6e});function v6e(e,t,n){let r=K(e,"a","bandPart");Z(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let s=r.shape,[a,i]=r.shape.slice(-2),o,l;typeof t=="number"?(Z(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Z(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),o=K(t<0?a:t,"numLower","bandPart")):(Z(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Rs(Vg(t,0),a,ld(t,a))),typeof n=="number"?(Z(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),Z(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=K(n<0?i:n,"numUpper","bandPart")):(Z(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Rs(Vg(n,0),i,ld(n,i)));let u=ue(Ih(0,a,1,"int32"),[-1,1]),c=Ih(0,i,1,"int32"),d=at(u,c),p=Io(Md(d,o),Ju(d,or(l))),h=Cr([a,i],r.dtype);return ue(Yr(Fr(ue(r,[-1,a,i])).map(m=>Rs(p,m,h))),s)}var w6e=ie({bandPart_:v6e});function k6e(e){let t;if(Array.isArray(e)){t=!1,Z(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let s=e[0].shape[0];for(let a=1;a<e.length;++a)Z(e[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${s})`)}else t=!0,e=Xa(e,e.shape[0],0).map(s=>zd(s,[0]));Z(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let s=0;s<e.length;++s)n.push(se.tidy(()=>{let a=r[s];if(s>0)for(let i=0;i<s;++i){let o=oe(yt(oe(n[i],a)),n[i]);a=at(a,o)}return ht(a,Ax(a,"euclidean"))}));return t?Yr(n,0):n}var I6e=ie({gramSchmidt_:k6e});function S6e(e,t=!1){if(Z(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return vU(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),r=Fr(ue(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach(l=>{let[u,c]=vU(l,t);s.push(u),a.push(c)});let i=ue(Yr(s,0),e.shape),o=ue(Yr(a,0),e.shape);return[i,o]}}function vU(e,t=!1){return se.tidy(()=>{Z(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],s=mN(n),a=ql(e),i=Kl([[1]],[1,1]),o=ql(i),l=n>=r?r:n;for(let u=0;u<l;++u){let c=a,d=o,p=s;[o,a,s]=se.tidy(()=>{let h=hn(a,[u,u],[n-u,1]),m=Ax(h),g=hn(a,[u,u],[1,1]),y=Rs(Ma(g,0),Kl([[-1]]),Kl([[1]])),b=at(g,oe(y,m)),v=ht(h,b);v.shape[0]===1?o=ql(i):o=Jn([i,hn(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);let k=or(ht(Qt(y,b),m)),I=hn(a,[u,0],[n-u,r]),S=oe(k,o),N=en(o);if(u===0)a=at(I,Qt(S,Qt(N,I)));else{let R=at(I,Qt(S,Qt(N,I)));a=Jn([hn(a,[0,0],[u,r]),R],0)}let T=en(S),A=hn(s,[0,u],[n,s.shape[1]-u]);if(u===0)s=at(A,Qt(Qt(A,o),T));else{let R=at(A,Qt(Qt(A,o),T));s=Jn([hn(s,[0,0],[n,u]),R],1)}return[o,a,s]}),qt([c,d,p])}return!t&&n>r&&(s=hn(s,[0,0],[n,r]),a=hn(a,[0,0],[r,r])),[s,a]})}var C6e=ie({qr_:S6e}),Ca;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ca||(Ca={}));function N6e(e,t,n=Ca.SUM_BY_NONZERO_WEIGHTS){let r=K(e,"losses","computeWeightedLoss"),s=null;t!=null&&(s=K(t,"weights","computeWeightedLoss"));let a=s==null?r:oe(r,s);if(n===Ca.NONE)return a;if(n===Ca.SUM)return yt(a);if(n===Ca.MEAN){if(s==null)return Sr(a);{let i=r.size/s.size,o=ht(yt(a),yt(s));return i>1?ht(o,Tt(i)):o}}if(n===Ca.SUM_BY_NONZERO_WEIGHTS){if(s==null)return ht(yt(a),Tt(r.size));{let i=oe(s,Ha(r.shape)),o=Ke(yt(kh(i,Tt(0))),"float32");return ht(yt(a),o)}}throw Error(`Unknown reduction: ${n}`)}var Qu=ie({computeWeightedLoss_:N6e});function T6e(e,t,n,r=Ca.SUM_BY_NONZERO_WEIGHTS){let s=K(e,"labels","absoluteDifference"),a=K(t,"predictions","absoluteDifference"),i=null;n!=null&&(i=K(n,"weights","absoluteDifference")),Fa(s.shape,a.shape,"Error in absoluteDifference: ");let o=Hr(at(s,a));return Qu(o,i,r)}var $6e=ie({absoluteDifference_:T6e});function E6e(e,t,n,r,s=Ca.SUM_BY_NONZERO_WEIGHTS){let a=K(e,"labels","cosineDistance"),i=K(t,"predictions","cosineDistance"),o=null;r!=null&&(o=K(r,"weights","cosineDistance")),Fa(a.shape,i.shape,"Error in cosineDistance: ");let l=Tt(1),u=at(l,yt(oe(a,i),n,!0));return Qu(u,o,s)}var _6e=ie({cosineDistance_:E6e});function A6e(e,t,n,r=Ca.SUM_BY_NONZERO_WEIGHTS){let s=K(e,"labels","hingeLoss"),a=K(t,"predictions","hingeLoss"),i=null;n!=null&&(i=K(n,"weights","hingeLoss")),Fa(s.shape,a.shape,"Error in hingeLoss: ");let o=Tt(1);s=at(oe(Tt(2),s),o);let l=Un(at(o,oe(s,a)));return Qu(l,i,r)}var R6e=ie({hingeLoss_:A6e});function D6e(e,t,n,r=1,s=Ca.SUM_BY_NONZERO_WEIGHTS){let a=K(e,"labels","huberLoss"),i=K(t,"predictions","huberLoss"),o=null;n!=null&&(o=K(n,"weights","huberLoss")),Fa(a.shape,i.shape,"Error in huberLoss: ");let l=Tt(r),u=Hr(at(i,a)),c=ld(u,l),d=at(u,c),p=Ae(oe(Tt(.5),Zn(c)),oe(l,d));return Qu(p,o,s)}var F6e=ie({huberLoss_:D6e});function O6e(e,t,n,r=1e-7,s=Ca.SUM_BY_NONZERO_WEIGHTS){let a=K(e,"labels","logLoss"),i=K(t,"predictions","logLoss"),o=null;n!=null&&(o=K(n,"weights","logLoss")),Fa(a.shape,i.shape,"Error in logLoss: ");let l=Tt(1),u=Tt(r),c=or(oe(a,Ni(Ae(i,u)))),d=oe(at(l,a),Ni(Ae(at(l,i),u))),p=at(c,d);return Qu(p,o,s)}var M6e=ie({logLoss_:O6e});function L6e(e,t,n,r=Ca.SUM_BY_NONZERO_WEIGHTS){let s=K(e,"labels","meanSquaredError"),a=K(t,"predictions","meanSquaredError"),i=null;n!=null&&(i=K(n,"weights","meanSquaredError")),Fa(s.shape,a.shape,"Error in meanSquaredError: ");let o=EN(s,a);return Qu(o,i,r)}var P6e=ie({meanSquaredError_:L6e});function z6e(e,t){let n=K(e,"labels","sigmoidCrossEntropyWithLogits"),r=K(t,"logits","sigmoidCrossEntropyWithLogits");Fa(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let s=Un(r),a=oe(r,n),i=ew(la(or(Hr(r))));return Ae(at(s,a),i)}function B6e(e,t,n,r=0,s=Ca.SUM_BY_NONZERO_WEIGHTS){let a=K(e,"multiClassLabels","sigmoidCrossEntropy"),i=K(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=K(n,"weights","sigmoidCrossEntropy")),Fa(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let u=Tt(r),c=Tt(1),d=Tt(.5);a=Ae(oe(a,at(c,u)),oe(d,u))}let l=z6e(a,i);return Qu(l,o,s)}var W6e=ie({sigmoidCrossEntropy_:B6e});function V6e(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return su((r,s,a)=>{let i=tw(s,[n],!0),o=at(Ke(s,"float32"),i);a([r,o]);let l=or(oe(o,r));return{value:yt(l,[n]),gradFunc:(u,c)=>{let[d,p]=c,h=wh(u.shape,[n]);return[oe(ue(u,h),at(Ke(d,"float32"),la(p))),oe(ue(u,h),at(la(p),Ke(d,"float32")))]}}})(e,t)}function U6e(e,t,n,r=0,s=Ca.SUM_BY_NONZERO_WEIGHTS){let a=K(e,"onehotLabels","softmaxCrossEntropy"),i=K(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=K(n,"weights","softmaxCrossEntropy")),Fa(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let u=Tt(r),c=Tt(1),d=Tt(a.shape[1]);a=Ae(oe(a,at(c,u)),ht(u,d))}let l=V6e(a,i);return Qu(l,o,s)}var G6e=ie({softmaxCrossEntropy_:U6e});function j6e(e,t,n,r){let s=K(e,"indices","sparseFillEmptyRows","int32"),a=K(t,"values","sparseFillEmptyRows"),i=K(n,"denseShape","sparseFillEmptyRows","int32"),o=K(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:s,values:a,denseShape:i,defaultValue:o},u=se.runKernel(F1,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var H6e=ie({sparseFillEmptyRows_:j6e});function q6e(e,t,n){let r=K(e,"inputIndices","sparseReshape","int32"),s=K(t,"inputShape","sparseReshape","int32"),a=K(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);let i={inputIndices:r,inputShape:s,newShape:a},o=se.runKernel(wx,i);return{outputIndices:o[0],outputShape:o[1]}}var K6e=ie({sparseReshape_:q6e});function X6e(e,t,n){let r=K(e,"data","sparseSegmentMean"),s=K(t,"indices","sparseSegmentMean","int32"),a=K(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);let i={data:r,indices:s,segmentIds:a};return se.runKernel(O1,i)}var Y6e=ie({sparseSegmentMean_:X6e});function Z6e(e,t,n){let r=K(e,"data","sparseSegmentSum"),s=K(t,"indices","sparseSegmentSum","int32"),a=K(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);let i={data:r,indices:s,segmentIds:a};return se.runKernel(M1,i)}var J6e=ie({sparseSegmentSum_:Z6e});function Q6e(e,t,n,r,s,a,i,o){let l=K(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=K(t,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},p=se.runKernel(z1,d,c);return{nGrams:p[0],nGramsSplits:p[1]}}var eGe=ie({stringNGrams_:Q6e});function tGe(e,t,n=!0){let r=K(e,"input","stringSplit","string"),s=K(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);let a={skipEmpty:n},i={input:r,delimiter:s},o=se.runKernel(B1,i,a);return{indices:o[0],values:o[1],shape:o[2]}}var nGe=ie({stringSplit_:tGe});function rGe(e,t){let n=K(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let s={input:n};return se.runKernel(W1,s,r)}var sGe=ie({stringToHashBucketFast_:rGe});function aGe(e,t,n,r=!0){let s=K(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return se.runKernel(P1,{x:s},a)}var iGe=ie({staticRegexReplace_:aGe}),fY={fft:ow,ifft:Hg,rfft:lw,irfft:$N},mY={hammingWindow:FUe,hannWindow:oY,frame:lY,stft:PUe},Bi={flipLeftRight:VUe,grayscaleToRGB:GUe,resizeNearestNeighbor:hY,resizeBilinear:pY,rgbToGrayscale:HUe,rotateWithOffset:KUe,cropAndResize:BUe,nonMaxSuppression:YUe,nonMaxSuppressionAsync:s6e,nonMaxSuppressionWithScore:i6e,nonMaxSuppressionWithScoreAsync:l6e,nonMaxSuppressionPadded:c6e,nonMaxSuppressionPaddedAsync:p6e,threshold:y6e,transform:b6e},GO={bandPart:w6e,gramSchmidt:I6e,qr:C6e},gY={absoluteDifference:$6e,computeWeightedLoss:Qu,cosineDistance:_6e,hingeLoss:R6e,huberLoss:F6e,logLoss:M6e,meanSquaredError:P6e,sigmoidCrossEntropy:W6e,softmaxCrossEntropy:G6e},yY={sparseFillEmptyRows:H6e,sparseReshape:K6e,sparseSegmentMean:Y6e,sparseSegmentSum:J6e},xY={stringNGrams:eGe,stringSplit:nGe,stringToHashBucketFast:sGe,staticRegexReplace:iGe},Pe={};Kt(Pe,{Serializable:()=>bY,SerializationMap:()=>vY,getRegisteredName:()=>lGe,registerClass:()=>wY});var oGe=new Map,AA=new Map,bY=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},vY=class ug{constructor(){this.classNameMap={}}static getMap(){return ug.instance==null&&(ug.instance=new ug),ug.instance}static register(t){ug.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function wY(e,t,n){Z(e.className!=null,()=>"Class being registered does not have the static className property defined."),Z(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),Z(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);let r=n,s=t+">"+r;return vY.register(e),oGe.set(s,e),AA.set(e,s),e}function lGe(e){return AA.has(e)?AA.get(e):e.className}var ec=class extends bY{minimize(e,t=!1,n){let{value:r,grads:s}=this.computeGradients(e,n);if(n!=null){let a=n.map(i=>({name:i.name,tensor:s[i.name]}));this.applyGradients(a)}else this.applyGradients(s);return qt(s),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return wX(e,t)}dispose(){this.iterations_!=null&&qt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Tt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(ec,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var jO=class extends ec{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=se.registeredVariables[t],s=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:ce(()=>gn(r).variable(s))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:ce(()=>gn(r).variable(s))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;ce(()=>{let l=Ae(oe(i,this.rho),oe(Zn(a),1-this.rho)),u=oe(ht(Ds(Ae(o,this.epsilon)),Ds(Ae(i,this.epsilon))),a),c=Ae(oe(o,this.rho),oe(Zn(u),1-this.rho));i.assign(l),o.assign(c);let d=Ae(oe(u,-this.learningRate),r);r.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(qt(this.accumulatedGrads.map(e=>e.variable)),qt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},HO=class extends ec{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=se.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:ce(()=>wi(r.shape,this.initialAccumulatorValue).variable(!1))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let a=this.accumulatedGrads[n].variable;ce(()=>{let i=Ae(a,Zn(s));a.assign(i);let o=Ae(oe(ht(s,Ds(Ae(i,se.backend.epsilon()))),-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&qt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},qO=class extends ec{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ce(()=>{this.accBeta1=Tt(t).variable(),this.accBeta2=Tt(n).variable()}),r==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ce(()=>{let n=at(1,this.accBeta1),r=at(1,this.accBeta2);t.forEach((s,a)=>{let i=se.registeredVariables[s],o=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:ce(()=>gn(i).variable(o))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${s}/v`,variable:ce(()=>gn(i).variable(o))});let l=Array.isArray(e)?e[a].tensor:e[s];if(l==null)return;let u=this.accumulatedFirstMoment[a].variable,c=this.accumulatedSecondMoment[a].variable,d=Ae(oe(u,this.beta1),oe(l,1-this.beta1)),p=Ae(oe(c,this.beta2),oe(Zn(l),1-this.beta2)),h=ht(d,n),m=ht(p,r);u.assign(d),c.assign(p);let g=Ae(oe(ht(h,Ae(Ds(m),this.epsilon)),-this.learningRate),i);i.assign(g)}),this.accBeta1.assign(oe(this.accBeta1,this.beta1)),this.accBeta2.assign(oe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&qt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&qt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),ce(()=>{this.accBeta1.assign(ru(this.beta1,this.iterations_+1)),this.accBeta2.assign(ru(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},KO=class extends ec{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ce(()=>{this.iteration=Tt(0).variable(),this.accBeta1=Tt(t).variable()}),r==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ce(()=>{let n=at(1,this.accBeta1),r=ht(-this.learningRate,Ae(oe(this.iteration,this.decay),1));t.forEach((s,a)=>{let i=se.registeredVariables[s],o=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:gn(i).variable(o)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${s}/v`,variable:gn(i).variable(o)});let l=Array.isArray(e)?e[a].tensor:e[s];if(l==null)return;let u=this.accumulatedFirstMoment[a].variable,c=this.accumulatedWeightedInfNorm[a].variable,d=Ae(oe(u,this.beta1),oe(l,1-this.beta1)),p=oe(c,this.beta2),h=Hr(l),m=cu(p,h);u.assign(d),c.assign(m);let g=Ae(oe(ht(r,n),ht(d,Ae(m,this.epsilon))),i);i.assign(g)}),this.iteration.assign(Ae(this.iteration,1)),this.accBeta1.assign(oe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&qt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&qt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},BN=class extends ec{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let s=se.registeredVariables[t];ce(()=>{let a=Ae(oe(this.c,r),s);s.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=cs(Tt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},XO=class extends BN{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Tt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=se.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:ce(()=>gn(r).variable(!1))});let s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];a!=null&&ce(()=>{let i,o=Ae(oe(this.m,s),a);this.useNesterov?i=Ae(oe(this.c,Ae(a,oe(o,this.m))),r):i=Ae(oe(this.c,o),r),s.assign(o),r.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&qt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},YO=class extends ec{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,r==null&&(this.epsilon=se.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=se.registeredVariables[t],s=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:ce(()=>gn(r).variable(s))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:ce(()=>gn(r).variable(s))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:ce(()=>gn(r).variable(s))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;ce(()=>{let l=Ae(oe(i,this.decay),oe(Zn(a),1-this.decay));if(this.centered){let u=this.accumulatedMeanGrads[n].variable,c=Ae(oe(u,this.decay),oe(a,1-this.decay)),d=ht(oe(a,this.learningRate),Ds(at(l,Ae(Zn(c),this.epsilon)))),p=Ae(oe(o,this.momentum),d);i.assign(l),u.assign(c),o.assign(p);let h=at(r,p);r.assign(h)}else{let u=Ae(oe(i,this.decay),oe(Zn(a),1-this.decay)),c=Ae(oe(o,this.momentum),ht(oe(a,this.learningRate),Ds(Ae(u,this.epsilon))));i.assign(u),o.assign(c);let d=at(r,c);r.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&qt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&qt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&qt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},uGe=[jO,HO,qO,KO,XO,YO,BN];function cGe(){for(let e of uGe)wY(e)}var qs={};Kt(qs,{CompositeArrayBuffer:()=>Yu,browserFiles:()=>yGe,browserHTTPRequest:()=>IGe,concatenateArrayBuffers:()=>Z4e,copyModel:()=>bze,decodeWeights:()=>qK,decodeWeightsStream:()=>XK,encodeWeights:()=>j4e,fromMemory:()=>CGe,fromMemorySync:()=>NY,getLoadHandlers:()=>aze,getModelArtifactsForJSON:()=>P3,getModelArtifactsForJSONSync:()=>ZK,getModelArtifactsInfoForJSON:()=>K1,getSaveHandlers:()=>sze,getWeightSpecs:()=>CA,http:()=>JO,isHTTPScheme:()=>DA,listModels:()=>yze,loadWeights:()=>bGe,moveModel:()=>vze,registerLoadRouter:()=>rze,registerSaveRouter:()=>nze,removeModel:()=>xze,weightsLoaderFactory:()=>IY,withSaveHandler:()=>NGe,withSaveHandlerSync:()=>TGe});var dGe="model",pGe=".json",hGe=".weights.bin";function wU(e){return new Promise(t=>setTimeout(t)).then(e)}var TI=class RA{constructor(t){if(!xe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(RA.URL_SCHEME)&&(t=t.slice(RA.URL_SCHEME.length)),(t==null||t.length===0)&&(t=dGe),this.modelJsonFileName=t+pGe,this.weightDataFileName=t+hGe}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=Yu.join(t.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let s=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],a=YK(t,s),i=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await wU(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await wU(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:K1(t)}}}};TI.URL_SCHEME="downloads://";var fGe=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=r=>{let s=JSON.parse(r.target.result),a=s.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}let i=P3(s,o=>this.loadWeights(o));e(i)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let a of e)t.push(...a.weights),n.push(...a.paths);let r=this.checkManifestAndWeightFiles(e),s=n.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(s).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((n,r)=>{let s=new FileReader;s.onload=a=>{let i=a.target.result;n(i)},s.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(s=>xU(s.name)),r={};for(let s of e)s.paths.forEach(a=>{let i=xU(a);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[a]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},mGe=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(TI.URL_SCHEME)?gGe(e.slice(TI.URL_SCHEME.length)):null;Xi.registerSaveRouter(mGe);function gGe(e="model"){return new TI(e)}function yGe(e){return new fGe(e)}function kU(e,t,n,r){i(e),n=n??0,r=r??1,o(n,r);let s=0,a=l=>(l.then(u=>{let c=n+ ++s/e.length*(r-n);return t(c),u}),l);function i(l){Z(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,u){Z(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),Z(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),Z(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(a))}async function kY(e,t){t==null&&(t={});let n=t.fetchFunc==null?xe().platform.fetch:t.fetchFunc,r=e.map(a=>n(a,t.requestInit,{isBinary:!0})),s=(t.onProgress==null?await Promise.all(r):await kU(r,t.onProgress,0,.5)).map(a=>a.arrayBuffer());return t.onProgress==null?await Promise.all(s):await kU(s,t.onProgress,.5,1)}function xGe(e,t){var n;let r=t.fetchFunc==null?xe().platform.fetch:t.fetchFunc,s=0,a;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;s<e.length;){a||(a=(await r(e[s],t.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:u}=await a.read();if(l){s++,a=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,s/e.length);continue}i.enqueue(u);return}i.close()}})}async function bGe(e,t="",n,r){return IY(s=>kY(s,{requestInit:r}))(e,t,n)}function IY(e){return async(t,n="",r)=>{let s=t.map(()=>!1),a={},i=r!=null?r.map(()=>!1):[],o=[];if(t.forEach((h,m)=>{let g=0;h.weights.forEach(y=>{let b="quantization"in y?y.quantization.dtype:y.dtype,v=gh[b]*Gn(y.shape),k=()=>{s[m]=!0,a[m]==null&&(a[m]=[]),a[m].push({manifestEntry:y,groupOffset:g,sizeBytes:v})};r!=null?r.forEach((I,S)=>{I===y.name&&(k(),i[S]=!0)}):k(),o.push(y.name),g+=v})}),!i.every(h=>h)){let h=r.filter((m,g)=>!i[g]);throw new Error(`Could not find weights in manifest with names: ${h.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=s.reduce((h,m,g)=>(m&&h.push(g),h),[]),u=[];l.forEach(h=>{t[h].paths.forEach(m=>{let g=n+(n.endsWith("/")?"":"/")+m;u.push(g)})});let c=await e(u),d={},p=0;return l.forEach(h=>{let m=t[h].paths.length,g=new Yu(c.slice(p,p+m));a[h].forEach(y=>{let b=g.slice(y.groupOffset,y.groupOffset+y.sizeBytes),v=qK(b,[y.manifestEntry]);for(let k in v)d[k]=v[k]}),p+=m}),d}}var vGe="application/octet-stream",wGe="application/json",ZO=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(Z(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=xe().platform.fetch,Z(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Z(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=YK(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:wGe}),"model.json"),e.weightData!=null){let a=Yu.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:vGe}),"model.weights.bin")}let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:K1(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return P3(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=CA(e.weightsManifest),r=()=>xGe(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:r})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=kGe(t),s=this.weightPathPrefix||n,a=[],i=[];for(let o of e)for(let l of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):a.push(s+l+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){let t=await this.getWeightUrls(e),n=CA(e),r=await kY(t,this.loadOptions);return[n,r]}};ZO.URL_SCHEME_REGEX=/^https?:\/\//;function kGe(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}function DA(e){return e.match(ZO.URL_SCHEME_REGEX)!=null}var SY=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>DA(r)):n=DA(e),n)return JO(e,t)}return null};Xi.registerSaveRouter(SY);Xi.registerLoadRouter(SY);function JO(e,t){return new ZO(e,t)}function IGe(e,t){return JO(e,t)}var BE=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},CY=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},SGe=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function CGe(e,t,n,r){let s=arguments;return new SGe(NY(...s))}function NY(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new BE(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new BE({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new BE({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function NGe(e){return new CY(e)}function TGe(e){return new CY(e)}var TY={};Kt(TY,{confusionMatrix:()=>EGe});function $Ge(e,t,n){let r=K(e,"labels","confusionMatrix"),s=K(t,"predictions","confusionMatrix");Z(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),Z(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),Z(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),Z(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),Z(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let a=Ug(Ke(r,"int32"),n),i=Ug(Ke(s,"int32"),n),o=en(a),l=Qt(o,i);return Ke(l,"int32")}var EGe=ie({confusionMatrix_:$Ge}),uw={};Kt(uw,{draw:()=>LGe,fromPixels:()=>PGe,fromPixelsAsync:()=>FGe,toPixels:()=>MGe});var yp,IU=!1;function $Y(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)a=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(Ev(II,se.backendName)!=null){let p={pixels:e},h={numChannels:t};return se.runKernel(II,p,h)}let[l,u]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height],c;if(i)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(a||s||o){if(yp==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")yp=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else yp=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});yp.canvas.width=l,yp.canvas.height=u,yp.drawImage(e,0,0,l,u),c=yp.getImageData(0,0,l,u).data}let d;if(t===4)d=new Int32Array(c);else{let p=l*u;d=new Int32Array(p*t);for(let h=0;h<p;h++)for(let m=0;m<t;++m)d[h*t+m]=c[h*4+m]}return _N(d,[u,l,t],"int32")}function _Ge(e){return e!=null&&e.data instanceof Uint8Array}function AGe(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function RGe(e){return e!=null&&e.width!==0&&e.height!==0}function DGe(e){return AGe()&&!(e instanceof ImageBitmap)&&RGe(e)&&!_Ge(e)}async function FGe(e,t=3){let n=null;if(xe().getBool("WRAP_TO_IMAGEBITMAP")&&DGe(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===e.width&&r.height===e.height?n=r:n=e}else n=e;return $Y(n,t)}function EY(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function OGe(e){let t=(e==null?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function MGe(e,t){let n=K(e,"img","toPixels");if(!(e instanceof Zt)){let u=n;n=Ke(u,"int32"),u.dispose()}EY(n);let[r,s]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let u=0;u<r*s;++u){let c=[0,0,0,255];for(let p=0;p<a;p++){let h=i[u*a+p];if(n.dtype==="float32"){if(h<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h}.`)}else if(n.dtype==="int32"&&(h<0||h>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h}.`);a===1?(c[0]=h*o,c[1]=h*o,c[2]=h*o):c[p]=h*o}let d=u*4;l[d+0]=Math.round(c[0]),l[d+1]=Math.round(c[1]),l[d+2]=Math.round(c[2]),l[d+3]=Math.round(c[3])}if(t!=null){IU||Ev(YC,se.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),IU=!0),t.width=s,t.height=r;let u=t.getContext("2d"),c=new ImageData(l,s,r);u.putImageData(c,0,0)}return n!==e&&n.dispose(),l}function LGe(e,t,n){let r=K(e,"img","draw");if(!(e instanceof Zt)){let i=r;r=Ke(i,"int32"),i.dispose()}EY(r),OGe(n==null?void 0:n.imageOptions);let s={image:r},a={canvas:t,options:n};se.runKernel(YC,s,a)}var PGe=ie({fromPixels_:$Y}),QO={};Kt(QO,{prepareAndValidate:()=>_Y});function _Y(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(Gn(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let s=t.shape,a=s[s.length-1],i=1;for(let d=0;d<s.length-1;++d)i*=s[d];let o=e.shape,l=s.slice();l.pop();let u=1;for(let d=a;d<n;++d)u*=o[d],l.push(o[d]);let c=[...Ny(e.shape).map(d=>d/u),1].slice(0,a);return[l,i,u,c]}var fs={};Kt(fs,{assertParamsValid:()=>BGe,computeFlatOffset:()=>jGe,computeOutShape:()=>VGe,getNormalizedAxes:()=>UGe,isSliceContinous:()=>GGe,maskToAxes:()=>WGe,parseSliceParams:()=>zY,sliceInfo:()=>HGe,startForAxis:()=>LY,startIndicesWithElidedDims:()=>FY,stopForAxis:()=>PY,stopIndicesWithElidedDims:()=>OY,stridesForAxis:()=>MY,stridesWithElidedDims:()=>AY});var FA=-2,zGe=-1;function BGe(e,t,n){let r=e.shape.length;Z(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),Z(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)Z(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function WGe(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function VGe(e,t,n){let r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function AY(e,t,n,r){let s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function RY(e,t,n){return n<=e?n:n-(t-1)}function DY(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function UGe(e,t,n,r,s,a,i,o,l){let u=e.length,c=new Array(u),d=new Array(u),p=new Array(u);if(t.length&&n>0){let h=t[0],m=n+1;c=FY(i,h,m,r,e),d=OY(o,h,m,s,e),p=AY(a,h,m,e)}else for(let h=0;h<u;h++)c[h]=LY(i,r,a,e,h,l),d[h]=PY(o,s,a,e,h,l),p[h]=MY(a,h,l);return{begin:c,end:d,strides:p}}function FY(e,t,n,r,s){let a=[...s],i=DY(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{let l=RY(t,n,o),u=r[l];e&1<<l&&(u=0),a[o]=u}return a}function OY(e,t,n,r,s){let a=[...s],i=DY(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{let l=RY(t,n,o),u=r[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),a[o]=u}for(let o=0;o<a.length;o++){let l=s[o];a[o]<0&&(a[o]+=l),a[o]=Tv(0,a[o],s[o])}return a}function MY(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function LY(e,t,n,r,s,a){let i=t[s],o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=r[s];return i<0&&(i+=l),i=Tv(0,i,l-1),i}function PY(e,t,n,r,s,a){let i=t[s],o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=r[s];return i<0&&(i+=l),o>0?i=Tv(0,i,l):i=Tv(-1,i,l-1),i}function GGe(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function jGe(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function zY(e,t,n){let r,s=e.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(i=>{Z(i!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((i,o)=>i>=0?i:(Z(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,a]}function HGe(e,t,n,r,s,a,i,o,l){let u;if(r==null?(u=new Array(t.length),u.fill(1)):u=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let v=0;v<d.dims;v++)c&&1<<v&o&&d.numAddAxisAfterEllipsis++,1<<v&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);let p={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};qGe(d,p);let h=!0,m=!0,g=!0,y=[],b=[];for(let v=0;v<e.length;++v){if(p.strides[v]===0)throw Error(`strides[${v}] must be non-zero`);let k=!!(p.shrinkAxisMask&1<<v),I=e[v];if(I===-1){y.push(k?1:-1);continue}let S=[p.beginMask&1<<v,p.endMask&1<<v],N=[p.strides[v]>0?0:-1,p.strides[v]>0?I:I-1];if(k&&p.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&p.strides[v]===1;let T=!!(p.beginMask&1<<v&&p.endMask&1<<v);if(p.beginValid&&p.endValid){if(k){let $=p.begin[v]<0?I+p.begin[v]:p.begin[v];if(p.begin[v]=$,p.end[v]=p.begin[v]+1,$<0||$>=I)throw Error(`slice index ${p.begin[v]} of dimension ${v} out of bounds.`)}else p.begin[v]=SU(p.begin[v],0,p.strides[v],I,S,N),p.end[v]=SU(p.end[v],1,p.strides[v],I,S,N);let D=p.strides[v]===1&&p.begin[v]===0&&p.end[v]===I;h=h&&D,m=m&&(v===0&&p.strides[v]===1||D)}else h=h&&p.strides[v]===1&&T,m=m&&(v===0&&p.strides[v]===1||T);let A,R=!1;if(p.beginValid&&p.endValid?(A=p.end[v]-p.begin[v],R=!0):k?(A=1,R=!0):T&&I>=0&&(p.strides[v]<0?A=-I:A=I,R=!0),R){let D;A===0||A<0!=p.strides[v]<0?D=0:D=Math.trunc(A/p.strides[v])+(A%p.strides[v]!==0?1:0),y.push(D)}else y.push(-1)}for(let v=0;v<p.finalShapeGatherIndices.length;++v){let k=p.finalShapeGatherIndices[v];k>=0?b.push(y[k]):k===FA&&b.push(1)}return{finalShapeSparse:b.filter((v,k)=>p.finalShapeGatherIndices[k]!==FA),finalShape:b,isIdentity:h,sliceDim0:m,isSimpleSlice:g,begin:p.begin,end:p.end,strides:p.strides}}function qGe(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(FA),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(zGe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function SU(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{let i=e<0?r+e:e;return i<a[0]?a[0]:i>a[1]?a[1]:i}}var KGe="4.22.0",BY=class{static sgd(e){return new BN(e)}static momentum(e,t,n=!1){return new XO(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new YO(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new qO(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new jO(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new KO(e,t,n,r,s)}static adagrad(e,t=.1){return new HO(e,t)}},wp=BY,XGe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function eM(){return new Promise(e=>XGe(()=>e()))}var V={};Kt(V,{ERF_A1:()=>c5e,ERF_A2:()=>d5e,ERF_A3:()=>p5e,ERF_A4:()=>h5e,ERF_A5:()=>f5e,ERF_P:()=>u5e,PARALLELIZE_THRESHOLD:()=>tM,RowPartitionType:()=>Fl,SELU_SCALE:()=>VY,SELU_SCALEALPHA:()=>WY,applyActivation:()=>PN,assertAndGetBroadcastShape:()=>er,assertAxesAreInnerMostDims:()=>HBe,assertParamsConsistent:()=>YGe,assignToTypedArray:()=>v5e,axesAreInnerMostDims:()=>pO,calculateShapes:()=>XX,checkEinsumDimSizes:()=>N5e,checkPadOnDimRoundingMode:()=>Oa,combineLocations:()=>gX,combineRaggedTensorToTensorShapes:()=>JGe,complexWithEvenIndex:()=>y5e,complexWithOddIndex:()=>x5e,computeConv2DInfo:()=>X1,computeConv3DInfo:()=>oX,computeDefaultPad:()=>K3,computeDilation2DInfo:()=>Gze,computeOptimalWindowSize:()=>n5e,computeOutAndReduceShapes:()=>yX,computeOutShape:()=>ZGe,computePool2DInfo:()=>iX,computePool3DInfo:()=>jze,convertConv2DDataFormat:()=>lX,decodeEinsumEquation:()=>S5e,eitherStridesOrDilationsAreOne:()=>uu,expandShapeToKeepDim:()=>wh,exponent:()=>k5e,exponents:()=>w5e,fromStringArrayToUint8:()=>q5e,fromUint8ToStringArray:()=>H5e,getAxesPermutation:()=>xX,getBroadcastDims:()=>fX,getComplexWithIndex:()=>b5e,getEinsumComputePath:()=>T5e,getEinsumPermutation:()=>C5e,getFusedBiasGradient:()=>LN,getFusedDyActivation:()=>MN,getImageCenter:()=>r5e,getInnerMostAxes:()=>qBe,getPermuted:()=>a5e,getRaggedRank:()=>e5e,getReductionAxes:()=>Qr,getReshaped:()=>s5e,getReshapedPermuted:()=>i5e,getRowPartitionTypesHelper:()=>QGe,getSliceBeginCoords:()=>o5e,getSliceSize:()=>l5e,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>A5e,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>R5e,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>D5e,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>M5e,getSparseReshapeInputOutputMismatchErrorMessage:()=>P5e,getSparseReshapeInputOutputMultipleErrorMessage:()=>L5e,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>F5e,getSparseReshapeNegativeOutputDimErrorMessage:()=>O5e,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>V5e,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>z5e,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>B5e,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>W5e,getUndoAxesPermutation:()=>hO,isIdentityPermutation:()=>$5e,log:()=>n4e,mergeRealAndImagArrays:()=>m5e,prepareAndValidate:()=>_Y,prepareSplitSize:()=>_5e,segment_util:()=>UY,shouldFuse:()=>zN,slice_util:()=>fs,splitRealAndImagArrays:()=>g5e,stridesOrDilationsArePositive:()=>vh,tupleValuesAreOne:()=>id,upcastType:()=>Ki,validateDefaultValueShape:()=>t5e,validateInput:()=>RN,validateUpdateShape:()=>OO,warn:()=>Dc});function YGe(e,t){let n=e[0].length;e.forEach((s,a)=>{Z(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),Z(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((s,a)=>{for(let i=0;i<n;i++)Z(i===t||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function ZGe(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var Fl;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(Fl||(Fl={}));function JGe(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){let a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function QGe(e){let t={FIRST_DIM_SIZE:Fl.FIRST_DIM_SIZE,VALUE_ROWIDS:Fl.VALUE_ROWIDS,ROW_LENGTHS:Fl.ROW_LENGTHS,ROW_SPLITS:Fl.ROW_SPLITS,ROW_LIMITS:Fl.ROW_LIMITS,ROW_STARTS:Fl.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function e5e(e){return e.length===0?0:e[0]===Fl.FIRST_DIM_SIZE?e.length-1:e.length}function t5e(e,t){if(e==null||t==null)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){let a=e[s],i=t[s+1];if(a>=0&&i>=0&&a!==1&&a!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${a} but ragged tensor input.flatValues.shape[${s-e.length}] = ${i}`)}}var tM=30;function n5e(e){return e<=tM?e:kI(e,Math.floor(Math.sqrt(e)))}function r5e(e,t,n){let r=n*(typeof e=="number"?e:e[0]),s=t*(typeof e=="number"?e:e[1]);return[r,s]}function s5e(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);let a=t.length;for(let i=0;i<a;++i)s=s.concat([e[i+1]/t[i],t[i]]);s=s.concat(e.slice(a+1))}return s}function a5e(e,t,n=!0){let r=[];if(n){r.push(t);for(let s=t+1;s<e;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{let s=[],a=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?a.push(i):s.push(i);r.push(...s),r.push(0),r.push(...a)}return r}function i5e(e,t,n,r=!0){let s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function o5e(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function l5e(e,t,n){let r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}var WY=1.7580993408473768,VY=1.0507009873554805,u5e=.3275911,c5e=.254829592,d5e=-.284496736,p5e=1.421413741,h5e=-1.453152027,f5e=1.061405429;function m5e(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function g5e(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function y5e(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function x5e(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function b5e(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function v5e(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function w5e(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){let a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function k5e(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}var WE="->",I5e=/->/g,CU=",",NU="...";function S5e(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(I5e,"").length)/WE.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${WE}").`);let[r,s]=e.split(WE);Z(r.indexOf(NU)===-1,()=>`The ellipsis notation ("${NU}") is not supported yet.`);let a=r.split(CU),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let p=0;p<s.length;++p){let h=s[p];if(!a.some(m=>m.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);o.indexOf(h)===-1&&o.push(h)}for(let p=0;p<r.length;++p){let h=r[p];o.indexOf(h)===-1&&h!==CU&&o.push(h)}let l=new Array(a.length);for(let p=0;p<i;++p){if(new Set(a[p].split("")).size!==a[p].length)throw new Error(`Found duplicate axes in input component ${a[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let h=0;h<a[p].length;++h)l[p].push(o.indexOf(a[p][h]))}let u=o.length,c=s.length,d=[];for(let p=c;p<u;++p)d.push(p);return{allDims:o,summedDims:d,idDims:l}}function C5e(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;let r=[];for(let s=0;s<e;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function N5e(e,t,n){let r=new Array(e);for(let s=0;s<n.length;++s){let a=n[s].shape;for(let i=0;i<t[s].length;++i)r[t[s][i]]===void 0?r[t[s][i]]=a[i]:Z(r[t[s][i]]===a[i],()=>`Expected dimension ${r[t[s][i]]} at axis ${i} of input shaped ${JSON.stringify(a)}, but got dimension ${a[i]}`)}}function T5e(e,t){let n=e,r=[],s=0;e.length===0&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);let a=[];for(let i=0;i<n.length;++i){let o=n[i],l=E5e(t,o);for(let u of l)a.indexOf(u)===-1&&(r[i].push(u),a.push(u))}return{path:n,steps:r}}function $5e(e){return e.every((t,n)=>t===n)}function E5e(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function _5e(e,t,n=0){let r=[];if(typeof t=="number")Z(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let s=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);Z(s<=1,()=>"There should be only one negative value in split array.");let a=t.indexOf(-1);if(a!==-1){let i=t.reduce((o,l)=>l>0?o+l:o);t[a]=e.shape[n]-i}Z(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function A5e(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function R5e(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function D5e(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function F5e(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function O5e(e,t){return`size ${e} must be non-negative, not ${t}`}function M5e(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function L5e(e,t){let n=Gn(e),r=Gn(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function P5e(e,t){let n=Gn(e),r=Gn(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function z5e(){return"segment ids must be >= 0"}function B5e(){return"segment ids are not increasing"}function W5e(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function V5e(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var UY={};Kt(UY,{collectGatherOpShapeInfo:()=>j5e,computeOutShape:()=>G5e,segOpComputeOptimalWindowSize:()=>U5e});function U5e(e,t){let n=!1,r;for(e<=tM?(r=e,n=!0):r=kI(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=kI(e,r+1);return r}function G5e(e,t,n){let r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function j5e(e,t,n,r){let s=t.shape.length,a=e.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let i=e.shape[n],o=[],l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<s;d++)o.push(t.shape[d]);for(let d=n+1;d<a;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function H5e(e){try{return e.map(t=>CI(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function q5e(e){return e.map(t=>H1(t))}var du={};Kt(du,{nonMaxSuppressionV3Impl:()=>uY,nonMaxSuppressionV4Impl:()=>cY,nonMaxSuppressionV5Impl:()=>dY,whereImpl:()=>JX});cGe();var GY={kernelName:Ty,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,pm(Ke(n,"float32"),-1))}}},K5e={kernelName:Gh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Zn(Ke(n,"float32")),s=Ds(at(Tt(1),r));return or(ht(e,s))}}}},X5e={kernelName:jh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Ds(at(Zn(Ke(n,"float32")),1));return ht(e,r)}}}},Y5e={kernelName:Ad,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=er(n.shape,r.shape);return{a:()=>{let a=e,i=Qr(n.shape,s);return i.length>0&&(a=yt(a,i)),ue(a,n.shape)},b:()=>{let a=e,i=Qr(r.shape,s);return i.length>0&&(a=yt(a,i)),ue(a,r.shape)}}}},Z5e={kernelName:Hh,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,s)=>{n[s]=()=>e.clone()}),n}},J5e={kernelName:_y,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>gn(n)}}},Q5e={kernelName:Ay,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>gn(n)}}},eje={kernelName:qh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ht(e,Ds(at(Tt(1),Zn(Ke(n,"float32")))))}}},tje={kernelName:Kh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Ds(Ae(Tt(1),Zn(Ke(n,"float32"))));return ht(e,r)}}}},nje={kernelName:Zh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=er(n.shape,r.shape);return{a:()=>{let a=Ae(Zn(n),Zn(r)),i=oe(e,ht(r,a)),o=Qr(n.shape,s);return o.length>0&&(i=yt(i,o)),ue(i,n.shape)},b:()=>{let a=Ae(Zn(n),Zn(r)),i=or(oe(e,ht(n,a))),o=Qr(r.shape,s);return o.length>0&&(i=yt(i,o)),ue(i,r.shape)}}}},rje={kernelName:Xh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ht(e,Ae(Zn(Ke(n,"float32")),1))}}},sje={kernelName:Yh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ht(e,at(Tt(1),Zn(Ke(n,"float32"))))}}};function aje(e,t,n,r,s,a){let i=K(e,"dy","avgPool3dGrad"),o=K(t,"input","avgPool3dGrad"),l=i,u=o,c=!1;o.rank===4&&(c=!0,l=ue(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=ue(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Z(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),Z(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Oa("avgPool3dGrad",s,a);let d={dy:l,input:u},p={filterSize:n,strides:r,pad:s,dimRoundingMode:a},h=se.runKernel(S1,d,p);return c?ue(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var ije=ie({avgPool3dGrad_:aje}),oje={kernelName:Ry,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>ije(e,r,s,a,i,o)}}};function lje(e,t,n,r,s){let a=K(e,"dy","avgPoolGrad"),i=K(t,"input","avgPoolGrad");Z(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,l=a,u=!1;i.rank===3&&(u=!0,o=ue(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=ue(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Z(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),Z(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let c={dy:l,input:o},d={filterSize:n,strides:r,pad:s},p=se.runKernel(I1,c,d);return u?ue(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var uje=ie({avgPoolGrad_:lje}),cje={kernelName:Jh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>uje(e,r,s,a,i)}}},dje={kernelName:Qh,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,s]=t,{transposeA:a,transposeB:i}=n;return!a&&!i?{a:()=>Qt(e,s,!1,!0),b:()=>Qt(r,e,!0,!1)}:!a&&i?{a:()=>Qt(e,s,!1,!1),b:()=>Qt(e,r,!0,!1)}:a&&!i?{a:()=>Qt(s,e,!1,!0),b:()=>Qt(r,e,!1,!1)}:{a:()=>Qt(s,e,!0,!0),b:()=>Qt(e,r,!0,!0)}}},pje={kernelName:Dy,gradFunc:(e,t,n)=>{let{blockShape:r,crops:s}=n;return{x:()=>sw(e,r,s)}}},hje={kernelName:EK,gradFunc:(e,t,n)=>{let r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let l=s.length-1;l>=0;l--)if(s[l]===a[l])i[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>yt(e,o,!0)}}},fje={kernelName:ef,gradFunc:e=>({x:()=>e.clone()})},mje={kernelName:tf,gradFunc:e=>({x:()=>gn(e)})},gje={kernelName:Rd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>Rs(Io(Ju(r,s),Md(r,a)),e,gn(e))}}},yje={kernelName:N1,inputsToSave:["x"],gradFunc:GY.gradFunc},xje={kernelName:My,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(o=>o.shape),{axis:s}=n,a=To(s,t[0].shape)[0],i=r.map(o=>o[a]);return Xa(e,i,a).map(o=>()=>o)}},bje={kernelName:nf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return Z(id(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>aO(r.shape,e,s,i,o,l),filter:()=>VO(r,e,s.shape,i,o,l)}}},vje={kernelName:rf,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>_a(e,s,a,i,o,1,l),filter:()=>VO(e,r,s.shape,a,i,o,l)}}};function wje(e,t,n,r,s){let a=e;e.rank===4&&(a=ue(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=ue(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Z(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),Z(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),Z(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),Z(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),Z(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return se.runKernel(Ly,o,l)}var kje=ie({conv3DBackpropFilter_:wje}),Ije={kernelName:sf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:a}=n;Z(id(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,o]=t;return{x:()=>pX(i.shape,e,o,s,a),filter:()=>kje(i,e,o.shape,s,a)}}},Sje={kernelName:af,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(or(CN(Ke(n,"float32"))),e)}}},Cje={kernelName:of,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(NN(Ke(n,"float32")),e)}}},Nje={kernelName:lf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{let o=xX([s],r.rank),l=hN(e,s,a,!i);return o!=null&&(l=en(l,o)),l}}}},Tje={kernelName:uf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=r??[1,1];Z(id(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,u]=t;return Z(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),Z(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),Z(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Z(uu(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),Oa("depthwiseConv2d",a,i),{x:()=>iY(l.shape,e,u,s,a,o,i),filter:()=>aY(l,e,u.shape,s,a,o,i)}}},$je={kernelName:cf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>se.runKernel(Pg,a,n),filter:()=>se.runKernel(zg,i,n)}}},Eje={kernelName:pf,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>se.runKernel(Vy,r)}}},_je={kernelName:hf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=oe(la(or(Zn(n))),2/Math.sqrt(Math.PI));return{x:()=>oe(e,r)}}},Aje={kernelName:ff,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,n)}}},Rje={kernelName:Gy,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>ue(e,n.shape)}}},Dje={kernelName:mf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,la(n))}}},Fje={kernelName:gf,gradFunc:e=>({x:()=>gn(e)})},Oje={kernelName:yf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=er(n.shape,r.shape);return{a:()=>{let a=ht(e,Ke(r,"float32")),i=Qr(n.shape,s);return i.length>0?ue(yt(a,i),n.shape):a},b:()=>{let a=oe(e,Ke(n,"float32")),i=Qr(r.shape,s);i.length>0&&(a=ue(yt(a,i),r.shape));let o=Zn(r);return or(ht(a,Ke(o,"float32")))}}}},Mje={kernelName:xf,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[s,a,i,o]=t,l=o??Tt(1),u=Qr(a.shape,s.shape),c=[];if(a.rank===1){for(let g=0;g<s.shape.length-1;++g)c.push(s.shape[g]);c.push(1)}let d=at(s,a),p=oe(e,l),h=IN(Ae(i,Tt(r))),m=oe(oe(oe(h,h),h),Tt(-.5));return{x:()=>a.rank===1?ue(oe(oe(e,xi(ue(h,[1,1,1,a.shape[0]]),c)),l),s.shape):ue(oe(oe(e,h),l),s.shape),mean:()=>{let g=oe(oe(h,Tt(-1)),p);return a.rank===1&&(g=yt(g,u)),ue(g,a.shape)},variance:()=>{let g=oe(oe(m,d),p);return a.rank===1&&(g=yt(g,u)),ue(g,a.shape)},scale:()=>{let g=oe(d,h),y=oe(e,g);return a.rank===1&&(y=yt(y,u)),ue(y,a.shape)},offset:()=>{let g=e;return a.rank===1&&(g=yt(g,u)),ue(g,a.shape)}}}},Lje={kernelName:Hy,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,s]=t,{axis:a,batchDims:i}=n,o=To(a,r.shape)[0],l=(u,c,d)=>()=>{let p=u.shape,h=c.size,m=p.slice(0,o),g=m.length,y=p.slice(a,p.length).slice(1),b=y.length,v=TU(0,g),k=TU(g+1,g+1+b),I=$U([m,[h],y]),S=ue(d,I),N=ue(c,[h]),T=$U([[g],v,k]),A=en(S,T),R=FN(A,N,u.shape[o]),D=hO(T);return R=en(R,D),R};if(i===1){let u=r.shape[0],c=r.split(u,0);return{x:()=>Yr(c.map((d,p)=>l(d,s.slice(p,1),e.slice(p,1))())).reshape(r.shape),indices:()=>s}}else return{x:l(r,s,e),indices:()=>s}}};function TU(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function $U(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var Pje={kernelName:bf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>gn(n),b:()=>gn(r)}}},zje={kernelName:vf,gradFunc:e=>({x:()=>Ke(e,"float32")})},Bje={kernelName:wf,gradFunc:e=>({x:()=>gn(e)})},Wje={kernelName:kf,gradFunc:e=>({x:()=>gn(e)})},Vje={kernelName:If,gradFunc:e=>({x:()=>gn(e)})},Uje={kernelName:Sf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:s}=n,a=Ma(r,0);return{x:()=>Rs(a,e,oe(e,s))}}},Gje={kernelName:Nf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ht(e,Ae(n,1))}}},jje={kernelName:Cf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ht(e,Ke(n,"float32"))}}},Hje={kernelName:AK,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n;return{logits:()=>{let a=la(r);return at(e,oe(yt(e,s,!0),a))}}}};function qje(e,t,n,r=5,s=1,a=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:r,bias:s,alpha:a,beta:i};return se.runKernel(tx,o,l)}var Kje=ie({localResponseNormalizationBackprop_:qje}),Xje={kernelName:Tf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>Kje(r,s,e,a,i,o,l)}}};function jY(e,t,n,r){return t.rank<n.rank&&(t=ue(t,wh(t.shape,r))),e.rank<n.rank&&(e=ue(e,wh(e.shape,r))),{x:()=>oe(e,Ke(Ci(n,t),e.dtype))}}var EU={kernelName:$f,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:s}=r,a=t[0],i=t[1],o=To(s,a.shape),l=jY(e,i,a,o);return{x:()=>l.x()}}},Yje={kernelName:Ef,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>oe(e,Ke(Ju(n,r),"float32")),b:()=>oe(e,Ke(Vg(n,r),"float32"))}}};function Zje(e,t,n,r,s,a,i){let o=K(e,"dy","maxPool3dGrad"),l=K(t,"input","maxPool3dGrad"),u=K(n,"output","maxPool3dGrad"),c=o,d=l,p=u,h=!1;l.rank===4&&(h=!0,c=ue(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=ue(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=ue(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Z(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),Z(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),Z(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),Oa("maxPool3dGrad",a,i);let m={dy:c,input:d,output:p},g={filterSize:r,strides:s,pad:a,dimRoundingMode:i},y=se.runKernel(A1,m,g);return h?ue(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}var Jje=ie({maxPool3dGrad_:Zje}),Qje={kernelName:nx,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>Jje(e,r,s,a,i,o,l)}}};function eHe(e,t,n,r,s,a,i){let o=K(e,"dy","maxPoolGrad"),l=K(t,"input","maxPoolGrad"),u=K(n,"output","maxPoolGrad");Z(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),Z(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),Z(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Oa("maxPoolGrad",a,i);let c={dy:o,input:l,output:u},d={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return se.runKernel(_1,c,d)}var tHe=ie({maxPoolGrad_:eHe}),nHe={kernelName:_f,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>tHe(e,r,s,a,i,o)}}},rHe={kernelName:Af,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,a=To(s,r.shape),i=yX(r.shape,a)[1],o=Gn(i);return{x:()=>{let l=r.shape.slice();a.forEach(c=>{l[c]=1});let u=ue(e,l);return ht(oe(u,Ha(r.shape,"float32")),o)}}}},sHe={kernelName:Rf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:s}=r,[a,i]=t,o=To(s,a.shape),l=jY(e,i,a,o);return{x:()=>l.x()}}},aHe={kernelName:Df,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>oe(e,Ke(Md(n,r),"float32")),b:()=>oe(e,Ke(Ma(n,r),"float32"))}}},iHe={kernelName:Ff,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>hn(e,a,r.shape)}}},oHe={kernelName:Of,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=er(n.shape,r.shape);return{a:()=>{let a=Qr(n.shape,s);return a.length>0?ue(yt(e,a),n.shape):e},b:()=>{let a=oe(e,or(Rx(ht(n,r)))),i=Qr(r.shape,s);return i.length>0?ue(yt(a,i),r.shape):a}}}},lHe={kernelName:Mf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=er(n.shape,r.shape);return{a:()=>{let a=oe(e,Ke(r,"float32")),i=Qr(n.shape,s);return i.length>0?ue(yt(a,i),n.shape):a},b:()=>{let a=oe(e,Ke(n,"float32")),i=Qr(r.shape,s);return i.length>0?ue(yt(a,i),r.shape):a}}}},uHe={kernelName:sx,gradFunc:e=>({x:()=>or(e)})},cHe={kernelName:Lf,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>Cr(n.shape,"float32")}}},dHe={kernelName:ux,gradFunc:e=>({x:()=>gn(e)})},pHe={kernelName:cx,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return Fr(e,r).map(s=>()=>s)}},_U={kernelName:Pf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>hn(e,a,r.shape)}}},hHe={kernelName:zf,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,s]=t,a=n,i=r,o=er(a.shape,i.shape);return{a:()=>{let l=Ke(i,"float32"),u=oe(e,oe(l,ru(a,at(l,Tt(1))))),c=Qr(a.shape,o);return c.length>0&&(u=yt(u,c)),ue(u,a.shape)},b:()=>{let l=Ma(a,0),u=Rs(l,Ni(a),gn(a)),c=oe(e,oe(s,u)),d=Qr(i.shape,o);return d.length>0&&(c=yt(c,d)),ue(c,i.shape)}}}},fHe={kernelName:Bf,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,s=Ma(n,0);return{x:()=>Rs(s,e,oe(e,r)),alpha:()=>{let a=Rs(s,gn(e),oe(e,n)),i=Qr(r.shape,e.shape);return i.length>0&&(a=yt(a,i)),ue(a,r.shape)}}}};function mHe(e,t,n){let r=e.shape.slice();r[n]=1;let s=ue(t,r),a=Ov(e,n,!0,!1),i=Ov(e,n,!0,!0),o=oe(a,i);return oe(s,o)}function gHe(e,t,n){let r=e.shape.length,s=r-n.length,a=V.getAxesPermutation(n,r),i=e;a!=null&&(i=en(e,a));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce((d,p)=>d*p,1);o.push(l);let u=i.reshape(o),c=mHe(u,t,s);if(c=c.reshape(i.shape),a!=null){let d=V.getUndoAxesPermutation(a);c=en(c,d)}return c}var yHe={kernelName:Wf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,a=[];return s==null?a=r.shape.map((i,o)=>o):typeof s=="number"?a=[s]:a=s,{x:()=>gHe(r,e,a)}}},xHe={kernelName:df,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=er(n.shape,r.shape);return{a:()=>{let a=ht(e,Ke(r,"float32")),i=Qr(n.shape,s);return i.length>0?ue(yt(a,i),n.shape):a},b:()=>{let a=oe(e,Ke(n,"float32")),i=Qr(r.shape,s);i.length>0&&(a=ue(yt(a,i),r.shape));let o=Zn(r);return or(ht(a,Ke(o,"float32")))}}}},bHe={kernelName:Vf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ht(e,or(Zn(n)))}}},vHe={kernelName:Hf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=oe(Md(n,6),pm(n));return{x:()=>oe(e,Ke(r,"float32"))}}},wHe={kernelName:Uf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,Ke(pm(n),"float32"))}}},kHe={kernelName:dx,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ue(e,n.shape)}}},IHe={kernelName:jf,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>se.runKernel(hx,s,n)}}},SHe={kernelName:Gf,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>se.runKernel(px,s,n)}}},CHe={kernelName:qf,gradFunc:(e,t,n)=>{let{dims:r}=n,s=To(r,e.shape);return{x:()=>Yi(e,s)}}},NHe={kernelName:Kf,gradFunc:e=>({x:()=>gn(e)})},THe={kernelName:Xf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>or(ht(e,oe(ru(n,1.5),2)))}}},$He={kernelName:yx,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>Ke(gn(n),"float32"),t:()=>oe(e,Ke(n,e.dtype)),e:()=>oe(e,Ke(nw(n),e.dtype))}}},EHe={kernelName:Yf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Ma(n,Tt(0)),s=Tt(WY),a=Tt(VY),i=oe(e,a),o=oe(oe(e,s),la(Ke(n,"float32")));return Rs(r,i,o)}}}},_He={kernelName:em,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,oe(n,at(Tt(1),n)))}}},AHe={kernelName:Qf,gradFunc:e=>({x:()=>gn(e)})},RHe={kernelName:Zf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(Z1(Ke(n,"float32")),e)}}},DHe={kernelName:Jf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(pN(Ke(n,"float32")),e)}}},FHe={kernelName:xx,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=zY(r,s,a),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>ml(e,u)}}},OHe={kernelName:sm,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:s}=n,a=!0,i=oe(e,r);return{logits:()=>at(i,oe(yt(i,[s],a),r))}}},MHe={kernelName:tm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,vo(n))}}},AU={kernelName:bx,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:s}=n;return{x:()=>Y1(e,r,s)}}},RU={kernelName:vx,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>Jn(e,r)}}},LHe={kernelName:nm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ht(e,oe(Ds(Ke(n,"float32")),2))}}},PHe={kernelName:L1,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,oe(Ke(n,"float32"),2))}}},zHe={kernelName:am,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Tt(2);return{a:()=>oe(e,oe(s,at(n,r))),b:()=>oe(e,oe(s,at(r,n)))}}},BHe={kernelName:Fd,gradFunc:e=>({x:()=>gn(e)})},WHe={kernelName:im,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=er(n.shape,r.shape);return{a:()=>{let a=e,i=Qr(n.shape,s);return i.length>0&&(a=yt(a,i)),ue(a,n.shape)},b:()=>{let a=e,i=Qr(r.shape,s);return i.length>0&&(a=yt(a,i)),ue(or(a),r.shape)}}}},VHe={kernelName:rm,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,s=r.shape.slice(),{axis:a}=n;To(a,r.shape).forEach(l=>{s[l]=1});let i=ue(e,s),o=oe(i,Ha(r.shape,"float32"));return{x:()=>o}}},UHe={kernelName:om,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ht(e,Zn(Z1(n)))}}},GHe={kernelName:lm,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(at(Tt(1),Zn(n)),e)}}},jHe={kernelName:Dd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:s}=n;return{x:()=>{let a=gn(r);if(r.rank===1)for(let i=0;i<s[0];++i)a=Ae(a,hn(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)a=Ae(a,hn(e,[i*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)for(let l=0;l<s[2];++l)a=Ae(a,hn(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)for(let l=0;l<s[2];++l)for(let u=0;u<s[3];++u)a=Ae(a,hn(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return a}}}},HHe={kernelName:Ru,gradFunc:(e,t,n)=>{let r=n,{perm:s}=r,a=hO(s);return{x:()=>en(e,a)}}},qHe={kernelName:Nx,gradFunc:(e,t,n)=>{let r=n,{axis:s}=r;return{value:()=>Yr(e,s)}}},KHe={kernelName:U1,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>XHe(e,n)}}};function XHe(e,t){let n=cu(t,gn(t)),r=Dx(e,n),s=Ju(t,Tt(0,"int32")),a=r.rank-s.rank;for(let o=0;o<a;++o)s=$s(s,o+1);s=Io(s,Ha(r.shape,"bool"));let i=gn(r);return Rs(s,r,i)}var YHe={kernelName:Tx,gradFunc:e=>({x:()=>gn(e)})},ZHe=[GY,K5e,X5e,Y5e,Z5e,J5e,Q5e,eje,tje,nje,rje,sje,oje,cje,dje,pje,hje,fje,mje,gje,yje,xje,vje,bje,Ije,Sje,Cje,Nje,Tje,$je,xHe,Eje,_je,Aje,Rje,Dje,Oje,Fje,Mje,Lje,Pje,zje,Bje,Wje,Vje,Uje,Gje,jje,Hje,Xje,EU,EU,Yje,Qje,nHe,rHe,sHe,aHe,iHe,oHe,lHe,uHe,cHe,dHe,pHe,_U,_U,hHe,fHe,yHe,bHe,vHe,wHe,kHe,IHe,SHe,CHe,NHe,THe,$He,EHe,_He,AHe,RHe,DHe,FHe,OHe,MHe,AU,AU,RU,RU,LHe,zHe,PHe,BHe,WHe,VHe,UHe,GHe,jHe,HHe,qHe,KHe,YHe];for(let e of ZHe)RK(e);De().prototype.abs=function(){return this.throwIfDisposed(),Hr(this)};De().prototype.acos=function(){return this.throwIfDisposed(),B3(this)};De().prototype.acosh=function(){return this.throwIfDisposed(),W3(this)};De().prototype.add=function(e){return this.throwIfDisposed(),Ae(this,e)};De().prototype.all=function(e,t){return this.throwIfDisposed(),uN(this,e,t)};De().prototype.any=function(e,t){return this.throwIfDisposed(),Rv(this,e,t)};De().prototype.argMax=function(e){return this.throwIfDisposed(),bh(this,e)};De().prototype.argMin=function(e){return this.throwIfDisposed(),V3(this,e)};De().prototype.asScalar=function(){return this.throwIfDisposed(),Z(this.size===1,()=>"The array must have only 1 element."),ue(this,[])};De().prototype.asType=function(e){return this.throwIfDisposed(),Ke(this,e)};De().prototype.as1D=function(){return this.throwIfDisposed(),ue(this,[this.size])};De().prototype.as2D=function(e,t){return this.throwIfDisposed(),ue(this,[e,t])};De().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),ue(this,[e,t,n])};De().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),ue(this,[e,t,n,r])};De().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),ue(this,[e,t,n,r,s])};De().prototype.asin=function(){return this.throwIfDisposed(),U3(this)};De().prototype.asinh=function(){return this.throwIfDisposed(),G3(this)};De().prototype.atan=function(){return this.throwIfDisposed(),j3(this)};De().prototype.atan2=function(e){return this.throwIfDisposed(),H3(this,e)};De().prototype.atanh=function(){return this.throwIfDisposed(),q3(this)};De().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Zu(this,e,t,n,r)};De().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Y1(this,e,t)};De().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),um(this,e,t,n,r,s)};De().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Gp(this,e)};De().prototype.cast=function(e){return this.throwIfDisposed(),Ke(this,e)};De().prototype.ceil=function(){return this.throwIfDisposed(),eO(this)};De().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),oa(this,e,t)};De().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Zt&&(e=[e]),Jn([this,...e],t)};De().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),cN(this,e,t,n,r,s,a)};De().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),dN(this,e,t,n,r,s)};De().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),_a(this,e,t,n,r,s,a)};De().prototype.cos=function(){return this.throwIfDisposed(),Z1(this)};De().prototype.cosh=function(){return this.throwIfDisposed(),pN(this)};De().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Ov(this,e,t,n)};De().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),hN(this,e,t,n)};De().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),lO(this,e,t)};De().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),cm(this,e,t,n,r,s,a)};De().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),uO(this,e,t,n,r,s)};De().prototype.divNoNan=function(e){return this.throwIfDisposed(),cO(this,e)};De().prototype.div=function(e){return this.throwIfDisposed(),ht(this,e)};De().prototype.dot=function(e){return this.throwIfDisposed(),dO(this,e)};De().prototype.elu=function(){return this.throwIfDisposed(),_x(this)};De().prototype.equal=function(e){return this.throwIfDisposed(),Ci(this,e)};De().prototype.erf=function(){return this.throwIfDisposed(),fN(this)};De().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),fO(this,e,t)};De().prototype.exp=function(){return this.throwIfDisposed(),la(this)};De().prototype.expandDims=function(e){return this.throwIfDisposed(),$s(this,e)};De().prototype.expm1=function(){return this.throwIfDisposed(),mO(this)};De().prototype.fft=function(){return this.throwIfDisposed(),ow(this)};De().prototype.flatten=function(){return this.throwIfDisposed(),ue(this,[this.size])};De().prototype.floor=function(){return this.throwIfDisposed(),Rx(this)};De().prototype.floorDiv=function(e){return this.throwIfDisposed(),lN(this,e)};De().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Dx(this,e,t,n)};De().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Ju(this,e)};De().prototype.greater=function(e){return this.throwIfDisposed(),Ma(this,e)};De().prototype.ifft=function(){return this.throwIfDisposed(),Hg(this)};De().prototype.irfft=function(){return this.throwIfDisposed(),$N(this)};De().prototype.isFinite=function(){return this.throwIfDisposed(),gO(this)};De().prototype.isInf=function(){return this.throwIfDisposed(),yO(this)};De().prototype.isNaN=function(){return this.throwIfDisposed(),xO(this)};De().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Q1(this,e)};De().prototype.lessEqual=function(e){return this.throwIfDisposed(),Md(this,e)};De().prototype.less=function(e){return this.throwIfDisposed(),Vg(this,e)};De().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),bO(this,e,t,n,r)};De().prototype.logSigmoid=function(){return this.throwIfDisposed(),vO(this)};De().prototype.logSoftmax=function(e){return this.throwIfDisposed(),yN(this,e)};De().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),tw(this,e,t)};De().prototype.log=function(){return this.throwIfDisposed(),Ni(this)};De().prototype.log1p=function(){return this.throwIfDisposed(),ew(this)};De().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Io(this,e)};De().prototype.logicalNot=function(){return this.throwIfDisposed(),nw(this)};De().prototype.logicalOr=function(e){return this.throwIfDisposed(),xN(this,e)};De().prototype.logicalXor=function(e){return this.throwIfDisposed(),wO(this,e)};De().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Qt(this,e,t,n)};De().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),Ss(this,e,t,n,r)};De().prototype.max=function(e,t){return this.throwIfDisposed(),Hi(this,e,t)};De().prototype.maximum=function(e){return this.throwIfDisposed(),cu(this,e)};De().prototype.mean=function(e,t){return this.throwIfDisposed(),Sr(this,e,t)};De().prototype.min=function(e,t){return this.throwIfDisposed(),Wg(this,e,t)};De().prototype.minimum=function(e){return this.throwIfDisposed(),ld(this,e)};De().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),IO(this,e,t)};De().prototype.mod=function(e){return this.throwIfDisposed(),SO(this,e)};De().prototype.mul=function(e){return this.throwIfDisposed(),oe(this,e)};De().prototype.neg=function(){return this.throwIfDisposed(),or(this)};De().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Ax(this,e,t,n)};De().prototype.notEqual=function(e){return this.throwIfDisposed(),kh(this,e)};De().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Ug(this,e,t,n)};De().prototype.onesLike=function(){return this.throwIfDisposed(),Ti(this)};De().prototype.pad=function(e,t){return this.throwIfDisposed(),ml(this,e,t)};De().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),CO(this,e,t,n,r,s,a)};De().prototype.pow=function(e){return this.throwIfDisposed(),ru(this,e)};De().prototype.prelu=function(e){return this.throwIfDisposed(),aw(this,e)};De().prototype.prod=function(e,t){return this.throwIfDisposed(),NO(this,e,t)};De().prototype.reciprocal=function(){return this.throwIfDisposed(),AO(this)};De().prototype.relu=function(){return this.throwIfDisposed(),Un(this)};De().prototype.relu6=function(){return this.throwIfDisposed(),wN(this)};De().prototype.reshapeAs=function(e){return this.throwIfDisposed(),ue(this,e.shape)};De().prototype.reshape=function(e){return this.throwIfDisposed(),ue(this,e)};De().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),pY(this,e,t,n)};De().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),hY(this,e,t,n)};De().prototype.reverse=function(e){return this.throwIfDisposed(),Yi(this,e)};De().prototype.rfft=function(){return this.throwIfDisposed(),lw(this)};De().prototype.round=function(){return this.throwIfDisposed(),kN(this)};De().prototype.rsqrt=function(){return this.throwIfDisposed(),IN(this)};De().prototype.selu=function(){return this.throwIfDisposed(),SN(this)};De().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Fx(this,e,t,n,r,s,a)};De().prototype.sigmoid=function(){return this.throwIfDisposed(),vo(this)};De().prototype.sign=function(){return this.throwIfDisposed(),RO(this)};De().prototype.sin=function(){return this.throwIfDisposed(),CN(this)};De().prototype.sinh=function(){return this.throwIfDisposed(),NN(this)};De().prototype.slice=function(e,t){return this.throwIfDisposed(),hn(this,e,t)};De().prototype.softmax=function(e){return this.throwIfDisposed(),Pd(this,e)};De().prototype.softplus=function(){return this.throwIfDisposed(),dm(this)};De().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),sw(this,e,t)};De().prototype.split=function(e,t){return this.throwIfDisposed(),Xa(this,e,t)};De().prototype.sqrt=function(){return this.throwIfDisposed(),Ds(this)};De().prototype.square=function(){return this.throwIfDisposed(),Zn(this)};De().prototype.squaredDifference=function(e){return this.throwIfDisposed(),EN(this,e)};De().prototype.squeeze=function(e){return this.throwIfDisposed(),zd(this,e)};De().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Zt?[this,e]:[this,...e];return Yr(n,t)};De().prototype.step=function(e){return this.throwIfDisposed(),pm(this,e)};De().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),DO(this,e,t,n,r,s,a,i,o)};De().prototype.sub=function(e){return this.throwIfDisposed(),at(this,e)};De().prototype.sum=function(e,t){return this.throwIfDisposed(),yt(this,e,t)};De().prototype.tan=function(){return this.throwIfDisposed(),FO(this)};De().prototype.tanh=function(){return this.throwIfDisposed(),od(this)};De().prototype.tile=function(e){return this.throwIfDisposed(),xi(this,e)};De().prototype.toBool=function(){return this.throwIfDisposed(),Ke(this,"bool")};De().prototype.toFloat=function(){return this.throwIfDisposed(),Ke(this,"float32")};De().prototype.toInt=function(){return this.throwIfDisposed(),Ke(this,"int32")};De().prototype.topk=function(e,t){return this.throwIfDisposed(),MO(this,e,t)};De().prototype.transpose=function(e){return this.throwIfDisposed(),en(this,e)};De().prototype.unique=function(e){return this.throwIfDisposed(),LO(this,e)};De().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),FN(this,e,t)};De().prototype.unstack=function(e){return this.throwIfDisposed(),Fr(this,e)};De().prototype.where=function(e,t){return this.throwIfDisposed(),Rs(e,this,t)};De().prototype.zerosLike=function(){return this.throwIfDisposed(),gn(this)};var Ac=class HY extends Error{constructor(t){super(t),Object.setPrototypeOf(this,HY.prototype)}},zl=class qY extends Error{constructor(t){super(t),Object.setPrototypeOf(this,qY.prototype)}},pe=class KY extends Error{constructor(t){super(t),Object.setPrototypeOf(this,KY.prototype)}},sn=class XY extends Error{constructor(t){super(t),Object.setPrototypeOf(this,XY.prototype)}},JHe=class YY extends Error{constructor(t){super(t),Object.setPrototypeOf(this,YY.prototype)}},ZY=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function Sh(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function Ol(e,t){if(!e)throw new JHe(t)}function DU(e,t){let n=0;for(let r of e)r===t&&n++;return n}function Ga(e){return e.length===1?e[0]:e}function Vn(e){return Array.isArray(e)?e:[e]}function Cu(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Ep(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var co={};function nM(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function OA(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>OA(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:OA(r))}}}function cw(e,t={},n={},r="object",s=!1){if(typeof e=="string"){let a=e,i;if(a in n)i=n[a];else if(a in co)i=co[a];else if(i=t[a],i==null)throw new pe(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let a=e;if(a.className==null||a.config==null)throw new pe(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);let i=a.className,o,l;if(i in n?[o,l]=n[i]:i in co?[o,l]=co.className:i in t&&([o,l]=t[i]),o==null)throw new pe(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let h of Object.keys(co))u[h]=co[h];for(let h of Object.keys(n))u[h]=n[h];let c=a.config;c.customObjects=u;let d=Object.assign({},co);for(let h of Object.keys(n))co[h]=n[h];OA(a.config);let p=l(o,a.config,n,s);return co=Object.assign({},d),p}else{let u=Object.assign({},co);for(let d of Object.keys(n))co[d]=n[d];let c=new o(a.config);return co=Object.assign({},u),c}}}function QHe(e,t){return e<t?-1:e>t?1:0}function Yk(e,t){return-1*QHe(e,t)}function qc(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function e8e(e){if(e==null)throw new pe(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function hm(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new pe(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function rM(e,t,n=0,r=1/0){return Ol(n>=0),Ol(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(s=>typeof s===t)}function As(e,t){Array.isArray(e)?(O.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>As(n,`element ${r+1} of ${t}`))):O.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${JY(e)}.`)}function JY(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>JY(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function t8e(e,t,n){let r=n!=null?n():O.now(),s;return(...a)=>{let i=n!=null?n():O.now();return i-r<t||(r=i,s=e(...a)),s}}function QY(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var n8e=0;function eZ(){return n8e++}var Zk={};function WN(e=""){return e in Zk||(Zk[e]=0),Zk[e]+=1,e+Zk[e].toString()}var r8e=["channelsFirst","channelsLast"],s8e=["nearest","bilinear"],a8e=["valid","same","causal"],i8e=["max","avg"],o8e=["sum","mul","concat","ave"],eg=new Map;function Vr(e){hm(r8e,"DataFormat",e)}function l8e(e){hm(s8e,"InterpolationFormat",e)}function Qi(e){hm(a8e,"PaddingMode",e)}function tZ(e){hm(i8e,"PoolMode",e)}var av=[],FU="/";function jp(e,t){av.push(e);try{let n=t();return av.pop(),n}catch(n){throw av.pop(),n}}function u8e(){return av.length===0?"":av.join(FU)+FU}function nZ(e){if(!sZ(e))throw new Error("Not a valid tensor name: '"+e+"'");return u8e()+e}function rZ(e){if(!sZ(e))throw new Error("Not a valid tensor name: '"+e+"'");eg.has(e)||eg.set(e,0);let t=eg.get(e);if(eg.set(e,eg.get(e)+1),t>0){let n=`${e}_${t}`;return eg.set(n,1),n}else return e}var c8e=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function sZ(e){return!!e.match(c8e)}function d8e(e){return e===parseInt(e.toString(),10)}function Kc(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function Kg(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function cd(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function ol(e,t){if(t<e)throw new pe(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}var VE;function ds(){return VE==null&&(VE=M3().epsilon()),VE}function ll(){return"channelsLast"}function Vu(e,t){return Ke(e,t)}function dw(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),ue(e,n)}function p8e(e,t){return ce(()=>{if(e.shape.length!==2)throw new pe(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=dw(e,1);return MA(n,[1,t,1])})}function h8e(e){let t=[Kc(e.shape)];return ue(e,t)}function f8e(e){if(e.rank<=1)throw new pe(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],Kc(e.shape,1)];return ue(e,t)}function Hp(e,t,n){return ce(()=>{switch(e.rank){case 1:return iw(e,t,n);case 2:return TN(e,[t,0],[n,e.shape[1]]);case 3:return Ox(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return jg(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return hn(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return hn(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new pe(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function UE(e,t,n){return ce(()=>{switch(e.rank){case 1:return iw(e,t,n);case 2:return TN(e,[0,t],[e.shape[0],n]);case 3:return Ox(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return jg(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new pe(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Jk(e,t,n,r){return ce(()=>{switch(e.rank){case 1:return iw(e,t,n);case 2:switch(r){case 1:return Hp(e,t,n);case 2:return UE(e,t,n);default:throw new pe(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Hp(e,t,n);case 2:return Ox(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return UE(e,t,n);default:throw new pe(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Hp(e,t,n);case 2:return jg(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return jg(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return UE(e,t,n);default:throw new pe(`The axis is not within the rank of the tensor ${r}`)}default:throw new pe(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function sM(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),Jn(e,t)}function OU(e,t){switch(e.rank){case 1:return tO([e,t]);case 2:return nO([e,t],0);case 3:return rO([e,t],0);case 4:return sO([e,t],0);default:throw new pe(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function MA(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new pe(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return xi(e,t)}function VN(e,t=0,n=1,r,s){return vN(e,t,n,r,s)}function Xl(e,t,n,r){if(e.rank<2||t.rank<2)throw new sn(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let s=e.shape.slice(-1)[0],a=t.shape.slice(-2)[0];if(s!==a)throw new sn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return qg.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?LA(e.rank,r,ll()):null,activation:n});{let s=e.shape.slice(),a=s.pop();e=ue(e,[-1,a]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},(p,h)=>h===0?t.rank-2:h<=t.rank-2?h-1:h);t=ue(en(t,c),[l,-1]);let d=[...s,...u];return ue(qg.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?LA(e.rank,r,ll()):null,activation:n}),d)}}function aZ(e,t,n){return ce(()=>(Array.isArray(t)?t=Ln(t,"int32"):t=Ke(t,"int32"),Dx(e,t,n)))}function pw(e){return oe(e,e)}function LA(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new pe(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?ue(t,[1,r[0],1,1,1]):ue(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?ue(t,[1,1,1,1,r[0]]):ue(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?ue(t,[1,r[0],1,1]):ue(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?ue(t,[1,1,1,r[0]]):ue(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?ue(t,[1,r[0],1]):ue(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?ue(t,[1,1,r[0]]):ue(t,[1].concat(r))}else if(e<3)return t;throw new pe(`Unsupported input rank by biasAdd: ${t.rank}`)}function gl(e,t,n){return ce(()=>(n==null&&(n=ll()),Vr(n),Ae(e,LA(e.rank,t,n))))}function m8e(e,t=1){if(t!==1)throw new sn(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return _x(e)}function g8e(e){return ce(()=>ht(e,Ae(Hr(e),1)))}function iZ(e,t,n,r){return ce(()=>BO(e,t,n,r))}function y8e(e){return ce(()=>{let t=Ae(.5,oe(.2,e));return oa(t,0,1)})}function hw(e,t,n=!1){return n?e():t()}var x8e=["fanIn","fanOut","fanAvg"],b8e=["normal","uniform","truncatedNormal"];function v8e(e){hm(x8e,"FanMode",e)}function w8e(e){hm(b8e,"Distribution",e)}var $o=class extends Pe.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},aM=class extends $o{apply(e,t){return Cr(e,t)}};aM.className="Zeros";Pe.registerClass(aM);var UN=class extends $o{apply(e,t){return Ha(e,t)}};UN.className="Ones";Pe.registerClass(UN);var iM=class extends $o{constructor(e){if(super(),typeof e!="object")throw new pe(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new pe(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ce(()=>oe(Tt(this.value),Ha(e,t)))}getConfig(){return{value:this.value}}};iM.className="Constant";Pe.registerClass(iM);var oM=class extends $o{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Ld(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};oM.className="RandomUniform";Pe.registerClass(oM);var lM=class extends $o{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new sn(`randomNormal does not support dType ${t}.`);return VN(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};lM.className="RandomNormal";Pe.registerClass(lM);var uM=class extends $o{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new sn(`truncatedNormal does not support dType ${t}.`);return DN(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};uM.className="TruncatedNormal";Pe.registerClass(uM);var cM=class extends $o{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return ce(()=>{if(e.length!==2||e[0]!==e[1])throw new pe("Identity matrix initializer can only be used for 2D square matrices.");return oe(this.gain,mN(e[0]))})}getConfig(){return{gain:this.gain}}};cM.className="Identity";Pe.registerClass(cM);function k8e(e,t="channelsLast"){let n,r;if(Vr(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let s=Kc(e,2);n=e[1]*s,r=e[0]*s}else if(t==="channelsLast"){let s=Kc(e,0,e.length-2);n=e[e.length-2]*s,r=e[e.length-1]*s}}else{let s=Kc(e);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}var ei=class extends $o{constructor(e){if(super(),e.scale<0)throw new pe(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,v8e(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,w8e(this.distribution),this.seed=e.seed}apply(e,t){let n=k8e(e),r=n[0],s=n[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),this.distribution==="normal"){let i=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new sn(`${this.getClassName()} does not support dType ${t}.`);return DN(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*a);return Ld(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};ei.className="VarianceScaling";Pe.registerClass(ei);var GN=class extends ei{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ei.className}};GN.className="GlorotUniform";Pe.registerClass(GN);var jN=class extends ei{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ei.className}};jN.className="GlorotNormal";Pe.registerClass(jN);var HN=class extends ei{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ei.className}};HN.className="HeNormal";Pe.registerClass(HN);var qN=class extends ei{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ei.className}};qN.className="HeUniform";Pe.registerClass(qN);var KN=class extends ei{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ei.className}};KN.className="LeCunNormal";Pe.registerClass(KN);var XN=class extends ei{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ei.className}};XN.className="LeCunUniform";Pe.registerClass(XN);var dM=class extends $o{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return ce(()=>{if(e.length<2)throw new sn("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=O.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);let a=[Math.max(r,n),Math.min(r,n)],i=VN(a,0,1,t,this.seed),o=GO.qr(i,!1),l=o[0],u=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return l=oe(l,u.sign()),n<r&&(l=l.transpose()),oe(Tt(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};dM.className="Orthogonal";Pe.registerClass(dM);var MU={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function LU(e,t={}){return cw(e,Pe.SerializationMap.getMap().classNameMap,t,"initializer")}function Tr(e){return nM(e)}function br(e){if(typeof e=="string"){let t=e in MU?MU[e]:e;if(t==="GlorotNormal")return new jN;if(t==="GlorotUniform")return new GN;if(t==="HeNormal")return new HN;if(t==="HeUniform")return new qN;if(t==="LeCunNormal")return new KN;if(t==="LeCunUniform")return new XN;{let n={};return n.className=t,n.config={},LU(n)}}else return e instanceof $o?e:LU(e)}function PA(e){return Array.isArray(e)&&Array.isArray(e[0])}function $I(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Vt(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new pe(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Nn(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new pe(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function EI(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,s)=>r*s);return t}var PU="Variable",oZ=class{constructor(e,t="float32",n=PU,r=!0,s=null){this.dtype=t??"float32",this.shape=e.shape,this.id=eZ(),n=n??PU,this.originalName=nZ(n),this.name=rZ(this.originalName),this.trainable_=r,this.constraint=s,this.val=PO(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),I8e(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function I8e(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function zA(e){return e.map(t=>t.read())}function pM(e){e.forEach(t=>{t[0].write(t[1])})}var Kr=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},ul=class{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=eZ(),a!=null&&(this.originalName=nZ(a),this.name=rZ(this.originalName)),this.rank=t.length}},S8e=0,YN=class{constructor(e,t){this.callArgs=t,this.id=S8e++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},C8e=0,an=class extends Pe.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=C8e++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Cu(n)+"_"+WN(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),n=[s].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new zl(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new pe(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Ga(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Ga(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ac(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ac(`Layer ${this.name} is not connected, no input to return.`);return Ga(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ac(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ac(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Ga(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=Vn(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=Vn(this.inputSpec);if(t.length!==n.length)throw new pe(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){let s=t[r],a=n[r];if(a==null)continue;let i=s.rank;if(a.ndim!=null&&i!==a.ndim)throw new pe(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${i}`);if(a.maxNDim!=null&&i>a.maxNDim)throw new pe(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${i}`);if(a.minNDim!=null&&i<a.minNDim)throw new pe(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${i}.`);if(a.dtype!=null&&s.dtype!==a.dtype)throw new pe(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${s.dtype}.`);if(a.axes){let o=s.shape;for(let l in a.axes){let u=Number(l),c=a.axes[l],d=u>=0?o[u]:o[o.length+u];if(c!=null&&[c,null].indexOf(d)===-1)throw new pe(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${o}.`)}}if(a.shape!=null)for(let o=0;o<a.shape.length;++o){let l=a.shape[o],u=s.shape[o];if(l!=null&&u!=null&&l!==u)throw new pe(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${s.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=Vn(e),r=$8e(e),s=E8e(e);if(r===s)throw new pe("Arguments to apply() must be all SymbolicTensors or all Tensors");return jp(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let a=[];for(let i of Vn(e))a.push(i.shape);this.build(Ga(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);let i=Vn(a),o=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(a=Ga(o),this.activityRegularizer!=null)throw new sn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=N8e(e),i=this.computeOutputShape(a),o,l=T8e(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((u,c)=>new ul(l,u,this,Vn(e),t,this.name,c)):o=new ul(l,i,this,Vn(e),t,this.name),this.addInboundNode(e,o,null,null,a,i,t),this._refCount++,this.activityRegularizer!=null)throw new sn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ac(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Ac(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new zl(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return EI(this.weights)}build(e){this.built=!0}getWeights(e=!1){return zA(e?this.trainableWeights:this.weights)}setWeights(e){ce(()=>{let t=this.weights;if(t.length!==e.length)throw new pe(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=zA(t);for(let s=0;s<r.length;++s){let a=r[s],i=t[s],o=e[s];if(!O.arraysEqual(a.shape,o.shape))throw new pe(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}pM(n)})}addWeight(e,t,n,r,s,a,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new pe(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=o!=null?o():br("zeros"));let l=r.apply(t,n),u=new oZ(l,n,e,a,i);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(u.read())),a==null&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Vn(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),s=Vn(t),a=Vn(r);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let i=0;i<s.length;i++)s[i].kerasMask=a[i]}addInboundNode(e,t,n,r,s,a,i=null){let o=Vn(e);t=Vn(t),n=Vn(n),r=Vn(r),s=$I(s),a=$I(a);let l=[],u=[],c=[];for(let d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex);new YN({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function N8e(e){e=Vn(e);let t=[];for(let n of e)t.push(n.shape);return Ga(t)}function T8e(e){return"float32"}function lZ(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let s=[];for(let a=0;a<r.inboundLayers.length;a++){let i=r.inputTensors[a],o=r.inboundLayers[a],l=r.nodeIndices[a],u=lZ(i,o,l);for(let c of u)s.indexOf(c)===-1&&s.push(c)}return s}}}function $8e(e){let t=!0;for(let n of Vn(e))if(!(n instanceof ul)){t=!1;break}return t}function E8e(e){let t=!0;for(let n of Vn(e))if(n instanceof ul){t=!1;break}return t}var Lx=class extends an{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:WN("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new pe("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new pe("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new pe("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new ul(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new YN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new pe(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};Lx.className="InputLayer";Pe.registerClass(Lx);function uZ(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new pe("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new Lx({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function _8e(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return Ke(t,e.dtype)}catch{throw new pe(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var dg=class cZ{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof cZ)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=_8e(t,n),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new pe(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof ul){if(this.id2Value[t.id]==null)throw new pe(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new pe(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof ul){if(this.id2Value[t.id]==null)throw new pe(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new pe(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&qt(this.id2Mask)}},_I=new ZY,AI=new ZY;function A8e(e){_I!=null&&_I.setMaxEntries(e),AI!=null&&AI.setMaxEntries(e)}function Kb(e,t,n,r){let s=n==null?!1:n.training,a=Array.isArray(e),i=a?e:[e],o=i.map(m=>m.name),l=[],u=t.names();for(let m of o)u.indexOf(m)!==-1?l.push(t.getValue(m)):l.push(null);let c=o.join(",")+"|"+t.names().sort().join(","),d=_I.get(c),p;if(d==null){let m=R8e(i,t);d=m.sorted,p=m.recipientCounts,_I.put(c,d),AI.put(c,p)}p={},s||Object.assign(p,AI.get(c));let h=new dg(t);for(let m=0;m<d.length;++m){let g=d[m],y=g.sourceLayer;if(y instanceof Lx)continue;let b=[],v=[],k=[],I=!1;for(let R of g.inputs){let D=h.getValue(R),$=h.getMask(R);b.push(D),v.push($),$!=null&&(I=!0),s||(p[R.name]--,p[R.name]===0&&!t.hasKey(R)&&o.indexOf(R.name)===-1&&!D.isDisposed&&R.sourceLayer.stateful!==!0&&k.push(D))}I&&(n=n||{},n.mask=v[0]);let S=Vn(y.apply(b,n)),N=null;y.supportsMasking&&(N=y.computeMask(b,v));let T=F8e(g),A=Array.isArray(T)?T:[T];for(let R=0;R<A.length;++R){h.hasKey(A[R])||h.add(A[R],S[R],Array.isArray(N)?N[0]:N);let D=o.indexOf(A[R].name);D!==-1&&(l[D]=S[R])}s||qt(k)}return h.disposeMasks(),a?l:l[0]}function R8e(e,t){O.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let s=zU(e[0],t);n=s.sorted,r=s.recipientMap}else{let s=new Set;for(let a of e){let{sorted:i,recipientMap:o}=zU(a,t);for(let l of i)s.has(l.name)||(n.push(l),s.add(l.name));for(let l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:D8e(r)}}function D8e(e){let t={};for(let n in e)t[n]=e[n].size;return t}function zU(e,t){let n=new Set,r=[],s={};for(let o of t.names())n.add(o);let a=[],i=[];for(a.push(e);a.length>0;){let o=a[a.length-1];if(n.has(o.name)){a.pop();continue}let l=i[i.length-1]===a.length-1;if(o.inputs.length===0||l)a.pop(),r.push(o),n.add(o.name),l&&i.pop();else{i.push(a.length-1);for(let u of o.inputs)s[u.name]==null&&(s[u.name]=new Set),s[u.name].add(o.name),!n.has(u.name)&&a.push(u)}}return{sorted:r,recipientMap:s}}function F8e(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var O8e=xe();O8e.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,A8e);var dZ={};Kt(dZ,{maxNorm:()=>M8e,minMaxNorm:()=>z8e,nonNeg:()=>P8e,unitNorm:()=>L8e});function hM(e,t){return ce(()=>Ds(yt(oe(e,e),t,!0)))}var fw=class extends Pe.Serializable{getConfig(){return{}}},fM=class extends fw{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ce(()=>{let t=hM(e,this.axis),n=oa(t,0,this.maxValue);return oe(e,ht(n,Ae(ds(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};fM.className="MaxNorm";Pe.registerClass(fM);var mM=class extends fw{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ce(()=>ht(e,Ae(ds(),hM(e,this.axis))))}getConfig(){return{axis:this.axis}}};mM.className="UnitNorm";Pe.registerClass(mM);var gM=class extends fw{apply(e){return Un(e)}};gM.className="NonNeg";Pe.registerClass(gM);var yM=class extends fw{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ce(()=>{let t=hM(e,this.axis),n=Ae(oe(this.rate,oa(t,this.minValue,this.maxValue)),oe(1-this.rate,t));return oe(e,ht(n,Ae(ds(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};yM.className="MinMaxNorm";Pe.registerClass(yM);var BU={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ms(e){return nM(e)}function WU(e,t={}){return cw(e,Pe.SerializationMap.getMap().classNameMap,t,"constraint")}function gs(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in BU?BU[e]:e,config:{}};return WU(t)}else return e instanceof fw?e:WU(e)}function M8e(e){return new fM(e)}function L8e(e){return new mM(e)}function P8e(){return new gM}function z8e(e){return new yM(e)}var pZ={};Kt(pZ,{constant:()=>V8e,glorotNormal:()=>X8e,glorotUniform:()=>K8e,heNormal:()=>Y8e,heUniform:()=>Z8e,identity:()=>H8e,leCunNormal:()=>J8e,leCunUniform:()=>Q8e,ones:()=>W8e,orthogonal:()=>e7e,randomNormal:()=>G8e,randomUniform:()=>U8e,truncatedNormal:()=>j8e,varianceScaling:()=>q8e,zeros:()=>B8e});function B8e(){return new aM}function W8e(){return new UN}function V8e(e){return new iM(e)}function U8e(e){return new oM(e)}function G8e(e){return new lM(e)}function j8e(e){return new uM(e)}function H8e(e){return new cM(e)}function q8e(e){return new ei(e)}function K8e(e){return new GN(e)}function X8e(e){return new jN(e)}function Y8e(e){return new HN(e)}function Z8e(e){return new qN(e)}function J8e(e){return new KN(e)}function Q8e(e){return new XN(e)}function e7e(e){return new dM(e)}var hZ={};Kt(hZ,{Layer:()=>an,RNN:()=>tc,RNNCell:()=>gw,activation:()=>Aqe,add:()=>Bqe,alphaDropout:()=>I9e,average:()=>Wqe,averagePooling1d:()=>EL,averagePooling2d:()=>_L,averagePooling3d:()=>AL,avgPool1d:()=>Yqe,avgPool2d:()=>Jqe,avgPool3d:()=>e9e,avgPooling1d:()=>Zqe,avgPooling2d:()=>Qqe,avgPooling3d:()=>t9e,batchNormalization:()=>qqe,bidirectional:()=>m9e,categoryEncoding:()=>$9e,centerCrop:()=>N9e,concatenate:()=>Vqe,conv1d:()=>kqe,conv2d:()=>Iqe,conv2dTranspose:()=>Sqe,conv3d:()=>Cqe,conv3dTranspose:()=>Nqe,convLstm2d:()=>d9e,convLstm2dCell:()=>p9e,cropping2D:()=>$qe,dense:()=>Rqe,depthwiseConv2d:()=>_qe,dot:()=>Hqe,dropout:()=>Dqe,elu:()=>gqe,embedding:()=>zqe,flatten:()=>Oqe,gaussianDropout:()=>k9e,gaussianNoise:()=>w9e,globalAveragePooling1d:()=>n9e,globalAveragePooling2d:()=>r9e,globalMaxPool1d:()=>y9e,globalMaxPool2d:()=>x9e,globalMaxPooling1d:()=>mJ,globalMaxPooling2d:()=>gJ,gru:()=>a9e,gruCell:()=>i9e,input:()=>AZ,inputLayer:()=>mqe,layerNormalization:()=>Kqe,leakyReLU:()=>xqe,lstm:()=>o9e,lstmCell:()=>l9e,masking:()=>S9e,maxPool1d:()=>b9e,maxPool2d:()=>v9e,maxPooling1d:()=>yJ,maxPooling2d:()=>xJ,maxPooling3d:()=>s9e,maximum:()=>Uqe,minimum:()=>Gqe,multiply:()=>jqe,permute:()=>Pqe,prelu:()=>bqe,randomWidth:()=>E9e,reLU:()=>yqe,repeatVector:()=>Mqe,rescaling:()=>C9e,reshape:()=>Lqe,resizing:()=>T9e,rnn:()=>h9e,separableConv2d:()=>Tqe,simpleRNN:()=>u9e,simpleRNNCell:()=>c9e,softmax:()=>vqe,spatialDropout1d:()=>Fqe,stackedRNNCells:()=>f9e,thresholdedReLU:()=>wqe,timeDistributed:()=>g9e,upSampling2d:()=>Eqe,zeroPadding2d:()=>Xqe});async function $c(e){if(e==null)return;let t=[],n=[],r=[];for(let s in e){let a=e[s];if(typeof a!="number"){let i=a;t.push(i.data()),n.push(s),r.push(i)}}if(t.length>0){let s=await Promise.all(t);for(let a=0;a<s.length;++a)e[n[a]]=s[a][0];qt(r)}}function fZ(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var VU;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(VU||(VU={}));var t7e=125,Xg=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},mZ=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},n7e=class extends Xg{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let r in t){let s=t[r];if(typeof s=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+s*n;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;let i=ce(()=>Ae(this.totals[r],oe(s,n)));this.totals[r]=i,a!=null&&a.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:ce(()=>{let r=oe(ht(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),cs(t[n])}))}},gZ=class extends Xg{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let s in this.history){let a=this.history[s];for(let i=0;i<a.length;++i)if(typeof a[i]!="number"){let o=a[i];e.push(o.data()),t.push(s),n.push(i)}}let r=await Promise.all(e);for(let s=0;s<r.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=r[s][0]}},yZ=class extends Xg{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||eM,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=t7e),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");O.isNumber(this.yieldEvery)&&(this.maybeWait=t8e(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await $c(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await $c(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await $c(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await $c(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await $c(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):O.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await $c(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await $c(e),await this.trainEnd(e))}};function xZ(e,t){return e==null&&(e={}),e instanceof Xg?[e]:Array.isArray(e)&&e[0]instanceof Xg?e:Vn(e).map(n=>new yZ(n,t))}var xM=class Nl{constructor(){}static registerCallbackConstructor(t,n){O.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Nl.checkForDuplicate(n),Nl.constructors[t]==null&&(Nl.constructors[t]=[]),Nl.constructors[t].push(n)}static checkForDuplicate(t){for(let n in Nl.constructors)Nl.constructors[+n].forEach(r=>{if(r===t)throw new pe("Duplicate callback constructor.")})}static clear(){Nl.constructors={}}static createCallbacks(t){let n=[];for(let r in Nl.constructors){let s=+r;t>=s&&n.push(...Nl.constructors[s])}return n.map(r=>new r)}};xM.constructors={};function bZ(e,t,n,r,s,a,i,o,l){let u=new gZ,c=[new n7e,...xM.createCallbacks(t)];e!=null&&c.push(...e),c.push(u);let d=new mZ(c);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function Qo(e,t={},n=!1){return cw(e,Pe.SerializationMap.getMap().classNameMap,t,"layer",n)}function RI(e,t){return ce(()=>{e.dtype!=="float32"&&(e=Ke(e,"float32"));let n=yt(pw(e),t,!0),r=wi(n.shape,ds()),s=Ds(cu(n,r));return ht(e,s)})}function fm(e,t){return ce(()=>Sr(pw(at(t,e)),-1))}function ZN(e,t){return ce(()=>Sr(Hr(at(t,e)),-1))}function Px(e,t){return ce(()=>{let n=at(e,t),r=oa(Hr(e),ds(),Number.MAX_VALUE),s=Hr(ht(n,r));return oe(100,Sr(s,-1))})}function r7e(e,t){return ce(()=>{let n=oa(t,ds(),Number.MAX_VALUE),r=Ni(Ae(1,n)),s=oa(e,ds(),Number.MAX_VALUE),a=Ni(Ae(1,s));return Sr(pw(at(r,a)),-1)})}function s7e(e,t){return ce(()=>{let n=cu(0,at(1,oe(e,t)));return Sr(pw(n),-1)})}function a7e(e,t){return ce(()=>{let n=cu(0,at(1,oe(e,t)));return Sr(n,-1)})}function i7e(e,t){return ce(()=>{let n=yt(oe(e,t),-1),r=Hi(oe(at(1,e),t),-1);return cu(0,Ae(1,at(r,n)))})}function o7e(e,t){return ce(()=>{let n=Math.log(2),r=at(t,e),s=at(Ae(r,dm(oe(-2,r))),n);return Sr(s,-1)})}function Mv(e,t,n=!1){return ce(()=>{if(n)t=Pd(t);else{let r=yt(t,t.shape.length-1,!0);t=ht(t,r)}return t=oa(t,ds(),1-ds()),or(yt(oe(Ke(e,"float32"),Ni(t)),t.shape.length-1))})}function DI(e,t,n=!1){return ce(()=>{let r=Ke(Rx(h8e(e)),"int32");t=oa(t,ds(),1-ds());let s=t.shape,a=ue(Ug(r,s[s.length-1]),s);return Mv(a,t,n)})}function l7e(e,t){if(!O.arraysEqual(e.shape,t.shape))throw new pe(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return ce(()=>{let n=Un(t),r=or(Hr(t));return Ae(at(n,oe(t,e)),ew(la(r)))})}function JN(e,t){return ce(()=>{let n;return n=oa(t,ds(),1-ds()),n=Ni(ht(n,at(1,n))),Sr(l7e(e,n),-1)})}function u7e(e,t){return ce(()=>{let n=oa(e,ds(),1),r=oa(t,ds(),1);return yt(oe(e,Ni(ht(n,r))),-1)})}function c7e(e,t){return ce(()=>{let n=Ni(Ae(ds(),t));return Sr(at(t,oe(e,n)),-1)})}function bM(e,t){return ce(()=>{let n=RI(e,-1),r=RI(t,-1),s=oe(n,r);return or(yt(s,-1))})}var FI={meanSquaredError:fm,meanAbsoluteError:ZN,meanAbsolutePercentageError:Px,meanSquaredLogarithmicError:r7e,squaredHinge:s7e,hinge:a7e,categoricalHinge:i7e,logcosh:o7e,categoricalCrossentropy:Mv,sparseCategoricalCrossentropy:DI,binaryCrossentropy:JN,kullbackLeiblerDivergence:u7e,poisson:c7e,cosineProximity:bM};function GE(e){if(typeof e=="string"){if(e in FI)return FI[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new pe(t)}else return e}function vM(e,t){return ce(()=>{let n=oe(.5,Ti(t)),r=Vu(Ma(t,n),e.dtype);return Sr(Ci(e,r),-1)})}function wM(e,t){return ce(()=>Vu(Ci(bh(e,-1),bh(t,-1)),"float32"))}function vZ(e,t){return ce(()=>Ke(yt(Io(Ci(e,1),Ci(t,1))),"float32"))}function d7e(e,t){return ce(()=>Ke(yt(Io(Ci(e,1),Ci(t,0))),"float32"))}function p7e(e,t){return ce(()=>Ke(yt(Io(Ci(e,0),Ci(t,1))),"float32"))}function wZ(e,t){return ce(()=>{let n=vZ(e,t),r=p7e(e,t),s=Ae(n,r);return Ke(Rs(Ma(s,0),ht(n,s),0),"float32")})}function h7e(e,t){return ce(()=>{let n=vZ(e,t),r=d7e(e,t),s=Ae(n,r);return Ke(Rs(Ma(s,0),ht(n,s),0),"float32")})}function kZ(e,t){return JN(e,t)}function IZ(e,t){return e.rank===t.rank&&(e=zd(e,[e.rank-1])),t=bh(t,-1),t.dtype!==e.dtype&&(t=Ke(t,e.dtype)),Ke(Ci(e,t),"float32")}function f7e(e,t){return ce(()=>{let n=e.sub(t).square().sum(),r=e.sub(e.mean()).square().sum();return Tt(1).sub(n.div(r))})}var m7e=fm,g7e=fm,y7e=ZN,x7e=ZN,b7e=Px,v7e=Px,kM=Mv,w7e=bM,SZ=DI,OI={binaryAccuracy:vM,categoricalAccuracy:wM,precision:wZ,categoricalCrossentropy:kM,sparseCategoricalCrossentropy:SZ,mse:m7e,MSE:g7e,mae:y7e,MAE:x7e,mape:b7e,MAPE:v7e,cosine:w7e};function k7e(e){if(typeof e=="string"&&e in OI)return OI[e];if(typeof e!="string"&&e!=null)return e;throw new pe(`Unknown metric ${e}`)}function Qk(e){if(Ol(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(FI))if(FI[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(OI))if(OI[n]===e){t=n;break}return t!==void 0?t:e.name}}function I7e(e){let t={Adagrad:()=>wp.adagrad(.01),Adadelta:()=>wp.adadelta(1,.95,ds()),Adam:()=>wp.adam(.001,.9,.999,ds()),Adamax:()=>wp.adamax(.002,.9,.999,ds(),0),RMSProp:()=>wp.rmsprop(.001,.9,0,ds()),SGD:()=>wp.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new pe(`Unknown Optimizer ${e}`)}function UU(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!BA(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function BA(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!BA(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!BA(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function S7e(e,t,n,r=console.log){let s=N7e(e),a=["Layer (type)","Input Shape","Output shape","Param #"];s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let i;if(!s){a.push("Receives inputs"),i=[];for(let c in e.nodesByDepth)i.push(...e.nodesByDepth[c])}r("_".repeat(t)),MI(a,n,r),r("=".repeat(t));let o=e.layers;for(let c=0;c<o.length;++c)s?T7e(o[c],n,r):$7e(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=C7e(e),u=EI(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function C7e(e){let t;return e.collectedTrainableWeights!=null?t=EI(e.collectedTrainableWeights):t=EI(e.trainableWeights),t}function N7e(e){let t=!0,n=[],r=[];for(let s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(let s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(let s of e.layers){let a=!1;for(let i of s.inboundNodes)if(r.indexOf(i)!==-1)if(a){t=!1;break}else a=!0;if(!t)break}return t}function MI(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function T7e(e,t,n){let r,s;try{s=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let a=e.name,i=e.getClassName(),o=[`${a} (${i})`,s,r,e.countParams().toString()];MI(o,t,n)}function $7e(e,t,n,r){let s,a;try{a=e.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{a="multiple"}try{s=JSON.stringify(e.outputShape)}catch{s="multiple"}let i=[];for(let d of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let p=0;p<d.inboundLayers.length;++p){let h=d.inboundLayers[p].name,m=d.nodeIndices[p],g=d.tensorIndices[p];i.push(`${h}[${m}][${g}]`)}let o=e.name,l=e.getClassName(),u=i.length===0?"":i[0],c=[`${o} (${l})`,a,s,e.countParams().toString(),u];MI(c,t,r);for(let d=1;d<i.length;++d)MI(["","","","",i[d]],t,r)}function CZ(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function Lv(e,t){if(e===null)return null;if(typeof e=="string")return Ep(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let a=e[s];CZ(t,s,a)?n.push(a):n.push(Lv(a,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r];if(r==="name"&&typeof s=="string")n[r]=s;else{let a=Ep(r);n[a]=Lv(s,a)}}return n}}function WA(e,t){if(e==null)return null;if(typeof e=="string")return Cu(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let a=e[s];CZ(t,s,a)?n.push(a):n.push(WA(a,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r],a=Cu(r);(r==="name"||r==="className")&&typeof s=="string"?n[a]=s:n[a]=WA(s,r)}return n}}var IM="4.22.0",E7e=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},_7e=class Tl extends an{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let v=this.getClassName().toLowerCase();this.name=WN(v)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],qc(this.inputs).length!==this.inputs.length)throw new pe(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(v=>v.name)}`);qc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(v=>v.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let v of this.outputs){let k=v.sourceLayer,I=v.nodeIndex,S=v.tensorIndex;this.outputLayers.push(k),this.outputLayersNodeIndices.push(I),this.outputLayersTensorIndices.push(S)}for(let v of this.inputs){let k=v.sourceLayer,I=v.nodeIndex,S=v.tensorIndex;Ol(I===0,"input layer has >1 nodes"),Ol(S===0,"input layer has >1 tensors"),this.inputLayers.push(k),this.inputLayersNodeIndices.push(I),this.inputLayersTensorIndices.push(S)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let v=0;v<this.inputLayers.length;v++){let k=this.inputLayers[v];if(!(k instanceof Lx))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${v} (0-based) originates from layer type ${k.getClassName()}.`);this.inputNames.push(k.name),this.feedInputShapes.push(k.batchInputShape),this.feedInputNames.push(k.name)}for(let v of this.outputLayers)this.outputNames.push(v.name);this.internalInputShapes=this.inputs.map(v=>v.shape),this.internalOutputShapes=this.outputs.map(v=>v.shape);let n={},r={},s={},a={},i={},o=[],l=(v,k,I,S,N,T)=>{(S==null||N==null||T==null)&&(S=v.sourceLayer,N=v.nodeIndex,T=v.tensorIndex);let A=S.inboundNodes[N];if(I.indexOf(A)!==-1)throw new zl(`The tensor ${v.name} at layer "${S.name}" is part of a cycle.`);if(k.indexOf(A)!==-1)return;this.containerNodes.add(Tl.nodeKey(S,N)),S.id in i||(i[S.id]=Object.keys(i).length),I.indexOf(A)===-1&&I.push(A);let R=A.inboundLayers.length;for(let D=0;D<R;D++){let $=A.inputTensors[D],_=A.inboundLayers[D],L=A.nodeIndices[D],z=A.tensorIndices[D];l($,k,I,_,L,z)}for(k.push(A);I.indexOf(A)>=0;)I.splice(I.indexOf(A),1);o.push(A)},u=[],c=[];for(let v of this.outputs)l(v,u,c);let d=o.slice().reverse();for(let v of d){r[v.id]=v,v.id in n||(n[v.id]=0);let k=n[v.id],I=s[v.outboundLayer.id]==null?0:s[v.outboundLayer.id];k=Math.max(k,I),s[v.outboundLayer.id]=k,a[v.outboundLayer.id]=v.outboundLayer,n[v.id]=k;for(let S=0;S<v.inboundLayers.length;S++){let N=v.inboundLayers[S],T=v.nodeIndices[S],A=N.inboundNodes[T],R=n[A.id]==null?0:n[A.id];n[A.id]=Math.max(k+1,R),r[A.id]=A}}let p={};for(let v in n){let k=n[v];k in p||(p[k]=[]),p[k].push(r[v])}let h={};for(let v in s){let k=s[v];k in h||(h[k]=[]),h[k].push(a[v])}let m=Object.keys(h).map(v=>parseInt(v,10)).sort(Yk);this.layers=[];for(let v of m){let k=h[v];k.sort((I,S)=>{let N=i[I.id],T=i[S.id];return N<T?-1:N>T?1:0});for(let I of k)I instanceof Tl&&this.internalContainerRefs.push(I),this.layers.push(I)}this.layersByDepth=h,m=Object.keys(p).map(v=>parseInt(v,10)).sort(Yk);let g=this.inputs.slice(),y=[];for(let v of m)for(let k of p[v]){let I=k.outboundLayer;if(I!=null){for(let S of k.inputTensors)if(g.indexOf(S)===-1)throw new zl(`Graph disconnected: cannot obtain value for tensor ${S} at layer "${I.name}". The following previous layers were accessed without issue: ${y}`);for(let S of k.outputTensors)g.push(S);y.push(I.name)}}this.nodesByDepth=p;let b=this.layers.map(v=>v.name);for(let v of b){let k=b.filter(I=>I===v).length;if(k!==1)throw new zl(`The name "${v}" is used ${k} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new YN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(v=>null),outputMasks:this.outputs.map(v=>null),inputShapes:this.inputs.map(v=>v.shape),outputShapes:this.outputs.map(v=>v.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new pe("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let r={},s=0,a=E7e(t);a&&this.parseWeights(t);for(let o of this.layers)for(let[l,u]of o.weights.entries()){let c=a?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(r[c]!=null)throw new pe(`Duplicate weight name: ${c}`);r[c]=u,s++}let i=[];for(let o in t){let l=o;if(r[o]==null){let u=o.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(r[l]!=null)i.push([r[l],t[o]]);else if(n)throw new pe(`Provided weight data has no target variable: ${o}`);delete r[l]}if(n){let o=[];for(let l in r)o.push(l);if(o.length>0)throw new pe(`${o.length} of ${s} weights are not set: ${o}`)}pM(i)}parseWeights(t){for(let n in Object.keys(t)){let r=n.split("/"),s=["vars","layer_checkpoint_dependencies"],a=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!s.includes(i)).join("/");a!==n&&(t[a]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${IM}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let r=WA(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return ce(()=>{t=Vn(t);let r=new dg;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Kb(this.outputs,r,n)})}computeMask(t,n){return ce(()=>{t=Vn(t);let r;return n==null?r=Sh(null,t.length):r=Vn(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){let n=$I(t);if(n.length!==this.inputLayers.length)throw new pe(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let o=0;o<n.length;o++){let l=this.inputLayers[o],u=n[o],c=l.name+"_0_0";r[c]=u}let s=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Yk);if(s.length>1)for(let o of s){let l=this.nodesByDepth[o];for(let u of l){let c=u.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(c.id)!==-1)continue;let d=[];for(let g=0;g<u.inboundLayers.length;g++){let y=u.inboundLayers[g],b=u.nodeIndices[g],v=u.tensorIndices[g],k=`${y.name}_${b}_${v}`,I=r[k];d.push(I)}let p=c.computeOutputShape(Ga(d)),h=$I(p),m=c.inboundNodes.indexOf(u);for(let g=0;g<h.length;g++){let y=`${c.name}_${m}_${g}`;r[y]=h[g]}}}let a=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],d=`${l.name}_${u}_${c}`;i.push(d)}for(let o=0;o<i.length;o++){let l=i[o];Ol(l in r),a.push(r[l])}return Ga(a)}runInternalGraph(t,n){n==null&&(n=Sh(null,t.length));let r={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],c=t[l],d=n[l];r[u.id]=[c,d]}let s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Yk);for(let l of s){let u=this.nodesByDepth[l];for(let c of u){let d=c.outboundLayer,p=c.inputTensors,h=c.outputTensors,m=new Array;for(let g of p)g.id in r&&m.push(r[g.id]);if(m.length===p.length){let g={},y,b,v,k;if(c.callArgs!=null&&(g=c.callArgs),m.length===1){let[I,S]=m[0];g.mask==null&&(g.mask=S),v=Vn(d.call(I,g)),k=Vn(d.computeMask(I,S)),y=[I],b=[S]}else y=m.map(I=>I[0]),b=m.map(I=>I[1]),g.mask==null&&(g.mask=b),v=Vn(d.call(y,g)),k=Vn(d.computeMask(y,b));if(d.activityRegularizer)throw new sn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let I=0;I<h.length;++I){let S=h[I],N=v[I],T=k[I];r[S.id]=[N,T]}}}}let a=[],i=[],o=[];for(let l of this.outputs){Ol(l.id in r,`Could not compute output ${l.name} : ${l.id}`);let[u,c]=r[l.id];o.push(u.shape),a.push(u),i.push(c)}return[a,i,o]}buildNodeConversionMap(t){let n={},r;for(let s of this.layers){r=s instanceof Tl?1:0;for(let a=0;a<s.inboundNodes.length;a++){let i=Tl.nodeKey(s,a);this.containerNodes.has(i)&&(n[i]=r,r+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new pe("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let r of this.layers)if(r.name===t)return r;throw new pe(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new pe(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return ce(()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let s=Tl.nodeKey(n,r);this.containerNodes.has(s)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let i of this.layers){let o=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){let p=i.inboundNodes[d],h=Tl.nodeKey(i,d),m={};if(this.containerNodes.has(h)){if(p.callArgs)try{JSON.stringify(p.callArgs),m=p.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),m={}}if(p.inboundLayers.length>0){let g=[];for(let y=0;y<p.inboundLayers.length;y++){let b=p.inboundLayers[y],v=p.nodeIndices[y],k=p.tensorIndices[y],I=Tl.nodeKey(b,v),S=n[I];S==null&&(S=0),g.push([b.name,S,k,m])}u.push(g)}}}let c={};c.name=i.name,c.className=o,c.config=l,c.inboundNodes=u,r.push(c)}t.layers=r;let s=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=Tl.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);let d=this.inputLayersTensorIndices[i];s.push([o.name,c,d])}t.inputLayers=s;let a=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=Tl.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);let d=this.outputLayersTensorIndices[i];a.push([o.name,c,d])}return t.outputLayers=a,t}static fromConfig(t,n,r={},s=!1){let a={},i={};function o(y,b){y.name in i?i[y.name].push(b):i[y.name]=[b]}function l(y,b){let v=[],k;for(let I of b){let S=I[0],N=I[1],T=I[2];if(k=I[3]==null?{}:I[3],!(S in a)){o(y,b);return}let A=a[S];if(A.inboundNodes.length<=N){o(y,b);return}let R=A.inboundNodes[N];v.push(R.outputTensors[T])}v.length>0&&y.apply(Ga(v),k)}function u(y){let b=y.name,v=Qo(y,n.customObjects!=null?n.customObjects:{});v.setFastWeightInitDuringBuild(s),a[b]=v,y.inboundNodes.forEach(k=>{if(!(k instanceof Array))throw new pe(`Corrupted configuration, expected array for nodeData: ${k}`);o(v,k)})}let c=n.name,d=n.layers;for(let y of d)u(y);for(;!e8e(i);)for(let y of d){let b=a[y.name];if(b.name in i){let v=i[b.name];delete i[b.name];for(let k of v)l(b,k)}}let p=[],h=[],m=n.inputLayers;for(let y of m){let b=y[0],v=y[1],k=y[2];Ol(b in a);let I=a[b].inboundNodes[v].outputTensors;p.push(I[k])}let g=n.outputLayers;for(let y of g){let b=y[0],v=y[1],k=y[2];Ol(b in a);let I=a[b].inboundNodes[v].outputTensors;h.push(I[k])}return new t({inputs:p,outputs:h,name:c})}get stateful(){if(this._stateful)throw new pe("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){ce(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function A7e(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let s=[];return t.forEach(a=>{a in e?s.push(e[a]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function NZ(e,t){return A7e(e,t,"classWeight")}async function TZ(e,t,n,r){if(n!=null){let s=ce(()=>{if(e.shape.length===1)return ql(e);if(e.shape.length===2){if(e.shape[1]>1)return bh(e,1);if(e.shape[1]===1)return ue(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await s.data());qt(s);let i=[];return a.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),Ln(i,"float32")}else return null}function R7e(e,t){return oe(e,t)}var D7e=32;function $Z(e,t){let n,r,s=t;n=s.xs,r=s.ys,O.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let a=GU("input",e.inputNames,n),i=GU("output",e.outputNames,r),o=a[0].shape[0];O.assert(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),O.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<a.length;l++)O.assert(a[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)O.assert(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:a,ys:i}}function GU(e,t,n){if(n instanceof Zt)return[n];if(Array.isArray(n))return O.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let s of t){if(n[s]==null)throw new pe(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function F7e(e){if(e.length===3)throw new sn("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function O7e(e,t,n){let r=n.batchesPerEpoch!=null;if(O.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),O.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),O.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),O.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),O.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let s=n.validationData!=null,a,i;if(s)if(jU(n.validationData))O.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let y=F7e(n.validationData);a=y.xs,i=y.ys}let o=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),u;s?u=l.slice().concat(l.map(y=>"val_"+y)):u=l.slice();let c=xZ(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:p,history:h}=bZ(c,d,n.epochs,null,null,M7e(t,n),null,s,u);p.setModel(e),e.history=h,await p.onTrainBegin(),e.stopTraining_=!1;let m=n.initialEpoch==null?0:n.initialEpoch,g=await t.iterator();for(;m<n.epochs;){let y={};await p.onEpochBegin(m);let b=0,v=0;for(r||(g=await t.iterator());!r||b<n.batchesPerEpoch;){let k=await g.next();if(r&&k.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(k.value!=null){let{xs:I,ys:S}=$Z(e,k.value),N={};N.batch=v,N.size=I[0].shape[0],await p.onBatchBegin(v,N);let T=[];if(n.classWeight!=null){let D=NZ(n.classWeight,e.outputNames);for(let $=0;$<D.length;++$)T.push(await TZ(S[$],null,D[$]))}let A=I.concat(S).concat(T),R=o(A);qt(A);for(let D=0;D<l.length;++D){let $=l[D],_=R[D];N[$]=_,cs(_)}await p.onBatchEnd(v,N),fZ(N),v++,b++}if(r?b>=n.batchesPerEpoch:k.done){if(s){let I;jU(n.validationData)?I=Vn(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):I=Vn(e.evaluate(a,i,{batchSize:n.validationBatchSize==null?D7e:n.validationBatchSize,verbose:0}));for(let S=0;S<e.metricsNames.length;++S)y[`val_${e.metricsNames[S]}`]=I[S]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(m,y),m++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function M7e(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function jU(e){return typeof e.iterator=="function"}function L7e(e){return typeof e.next=="function"}async function P7e(e,t,n){n=n||{};let r=n.batches!=null,s=e.testFunction,a=[];if(n.verbose>0)throw new sn("Verbose mode is not implemented yet.");O.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=L7e(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let u=await i.next();if(a=ce(()=>{if(u.value){let{xs:c,ys:d}=$Z(e,u.value),p=c.concat(d),h=ce(()=>s(p));if(qt(p),l===0)for(let g=0;g<h.length;++g)a.push(Tt(0));let m=p[0].shape[0];for(let g=0;g<h.length;++g){let y=h[g],b=a[g];a[g]=ce(()=>Ae(a[g],oe(m,y))),l>0&&qt(b)}qt(h),o+=m,++l}return a}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){let c=a[u];a[u]=ht(a[u],o),qt(c)}return Ga(a)}function jE(e){O.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Ob(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>Hp(r,t,n-t)):Hp(e,t,n-t)}function VA(e,t){return ce(()=>e==null?null:Array.isArray(e)?e.map(n=>VA(n,t)):aZ(e,t.dtype==="int32"?t:Ke(t,"int32")))}function HE(e,t){let n=[],r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function EZ(e){let t=[];e instanceof Zt&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(dw(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function zo(e,t){if(e==null)return;let n=[];if(t instanceof Zt)n.push(t.id);else if(Array.isArray(t))t.forEach(s=>n.push(s.id));else if(t!=null)for(let s in t){let a=t[s];n.push(a.id)}let r=[];if(e instanceof Zt)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(e!=null)for(let s in e){let a=e[s];n.indexOf(a.id)===-1&&r.push(a)}r.forEach(s=>{s.isDisposed||s.dispose()})}function z7e(e){return e instanceof Zt}function UA(e){return Array.isArray(e)}function HU(e){return!z7e(e)&&!UA(e)}function qU(e,t,n,r=!0,s=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(UA(e)&&e.length>0)i=!0;else if(HU(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new pe(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let a;if(HU(e)){e=e,a=[];for(let i of t){if(e[i]==null)throw new pe(`No data provided for "${i}". Need data for each key in: ${t}`);a.push(e[i])}}else if(UA(e)){if(e=e,e.length!==t.length)throw new pe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new pe(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=EZ(a),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=a[i];if(o.shape.length!==n[i].length)throw new pe(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let u=o.shape[l],c=n[i][l];if(c!=null&&c>=0&&u!==c)throw new pe(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function B7e(e,t,n){let r=qc(e.map(a=>a.shape[0]));r.sort();let s=qc(t.map(a=>a.shape[0]));if(s.sort(),r.length>1)throw new pe(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>1)throw new pe(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(r.length>0&&s.length>0&&!O.arraysEqual(r,s))throw new pe(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function W7e(e,t,n){let r=[fm,JN,Mv];for(let s=0;s<e.length;++s){let a=e[s],i=t[s],o=n[s];if(i!=null){if(i===Mv&&a.shape[a.shape.length-1]===1)throw new pe(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){let l=a.shape.slice(1),u=o.slice(1);for(let c=0;c<l.length;++c){let d=l[c],p=u[c];if(p!=null&&d!==p)throw new pe(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function KU(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new pe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new pe(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=a[i];if(o.shape.length!==n[i].length)throw new pe(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let u=o.shape[l],c=n[i][l];if(c!=null&&c!==u)throw new pe(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function V7e(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let s of t){let a=n.hasOwnProperty(s)?n[s]:[];Array.isArray(a)||(a=[a]),r.push(a)}return r}}var U7e="layers-model",Du=class extends _7e{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new pe("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");S7e(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=I7e(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof ec))throw new pe("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new pe(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(GE(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new pe(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>GE(a))}else{let a=GE(e.loss);this.outputs.forEach(i=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let i=this.internalOutputShapes[a],o=this.outputNames[a];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[a])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],jp("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([i,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let r=V7e(e.metrics,this.outputNames),s=(a,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[a]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,a])};jp("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=r[a];(o=>{let l="",u,c,d;for(let p of o){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){let m=this.internalOutputShapes[a];m[m.length-1]===1||this.lossFunctions[a]===JN?["accuracy","acc"].indexOf(p)!==-1?c=vM:["crossentropy","ce"].indexOf(p)!==-1&&(c=kZ):this.lossFunctions[a]===DI?["accuracy","acc"].indexOf(p)!==-1?c=IZ:["crossentropy","ce"].indexOf(p)!==-1&&(c=SZ):["accuracy","acc"].indexOf(p)!==-1?c=wM:["crossentropy","ce"].indexOf(p)!==-1&&(c=kM);let g;["accuracy","acc"].indexOf(p)!==-1?g="acc":["crossentropy","ce"].indexOf(p)!==-1&&(g="ce"),d=c,u=l+g}else d=k7e(p),u=l+Qk(p);let h;jp(u,()=>{h=d}),s(a,u,h)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;jE(r);let s=this.standardizeUserDataXY(e,t,!0,r);try{let a=s[0].concat(s[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,a,r,n.verbose,n.steps);return Ga(o)}finally{zo(s[0],e),zo(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),P7e(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(n!=null){if(s=null,t!=null)throw new pe(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new pe(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new pe("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new dg;if(e instanceof Zt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new pe(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)a.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(l==null)throw new pe(`No value is provided for the model's input ${o.name}`);a.add(o,l)}let i=Kb(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Sh(null,e.length),n=e.length;for(let r of this.layers){let s=Array.isArray(r.output)?r.output:[r.output],a=s.map(i=>i.name);for(let i=0;i<e.length;++i){let o=a.indexOf(e[i]);if(o!==-1&&(t[i]=s[o],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw t.forEach((s,a)=>{s==null&&r.push(e[a])}),new pe(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return ce(()=>{let r=this.checkNumSamples(e);if(n)throw new sn("Verbose predictLoop() is not implemented yet.");let s=HE(r,t),a=this.outputs.map(i=>[]);for(let i=0;i<s.length;++i)ce(()=>{let o=s[i][0],l=s[i][1],u=Ob(e,o,l),c=[];if(Array.isArray(u))for(let p=0;p<u.length;++p)c.push({key:this.inputs[p],value:u[p]});else c.push({key:this.inputs[0],value:u});let d=new dg(c);return Kb(this.outputs,d)}).forEach((o,l)=>a[l].push(o));return Ga(a.map(i=>Jn(i,0)))})}predict(e,t={}){let n=EZ(e);KU(n,this.inputNames,this.feedInputShapes,!1);try{let r=t.batchSize==null?32:t.batchSize;return jE(r),this.predictLoop(n,r)}finally{zo(n,e)}}predictOnBatch(e){KU(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new zl("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let a=0;a<this.feedOutputShapes.length;++a){let i=this.feedOutputShapes[a];this.feedLossFns[a]===DI?s.push(i.slice(0,i.length-1).concat([1])):s.push(i)}if(e=qU(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=qU(t,this.feedOutputNames,s,!1,"target"),B7e(e,t),W7e(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new pe(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){let[i,o]=this.standardizeUserDataXY(e,t,s,a);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){let u=NZ(r,this.outputNames);l=[];for(let c=0;c<u.length;++c)l.push(await TZ(o[c],null,u[c]))}return[i,o,l]}testLoop(e,t,n,r=0,s){return ce(()=>{let a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new sn("Verbose mode is not implemented yet.");if(s!=null)throw new sn("steps mode in testLoop() is not implemented yet");{let o=HE(a,n),l=Ln(ol(0,a));for(let u=0;u<o.length;++u){let c=o[u][0],d=o[u][1],p=Hp(l,c,d-c),h=VA(t,p),m=e(h);if(u===0)for(let g=0;g<m.length;++g)i.push(Tt(0));for(let g=0;g<m.length;++g){let y=m[g];i[g]=Ae(i[g],oe(d-c,y))}}for(let u=0;u<i.length;++u)i[u]=ht(i[u],a)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],s=r;if(DU(e,r)>1){let a=DU(e.slice(0,n),r);s+=`_${a}`}t.push(s)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],i=()=>{let l=[];for(let p=0;p<this.inputs.length;++p)l.push({key:this.inputs[p],value:n[p]});let u=new dg(l),c=Kb(this.outputs,u,{training:!0}),d;for(let p=0;p<this.lossFunctions.length;++p){let h=this.lossFunctions[p],m=h(r[p],c[p]);s[p]!=null&&(m=R7e(m,s[p]));let g=Sr(m);t.push(g),p===0?d=m:d=Ae(d,m)}for(let p=0;p<this.metricsTensors.length;++p){let h;if(this.outputs.length>1&&p<this.outputs.length)h=t[p];else{let m=this.metricsTensors[p][0],g=this.metricsTensors[p][1];h=Sr(m(r[g],c[g]))}cs(h),a.push(h)}return d=Sr(d),this.calculateLosses().forEach(p=>{d=Ae(d,p)}),d},o=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(i,!0,o)].concat(a)}}makeTestFunction(){this.testFunction=e=>ce(()=>{let t=[],n,r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let l=0;l<this.inputs.length;++l)a.push({key:this.inputs[l],value:r[l]});let i=new dg(a),o=Kb(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let u=this.lossFunctions[l],c=Sr(u(s[l],o[l]));l===0?n=c:n=Ae(n,c),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let u=this.metricsTensors[l][0],c=this.metricsTensors[l][1],d=Sr(u(s[c],o[c]));t.push(d)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,s,a,i,o,l,u,c,d;try{let p=n.batchSize==null?32:n.batchSize;jE(p);let h=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,p);r=h[0],s=h[1],d=h[2];let m=!1,g;if(n.validationData!=null&&n.validationData.length>0){if(m=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new sn("validationData including sample weights is not supported yet."):new pe(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let N=await this.standardizeUserData(o,l,null,null,!0,p);u=N[0],c=N[1],g=u.concat(c)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){m=!0;let N=Math.floor(r[0].shape[0]*(1-n.validationSplit)),T=r[0].shape[0];u=Ob(r,N,T),a=r,r=Ob(r,0,N),c=Ob(s,N,T),i=s,s=Ob(s,0,N),g=u.concat(c)}else n.validationSteps!=null&&(m=!0);let y=r.concat(s).concat(d);this.checkTrainableWeightsConsistency();let b=this.makeTrainFunction(),v=this.getDedupedMetricsNames(),k,I;m?(this.makeTestFunction(),k=this.testFunction,I=v.slice().concat(v.map(N=>"val_"+N))):(k=null,g=[],I=v.slice());let S=xZ(n.callbacks,n.yieldEvery);return await this.fitLoop(b,y,v,p,n.epochs,n.verbose,S,k,g,n.shuffle,I,n.initialEpoch,null,null)}finally{this.isTraining=!1,zo(r,e),zo(s,t),zo(a,e),zo(i,t),zo(u,o),zo(c,l),d!=null&&qt(d)}}async fitLoop(e,t,n,r,s,a,i,o,l,u,c,d,p,h){r==null&&(r=32),s==null&&(s=1),u==null&&(u=!0),d==null&&(d=0);let m=!1;if(o!=null&&l!=null&&(m=!0),h!=null&&(m=!0,p==null))throw new pe("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=this.checkNumSamples(t,r,p,"steps_per_epoch"),y;g!=null&&(y=ol(0,g)),a==null&&(a=1);let{callbackList:b,history:v}=bZ(i,a,s,d,g,p,r,m,c);b.setModel(this),this.history=v,await b.onTrainBegin(),this.stopTraining_=!1;for(let k=d;k<s;++k){await b.onEpochBegin(k);let I={};if(p!=null)throw new sn("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new sn("batch shuffling is not implemneted yet");u&&O.shuffle(y);let S=Ln(y),N=HE(g,r);for(let T=0;T<N.length;++T){let A={};if(await b.onBatchBegin(T,A),ce(()=>{let R=N[T][0],D=N[T][1],$=Hp(S,R,D-R);A.batch=T,A.size=D-R;let _=VA(t,$),L=e(_);for(let z=0;z<n.length;++z){let W=n[z],G=L[z];A[W]=G,cs(G)}if(T===N.length-1&&m){let z=this.testLoop(o,l,r);for(let W=0;W<n.length;++W){let G=n[W],q=z[W];cs(q),I["val_"+G]=q}}}),await b.onBatchEnd(T,A),fZ(A),this.stopTraining_)break}S.dispose()}if(await b.onEpochEnd(k,I),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return O7e(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(let o of a){let l=await o.data();i.push(l[0])}return qt(a),zo(n[0],e),zo(n[1],t),Ga(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<r.length;++a)n&&!r[a].trainable||t.push({name:r[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=SA().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-SA().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Cu(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Cu(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]=="string")e[r]=Cu(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Cu(Qk(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Cu(Qk(e)));{let e={};for(let t in this.metrics)e[t]=Cu(Qk(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=Lv(e.optimizer_config),n=Qo(t),r;if(typeof e.loss=="string")r=Ep(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>Ep(a));else if(e.loss!=null){r={};for(let a in e.loss)r[a]=Ep(e.loss[a])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(a=>Ep(a));else if(e.metrics!=null){s={};for(let a in e.metrics)s[a]=Ep(e.metrics[a])}this.compile({loss:r,metrics:s,optimizer:n})}async save(e,t){if(typeof e=="string"){let s=qs.getSaveHandlers(e);if(s.length===0)throw new pe(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new pe(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new pe("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await qs.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:U7e,generatedBy:`TensorFlow.js tfjs-layers v${IM}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){r.trainingConfig=this.getTrainingConfig();let s="optimizer",{data:a,specs:i}=await qs.encodeWeights(await this.optimizer.getWeights(),s);n.specs.push(...i),n.data=qs.concatenateArrayBuffers([n.data,a])}return this.userDefinedMetadata!=null&&(UU(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){UU(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};Du.className="Model";Pe.registerClass(Du);var _Z=class extends Du{};_Z.className="Functional";Pe.registerClass(_Z);async function G7e(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=Lv(n),s=Qo(r,t);if(e.weightsManifest!=null){let a=await qs.loadWeights(e.weightsManifest,e.pathPrefix,s.weights.map(o=>o.originalName)),i={};for(let o of s.weights)i[o.originalName]=a[o.originalName];s.loadWeights(i),qt(a)}return s}async function j7e(e,t){if(t==null&&(t={}),typeof e=="string"){let n=qs.getLoadHandlers(e,t);if(n.length===0)n.push(qs.browserHTTPRequest(e,t));else if(n.length>1)throw new pe(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return H7e(e,void 0,t)}async function H7e(e,t,n){if(n==null&&(n={}),e.load==null)throw new pe("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),s=r.modelTopology;s.model_config!=null&&(s=s.model_config);let a=n.strict==null?!0:n.strict,i=r.weightData!=null&&r.weightSpecs!=null&&a,o=Qo(Lv(s),t,i),l=r.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),r.userDefinedMetadata!=null&&o.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new pe("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:u,optimizerWeights:c}=q7e(r.weightData,r.weightSpecs);o.loadWeights(u,a),o.optimizer!=null&&c.length>0&&await o.optimizer.setWeights(c),qt(u),qt(c.map(d=>d.tensor))}return o}function q7e(e,t){let n=qs.decodeWeights(e,t),r={},s=[];return t.forEach(a=>{a.group==="optimizer"?s.push({name:a.name,tensor:n[a.name]}):r[a.name]=n[a.name]}),{modelWeights:r,optimizerWeights:s}}var QN=class GA extends Du{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:WN("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new pe(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof GA||t instanceof Du,r;if(n){if(r=t,r.outputs.length!==1)throw new pe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new pe("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new pe("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let s=uZ({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(s)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new pe(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new pe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=lZ(this.outputs[0])}this.inboundNodes=[],new YN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Sh(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{let s=t.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(Nn(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Du({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,r=console.log){this.built||this.build(),super.summary(t,n,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,r={}){if(!this.built)throw new zl("The model needs to be compiled before being used.");return this.model.evaluate(t,n,r)}async evaluateDataset(t,n){if(!this.built)throw new zl("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,r={}){if(!this.built)throw new zl("The model needs to be compiled before being used.");return this.model.fit(t,n,r)}async fitDataset(t,n){if(!this.built)throw new zl("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,r={},s=!1){let a,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new pe("Legacy serialization format not supported yet.");a=n}else O.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof GA))throw new sn(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let l of a){let u=Qo(l,void 0,s);s&&u.setFastWeightInitDuringBuild(!0),o.add(u)}return o}set stopTraining(t){if(this.model==null)throw new pe("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new pe("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let r={};r.className=n.getClassName(),r.config=n.getConfig(),t.push(r)}return{name:this.name,layers:t}}};QN.className="Sequential";Pe.registerClass(QN);function K7e(e){return new Du(e)}function X7e(e){return new QN(e)}function AZ(e){return uZ(e)}function Y7e(e,t){xM.registerCallbackConstructor(e,t)}var pa=class extends Pe.Serializable{getConfig(){return{}}},RZ=class extends pa{apply(e,t=1){return m8e(e,t)}};RZ.className="elu";Pe.registerClass(RZ);var DZ=class extends pa{apply(e){return SN(e)}};DZ.className="selu";Pe.registerClass(DZ);var FZ=class extends pa{apply(e){return Un(e)}};FZ.className="relu";Pe.registerClass(FZ);var OZ=class extends pa{apply(e){return ce(()=>ld(6,Un(e)))}};OZ.className="relu6";Pe.registerClass(OZ);var MZ=class extends pa{apply(e){return e}};MZ.className="linear";Pe.registerClass(MZ);var LZ=class extends pa{apply(e){return vo(e)}};LZ.className="sigmoid";Pe.registerClass(LZ);var PZ=class extends pa{apply(e){return y8e(e)}};PZ.className="hardSigmoid";Pe.registerClass(PZ);var zZ=class extends pa{apply(e){return dm(e)}};zZ.className="softplus";Pe.registerClass(zZ);var BZ=class extends pa{apply(e){return g8e(e)}};BZ.className="softsign";Pe.registerClass(BZ);var WZ=class extends pa{apply(e){return od(e)}};WZ.className="tanh";Pe.registerClass(WZ);var SM=class extends pa{apply(e,t=-1){return Pd(e,t)}};SM.className="softmax";Pe.registerClass(SM);var VZ=class extends pa{apply(e,t=-1){return yN(e,t)}};VZ.className="logSoftmax";Pe.registerClass(VZ);var UZ=class extends pa{apply(e){return ce(()=>ce(()=>{let t=Math.sqrt(2),n=oe(.5,Ae(1,fN(ht(e,t))));return oe(e,n)}))}};UZ.className="gelu";Pe.registerClass(UZ);var GZ=class extends pa{apply(e){return ce(()=>oe(.5,oe(e,Ae(1,od(oe(Ds(ht(2,Math.PI)),Ae(e,oe(.044715,ru(e,3)))))))))}};GZ.className="gelu_new";Pe.registerClass(GZ);var jZ=class extends pa{apply(e){return ce(()=>oe(e,od(dm(e))))}};jZ.className="mish";Pe.registerClass(jZ);var HZ=class extends pa{apply(e,t=1){return ce(()=>oe(vo(oe(e,t)),e))}};HZ.className="swish";Pe.registerClass(HZ);function dd(e){return e.getClassName()}function qE(e,t={}){return cw(e,Pe.SerializationMap.getMap().classNameMap,t,"activation")}function pd(e){if(e==null){let t={};return t.className="linear",t.config={},qE(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},qE(t)}else return e instanceof pa?e:qE(e)}function CM(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var qZ=class extends Pe.Serializable{},mw=class extends qZ{constructor(e){super(),CM(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ce(()=>{let t=Cr([1]);return this.hasL1&&(t=Ae(t,yt(oe(this.l1,Hr(e))))),this.hasL2&&(t=Ae(t,yt(oe(this.l2,pw(e))))),ue(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};mw.className="L1L2";Pe.registerClass(mw);function Z7e(e){return CM(e),new mw({l1:e!=null?e.l1:null,l2:0})}function J7e(e){return CM(e),new mw({l2:e!=null?e.l2:null,l1:0})}var XU={l1l2:"L1L2"};function rr(e){return nM(e)}function YU(e,t={}){return cw(e,Pe.SerializationMap.getMap().classNameMap,t,"regularizer")}function wr(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in XU?XU[e]:e,config:{}};return YU(t)}else return e instanceof qZ?e:YU(e)}var NM=class extends an{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Vt(e);let n=Un(e);return this.maxValue!=null&&(n=oa(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};NM.className="ReLU";Pe.registerClass(NM);var TM=class extends an{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Vt(e);return Q1(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};TM.className="LeakyReLU";Pe.registerClass(TM);var $M=class extends an{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=br(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=wr(e.alphaRegularizer),this.alphaConstraint=gs(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new pe(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Nn(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Kr({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Vt(e),aw(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Tr(this.alphaInitializer),alphaRegularizer:rr(this.alphaRegularizer),alphaConstraint:ms(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};$M.className="PReLU";Pe.registerClass($M);var EM=class extends an{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new sn(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Vt(e);return _x(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};EM.className="ELU";Pe.registerClass(EM);var _M=class extends an{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Vt(e);return oe(n,Ke(Ma(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};_M.className="ThresholdedReLU";Pe.registerClass(_M);var AM=class extends an{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new SM().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return ce(()=>{let n=Vt(e),r=t.mask;if(r!=null){let s=oe(at(Ha(n.shape),Ke(r,n.dtype)),Tt(-1e9));n=Ae(n,s)}return this.axis instanceof Array?this.axis.length>1?la(at(n,tw(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};AM.className="Softmax";Pe.registerClass(AM);function wg(e,t,n){if(typeof e=="number")return Sh(e,t);if(e.length!==t)throw new pe(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let s=e[r];if(!d8e(s))throw new pe(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function el(e,t,n,r,s=1){if(e==null)return e;let a=t+(t-1)*(s-1),i;return n==="same"?i=e:i=e-a+1,Math.floor((i+r-1)/r)}function Ml(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+cd([n-t,0]);else if(r==="same")e=e*t;else throw new pe(`Unsupport padding mode: ${r}.`);return e}function RM(e,t){return ce(()=>(Vr(t),t==="channelsFirst"?en(e,[0,2,3,1]):e))}function KZ(e,t){return ce(()=>(Vr(t),t==="channelsFirst"?en(e,[0,2,3,4,1]):e))}function Q7e(e,t,n,r=1,s="valid",a,i=1){return ce(()=>{if(a==null&&(a=ll()),Vr(a),e.shape.length!==3)throw new pe(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new pe(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new pe(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(a==="channelsFirst"&&(e=en(e,[0,2,1])),s==="causal")throw new sn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=cN(e,t,r,s==="same"?"same":"valid","NWC",i);return n!=null&&(o=gl(o,n)),o})}function ZU(e,t,n,r=[1,1],s="valid",a,i,o=null){return ce(()=>{if(a==null&&(a=ll()),Vr(a),e.rank!==3&&e.rank!==4)throw new pe(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new pe(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=RM(e,a);if(s==="causal")throw new sn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=qg.conv2d({x:l,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),a==="channelsFirst"&&(l=en(l,[0,3,1,2])),l})}function eqe(e,t,n,r=[1,1,1],s="valid",a,i){return ce(()=>{if(a==null&&(a=ll()),Vr(a),e.rank!==4&&e.rank!==5)throw new pe(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new pe(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=KZ(e,a);if(s==="causal")throw new sn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=iO(o,t,r,s==="same"?"same":"valid","NDHWC",i),n!=null&&(o=gl(o,n)),a==="channelsFirst"&&(o=en(o,[0,4,1,2,3])),o})}var XZ=class YZ extends an{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",YZ.verifyArgs(n),this.rank=t,As(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new sn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=wg(n.kernelSize,t,"kernelSize"),this.strides=wg(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,Qi(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Vr(this.dataFormat),this.activation=pd(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=br(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=gs(n.biasConstraint),this.biasRegularizer=wr(n.biasRegularizer),this.activityRegularizer=wr(n.activityRegularizer),this.dilationRate=wg(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new pe(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new pe(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new pe(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Ol("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!rM(t.kernelSize,"number",1,3))throw new pe(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:dd(this.activation),useBias:this.useBias,biasInitializer:Tr(this.biasInitializer),biasRegularizer:rr(this.biasRegularizer),activityRegularizer:rr(this.activityRegularizer),biasConstraint:ms(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},eT=class ZZ extends XZ{constructor(t,n){super(t,n),this.kernel=null,ZZ.verifyArgs(n),this.filters=n.filters,As(this.filters,"filters"),this.kernelInitializer=br(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=gs(n.kernelConstraint),this.kernelRegularizer=wr(n.kernelRegularizer)}build(t){t=Nn(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new pe(`The channel dimension of the input should be defined. Found ${t[n]}`);let r=t[n],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return ce(()=>{t=Vt(t);let r,s=this.bias==null?null:this.bias.read(),a=QY(this.activation.getClassName());if(a!=null&&this.rank===2)r=ZU(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)r=Q7e(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=ZU(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=eqe(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new sn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Nn(t);let n=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<r.length;++a){let i=el(r[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);n.push(i)}let s=[t[0]];return this.dataFormat==="channelsLast"?(s=s.concat(n),s.push(this.filters)):(s.push(this.filters),s=s.concat(n)),s}getConfig(){let t={filters:this.filters,kernelInitializer:Tr(this.kernelInitializer),kernelRegularizer:rr(this.kernelRegularizer),kernelConstraint:ms(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new pe(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},tT=class JZ extends eT{constructor(t){super(2,t),JZ.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!rM(t.kernelSize,"number",1,2))throw new pe(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};tT.className="Conv2D";Pe.registerClass(tT);var nT=class QZ extends eT{constructor(t){super(3,t),QZ.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new pe(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};nT.className="Conv3D";Pe.registerClass(nT);var DM=class extends tT{constructor(e){if(super(e),this.inputSpec=[new Kr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new pe(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Nn(e),e.length!==4)throw new pe("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new pe("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Kr({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return ce(()=>{let n=Vt(e);if(n.shape.length!==4)throw new pe(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],a,i;this.dataFormat==="channelsFirst"?(a=2,i=3):(a=1,i=2);let o=r[a],l=r[i],u=this.kernelSize[0],c=this.kernelSize[1],d=this.strides[0],p=this.strides[1],h=Ml(o,d,u,this.padding),m=Ml(l,p,c,this.padding),g=[s,h,m,this.filters];this.dataFormat!=="channelsLast"&&(n=en(n,[0,2,3,1]));let y=dN(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=en(y,[0,3,1,2])),this.bias!=null&&(y=gl(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(e){e=Nn(e);let t=e.slice(),n,r,s;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3):(n=3,r=1,s=2);let a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=Ml(t[r],o,a,this.padding),t[s]=Ml(t[s],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};DM.className="Conv2DTranspose";Pe.registerClass(DM);var FM=class extends nT{constructor(e){if(super(e),this.inputSpec=[new Kr({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new pe(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Nn(e),e.length!==5)throw new pe("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new pe("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Kr({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return ce(()=>{let n=Vt(e);if(n.shape.length!==5)throw new pe(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],a,i,o;this.dataFormat==="channelsFirst"?(o=2,a=3,i=4):(o=1,a=2,i=3);let l=r[o],u=r[a],c=r[i],d=this.kernelSize[0],p=this.kernelSize[1],h=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],b=Ml(l,m,d,this.padding),v=Ml(u,g,p,this.padding),k=Ml(c,y,h,this.padding),I=[s,b,v,k,this.filters];this.dataFormat!=="channelsLast"&&(n=en(n,[0,2,3,4,1]));let S=oO(n,this.kernel.read(),I,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=en(S,[0,4,1,2,3])),this.bias!==null&&(S=gl(S,this.bias.read(),this.dataFormat)),this.activation!==null&&(S=this.activation.apply(S)),S})}computeOutputShape(e){e=Nn(e);let t=e.slice(),n,r,s,a;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=Ml(t[r],u,i,this.padding),t[s]=Ml(t[s],c,o,this.padding),t[a]=Ml(t[a],d,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};FM.className="Conv3DTranspose";Pe.registerClass(FM);var eJ=class extends eT{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new pe("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new pe("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new pe(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=br(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=wr(t.depthwiseRegularizer),this.depthwiseConstraint=gs(t.depthwiseConstraint),this.pointwiseInitializer=br(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=wr(t.pointwiseRegularizer),this.pointwiseConstraint=gs(t.pointwiseConstraint)}build(e){if(e=Nn(e),e.length<this.rank+2)throw new pe(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new pe(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Kr({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return ce(()=>{e=Vt(e);let n;if(this.rank===1)throw new sn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=en(e,[0,2,3,1])),n=Fx(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=gl(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=en(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Tr(this.depthwiseInitializer),e.pointwiseInitializer=Tr(this.pointwiseInitializer),e.depthwiseRegularizer=rr(this.depthwiseRegularizer),e.pointwiseRegularizer=rr(this.pointwiseRegularizer),e.depthwiseConstraint=ms(this.depthwiseConstraint),e.pointwiseConstraint=ms(this.pointwiseConstraint),e}};eJ.className="SeparableConv";var OM=class extends eJ{constructor(e){super(2,e)}};OM.className="SeparableConv2D";Pe.registerClass(OM);var MM=class tJ extends eT{constructor(t){super(1,t),tJ.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!rM(t.kernelSize,"number",1,1))throw new pe(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};MM.className="Conv1D";Pe.registerClass(MM);var LM=class extends an{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ce(()=>{if(e=Vt(e),this.dataFormat==="channelsLast"){let n=Jk(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Jk(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Jk(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Jk(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};LM.className="Cropping2D";Pe.registerClass(LM);var PM=class extends an{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vr(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,l8e(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return ce(()=>{let n=Vt(e),r=n.shape;if(this.dataFormat==="channelsFirst"){n=en(n,[0,2,3,1]);let s=this.size[0]*r[2],a=this.size[1]*r[3],i=this.interpolation==="nearest"?Bi.resizeNearestNeighbor(n,[s,a]):Bi.resizeBilinear(n,[s,a]);return en(i,[0,3,1,2])}else{let s=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?Bi.resizeNearestNeighbor(n,[s,a]):Bi.resizeBilinear(n,[s,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};PM.className="UpSampling2D";Pe.registerClass(PM);function tqe(e,t,n=[1,1],r="valid",s,a){return ce(()=>{s==null&&(s=ll()),Vr(s);let i=RM(e,s);if(e.rank!==4)throw new pe(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new pe(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=cm(i,t,n,r==="same"?"same":"valid","NHWC",a),s==="channelsFirst"&&(i=en(i,[0,3,1,2])),i})}var zM=class extends XZ{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=br(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=gs(e.depthwiseConstraint),this.depthwiseRegularizer=wr(e.depthwiseRegularizer)}build(e){if(e=Nn(e),e.length<4)throw new pe(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new pe(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ce(()=>{e=Vt(e);let n=tqe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=gl(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=Nn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=el(t,this.kernelSize[0],this.padding,this.strides[0]),a=el(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Tr(this.depthwiseInitializer),e.depthwiseRegularizer=rr(this.depthwiseRegularizer),e.depthwiseConstraint=ms(this.depthwiseRegularizer),e}};zM.className="DepthwiseConv2D";Pe.registerClass(zM);function nJ(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new pe("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(a){return a==null||Array.isArray(a)?a:[a]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function rJ(e,t,n,r=!1,s,a,i=!1,o=!1){return ce(()=>{let l=t.shape.length;if(l<3)throw new pe(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(ol(2,l));t=en(t,u),a!=null,i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=Ke(Ke(s,"bool"),"float32"),s.rank===l-1&&(s=$s(s,-1)),s=en(s,u)),r&&(t=Yi(t,0),s!=null&&(s=Yi(s,0)));let c=[],d,p=n,h=t.shape[0],m=Fr(t),g;s!=null&&(g=Fr(s));for(let b=0;b<h;++b){let v=m[b],k=ce(()=>e(v,p));if(s==null)d=k[0],p=k[1];else{let I=ce(()=>{let S=g[b],N=at(Ti(S),S),T=Ae(oe(k[0],S),oe(p[0],N)),A=p.map((R,D)=>Ae(oe(k[1][D],S),oe(R,N)));return{output:T,newStates:A}});d=I.output,p=I.newStates}o&&c.push(d)}let y;return o&&(y=Yr(c,1)),[d,y,p]})}var tc=class sJ extends an{constructor(t){super(t);let n;if(t.cell==null)throw new pe("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new aT({cells:t.cell}):n=t.cell,n.stateSize==null)throw new pe("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Kr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return ol(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){PA(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let r=n[0],s;if(this.returnSequences?s=[t[0],t[1],r]:s=[t[0],r],this.returnState){let a=[];for(let i of n)a.push([t[0],i]);return[s].concat(a)}else return s}computeMask(t,n){return ce(()=>{Array.isArray(n)&&(n=n[0]);let r=this.returnSequences?n:null;if(this.returnState){let s=this.states.map(a=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<t;++r)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new sn("Constants support is not implemented in RNN yet.");PA(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new Kr({shape:[n,null,...r]});let s=[t[0]].concat(t.slice(2));this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!O.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new pe(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new Kr({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){ce(()=>{if(!this.stateful)throw new Ac("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape[0];if(r==null)throw new pe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Cr([r,s])):this.states_=[Cr([r,this.cell.stateSize])];else if(t==null)qt(this.states_),this.keptStates!=null&&(qt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Cr([r,s])):this.states_[0]=Cr([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new pe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):qt(this.states_);for(let s=0;s<this.states_.length;++s){let a=t[s],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,o=[r,i];if(!O.arraysEqual(a.shape,o))throw new pe(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[s]=a}}this.states_=this.states_.map(s=>cs(s.clone()))})}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});let a=nJ(t,r,s,this.numConstants);t=a.inputs,r=a.initialState,s=a.constants;let i=[],o=[];if(r!=null){n.initialState=r,i=i.concat(r),this.stateSpec=[];for(let l of r)this.stateSpec.push(new Kr({shape:l.shape}));o=o.concat(this.stateSpec)}if(s!=null&&(n.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof ul){let l=[t].concat(i),u=this.inputSpec.concat(o),c=this.inputSpec;this.inputSpec=u;let d=super.apply(l,n);return this.inputSpec=c,d}else return super.apply(t,n)}call(t,n){return ce(()=>{let r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;t=Vt(t),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new pe(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:s},l=rJ((h,m)=>{let g=this.cell.call([h].concat(m),o);return[g[0],g.slice(1)]},t,a,this.goBackwards,r,null,this.unroll,this.returnSequences),u=l[0],c=l[1],d=l[2];this.stateful&&this.resetStates(d,s);let p=this.returnSequences?c:u;return this.returnState?[p].concat(d):p})}getInitialState(t){return ce(()=>{let n=Cr(t.shape);return n=yt(n,[1,2]),n=dw(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?MA(n,[1,r]):n):this.cell.stateSize>1?[MA(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===sJ.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(t,n,r={}){let s=n.cell,a=Qo(s,r);return new t(Object.assign(n,{cell:a}))}};tc.className="RNN";Pe.registerClass(tc);var gw=class extends an{},rT=class extends gw{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,As(this.units,"units"),this.activation=pd(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=br(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=br(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=br(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wr(e.kernelRegularizer),this.recurrentRegularizer=wr(e.recurrentRegularizer),this.biasRegularizer=wr(e.biasRegularizer),this.kernelConstraint=gs(e.kernelConstraint),this.recurrentConstraint=gs(e.recurrentConstraint),this.biasConstraint=gs(e.biasConstraint),this.dropout=Kg([1,cd([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Kg([1,cd([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Nn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ce(()=>{if(e=e,e.length!==2)throw new pe(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hd({ones:()=>Ti(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hd({ones:()=>Ti(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let s,a=this.dropoutMask,i=this.recurrentDropoutMask;a!=null?s=Xl(oe(e,a),this.kernel.read()):s=Xl(e,this.kernel.read()),this.bias!=null&&(s=gl(s,this.bias.read())),i!=null&&(n=oe(n,i));let o=Ae(s,Xl(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:dd(this.activation),useBias:this.useBias,kernelInitializer:Tr(this.kernelInitializer),recurrentInitializer:Tr(this.recurrentInitializer),biasInitializer:Tr(this.biasInitializer),kernelRegularizer:rr(this.kernelRegularizer),recurrentRegularizer:rr(this.recurrentRegularizer),biasRegularizer:rr(this.biasRegularizer),activityRegularizer:rr(this.activityRegularizer),kernelConstraint:ms(this.kernelConstraint),recurrentConstraint:ms(this.recurrentConstraint),biasConstraint:ms(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};rT.className="SimpleRNNCell";Pe.registerClass(rT);var BM=class extends tc{constructor(e){e.cell=new rT(e),super(e)}call(e,t){return ce(()=>{this.cell.dropoutMask!=null&&(qt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(qt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return new e(t)}};BM.className="SimpleRNN";Pe.registerClass(BM);var sT=class extends gw{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new pe("GRUCell does not support reset_after parameter set to true.");this.units=e.units,As(this.units,"units"),this.activation=pd(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=pd(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=br(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=br(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=br(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wr(e.kernelRegularizer),this.recurrentRegularizer=wr(e.recurrentRegularizer),this.biasRegularizer=wr(e.biasRegularizer),this.kernelConstraint=gs(e.kernelConstraint),this.recurrentConstraint=gs(e.recurrentConstraint),this.biasConstraint=gs(e.biasConstraint),this.dropout=Kg([1,cd([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Kg([1,cd([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Nn(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ce(()=>{if(e=e,e.length!==2)throw new pe(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hd({ones:()=>Ti(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hd({ones:()=>Ti(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,a=this.recurrentDropoutMask,i,o,l;0<this.dropout&&this.dropout<1&&(e=oe(e,s[0]));let u=Xl(e,this.kernel.read());this.useBias&&(u=gl(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=oe(r,a[0]));let c=this.recurrentKernel.read(),[d,p]=Xa(c,[2*this.units,this.units],c.rank-1),h=Xl(r,d),[m,g,y]=Xa(u,3,u.rank-1),[b,v]=Xa(h,2,h.rank-1);i=this.recurrentActivation.apply(Ae(m,b)),o=this.recurrentActivation.apply(Ae(g,v));let k=Xl(oe(o,r),p);l=this.activation.apply(Ae(y,k));let I=Ae(oe(i,r),oe(Ae(1,or(i)),l));return[I,I]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:dd(this.activation),recurrentActivation:dd(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Tr(this.kernelInitializer),recurrentInitializer:Tr(this.recurrentInitializer),biasInitializer:Tr(this.biasInitializer),kernelRegularizer:rr(this.kernelRegularizer),recurrentRegularizer:rr(this.recurrentRegularizer),biasRegularizer:rr(this.biasRegularizer),activityRegularizer:rr(this.activityRegularizer),kernelConstraint:ms(this.kernelConstraint),recurrentConstraint:ms(this.recurrentConstraint),biasConstraint:ms(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};sT.className="GRUCell";Pe.registerClass(sT);var WM=class extends tc{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new sT(e),super(e)}call(e,t){return ce(()=>{this.cell.dropoutMask!=null&&(qt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(qt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};WM.className="GRU";Pe.registerClass(WM);var yw=class extends gw{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,As(this.units,"units"),this.activation=pd(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=pd(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=br(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=br(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=br(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=wr(e.kernelRegularizer),this.recurrentRegularizer=wr(e.recurrentRegularizer),this.biasRegularizer=wr(e.biasRegularizer),this.kernelConstraint=gs(e.kernelConstraint),this.recurrentConstraint=gs(e.recurrentConstraint),this.biasConstraint=gs(e.biasConstraint),this.dropout=Kg([1,cd([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Kg([1,cd([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Nn(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,a=this.units;r=new(t=class extends $o{apply(i,o){let l=s.apply([a]),u=new UN().apply([a]),c=s.apply([a*2]);return OU(OU(l,u),c)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ce(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new pe(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hd({ones:()=>Ti(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hd({ones:()=>Ti(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,i=this.recurrentDropoutMask,o,l,u,c;0<this.dropout&&this.dropout<1&&(e=oe(e,a[0]));let d=Xl(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=oe(r,i[0])),d=Ae(d,Xl(r,this.recurrentKernel.read())),this.useBias&&(d=gl(d,this.bias.read()));let[p,h,m,g]=Xa(d,4,d.rank-1);o=this.recurrentActivation.apply(p),l=this.recurrentActivation.apply(h),u=Ae(oe(l,s),oe(o,this.activation.apply(m))),c=this.recurrentActivation.apply(g);let y=oe(c,this.activation.apply(u));return[y,y,u]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:dd(this.activation),recurrentActivation:dd(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Tr(this.kernelInitializer),recurrentInitializer:Tr(this.recurrentInitializer),biasInitializer:Tr(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:rr(this.kernelRegularizer),recurrentRegularizer:rr(this.recurrentRegularizer),biasRegularizer:rr(this.biasRegularizer),activityRegularizer:rr(this.activityRegularizer),kernelConstraint:ms(this.kernelConstraint),recurrentConstraint:ms(this.recurrentConstraint),biasConstraint:ms(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};yw.className="LSTMCell";Pe.registerClass(yw);var VM=class extends tc{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new yw(e),super(e)}call(e,t){return ce(()=>{this.cell.dropoutMask!=null&&(qt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(qt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};VM.className="LSTM";Pe.registerClass(VM);var aT=class extends gw{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ce(()=>{e=e;let n=e.slice(1),r=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(n.splice(0,i.stateSize.length)):r.push(n.splice(0,1));r.reverse();let s=[],a;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],i===0?a=[e[0]].concat(n):a=[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(let i of s.slice().reverse())n.push(...i);return[a[0]].concat(n)})}build(e){PA(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{jp(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let r=[];for(let s of t.cells)r.push(Qo(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return zA(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,s=e.splice(r);for(let a=0;a<n.weights.length;++a)t.push([n.weights[a],s[a]])}pM(t)}};aT.className="StackedRNNCells";Pe.registerClass(aT);function hd(e){let{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>a!=null?a(t(),n):iZ(t(),n),o=()=>hw(i,t,r);return!s||s<=1?cs(o().clone()):Array(s).fill(void 0).map(o).map(l=>cs(l.clone()))}var nqe=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n},aJ=class extends tc{constructor(e){if(e.unroll)throw new sn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new sn("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Kr({ndim:5})]}call(e,t){return ce(()=>{if(this.cell.dropoutMask!=null&&(qt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(qt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new pe("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ce(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)],a=Cr(s);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){ce(()=>{if(!this.stateful)throw new Ac("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(n[0]==null)throw new pe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Cr(s)):this.states_=[Cr(s)];else if(e==null)qt(this.states_),this.keptStates!=null&&(qt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Cr(s)):this.states_[0]=Cr(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new pe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):qt(this.states_);for(let a=0;a<this.states_.length;++a){let i=e[a],o=s;if(!O.arraysEqual(i.shape,o))throw new pe(`State ${a} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[a]=i}}this.states_=this.states_.map(a=>cs(a.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o=t==="channelsFirst",l=e[o?3:2],u=e[o?4:3],c=el(l,r[0],s,a[0],i[0]),d=el(u,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}};aJ.className="ConvRNN2D";var iT=class extends yw{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,As(this.filters,"filters"),this.kernelSize=wg(n,2,"kernelSize"),this.kernelSize.forEach(o=>As(o,"kernelSize")),this.strides=wg(r||1,2,"strides"),this.strides.forEach(o=>As(o,"strides")),this.padding=s||"valid",Qi(this.padding),this.dataFormat=a||"channelsLast",Vr(this.dataFormat),this.dilationRate=wg(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>As(o,"dilationRate"))}build(e){var t;e=Nn(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new pe(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],s=4,a=this.kernelSize.concat([r,this.filters*s]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,u=this.filters;o=new(t=class extends $o{apply(c,d){let p=l.apply([u]),h=Ha([u]),m=l.apply([u*2]);return sM([p,h,m])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ce(()=>{if(e.length!==3)throw new pe(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],s=e[1],a=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hd({ones:()=>Ti(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(j,H,P)=>!H||!H[P]?j:oe(H[P],j),u=l(r,o,0),c=l(r,o,1),d=l(r,o,2),p=l(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hd({ones:()=>Ti(s),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,m=l(s,h,0),g=l(s,h,1),y=l(s,h,2),b=l(s,h,3),v=3,[k,I,S,N]=Xa(this.kernel.read(),i,v),[T,A,R,D]=this.useBias?Xa(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,k,T,this.padding),c=this.inputConv(c,I,A,this.padding),d=this.inputConv(d,S,R,this.padding),p=this.inputConv(p,N,D,this.padding);let[$,_,L,z]=Xa(this.recurrentKernel.read(),i,v);m=this.recurrentConv(m,$),g=this.recurrentConv(g,_),y=this.recurrentConv(y,L),b=this.recurrentConv(b,z);let W=this.recurrentActivation.apply(Ae(u,m)),G=this.recurrentActivation.apply(Ae(c,g)),q=Ae(oe(G,a),oe(W,this.activation.apply(Ae(d,y)))),B=oe(this.recurrentActivation.apply(Ae(p,b)),this.activation.apply(q));return[B,B,q]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=nqe(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let s=_a(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?gl(s,n,this.dataFormat):s}recurrentConv(e,t){return _a(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};iT.className="ConvLSTM2DCell";Pe.registerClass(iT);var UM=class extends aJ{constructor(e){let t=new iT(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};UM.className="ConvLSTM2D";Pe.registerClass(UM);var oT=class extends an{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=Vt(e);if(0<this.rate&&this.rate<1){let r=t.training==null?!1:t.training,s=this.getNoiseShape(n);return hw(()=>iZ(n,this.rate,s,this.seed),()=>n,r)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};oT.className="Dropout";Pe.registerClass(oT);var GM=class extends oT{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};GM.className="SpatialDropout1D";Pe.registerClass(GM);var jM=class extends an{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,As(this.units,"units"),this.activation=pd(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=br(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=br(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=gs(e.kernelConstraint),this.biasConstraint=gs(e.biasConstraint),this.kernelRegularizer=wr(e.kernelRegularizer),this.biasRegularizer=wr(e.biasRegularizer),this.activityRegularizer=wr(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Nn(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Nn(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=Vt(e),r=QY(this.activation.getClassName()),s;return r!=null?s=Xl(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=Xl(n,this.kernel.read()),this.bias!=null&&(s=gl(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let e={units:this.units,activation:dd(this.activation),useBias:this.useBias,kernelInitializer:Tr(this.kernelInitializer),biasInitializer:Tr(this.biasInitializer),kernelRegularizer:rr(this.kernelRegularizer),biasRegularizer:rr(this.biasRegularizer),activityRegularizer:rr(this.activityRegularizer),kernelConstraint:ms(this.kernelConstraint),biasConstraint:ms(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};jM.className="Dense";Pe.registerClass(jM);var HM=class extends an{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Nn(e);for(let t of e.slice(1))if(t==null)throw new pe(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Kc(e,1)]}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=Vt(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let s=2;s<n.rank;++s)r.push(s);r.push(1),n=en(n,r)}return f8e(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};HM.className="Flatten";Pe.registerClass(HM);var qM=class extends an{constructor(e){super(e),this.supportsMasking=!0,this.activation=pd(e.activation)}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=Vt(e);return this.activation.apply(n)})}getConfig(){let e={activation:dd(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};qM.className="Activation";Pe.registerClass(qM);var KM=class extends an{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ce(()=>(e=Vt(e),p8e(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};KM.className="RepeatVector";Pe.registerClass(KM);var XM=class extends an{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),s=1,a=null;for(let o=0;o<r.length;++o){let l=r[o];if(this.isUnknown(l))if(a===null)a=o;else throw new pe("Can only specifiy one unknown dimension.");else s*=l}let i=Kc(e);if(a!==null){if(s===0||i%s!==0)throw new pe(n);r[a]=i/s}else if(i!==s)throw new pe(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=Vt(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return ue(n,s)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};XM.className="Reshape";Pe.registerClass(XM);var YM=class extends an{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=ol(1,e.dims.length+1);if(!O.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Kr({ndim:this.dims.length+1})]}computeOutputShape(e){e=Nn(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return en(Vt(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};YM.className="Permute";Pe.registerClass(YM);var ZM=class extends an{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Vt(e);return Rv(kh(n,this.maskValue),-1)}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=Vt(e),r=Rv(kh(n,this.maskValue),-1,!0);return oe(n,Ke(r,n.dtype))})}};ZM.className="Masking";Pe.registerClass(ZM);var JM=class extends an{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Vn(e.inputLength))}this.inputDim=e.inputDim,As(this.inputDim,"inputDim"),this.outputDim=e.outputDim,As(this.outputDim,"outputDim"),this.embeddingsInitializer=br(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=wr(e.embeddingsRegularizer),this.activityRegularizer=wr(e.activityRegularizer),this.embeddingsConstraint=gs(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ce(()=>this.maskZero?(e=Vt(e),kh(e,gn(e))):null)}computeOutputShape(e){if(e=Nn(e),this.inputLength==null)return[...e,this.outputDim];let t=Vn(this.inputLength);if(t.length!==e.length-1)throw new pe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let s=t[r],a=e[r+1];if(s!=null&&a!=null&&s!==a)throw new pe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=Vt(e);n.dtype!=="int32"&&(n=Vu(n,"int32"));let r=aZ(this.embeddings.read(),ue(n,[n.size]));return ue(r,Nn(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Tr(this.embeddingsInitializer),embeddingsRegularizer:rr(this.embeddingsRegularizer),activityRegularizer:rr(this.activityRegularizer),embeddingsConstraint:ms(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};JM.className="Embedding";Pe.registerClass(JM);var mm=class extends an{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new sn}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let s=e[e.length-t.length+r],a=t[r];if(s==null||a==null||s<0||a<0)n.push(null);else if(s===1)n.push(a);else if(a===1)n.push(s);else{if(s!==a)throw new pe("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Nn(e)]),e=e,e.length<2)throw new pe(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=qc(t),t.length>1)throw new pe(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){let a=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let r=e.map(s=>s.length);e.indexOf(null)===-1&&qc(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ce(()=>{if(e=e,this.reshapeRequired){let n=[],r=e.map(s=>s.rank);if(r.indexOf(null)===-1){let s=cd(r);for(let a of e){let i=a.rank;for(let o=0;o<s-i;++o)a=dw(a,1);n.push(a)}return this.mergeFunction(n)}else{let s=!1;for(let o of e){let l=o.rank;if(l==null){let u=o.shape,c=u[0],d=u.slice(1).concat([c]),p=ue(o,[c].concat(Kc(u.slice(1))));p=en(p,[1,0]),p=ue(p,d),n.push(p),s=!0}else if(l>1){let u=ol(1,l).concat([0]);n.push(en(o,u)),s=!0}else n.push(o)}let a=this.mergeFunction(n),i=a.rank;if(s){if(i==null){let o=a.shape,l=o.length,u=o[l-1],c=[u].concat(o.slice(0,o.length-1));a=ue(en(ue(a,[-1,u]),[1,0]),c)}else if(i>1){let o=[i-1].concat(ol(0,i-1));a=en(a,o)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(let r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=qc(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return ce(()=>{if(t==null)return null;if(!Array.isArray(t))throw new pe("`mask` should be an Array");if(!Array.isArray(e))throw new pe("`inputs` should be an Array");if(t.length!==e.length)throw new pe(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:$s(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=Io(n,t[r]);return n})}},QM=class extends mm{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ae(t,e[n]);return t})}};QM.className="Add";Pe.registerClass(QM);var eL=class extends mm{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=oe(t,e[n]);return t})}};eL.className="Multiply";Pe.registerClass(eL);var tL=class extends mm{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ae(t,e[n]);return oe(1/e.length,t)})}};tL.className="Average";Pe.registerClass(tL);var nL=class extends mm{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=cu(t,e[n]);return t})}};nL.className="Maximum";Pe.registerClass(nL);var rL=class extends mm{constructor(e){super(e)}mergeFunction(e){return ce(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ld(t,e[n]);return t})}};rL.className="Minimum";Pe.registerClass(rL);var sL=class extends mm{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new pe("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let r of e)if(r!=null){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let s=e[r].slice();s.splice(this.axis,1);let a=!1;for(let i of n)if(O.arraysEqual(i,s)){a=!0;break}a||n.push(s)}if(n.length>1)throw new pe("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ce(()=>sM(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new pe("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let s of t.slice(1)){if(n[r]==null||s[r]==null){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new pe("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new pe("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new pe(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ce(()=>{let n=!0;if(t.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;let r=[];for(let a=0;a<e.length;++a)t[a]==null?r.push(Ke(Ti(e[a]),"bool")):t[a].rank<e[a].rank?r.push($s(t[a],-1)):r.push(t[a]);let s=Jn(r,this.axis);return uN(s,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};sL.className="Concatenate";Pe.registerClass(sL);function Mb(e,t){for(;e<0;)e+=t;return e}function rqe(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new sn("batchDot is not implemented for tensors of 4D or higher rank yet");if(O.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),O.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new sn("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,s=t.shape.length;n==null&&(n=[r-1,s-2]);let a=n;return ce(()=>{let i;if(r>s){i=r-s;let l=[];for(let u=0;u<i;++u)l.push(1);t=ue(t,t.shape.concat(l))}else if(s>r){i=s-r;let l=[];for(let u=0;u<i;++u)l.push(1);e=ue(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)a[0]===a[1]?o=yt(oe(e,t),a[0]):o=yt(oe(en(e,[1,0]),t),a[1]);else{let l=a[0]!==e.shape.length-1,u=a[1]===t.shape.length-1;o=Qt(e,t,l,u)}if(i>0){let l;r>s?l=r+s-3:l=r-1;let u=[];for(let c=l;c<l+i;++c)u.push(c);o=zd(o,u)}return o.shape.length===1&&(o=$s(o,1)),o})}var aL=class extends mm{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){O.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new sn("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new pe(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new pe(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((s,a)=>Mb(s,e[a].shape.length)):r=[Mb(this.axes,t.shape.length),Mb(this.axes,n.shape.length)],this.normalize&&(t=RI(t,r[0]),n=RI(n,r[1])),rqe(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Mb(this.axes,e.length),Mb(this.axes,t.length)],n}computeOutputShape(e){O.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new sn("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let s=t.concat(n);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};aL.className="Dot";Pe.registerClass(aL);var iL=class extends an{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=Vt(e);return hw(()=>Ae(VN(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};iL.className="GaussianNoise";Pe.registerClass(iL);var oL=class extends an{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ce(()=>{this.invokeCallHook(e,t);let n=Vt(e);return this.rate>0&&this.rate<1?hw(()=>{let r=Math.sqrt(this.rate/(1-this.rate));return oe(n,VN(n.shape,1,r))},()=>n,t.training||!1):n})}};oL.className="GaussianDropout";Pe.registerClass(oL);var lL=class extends an{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Vt(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ce(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return hw(()=>{let r=Vt(e),s=-1.6732632423543772*1.0507009873554805,a=Ju(Ld(n),this.rate);a=Vu(a,"float32");let i=((1-this.rate)*(1+this.rate*s**2))**-.5,o=-i*s*this.rate,l=Ae(oe(r,a),oe(Ae(a,-1),s));return Ae(oe(l,i),o)},()=>Vt(e),t.training||!1)}return e})}};lL.className="AlphaDropout";Pe.registerClass(lL);function Pv(e,t,n,r,s,a=.001){let i;if(e.rank===2)i=Y3(e,t,n,r,s,a);else if(e.rank===3)i=Z3(e,t,n,r,s,a);else if(e.rank===4)i=J3(e,t,n,r,s,a);else throw new sn(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function sqe(e,t,n,r,s=.001){return ce(()=>{let a=rw(e,r),i=a.mean,o=a.variance;return[Pv(e,i,o,n,t,s),i,o]})}function aqe(e,t,n,r,s=.001){return ce(()=>{let a=rw(e,r),i=a.mean,o=a.variance,l=[];for(let h of ol(0,e.rank))r.indexOf(h)!==-1?l.push(1):l.push(e.shape[h]);let u=ue(i,l),c=ue(o,l),d=t==null?null:ue(t,l),p=n==null?null:ue(n,l);return[Pv(e,u,c,p,d,s),i,o]})}function iqe(e,t,n,r,s=.001){return O.arraysEqual(r.slice().sort(),ol(0,e.rank-1))?sqe(e,t,n,r,s):aqe(e,t,n,r,s)}var uL=class extends an{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=br(e.betaInitializer||"zeros"),this.gammaInitializer=br(e.gammaInitializer||"ones"),this.movingMeanInitializer=br(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=br(e.movingVarianceInitializer||"ones"),this.betaConstraint=gs(e.betaConstraint),this.gammaConstraint=gs(e.gammaConstraint),this.betaRegularizer=wr(e.betaRegularizer),this.gammaRegularizer=wr(e.gammaRegularizer)}build(e){e=Nn(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new pe(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Kr({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ce(()=>{let n=t.training==null?!1:t.training,r=Vt(e),s=r.shape,a=s.length,i=ol(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);let l=Sh(1,a);l[o]=s[o];let u=i.slice();u.sort();let c=!O.arraysEqual(u,ol(0,a).slice(0,a-1)),d=()=>{if(c){let y=ue(this.movingMean.read(),l),b=ue(this.movingVariance.read(),l),v=this.center?ue(this.beta.read(),l):null,k=this.scale?ue(this.gamma.read(),l):null;return Pv(r,y,b,v,k,this.epsilon)}else return Pv(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[p,h,m]=iqe(r,this.gamma.read(),this.beta.read(),i,this.epsilon),g=(y,b,v)=>{ce(()=>{let k=1-v,I=y.read(),S=oe(at(I,b),k);y.write(at(I,S))})};return g(this.movingMean,h,this.momentum),g(this.movingVariance,m,this.momentum),p})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Tr(this.betaInitializer),gammaInitializer:Tr(this.gammaInitializer),movingMeanInitializer:Tr(this.movingMeanInitializer),movingVarianceInitializer:Tr(this.movingVarianceInitializer),betaRegularizer:rr(this.betaRegularizer),gammaRegularizer:rr(this.gammaRegularizer),betaConstraint:ms(this.betaConstraint),gammaConstraint:ms(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};uL.className="BatchNormalization";Pe.registerClass(uL);var cL=class extends an{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=br(e.betaInitializer||"zeros"),this.gammaInitializer=br(e.gammaInitializer||"ones"),this.betaRegularizer=wr(e.betaRegularizer),this.gammaRegularizer=wr(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Nn(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(let s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==qc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>e[s]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Vt(e),r=n.shape,s=r.length;return ce(()=>{let{mean:a,variance:i}=rw(n,this.axis,!0),o=Sh(1,s);for(let h of this.axis)o[h]=r[h];let l=h=>h!=null&&h.shape.length!==s?ue(h,o):h,u=this.scale?l(this.gamma.read()):null,c=this.center?l(this.beta.read()):null,d=[],p=[];for(let h=0;h<s;++h)this.axis.indexOf(h)!==-1?(d.push(r[h]),p.push(1)):(d.push(1),p.push(r[h]));return a=xi(a,d),i=xi(i,d),u!=null&&(u=xi(u,p)),c!=null&&(c=xi(c,p)),Pv(n,a,i,c,u,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Tr(this.betaInitializer),gammaInitializer:Tr(this.gammaInitializer),betaRegularizer:rr(this.betaRegularizer),gammaRegularizer:rr(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};cL.className="LayerNormalization";Pe.registerClass(cL);function oqe(e,t,n){return ce(()=>{if(e.rank!==4)throw new pe(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new pe("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=ll()),n!=="channelsLast"&&n!=="channelsFirst")throw new pe(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],ml(e,r)})}var dL=class extends an{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?ll():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new pe(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new pe(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new pe(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Kr({ndim:4})]}computeOutputShape(e){e=Nn(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return ce(()=>oqe(Vt(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};dL.className="ZeroPadding2D";Pe.registerClass(dL);function lT(e,t,n,r,s,a){return ce(()=>{Vr(s),tZ(a),Qi(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=ll()),a==null&&(a="max"),e=RM(e,s);let i,o=r==="same"?"same":"valid";return a==="max"?i=Ss(e,t,n,o):i=Zu(e,t,n,o),s==="channelsFirst"&&(i=en(i,[0,3,1,2])),i})}function iJ(e,t,n,r,s,a){return ce(()=>{Vr(s),tZ(a),Qi(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=ll()),a==null&&(a="max"),e=KZ(e,s);let i,o=r==="same"?"same":"valid";return a==="max"?i=kO(e,t,n,o):i=X3(e,t,n,o),s==="channelsFirst"&&(i=en(i,[0,4,1,2,3])),i})}var oJ=class extends an{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new pe(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(As(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new pe(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);As(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Qi(this.padding),this.inputSpec=[new Kr({ndim:3})]}computeOutputShape(e){e=Nn(e);let t=el(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ce(()=>{this.invokeCallHook(e,t),e=dw(Vt(e),2);let n=this.poolingFunction(Vt(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return zd(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},pL=class extends oJ{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Vr(s),Qi(r),lT(e,t,n,r,s,"max")}};pL.className="MaxPooling1D";Pe.registerClass(pL);var hL=class extends oJ{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Vr(s),Qi(r),lT(e,t,n,r,s,"avg")}};hL.className="AveragePooling1D";Pe.registerClass(hL);var lJ=class extends an{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new pe(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];As(this.poolSize,"poolSize"),As(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vr(this.dataFormat),Qi(this.padding),this.inputSpec=[new Kr({ndim:4})]}computeOutputShape(e){e=Nn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=el(t,this.poolSize[0],this.padding,this.strides[0]),n=el(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return ce(()=>(this.invokeCallHook(e,t),this.poolingFunction(Vt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},fL=class extends lJ{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Vr(s),Qi(r),lT(e,t,n,r,s,"max")}};fL.className="MaxPooling2D";Pe.registerClass(fL);var mL=class extends lJ{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Vr(s),Qi(r),lT(e,t,n,r,s,"avg")}};mL.className="AveragePooling2D";Pe.registerClass(mL);var uJ=class extends an{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new pe(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];As(this.poolSize,"poolSize"),As(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vr(this.dataFormat),Qi(this.padding),this.inputSpec=[new Kr({ndim:5})]}computeOutputShape(e){e=Nn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=el(t,this.poolSize[0],this.padding,this.strides[0]),n=el(n,this.poolSize[1],this.padding,this.strides[1]),r=el(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return ce(()=>(this.invokeCallHook(e,t),this.poolingFunction(Vt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},gL=class extends uJ{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Vr(s),Qi(r),iJ(e,t,n,r,s,"max")}};gL.className="MaxPooling3D";Pe.registerClass(gL);var yL=class extends uJ{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Vr(s),Qi(r),iJ(e,t,n,r,s,"avg")}};yL.className="AveragePooling3D";Pe.registerClass(yL);var cJ=class extends an{constructor(e){super(e),this.inputSpec=[new Kr({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new sn}},xL=class extends cJ{constructor(e){super(e||{})}call(e,t){return ce(()=>{let n=Vt(e);return Sr(n,1)})}};xL.className="GlobalAveragePooling1D";Pe.registerClass(xL);var bL=class extends cJ{constructor(e){super(e||{})}call(e,t){return ce(()=>{let n=Vt(e);return Hi(n,1)})}};bL.className="GlobalMaxPooling1D";Pe.registerClass(bL);var dJ=class extends an{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vr(this.dataFormat),this.inputSpec=[new Kr({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new sn}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},vL=class extends dJ{call(e,t){return ce(()=>{let n=Vt(e);return this.dataFormat==="channelsLast"?Sr(n,[1,2]):Sr(n,[2,3])})}};vL.className="GlobalAveragePooling2D";Pe.registerClass(vL);var wL=class extends dJ{call(e,t){return ce(()=>{let n=Vt(e);return this.dataFormat==="channelsLast"?Hi(n,[1,2]):Hi(n,[2,3])})}};wL.className="GlobalMaxPooling2D";Pe.registerClass(wL);var pJ=class extends an{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,s=Qo(r,n);delete t.layer;let a={layer:s};return Object.assign(a,t),new e(a)}},kL=class extends pJ{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Nn(e),e.length<3)throw new pe(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Nn(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return ce(()=>(e=Vt(e),rJ((n,r)=>[Vt(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};kL.className="TimeDistributed";Pe.registerClass(kL);function lqe(e){hm(o8e,"BidirectionalMergeMode",e)}var uqe="concat",IL=class extends pJ{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Qo(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Qo(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?uqe:e.mergeMode,lqe(this.mergeMode),e.weights)throw new sn("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,s;return this.returnState&&(s=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):Ga(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let s=nJ(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let a=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new pe("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);let u=n.map(c=>new Kr({shape:c.shape}));this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),i.push(...u)}if(r!=null)throw new sn("Support for constants in Bidirectional layers is not implemented yet.");let o=a[0]instanceof ul;for(let l of a)if(l instanceof ul!==o)throw new pe("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let l=[e].concat(a),u=this.inputSpec.concat(i),c=this.inputSpec;this.inputSpec=u;let d=super.apply(l,t);return this.inputSpec=c,d}else return super.apply(e,t)}call(e,t){return ce(()=>{let n=t.initialState,r,s;if(n==null)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=Yi(s,1));let i;return this.mergeMode==="concat"?i=sM([r,s]):this.mergeMode==="sum"?i=Ae(r,s):this.mergeMode==="ave"?i=oe(.5,Ae(r,s)):this.mergeMode==="mul"?i=oe(r,s):this.mergeMode==null&&(i=[r,s]),this.returnState?this.mergeMode==null?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){jp(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),jp(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let r=this.forwardLayer.states.map(s=>null);return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Qo(t.layer);if(delete t.layer,t.numConstants!=null)throw new sn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};IL.className="Bidirectional";Pe.registerClass(IL);var SL=class extends an{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ce(()=>(e=Vt(e),e.dtype!=="float32"&&(e=Vu(e,"float32")),Ae(oe(e,this.scale),this.offset)))}};SL.className="Rescaling";Pe.registerClass(SL);var{resizeBilinear:cqe,cropAndResize:dqe}=Bi,CL=class extends an{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,o){return ce(()=>{let l,u=!1,c=t/a,d=n/i,p=(r+t)/a,h=(s+n)/i,m=[c,d,p,h],g=[];e.rank===3?(u=!0,l=Yr([e])):l=e;for(let k=0;k<l.shape[0];k++)g.push(m);let y=$a(g,[g.length,4]),b=Ih(0,g.length,1,"int32"),v=dqe(l,y,b,[r,s],"nearest");return Vu(u?Vt(Fr(v)):v,o)})}upsize(e,t,n,r){return ce(()=>{let s=cqe(e,[t,n]);return Vu(s,r)})}call(e,t){return ce(()=>{let n=Vt(e),r=n.dtype,s=n.shape,a=s[s.length-3],i=s[s.length-2],o=0;a!==this.height&&(o=Math.floor((a-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,a,i,r):this.upsize(e,this.height,this.width,r)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Nn(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};CL.className="CenterCrop";Pe.registerClass(CL);function pqe(e,t,n,r){let s=Vt(e);if(s.dtype!=="int32"&&(s=Vu(s,"int32")),t==="int")return s;let a=s.shape;if(s.rank===0&&(s=$s(s,-1)),t==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=$s(s,-1)),s.rank>2)throw new pe(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);let i=["multiHot","oneHot"].includes(t),o=s,l;if(typeof r<"u"&&t==="count"?l=NI(o,r,n,i):l=NI(o,[],n,i),t!=="tfIdf")return l;if(r)return oe(l,r);throw new pe("When outputMode is 'tfIdf', weights must be provided.")}var NL=class extends an{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Nn(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return ce(()=>{e=Vt(e),e.dtype!=="int32"&&(e=Vu(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new pe(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Vt(t.countWeights)}let r=Hi(e),s=Wg(e),a=Ma(this.numTokens,r).bufferSync().get(0),i=Ju(s,0).bufferSync().get(0);if(!(a&&i))throw new pe(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return pqe(e,this.outputMode,this.numTokens,n)})}};NL.className="CategoryEncoding";Pe.registerClass(NL);var hqe=["bilinear","nearest"],JU=new Set(hqe),TL=class extends an{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(JU.has(e.interpolation))this.interpolation=e.interpolation;else throw new pe(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Nn(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ce(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return Bi.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Bi.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...JU]} are supported`)})}};TL.className="Resizing";Pe.registerClass(TL);var hJ=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};hJ.className="RandomSeed";var fJ=class extends an{constructor(e){super(e),this.randomGenerator=new hJ(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};fJ.className="BaseRandomLayer";var fqe=["bilinear","nearest"],QU=new Set(fqe),$L=class extends fJ{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new pe(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new pe(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new pe(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(QU.has(n))this.interpolation=n;else throw new pe(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Nn(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return ce(()=>{let n=Vt(e);this.imgHeight=n.shape[n.shape.length-3];let r=n.shape[n.shape.length-2];this.widthFactor=Ld([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let s=this.widthFactor.dataSync()[0]*r;s=Math.round(s);let a=[this.imgHeight,s];switch(this.interpolation){case"bilinear":return Bi.resizeBilinear(e,a);case"nearest":return Bi.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...QU]} are supported`)}})}};$L.className="RandomWidth";Pe.registerClass($L);function mqe(e){return new Lx(e)}function gqe(e){return new EM(e)}function yqe(e){return new NM(e)}function xqe(e){return new TM(e)}function bqe(e){return new $M(e)}function vqe(e){return new AM(e)}function wqe(e){return new _M(e)}function kqe(e){return new MM(e)}function Iqe(e){return new tT(e)}function Sqe(e){return new DM(e)}function Cqe(e){return new nT(e)}function Nqe(e){return new FM(e)}function Tqe(e){return new OM(e)}function $qe(e){return new LM(e)}function Eqe(e){return new PM(e)}function _qe(e){return new zM(e)}function Aqe(e){return new qM(e)}function Rqe(e){return new jM(e)}function Dqe(e){return new oT(e)}function Fqe(e){return new GM(e)}function Oqe(e){return new HM(e)}function Mqe(e){return new KM(e)}function Lqe(e){return new XM(e)}function Pqe(e){return new YM(e)}function zqe(e){return new JM(e)}function Bqe(e){return new QM(e)}function Wqe(e){return new tL(e)}function Vqe(e){return new sL(e)}function Uqe(e){return new nL(e)}function Gqe(e){return new rL(e)}function jqe(e){return new eL(e)}function Hqe(e){return new aL(e)}function qqe(e){return new uL(e)}function Kqe(e){return new cL(e)}function Xqe(e){return new dL(e)}function EL(e){return new hL(e)}function Yqe(e){return EL(e)}function Zqe(e){return EL(e)}function _L(e){return new mL(e)}function Jqe(e){return _L(e)}function Qqe(e){return _L(e)}function AL(e){return new yL(e)}function e9e(e){return AL(e)}function t9e(e){return AL(e)}function n9e(e){return new xL(e)}function r9e(e){return new vL(e)}function mJ(e){return new bL(e)}function gJ(e){return new wL(e)}function yJ(e){return new pL(e)}function xJ(e){return new fL(e)}function s9e(e){return new gL(e)}function a9e(e){return new WM(e)}function i9e(e){return new sT(e)}function o9e(e){return new VM(e)}function l9e(e){return new yw(e)}function u9e(e){return new BM(e)}function c9e(e){return new rT(e)}function d9e(e){return new UM(e)}function p9e(e){return new iT(e)}function h9e(e){return new tc(e)}function f9e(e){return new aT(e)}function m9e(e){return new IL(e)}function g9e(e){return new kL(e)}var y9e=mJ,x9e=gJ,b9e=yJ,v9e=xJ;function w9e(e){return new iL(e)}function k9e(e){return new oL(e)}function I9e(e){return new lL(e)}function S9e(e){return new ZM(e)}function C9e(e){return new SL(e)}function N9e(e){return new CL(e)}function T9e(e){return new TL(e)}function $9e(e){return new NL(e)}function E9e(e){return new $L(e)}var bJ={};Kt(bJ,{MAPE:()=>B9e,MSE:()=>U9e,binaryAccuracy:()=>_9e,binaryCrossentropy:()=>A9e,categoricalAccuracy:()=>D9e,categoricalCrossentropy:()=>F9e,cosineProximity:()=>L9e,mape:()=>W9e,meanAbsoluteError:()=>P9e,meanAbsolutePercentageError:()=>z9e,meanSquaredError:()=>V9e,mse:()=>G9e,precision:()=>O9e,r2Score:()=>j9e,recall:()=>M9e,sparseCategoricalAccuracy:()=>R9e});function _9e(e,t){return vM(e,t)}function A9e(e,t){return kZ(e,t)}function R9e(e,t){return IZ(e,t)}function D9e(e,t){return wM(e,t)}function F9e(e,t){return kM(e,t)}function O9e(e,t){return wZ(e,t)}function M9e(e,t){return h7e(e,t)}function L9e(e,t){return bM(e,t)}function P9e(e,t){return ZN(e,t)}function z9e(e,t){return Px(e,t)}function B9e(e,t){return Px(e,t)}function W9e(e,t){return Px(e,t)}function V9e(e,t){return fm(e,t)}function U9e(e,t){return fm(e,t)}function G9e(e,t){return fm(e,t)}function j9e(e,t){return f7e(e,t)}var vJ={};Kt(vJ,{modelFromJSON:()=>G7e});var wJ={};Kt(wJ,{l1:()=>q9e,l1l2:()=>H9e,l2:()=>K9e});function H9e(e){return new mw(e)}function q9e(e){return Z7e(e)}function K9e(e){return J7e(e)}var kJ=class extends Xg{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Du))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function e2(e,t){return e<t}function e6(e,t){return e>t}var IJ=class extends kJ{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new sn("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=e2:this.mode==="max"?this.monitorFunc=e6:this.monitor.indexOf("acc")!==-1?this.monitorFunc=e6:this.monitorFunc=e2,this.monitorFunc===e2&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===e2?1/0:-1/0}async onEpochEnd(e,t){await $c(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function X9e(e){return new IJ(e)}var Y9e={earlyStopping:X9e},Z9e=xe();Z9e.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var pi;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(pi||(pi={}));var t6;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(t6||(t6={}));var RL={};function J9e(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};RL[e]=n}function SJ(e){return RL[e]}function Q9e(e){delete RL[e]}function M(e,t,n,r,s){let a=t.inputParams[e];if(a&&a.inputIndexStart!==void 0){let o=a.inputIndexStart,l=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?o+1:a.inputIndexEnd,u=o<0?t.inputNames.length+o:o;if(a.type==="tensor")return js(t.inputNames[u],n,r,s);if(a.type==="tensors"){let p=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((h,m)=>{var g;return((g=p[m])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(h=>js(h,n,r,s))}let c=js(t.inputNames[u],n,r,s),d=c.dataSync();return a.type==="number"?d[0]:O.toNestedArray(c.shape,d)}let i=t.attrParams[e];return i&&i.value}function js(e,t,n,r){let[s,a]=fi(e,n);if(r!=null){let o=r.getHashTableHandleByName(s);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[LI(s,o)]);return i!==void 0?t[LI(s,i)][a]:void 0}function n6(e,t,n){return t[LI(e,n.currentContextId)]}function Nu(e,t){let[n,r,s]=fi(e,t);return[LI(n,t&&t.currentContextId),r,s]}function LI(e,t){return t?`${e}-${t}`:e}function fi(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let a=t.parseNodeNameCache.get(e);if(a!=null)return a}let r=e.split(":"),s;if(r.length===1)s=[e,0,void 0];else{let a=r[0],i=r.length===3?r[1]:void 0,o=Number(r[r.length-1]);s=[a,o,i]}return n&&t.parseNodeNameCache.set(e,s),s}function T2(e,t,n){let r=M("pad",e,t,n);if(r==="explicit"){r=M("explicitPaddings",e,t,n);let s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function Tu(e){return e.kept?e:ql(e)}var CJ={};Kt(CJ,{json:()=>eKe});var eKe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],NJ={};Kt(NJ,{json:()=>tKe});var tKe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],TJ={};Kt(TJ,{json:()=>nKe});var nKe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],$J={};Kt($J,{json:()=>rKe});var rKe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],EJ={};Kt(EJ,{json:()=>sKe});var sKe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],_J={};Kt(_J,{json:()=>aKe});var aKe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],AJ={};Kt(AJ,{json:()=>iKe});var iKe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],RJ={};Kt(RJ,{json:()=>oKe});var oKe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],DJ={};Kt(DJ,{json:()=>lKe});var lKe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],FJ={};Kt(FJ,{json:()=>uKe});var uKe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],OJ={};Kt(OJ,{json:()=>cKe});var cKe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],MJ={};Kt(MJ,{json:()=>dKe});var dKe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],LJ={};Kt(LJ,{json:()=>pKe});var pKe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],PJ={};Kt(PJ,{json:()=>hKe});var hKe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],zJ={};Kt(zJ,{json:()=>fKe});var fKe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],BJ={};Kt(BJ,{json:()=>mKe});var mKe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],WJ={};Kt(WJ,{json:()=>gKe});var gKe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],VJ={};Kt(VJ,{json:()=>yKe});var yKe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],UJ={};Kt(UJ,{json:()=>xKe});var xKe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],r6=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[CJ,NJ,TJ,$J,EJ,_J,AJ,RJ,DJ,FJ,OJ,MJ,LJ,PJ,zJ,BJ,WJ,VJ,UJ],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){let n=e.node,r=[],s=[],a=[],i=n.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?r.push(m[g.name]):g.op==="Const"?s.push(m[g.name]):(g.input==null||g.input.length===0)&&a.push(m[g.name]),m),{}),o=[],l=[],u={},c={};t!=null&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach(m=>{let g=i[m];g.inputNames.forEach((y,b)=>{let[v,,k]=Nu(y),I=i[v];if(I.outputs!=null){let S=I.outputs.indexOf(k);if(S!==-1){let N=`${v}:${S}`;g.inputNames[b]=N}}g.inputs.push(I),I.children.push(g)})}),Object.keys(c).length===0?d.forEach(m=>{let g=i[m];g.children.length===0&&l.push(g)}):Object.keys(c).forEach(m=>{let[g]=Nu(m),y=i[g];y!=null&&(y.signatureKey=c[m],l.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{let[g]=Nu(m),y=i[g];y&&(y.signatureKey=u[m],o.push(y))}):o=r;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));let h={nodes:i,inputs:o,outputs:l,weights:s,placeholders:r,signature:t,functions:p};return a.length>0&&(h.initNodes=a),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=SJ(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,s)=>(r[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,s)=>{let a=s.type,i;switch(s.type){case"string":i=jA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=jA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":i=JA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=JA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":i=qA(e.attr,s.tfName,s.defaultValue||0),i===void 0&&s.tfDeprecatedName&&(i=qA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":i=ZA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=ZA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":i=HA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=HA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":i=eR(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=eR(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":i=YA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=YA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":i=QA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=QA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":i=KA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=KA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":i=XA(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=XA(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":i=s6(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=s6(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return r[s.name]={value:i,type:a},r},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],s={};t!=null&&(s=t.reduce((u,c)=>(u[c.name]=this.mapNode(c),c.op==="Const"&&r.push(u[c.name]),u),{}));let a=[],i=[];e.signature.inputArg.forEach(u=>{let[c]=Nu(u.name),d={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:DL(u.type),type:"dtype"}},children:[]};d.signatureKey=u.name,a.push(d),s[c]=d}),Object.keys(s).forEach(u=>{let c=s[u];c.inputNames.forEach((d,p)=>{let[h,,m]=Nu(d),g=s[h];if(g.outputs!=null){let y=g.outputs.indexOf(m);if(y!==-1){let b=`${h}:${y}`;c.inputNames[p]=b}}c.inputs.push(g),g.children.push(c)})});let o=e.ret;e.signature.outputArg.forEach(u=>{let[c,d]=Nu(o[u.name]),p=s[c];p!=null&&(p.defaultOutput=d,i.push(p))});let l=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function bKe(e){let t=xe().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function GJ(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):bKe(e);return t?n:n.toLowerCase()}function jA(e,t,n,r=!1){let s=e[t];return s!=null?GJ(s.s,r):n}function HA(e,t,n){let r=e[t];return r?r.b:n}function qA(e,t,n){let r=e[t]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function DL(e){switch(typeof e=="string"&&(e=pi[e]),e){case pi.DT_FLOAT:case pi.DT_HALF:return"float32";case pi.DT_INT32:case pi.DT_INT64:case pi.DT_INT8:case pi.DT_UINT8:return"int32";case pi.DT_BOOL:return"bool";case pi.DT_DOUBLE:return"float32";case pi.DT_STRING:return"string";case pi.DT_COMPLEX64:case pi.DT_COMPLEX128:return"complex64";default:return null}}function s6(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function KA(e,t,n){let r=e[t];return r&&r.type?DL(r.type):n}function XA(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(s=>DL(s)):n}function jJ(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function YA(e,t,n){let r=e[t];return r&&r.shape?jJ(r.shape):n}function ZA(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function JA(e,t,n,r=!1){let s=e[t];return s&&s.list&&s.list.s?s.list.s.map(a=>GJ(a,r)):n}function QA(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>jJ(s)):n}function eR(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var vKe=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,s)=>(r[s]=this.getAttr(s),r),{}))}getInput(e){return js(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return js(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return qA(this.node.rawAttrs,e,t);if(n.s!=null)return jA(this.node.rawAttrs,e,t);if(n.b!=null)return HA(this.node.rawAttrs,e,t);if(n.shape!=null)return YA(this.node.rawAttrs,e,t);if(n.type!=null)return KA(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return ZA(this.node.rawAttrs,e,t);if(n.list.s!=null)return JA(this.node.rawAttrs,e,t);if(n.list.shape!=null)return QA(this.node.rawAttrs,e,t);if(n.list.b!=null)return eR(this.node.rawAttrs,e,t);if(n.list.type!=null)return XA(this.node.rawAttrs,e,t)}return t}},Ms={};Kt(Ms,{OP_SCOPE_SUFFIX:()=>O3,abs:()=>Hr,acos:()=>B3,acosh:()=>W3,add:()=>Ae,addN:()=>aX,all:()=>uN,any:()=>Rv,argMax:()=>bh,argMin:()=>V3,asin:()=>U3,asinh:()=>G3,atan:()=>j3,atan2:()=>H3,atanh:()=>q3,avgPool:()=>Zu,avgPool3d:()=>X3,basicLSTMCell:()=>uX,batchNorm:()=>um,batchNorm2d:()=>Y3,batchNorm3d:()=>Z3,batchNorm4d:()=>J3,batchToSpaceND:()=>Y1,bincount:()=>Q3,bitwiseAnd:()=>cX,booleanMaskAsync:()=>QX,broadcastArgs:()=>dX,broadcastTo:()=>Gp,buffer:()=>tn,cast:()=>Ke,ceil:()=>eO,clipByValue:()=>oa,clone:()=>ql,complex:()=>Wu,concat:()=>Jn,concat1d:()=>tO,concat2d:()=>nO,concat3d:()=>rO,concat4d:()=>sO,conv1d:()=>cN,conv2d:()=>_a,conv2dTranspose:()=>dN,conv3d:()=>iO,conv3dTranspose:()=>oO,cos:()=>Z1,cosh:()=>pN,cosineWindow:()=>ON,cumprod:()=>Ov,cumsum:()=>hN,denseBincount:()=>NI,depthToSpace:()=>lO,depthwiseConv2d:()=>cm,diag:()=>hX,dilation2d:()=>uO,div:()=>ht,divNoNan:()=>cO,dot:()=>dO,dropout:()=>BO,einsum:()=>$p,elu:()=>_x,enclosingPowerOfTwo:()=>WO,ensureShape:()=>mX,equal:()=>Ci,erf:()=>fN,euclideanNorm:()=>fO,exp:()=>la,expandDims:()=>$s,expm1:()=>mO,eye:()=>mN,fft:()=>ow,fill:()=>wi,floor:()=>Rx,floorDiv:()=>lN,fused:()=>qg,gather:()=>Dx,gatherND:()=>rY,greater:()=>Ma,greaterEqual:()=>Ju,ifft:()=>Hg,imag:()=>J1,image:()=>Bi,inTopKAsync:()=>sY,irfft:()=>$N,isFinite:()=>gO,isInf:()=>yO,isNaN:()=>xO,leakyRelu:()=>Q1,less:()=>Vg,lessEqual:()=>Md,linalg:()=>GO,linspace:()=>vX,localResponseNormalization:()=>bO,log:()=>Ni,log1p:()=>ew,logSigmoid:()=>vO,logSoftmax:()=>yN,logSumExp:()=>tw,logicalAnd:()=>Io,logicalNot:()=>nw,logicalOr:()=>xN,logicalXor:()=>wO,losses:()=>gY,lowerBound:()=>kX,matMul:()=>Qt,max:()=>Hi,maxPool:()=>Ss,maxPool3d:()=>kO,maxPoolWithArgmax:()=>IX,maximum:()=>cu,mean:()=>Sr,meshgrid:()=>SX,min:()=>Wg,minimum:()=>ld,mirrorPad:()=>IO,mod:()=>SO,moments:()=>rw,movingAverage:()=>eY,mul:()=>oe,multiRNNCell:()=>CX,multinomial:()=>NX,neg:()=>or,norm:()=>Ax,notEqual:()=>kh,oneHot:()=>Ug,ones:()=>Ha,onesLike:()=>Ti,op:()=>ie,outerProduct:()=>TX,pad:()=>ml,pad1d:()=>$X,pad2d:()=>EX,pad3d:()=>_X,pad4d:()=>AX,pool:()=>CO,pow:()=>ru,prelu:()=>aw,print:()=>z3,prod:()=>NO,raggedGather:()=>RX,raggedRange:()=>DX,raggedTensorToTensor:()=>FX,rand:()=>OX,randomGamma:()=>zX,randomNormal:()=>vN,randomStandardNormal:()=>BX,randomUniform:()=>Ld,randomUniformInt:()=>WX,range:()=>Ih,real:()=>Gg,reciprocal:()=>AO,relu:()=>Un,relu6:()=>wN,reshape:()=>ue,reverse:()=>Yi,reverse1d:()=>VX,reverse2d:()=>UX,reverse3d:()=>GX,reverse4d:()=>jX,rfft:()=>lw,round:()=>kN,rsqrt:()=>IN,scalar:()=>Tt,scatterND:()=>tY,searchSorted:()=>bN,selu:()=>SN,separableConv2d:()=>Fx,setdiff1dAsync:()=>HX,sigmoid:()=>vo,sign:()=>RO,signal:()=>mY,sin:()=>CN,sinh:()=>NN,slice:()=>hn,slice1d:()=>iw,slice2d:()=>TN,slice3d:()=>Ox,slice4d:()=>jg,softmax:()=>Pd,softplus:()=>dm,spaceToBatchND:()=>sw,sparse:()=>yY,sparseToDense:()=>nY,spectral:()=>fY,split:()=>Xa,sqrt:()=>Ds,square:()=>Zn,squaredDifference:()=>EN,squeeze:()=>zd,stack:()=>Yr,step:()=>pm,stridedSlice:()=>DO,string:()=>xY,sub:()=>at,sum:()=>yt,tan:()=>FO,tanh:()=>od,tensor:()=>$a,tensor1d:()=>Ln,tensor2d:()=>Kl,tensor3d:()=>_N,tensor4d:()=>ud,tensor5d:()=>qX,tensor6d:()=>KX,tensorScatterUpdate:()=>YX,tile:()=>xi,topk:()=>MO,transpose:()=>en,truncatedNormal:()=>DN,unique:()=>LO,unsortedSegmentSum:()=>FN,unstack:()=>Fr,upperBound:()=>ZX,variable:()=>PO,where:()=>Rs,whereAsync:()=>zO,zeros:()=>Cr,zerosLike:()=>gn});var wKe=(e,t,n,r=Ms)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(M("a",e,t,n),M("b",e,t,n))];case"AddN":return[r.addN(M("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(M("a",e,t,n),M("b",e,t,n))];case"Mul":return[r.mul(M("a",e,t,n),M("b",e,t,n))];case"RealDiv":case"Div":return[r.div(M("a",e,t,n),M("b",e,t,n))];case"DivNoNan":return[r.divNoNan(M("a",e,t,n),M("b",e,t,n))];case"FloorDiv":return[r.floorDiv(M("a",e,t,n),M("b",e,t,n))];case"Sub":return[r.sub(M("a",e,t,n),M("b",e,t,n))];case"Minimum":return[r.minimum(M("a",e,t,n),M("b",e,t,n))];case"Maximum":return[r.maximum(M("a",e,t,n),M("b",e,t,n))];case"Pow":return[r.pow(M("a",e,t,n),M("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(M("a",e,t,n),M("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},kKe=(e,t,n,r=Ms)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(M("x",e,t,n))];case"Acos":return[r.acos(M("x",e,t,n))];case"Acosh":return[r.acosh(M("x",e,t,n))];case"Asin":return[r.asin(M("x",e,t,n))];case"Asinh":return[r.asinh(M("x",e,t,n))];case"Atan":return[r.atan(M("x",e,t,n))];case"Atan2":return[r.atan2(M("x",e,t,n),M("y",e,t,n))];case"Atanh":return[r.atanh(M("x",e,t,n))];case"Ceil":return[r.ceil(M("x",e,t,n))];case"Complex":return[r.complex(M("real",e,t,n),M("imag",e,t,n))];case"Cos":return[r.cos(M("x",e,t,n))];case"Cosh":return[r.cosh(M("x",e,t,n))];case"Elu":return[r.elu(M("x",e,t,n))];case"Erf":return[r.erf(M("x",e,t,n))];case"Exp":return[r.exp(M("x",e,t,n))];case"Expm1":return[r.expm1(M("x",e,t,n))];case"Floor":return[r.floor(M("x",e,t,n))];case"Log":return[r.log(M("x",e,t,n))];case"Log1p":return[r.log1p(M("x",e,t,n))];case"Imag":return[r.imag(M("x",e,t,n))];case"Neg":return[r.neg(M("x",e,t,n))];case"Reciprocal":return[r.reciprocal(M("x",e,t,n))];case"Real":return[r.real(M("x",e,t,n))];case"Relu":return[r.relu(M("x",e,t,n))];case"Round":return[r.round(M("x",e,t,n))];case"Selu":return[r.selu(M("x",e,t,n))];case"Sigmoid":return[r.sigmoid(M("x",e,t,n))];case"Sin":return[r.sin(M("x",e,t,n))];case"Sign":return[r.sign(M("x",e,t,n))];case"Sinh":return[r.sinh(M("x",e,t,n))];case"Softplus":return[r.softplus(M("x",e,t,n))];case"Sqrt":return[r.sqrt(M("x",e,t,n))];case"Square":return[r.square(M("x",e,t,n))];case"Tanh":return[r.tanh(M("x",e,t,n))];case"Tan":return[r.tan(M("x",e,t,n))];case"ClipByValue":return[r.clipByValue(M("x",e,t,n),M("clipValueMin",e,t,n),M("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(M("x",e,t,n))];case"Rsqrt":return[r.rsqrt(js(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(M("x",e,t,n),M("alpha",e,t,n))];case"Prelu":return[r.prelu(M("x",e,t,n),M("alpha",e,t,n))];case"IsNan":return[r.isNaN(js(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(js(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(js(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function mo(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){O.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let s=e[r],a=t[r];O.assert(s<0||a<0||s===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function a6(e){return!(typeof e=="number"||e.some(t=>t<0))}function Lb(e,t,n){let r=tR(e,n),s=!a6(r);if(s&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(a=>{r=tR(a.shape,r)}),!a6(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function tR(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}var IKe=class{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Tt(0),cs(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),mo(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,cs(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return $a([],[0].concat(this.elementShape));let n=this.readMany(e);return mo(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Yr(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return $a([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return mo(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Jn(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Fr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,a=[];ce(()=>{t=ue(t,[1,n,s]);for(let o=0;o<e.length;++o){let l=[0,o===0?0:r[o-1],0],u=[1,e[o],s];a[o]=ue(hn(t,l,u),this.elementShape)}return a});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,a)}},uT=class nR{get id(){return this.idTensor.id}constructor(t,n,r,s=-1){this.tensors=t,this.elementShape=n,this.elementDtype=r,t!=null&&t.forEach(a=>{if(r!==a.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${a.dtype}`);mo(n,a.shape,"TensorList shape mismatch: "),cs(a)}),this.idTensor=Tt(0),this.maxNumElements=s,cs(this.idTensor)}copy(){return new nR([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);mo(t,this.elementShape,"TensorList shape mismatch: ");let s=Lb(this.elementShape,this.tensors,t);return ce(()=>{let a=this.tensors.map(i=>ue(i,s));return Yr(a,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=Lb(this.elementShape,this.tensors,t),s=this.tensors.pop();return s.kept=!1,mo(s.shape,t,"TensorList shape mismatch: "),ue(s,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(mo(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");cs(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new nR([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)n.tensors[r]=this.tensors[r];return n}getItem(t,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);mo(this.tensors[t].shape,n,"TensorList shape mismatch: ");let s=Lb(this.elementShape,this.tensors,n);return ue(this.tensors[t],s)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);mo(this.elementShape,n.shape,"TensorList shape mismatch: "),cs(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);mo(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());let s=Lb(this.elementShape,this.tensors,r);return t.length===0?$a([],[0].concat(s)):ce(()=>{let a=t.map(i=>ue(this.tensors[i],s));return Yr(a,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);mo(this.elementShape,n,"TensorList shape mismatch: ");let r=Lb(this.elementShape,this.tensors,n);return this.size()===0?$a([],[0].concat(r)):ce(()=>{let s=this.tensors.map(a=>ue(a,r));return Jn(s,0)})}};function SKe(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let s=e.shape.slice(1);mo(s,t,"TensorList shape mismatch: ");let a=Fr(e);return new uT(a,t,r)}function CKe(e,t,n,r){return new uT([],e,t,r)}function NKe(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let s=Math.max(...t);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);let a=new uT([],n,e.dtype,r),i=Fr(e,0);return t.forEach((o,l)=>{a.setItem(o,i[l])}),a}function TKe(e,t,n){let r=0,s=t.map(c=>(r+=c,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let a=e.shape.slice(1),i=tR(a,n),o=r===0?0:e.size/r,l=ce(()=>{let c=[];e=ue(e,[1,r,o]);for(let d=0;d<t.length;++d){let p=[0,d===0?0:s[d-1],0],h=[1,t[d],o];c[d]=ue(hn(e,p,h),i)}return e.dispose(),c}),u=new uT([],n,e.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}var $Ke=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=M("thenBranch",e,t,n),s=M("elseBranch",e,t,n),a=M("cond",e,t,n),i=M("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=M("body",e,t,n),s=M("cond",e,t,n),a=M("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map(c=>c.id),l=await i[0].data();i.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let u=a;for(;l[0];){let c=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let d=u.map(h=>h.id);c.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()});let p=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await p[0].data(),p.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()})}return u}case"LoopCond":{let r=M("pred",e,t,n);return[Tu(r)]}case"Switch":{let r=M("pred",e,t,n),s=M("data",e,t,n);return s.kept||(s=Tu(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{let r=e.inputNames.find(s=>js(s,t,n)!==void 0);if(r){let s=js(r,t,n);return[Tu(s)]}return}case"Enter":{let r=M("frameName",e,t,n),s=M("tensor",e,t,n);return n.enterFrame(r),[Tu(s)]}case"Exit":{let r=M("tensor",e,t,n);return n.exitFrame(),[Tu(r)]}case"NextIteration":{let r=M("tensor",e,t,n);return n.nextIteration(),[Tu(r)]}case"TensorArrayV3":{let r=M("size",e,t,n),s=M("dtype",e,t,n),a=M("elementShape",e,t,n),i=M("dynamicSize",e,t,n),o=M("clearAfterRead",e,t,n),l=M("identicalElementShapes",e,t,n),u=M("name",e,t,n),c=new IKe(u,s,r,a,l,i,o);return n.addTensorArray(c),[c.idTensor,Tt(1)]}case"TensorArrayWriteV3":{let r=M("tensorArrayId",e,t,n),s=M("index",e,t,n),a=M("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{let r=M("tensorArrayId",e,t,n),s=M("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{let r=M("tensorArrayId",e,t,n),s=M("indices",e,t,n),a=M("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{let r=M("tensorArrayId",e,t,n),s=M("indices",e,t,n),a=M("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{let r=M("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=M("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{let r=M("tensorArrayId",e,t,n),s=M("tensor",e,t,n),a=M("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{let r=M("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return[Tt(s.size(),"int32")]}case"TensorArrayCloseV3":{let r=M("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{let r=M("tensorListId",e,t,n),s=M("index",e,t,n),a=M("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{let r=M("tensorListId",e,t,n),s=M("index",e,t,n),a=M("elementShape",e,t,n),i=M("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=M("indices",e,t,n),s=M("tensor",e,t,n),a=M("elementShape",e,t,n),i=M("numElements",e,t,n),o=NKe(s,r,a,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=M("elementShape",e,t,n),s=M("elementDType",e,t,n),a;e.op==="TensorListReserve"?a="numElements":a="maxNumElements";let i=M(a,e,t,n),o=e.op==="TensorListReserve"?-1:i,l=CKe(r,s,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=M("tensorListId",e,t,n),s=M("indices",e,t,n),a=M("elementShape",e,t,n),i=M("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{let r=M("tensorListId",e,t,n),s=M("elementShape",e,t,n),a=M("elementDType",e,t,n),i=M("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{let r=M("tensor",e,t,n),s=M("elementShape",e,t,n),a=M("elementDType",e,t,n),i=SKe(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=M("tensorListId",e,t,n),s=n.getTensorList(r.id),a=M("dtype",e,t,n),i=M("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{let r=M("tensorListId",e,t,n),s=M("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{let r=M("tensorListId",e,t,n),s=M("elementShape",e,t,n),a=M("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{let r=M("tensor",e,t,n),s=M("elementShape",e,t,n),a=M("lengths",e,t,n),i=TKe(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=M("tensorListId",e,t,n),s=n.getTensorList(r.id);return[Tt(s.size(),"int32")]}case"TensorListResize":{let r=M("tensorListId",e,t,n),s=M("size",e,t,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function i6(e,t,n){let[r,s]=M("fusedOps",e,t,n),a=r==="biasadd",i=!a,o=s==="prelu",l=r==="fusedbatchnorm",u=M("numArgs",e,t,n);if(a){if(o&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=M("strides",e,t,n),d=T2(e,t,n),p=M("dataFormat",e,t,n).toUpperCase(),h=M("dilations",e,t,n),[m,g]=M("args",e,t,n);i&&(g=m,m=void 0);let y=M("leakyreluAlpha",e,t,n);return{stride:c,pad:d,dataFormat:p,dilations:h,biasArg:m,preluArg:g,activationFunc:s,leakyreluAlpha:y}}var EKe=(e,t,n,r=Ms)=>{switch(e.op){case"Conv1D":{let s=M("stride",e,t,n),a=M("pad",e,t,n),i=M("dataFormat",e,t,n).toUpperCase(),o=M("dilation",e,t,n);return[r.conv1d(M("x",e,t,n),M("filter",e,t,n),s,a,i,o)]}case"Conv2D":{let s=M("strides",e,t,n),a=T2(e,t,n),i=M("dataFormat",e,t,n).toUpperCase(),o=M("dilations",e,t,n);return[r.conv2d(M("x",e,t,n),M("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=i6(e,t,n);return[r.fused.conv2d({x:M("x",e,t,n),filter:M("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{let{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=i6(e,t,n);return[r.fused.depthwiseConv2d({x:M("x",e,t,n),filter:M("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let s=M("outputShape",e,t,n),a=M("strides",e,t,n),i=T2(e,t,n);return[r.conv2dTranspose(M("x",e,t,n),M("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let s=M("strides",e,t,n),a=T2(e,t,n),i=M("dilations",e,t,n),o=M("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(M("input",e,t,n),M("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{let s=M("strides",e,t,n),a=M("pad",e,t,n),i=M("dataFormat",e,t,n).toUpperCase(),o=M("dilations",e,t,n);return[r.conv3d(M("x",e,t,n),M("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{let s=M("strides",e,t,n),a=M("pad",e,t,n),i=M("kernelSize",e,t,n);return[r.avgPool(M("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{let s=M("strides",e,t,n),a=M("pad",e,t,n),i=M("kernelSize",e,t,n);return[r.maxPool(M("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{let s=M("strides",e,t,n),a=M("pad",e,t,n),i=M("kernelSize",e,t,n),o=M("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(M("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[l,u]}case"AvgPool3D":{let s=M("strides",e,t,n),a=M("pad",e,t,n),i=M("kernelSize",e,t,n);return[r.avgPool3d(M("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{let s=M("strides",e,t,n),a=M("pad",e,t,n),i=M("kernelSize",e,t,n);return[r.maxPool3d(M("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{let s=M("strides",e,t,n),a=M("pad",e,t,n),i=M("dilations",e,t,n),o=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(M("x",e,t,n),M("filter",e,t,n),[o,l],a,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},_Ke=(e,t,n,r=Ms)=>{switch(e.op){case"Fill":{let s=M("shape",e,t,n),a=M("dtype",e,t,n),i=M("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{let s=M("start",e,t,n),a=M("stop",e,t,n),i=M("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{let s=M("logits",e,t,n),a=M("numSamples",e,t,n),i=M("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{let s=M("indices",e,t,n),a=M("depth",e,t,n),i=M("onValue",e,t,n),o=M("offValue",e,t,n),l=M("dtype",e,t,n);return[r.oneHot(s,a,i,o,l)]}case"Ones":return[r.ones(M("shape",e,t,n),M("dtype",e,t,n))];case"OnesLike":return[r.onesLike(M("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(M("shape",e,t,n),M("dtype",e,t,n),M("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(M("shape",e,t,n),M("minval",e,t,n),M("maxval",e,t,n),M("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(M("shape",e,t,n),M("minval",e,t,n),M("maxval",e,t,n),M("seed",e,t,n))];case"Range":{let s=M("start",e,t,n),a=M("stop",e,t,n),i=M("step",e,t,n);return[r.range(s,a,i,M("dtype",e,t,n))]}case"TruncatedNormal":{let s=M("shape",e,t,n),a=M("mean",e,t,n),i=M("stdDev",e,t,n),o=M("seed",e,t,n);return[r.truncatedNormal(s,a,i,M("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(M("shape",e,t,n),M("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(M("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function KE(e,t,n){let r=M("boxes",e,t,n),s=M("scores",e,t,n),a=M("maxOutputSize",e,t,n),i=M("iouThreshold",e,t,n),o=M("scoreThreshold",e,t,n),l=M("softNmsSigma",e,t,n);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var AKe=async(e,t,n,r,s=Ms)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=KE(e,t,n),d=await s.image.nonMaxSuppressionWithScoreAsync(a,i,o,l,u,c);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=KE(e,t,n),c=M("padToMaxOutputSize",e,t,n),d=await s.image.nonMaxSuppressionPaddedAsync(a,i,o,l,u,c);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=KE(e,t,n);return[await s.image.nonMaxSuppressionAsync(a,i,o,l,u)]}case"Where":{let a=s.cast(M("condition",e,t,n),"bool"),i=[await s.whereAsync(a)];return a.dispose(),i}case"ListDiff":return s.setdiff1dAsync(M("x",e,t,n),M("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},RKe=(e,t,n,r=Ms)=>{switch(e.op){case"LowerBound":{let s=M("sortedSequence",e,t,n),a=M("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{let s=M("x",e,t,n),a=M("k",e,t,n),i=M("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{let s=M("sortedSequence",e,t,n),a=M("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{let s=M("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{let s=M("x",e,t,n),a=M("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},DKe=(e,t,n,r=Ms)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let s=M("default",e,t,n);return[js(e.name,t,n)||s];case"Placeholder":return[js(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=M("x",e,t,n);return[Tu(c)]}case"IdentityN":return M("x",e,t,n).map(c=>Tu(c));case"Snapshot":let a=M("x",e,t,n);return[Tu(a)];case"Shape":return[r.tensor1d(M("x",e,t,n).shape,"int32")];case"ShapeN":return M("x",e,t,n).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(M("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(M("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=M("x",e,t,n),o=M("data",e,t,n),l=M("message",e,t,n),u=M("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},FKe=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Tt(0),this.tensorMap=new Map,cs(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Tt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),ce(()=>{let r=Fr(t),s=n.length,a=r.length;O.assert(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let i=0;i<s;i++){let o=n[i],l=r[i];cs(l),this.tensorMap.set(o,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return ce(()=>{let r=[];for(let s=0;s<n.length;s++){let a=n[s],i=this.findWithDefault(a,t);r.push(i)}return Yr(r)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},OKe=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let s=r.getHashTableHandleByName(e.name);if(s!=null)return[s];{let a=M("keyDType",e,t,n),i=M("valueDType",e,t,n),o=new FKe(a,i);return r.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let s=M("tableHandle",e,t,n,r),a=M("keys",e,t,n),i=M("values",e,t,n);return[await r.getHashTableById(s.id).import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{let s=M("tableHandle",e,t,n,r),a=M("keys",e,t,n),i=M("defaultValue",e,t,n);return[await r.getHashTableById(s.id).find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let s=M("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},MKe=(e,t,n,r=Ms)=>{switch(e.op){case"ResizeBilinear":{let s=M("images",e,t,n),a=M("size",e,t,n),i=M("alignCorners",e,t,n),o=M("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{let s=M("images",e,t,n),a=M("size",e,t,n),i=M("alignCorners",e,t,n),o=M("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{let s=M("image",e,t,n),a=M("boxes",e,t,n),i=M("boxInd",e,t,n),o=M("cropSize",e,t,n),l=M("method",e,t,n),u=M("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,l,u)]}case"ImageProjectiveTransformV3":{let s=M("images",e,t,n),a=M("transforms",e,t,n),i=M("outputShape",e,t,n),o=M("fillValue",e,t,n),l=M("interpolation",e,t,n),u=M("fillMode",e,t,n);return[r.image.transform(s,a,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},LKe=(e,t,n,r=Ms)=>{switch(e.op){case"Equal":return[r.equal(M("a",e,t,n),M("b",e,t,n))];case"NotEqual":return[r.notEqual(M("a",e,t,n),M("b",e,t,n))];case"Greater":return[r.greater(M("a",e,t,n),M("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(M("a",e,t,n),M("b",e,t,n))];case"Less":return[r.less(M("a",e,t,n),M("b",e,t,n))];case"LessEqual":return[r.lessEqual(M("a",e,t,n),M("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(M("a",e,t,n),M("b",e,t,n))];case"LogicalNot":return[r.logicalNot(M("a",e,t,n))];case"LogicalOr":return[r.logicalOr(M("a",e,t,n),M("b",e,t,n))];case"Select":case"SelectV2":return[r.where(M("condition",e,t,n),M("a",e,t,n),M("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(M("a",e,t,n),M("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},PKe=(e,t,n,r=Ms)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(M("a",e,t,n),M("b",e,t,n),M("transposeA",e,t,n),M("transposeB",e,t,n))];case"Einsum":return[r.einsum(M("equation",e,t,n),...M("tensors",e,t,n))];case"Transpose":return[r.transpose(M("x",e,t,n),M("perm",e,t,n))];case"_FusedMatMul":let[s,a]=M("fusedOps",e,t,n),i=s==="biasadd",o=a==="prelu",l=M("numArgs",e,t,n),u=M("leakyreluAlpha",e,t,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,d]=M("args",e,t,n);return[r.fused.matMul({a:M("a",e,t,n),b:M("b",e,t,n),transposeA:M("transposeA",e,t,n),transposeB:M("transposeB",e,t,n),bias:c,activation:a,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(M("a",e,t,n),M("numLower",e,t,n),M("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},zKe=(e,t,n,r=Ms)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(M("x",e,t,n),M("axis",e,t,n),M("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(M("x",e,t,n),M("mean",e,t,n),M("variance",e,t,n),M("offset",e,t,n),M("scale",e,t,n),M("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(M("x",e,t,n),M("mean",e,t,n),M("variance",e,t,n),M("offset",e,t,n),M("scale",e,t,n),M("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(M("x",e,t,n),M("radius",e,t,n),M("bias",e,t,n),M("alpha",e,t,n),M("beta",e,t,n))];case"Softmax":return[r.softmax(M("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(M("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},BKe=(e,t,n,r=Ms)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(M("paramsNestedSplits",e,t,n),M("paramsDenseValues",e,t,n),M("indices",e,t,n),M("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{let{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(M("starts",e,t,n),M("limits",e,t,n),M("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(M("shape",e,t,n),M("values",e,t,n),M("defaultValue",e,t,n),M("rowPartitionTensors",e,t,n),M("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},WKe=(e,t,n,r=Ms)=>{switch(e.op){case"Max":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[r.max(M("x",e,t,n),o,l)]}case"Mean":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[r.mean(M("x",e,t,n),o,l)]}case"Min":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[r.min(M("x",e,t,n),o,l)]}case"Sum":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[r.sum(M("x",e,t,n),o,l)]}case"All":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[r.all(M("x",e,t,n),o,l)]}case"Any":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[r.any(M("x",e,t,n),o,l)]}case"ArgMax":{let o=M("axis",e,t,n);return[r.argMax(M("x",e,t,n),o)]}case"ArgMin":{let o=M("axis",e,t,n);return[r.argMin(M("x",e,t,n),o)]}case"Prod":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[r.prod(M("x",e,t,n),o,l)]}case"Cumprod":{let o=M("axis",e,t,n),l=M("exclusive",e,t,n),u=M("reverse",e,t,n);return[r.cumprod(M("x",e,t,n),o,l,u)]}case"Cumsum":{let o=M("axis",e,t,n),l=M("exclusive",e,t,n),u=M("reverse",e,t,n);return[r.cumsum(M("x",e,t,n),o,l,u)]}case"Bincount":let s=M("x",e,t,n),a=M("weights",e,t,n),i=M("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{let o=M("x",e,t,n),l=M("weights",e,t,n),u=M("size",e,t,n),c=M("binaryOutput",e,t,n);return[r.denseBincount(o,l,u,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},VKe=(e,t,n,r=Ms)=>{switch(e.op){case"ConcatV2":case"Concat":{let s=M("n",e,t,n),a=M("axis",e,t,n),i=M("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{let s=M("x",e,t,n),a=M("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{let s=M("axis",e,t,n),a=M("batchDims",e,t,n),i=M("x",e,t,n),o=M("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{let s=M("dims",e,t,n),a=[];for(let o=0;o<s.length;o++)s[o]&&a.push(o);let i=M("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{let s=M("axis",e,t,n),a=M("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{let s=M("begin",e,t,n),a=M("size",e,t,n);return[r.slice(M("x",e,t,n),s,a)]}case"StridedSlice":{let s=M("begin",e,t,n),a=M("end",e,t,n),i=M("strides",e,t,n),o=M("beginMask",e,t,n),l=M("endMask",e,t,n),u=M("ellipsisMask",e,t,n),c=M("newAxisMask",e,t,n),d=M("shrinkAxisMask",e,t,n),p=M("x",e,t,n);return[r.stridedSlice(p,s,a,i,o,l,u,c,d)]}case"Pack":return ce(()=>{let s=M("axis",e,t,n),a=M("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,l=a.map(u=>{let c=O.arraysEqual(u.shape,i);if(!c&&!O.arraysEqual(r.squeeze(u).shape,o))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,i)});return[r.stack(l,s)]});case"Unpack":{let s=M("axis",e,t,n),a=M("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{let s=M("reps",e,t,n);return[r.tile(M("x",e,t,n),s)]}case"Split":case"SplitV":{let s=M("axis",e,t,n),a=M("numOrSizeSplits",e,t,n),i=M("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{let s=M("indices",e,t,n),a=M("values",e,t,n),i=M("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{let s=M("x",e,t,n),a=M("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{let s=M("sparseIndices",e,t,n),a=M("outputShape",e,t,n),i=M("sparseValues",e,t,n),o=M("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let s=M("indices",e,t,n),a=M("values",e,t,n),i=M("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},UKe=(e,t,n,r=Ms)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(M("indices",e,t,n),M("values",e,t,n),M("denseShape",e,t,n),M("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{let{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(M("inputIndices",e,t,n),M("inputShape",e,t,n),M("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(M("data",e,t,n),M("indices",e,t,n),M("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(M("data",e,t,n),M("indices",e,t,n),M("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},GKe=(e,t,n,r=Ms)=>{switch(e.op){case"FFT":return[r.fft(M("x",e,t,n))];case"IFFT":return[r.ifft(M("x",e,t,n))];case"RFFT":return[r.rfft(M("x",e,t,n))];case"IRFFT":return[r.irfft(M("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},jKe=(e,t,n,r=Ms)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(M("input",e,t,n),M("pattern",e,t,n),M("rewrite",e,t,n),M("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(M("data",e,t,n),M("dataSplits",e,t,n),M("separator",e,t,n),M("nGramWidths",e,t,n),M("leftPad",e,t,n),M("rightPad",e,t,n),M("padWidth",e,t,n),M("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{let{indices:s,values:a,shape:i}=r.string.stringSplit(M("input",e,t,n),M("delimiter",e,t,n),M("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(M("input",e,t,n),M("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},HKe=(e,t,n,r=Ms)=>{switch(e.op){case"Cast":return[r.cast(M("x",e,t,n),M("dtype",e,t,n))];case"ExpandDims":{let s=M("axis",e,t,n);return[r.expandDims(M("x",e,t,n),s)]}case"Squeeze":{let s=M("axis",e,t,n);return[r.squeeze(M("x",e,t,n),s)]}case"Reshape":return[r.reshape(M("x",e,t,n),M("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(M("x",e,t,n),M("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(M("x",e,t,n),M("padding",e,t,n),M("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(M("x",e,t,n),M("padding",e,t,n),M("constantValue",e,t,n))];case"SpaceToBatchND":{let s=M("blockShape",e,t,n),a=M("paddings",e,t,n);return[r.spaceToBatchND(M("x",e,t,n),s,a)]}case"BatchToSpaceND":{let s=M("blockShape",e,t,n),a=M("crops",e,t,n);return[r.batchToSpaceND(M("x",e,t,n),s,a)]}case"DepthToSpace":{let s=M("blockSize",e,t,n),a=M("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(M("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(M("x",e,t,n),M("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(M("s0",e,t,n),M("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function o6(e,t,n,r,s=ce){let a=((i,o,l)=>{switch(i.category){case"arithmetic":return s(()=>wKe(i,o,l));case"basic_math":return s(()=>kKe(i,o,l));case"control":return $Ke(i,o,l);case"convolution":return s(()=>EKe(i,o,l));case"creation":return s(()=>_Ke(i,o,l));case"dynamic":return AKe(i,o,l);case"evaluation":return s(()=>RKe(i,o,l));case"image":return s(()=>MKe(i,o,l));case"graph":return s(()=>DKe(i,o,l));case"logical":return s(()=>LKe(i,o,l));case"matrices":return s(()=>PKe(i,o,l));case"normalization":return s(()=>zKe(i,o,l));case"ragged":return s(()=>BKe(i,o,l));case"reduction":return s(()=>WKe(i,o,l));case"slice_join":return s(()=>VKe(i,o,l));case"sparse":return s(()=>UKe(i,o,l));case"spectral":return s(()=>GKe(i,o,l));case"string":return s(()=>jKe(i,o,l));case"transformation":return s(()=>HKe(i,o,l));case"hash_table":return OKe(i,o,l,r);case"custom":let u=SJ(i.op);if(u&&u.customExecutor)return u.customExecutor(new vKe(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return O.isPromise(a)?a.then(i=>[].concat(i)):[].concat(a)}var l6=class{constructor(e={},t={},n={},r={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function u6(e,t,n,r){let s=new Set,a=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map(p=>fi(p)[0]));r=r||[];let c=new Set(r.map(p=>fi(p.name)[0])),d=[...t];for(;d.length>0;){let p=d.pop();if((_p(p)||eXe(p)||tXe(p))&&i==null&&(i=p,o=i.children.map(h=>h.name).filter(h=>s.has(h))),s.add(p.name),n[p.name]==null&&!u.has(p.name)&&!c.has(p.name)){if(p.inputs.length===0){a.push(p.name);continue}p.inputs.forEach(h=>{l.has(h.name)||(l.add(h.name),d.push(h))})}}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}function qKe(e,t){let{usedNodes:n,inputs:r}=t,s=Object.keys(r).map(y=>fi(y)[0]).map(y=>e.nodes[y]),a=e.initNodes||[],i=y=>n.has(typeof y=="string"?y:y.name);function o(y){return[...new Map(y.map(b=>[b.name,b])).values()]}let l=o([...s,...e.weights,...a]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map(y=>[y.name,y])),d={};for(let y of u){d[y.name]=d[y.name]||0;for(let b of y.children)i(b)||(d[b.name]=Number.POSITIVE_INFINITY),d[b.name]=(d[b.name]||0)+1}let p=Object.entries(d).filter(([,y])=>y===0).map(([y])=>y),h=[...p];for(;p.length>0;){let y=p.pop(),b=c.get(y);for(let v of b.children.filter(i))--d[v.name]===0&&(h.push(v.name),p.push(v.name))}let m=h.map(y=>c.get(y)),g=KKe(m,l);return XKe(g,l),g}function KKe(e,t){let n=new Map(e.map(a=>[a.name,a])),r=t.map(a=>a.name),s=new Set(r);for(;r.length>0;){let a=r.pop(),i=n.get(a);for(let o of i.children)!n.has(o.name)||s.has(o.name)||(s.add(o.name),r.push(o.name))}return e.filter(a=>s.has(a.name))}var t2=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function XKe(e,t){let n=new Map(e.map((o,l)=>[o.name,l])),r=new Set(t.map(o=>o.name)),s=o=>r.has(typeof o=="string"?o:o.name),a=new Set(e.map(o=>o.name)),i=o=>a.has(typeof o=="string"?o:o.name);for(let o of e){for(let l of o.children.filter(i)){if(!n.has(l.name))throw new t2(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new t2(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!s(o))for(let l of o.inputs){if(!n.has(l.name))throw new t2(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new t2(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function YKe(e){let t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,r=e.map((o,l)=>_p(o)?n:l),s=o=>{let l=r[t.get(o.name)];return l??-1},a=e.map((o,l)=>o.children.map(s).reduce((u,c)=>Math.max(u,c),r[l])),i=new Map;for(let o=0;o<e.length;++o){let l=a[o];if(l===n)continue;let u=e[o],c=e[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u)}return i}var ZKe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),JKe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),QKe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function _p(e){return ZKe.has(e.op)}function eXe(e){return JKe.has(e.op)}function tXe(e){return QKe.has(e.op)}var c6=class HJ{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new HJ(t.functions[r],this)})}getCompilationKey(t,n){let r=t.map(a=>a.name).sort(),s=n.map(a=>a.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(t,n){let r=u6(t,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:a,syncInputs:i}=r;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){let u=n.map(d=>d.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${s}]`)}let o=qKe(this.graph,r),l=YKe(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return cs(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let s=r.map(p=>this.graph.nodes[fi(p)[0]]),a=n.map(p=>fi(p)[0]),i=new Set(a),o=a.map(p=>this.graph.nodes[p]);o.length===0&&(o=this._outputs);let l=this.getCompilationKey(s,o),u=this.compiledMap.get(l);u==null&&(u=this.compile(t,o),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=xe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}let c={},d={};return ce(()=>{let p=new l6(this.weightMap,c,d,this.functionExecutorMap,this.parseNodeNameCache),h=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(b=>{let[v,k]=fi(b,p),I=[];I[k]=t[b],h[v]=I,this.keepIntermediateTensors&&(this.clonedTensorsMap[v]=this.cloneTensorList(I))});let m=this.getFrozenTensorIds(h),{orderedNodes:g,nodeLiveUntilMap:y}=u;for(let b of g){if(h[b.name])continue;let v=o6(b,h,p,this._resourceManager);if(O.isPromise(v))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);h[b.name]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(v)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,h,p,m,i,y.get(b.name))}return this.parent==null&&p.dispose(m),n.map(b=>js(b,h,p))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(t,n,r,s,a,i,o){if(!(_p(n)||i.has(t))){for(let l of r[t])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(let l of n.inputs){if(_p(l))continue;let u=n6(l.name,r,s);if(u!=null)for(let c of u){if(!c||c.kept||a.has(c.id))continue;let d=o[c.id];d===1?(c.dispose(),delete o[c.id]):d!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,r,s,a,i){function o(l){return _p(l)||a.has(l.name)}if(!(_p(t)||i==null))for(let l of i){if(o(l))continue;let u=n6(l.name,n,r);for(let c of u)!c||c.kept||s.has(c.id)||c.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,r=!1,s={},a={}){this.disposeIntermediateTensors(),r||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=xe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}let i=new l6(this.weightMap,s,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,n,r),l=n.map(p=>js(p,o,i)),u=l.map(p=>p.id),c=Object.keys(t).map(p=>t[p].id),d=new Set([...u,...c,...this.weightIds]);return Object.values(o).forEach(p=>{p.forEach(h=>{h&&!h.isDisposed&&!d.has(h.id)&&h.dispose()})}),this.parent==null&&i.dispose(d),l}async executeFunctionAsync(t,n,r){let s=t.reduce((a,i,o)=>(a[this.inputs[o].name]=i,a),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(t,n,r,s){let a=Object.keys(t),i=a.map(I=>this.graph.nodes[fi(I)[0]]),o=r.map(I=>fi(I)[0]),l=new Set(o),u=o.map(I=>this.graph.nodes[I]);u.length===0&&(u=this._outputs);let{usedNodes:c,missingInputs:d,dynamicNode:p,syncInputs:h}=u6(t,u,this.weightMap,this._initNodes),m=[...i,...this.graph.weights,...this._initNodes||[]].map(I=>({node:I,contexts:n.currentContext})),g=Object.assign({},this.weightMap);Object.keys(t).forEach(I=>{let[S,N]=fi(I),T=[];T[N]=t[I],g[S]=T});let y={},b=this.getFrozenTensorIds(g),v={};for(;m.length>0;){let I=this.processStack(i,m,n,g,v,b,l,y,c);await Promise.all(I)}p==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let k=u.filter(I=>!_p(I)&&!js(I.name,g,n)).map(I=>I.name);if(k.length>0){let I="";throw p!=null&&(I=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${k}] from the provided inputs [${a}]. Consider providing the following inputs: [${d}]. ${I}`)}return g}processStack(t,n,r,s,a,i,o,l,u){let c=[];for(;n.length>0;){let d=n.pop();r.currentContext=d.contexts;let p="";if(d.node.op==="Enter"&&M("isConstant",d.node,s,r)&&([p]=Nu(d.node.name,r)),s[d.node.name]==null){let h=o6(d.node,s,r,this._resourceManager);p||([p]=Nu(d.node.name,r));let m=r.currentContext;O.isPromise(h)?c.push(h.then(g=>(s[p]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(g)),r.currentContext=m,this.checkTensorForDisposal(p,d.node,s,r,i,o,l),this.processChildNodes(d.node,n,r,s,a,u),g))):(s[p]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(h)),this.checkTensorForDisposal(p,d.node,s,r,i,o,l),this.processChildNodes(d.node,n,r,s,a,u))}else this.processChildNodes(d.node,n,r,s,a,u)}return c}processChildNodes(t,n,r,s,a,i){t.children.forEach(o=>{let[l]=Nu(o.name,r);a[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(u=>!!js(u,s,r))&&(a[l]=!0,n.push({contexts:r.currentContext,node:o})):o.inputNames.every(u=>!!js(u,s,r))&&(a[l]=!0,n.push({contexts:r.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let r=t[n],[s]=fi(n),a=this.graph.nodes[s];if(a.attrParams.shape&&a.attrParams.shape.value){let i=a.attrParams.shape.value,o=i.length===r.shape.length&&r.shape.every((l,u)=>i[u]===-1||i[u]===l);O.assert(o,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&O.assert(r.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var n,r;let s={};for(let a in t){let i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[a];i!=null?s[i.name]=t[a]:s[a]=t[a]}return s}checkInputs(t){let n=Object.keys(t).filter(r=>{let[s]=fi(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var r,s;let a=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[n];return a!=null?a.name:n},{})}checkOutputs(t){t.forEach(n=>{let[r]=fi(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}},nXe=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},rXe="?tfjs-format=file",sXe="model.json",FL=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=qs){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new nXe}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return O.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await XK(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(r=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new c6(r6.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=r6.Instance.transformGraph(e.modelInitializer);this.initializer=new c6(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Zt?[e]:e,n={};return t.forEach((r,s)=>n[this.structuredOutputKeys[s]]=r),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Zt)&&!Array.isArray(e)){let s=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(s!=null)for(let a in s){let i=s[a];i.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((s,a)=>{var i,o,l;let u=(l=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[a])===null||l===void 0?void 0:l.resourceId;return u!=null?s[a]=this.resourceIdToCapturedInput[u]:s[a]=e[r++],s},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let s=n[r],a=t[s];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&qt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function aXe(e,t={},n=qs){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=oXe(e));let r=new FL(e,t,n);return await r.load(),r}function iXe(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[r,s]=e;if(!r)throw new Error("modelJSON must be the first element of the array");if(!s||!(s instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let a=qs.getWeightSpecs(r.weightsManifest),i=qs.getModelArtifactsForJSONSync(r,a,s);t=qs.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=qs.fromMemorySync(e);else throw new Error("Unknown model format");let n=new FL(t);return n.load(),n}function oXe(e){return e.endsWith("/")||(e=e+"/"),`${e}${sXe}${rXe}`}var lXe="4.22.0",qJ={};Kt(qJ,{CSVDataset:()=>sQ,Dataset:()=>zx,FileDataSource:()=>dQ,TextLineDataset:()=>rQ,URLDataSource:()=>pQ,array:()=>AXe,csv:()=>GXe,func:()=>jXe,generator:()=>HXe,microphone:()=>KXe,version_data:()=>XXe,webcam:()=>qXe,zip:()=>RXe});var uXe=_d(VC()),cXe=_d(VC());function dXe(e,t){return PI(e,t)}function PI(e,t,n=new Map,r=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(Yg(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let i in e){let o=e[i],l=PI(o,t,n,r);a[i]=l}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,s.value),s.value}function pXe(e,t=XJ){return KJ(e,t)}function KJ(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(Yg(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let o=e.map(u=>u[i]),l=KJ(o,t,n);a[i]=l}return n.delete(r),a}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function XJ(e){return e===null?null:Yg(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function YJ(e,t){let n=new Map;PI(e,t,n);for(let r of Array.from(n.keys())){let s=n.get(r);if(O.isPromise(s)){let a=await s;n.set(r,a)}}return PI(e,t,n)}function Yg(e){let t=!1;if(xe().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=mK();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Zt)&&!(e instanceof Promise)&&!t)}function hXe(e){return e==null||fXe(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Zt||O.isTypedArray(e)}function fXe(e){return e===null||typeof e!="object"&&typeof e!="function"}function mXe(e){return dXe(e,gXe)}function gXe(e){return e instanceof Zt?{value:e.clone(),recurse:!1}:Yg(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var ZJ=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},JJ=class QJ extends ZJ{constructor(){super(QJ.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),r=this.length();for(let s=0;s<r;s++)n[s]=this.get(this.wrap(this.begin+s));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}};JJ.INITIAL_CAPACITY=32;function eQ(e){return new bXe(e)}function OL(e){return new vXe(e)}function yXe(e,t){return new tQ(e,t)}function xXe(e,t=zc.FAIL){return new EXe(e,t)}var Fs=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new TXe(this,e)}filter(e){return new CXe(this,e)}map(e){return new NXe(this,e)}mapAsync(e){return new d6(this,e)}serialMapAsync(e){return new d6(this,e).serial()}flatmap(e){return new $Xe(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new SXe(this,e,t)}columnMajorBatch(e,t=!0,n=XJ){return this.rowMajorBatch(e,t).map(r=>pXe(r,n))}concatenate(e,t){return new tQ(eQ([this,e]),t)}take(e){return e<0||e==null?this:new IXe(this,e)}skip(e){return e<0||e==null?this:new kXe(this,e)}prefetch(e){return new nQ(this,e)}shuffle(e,t){return new _Xe(this,e,t)}serial(){return new wXe(this)}},bXe=class extends Fs{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:mXe(e),done:!1}}},vXe=class extends Fs{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},wXe=class extends Fs{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},kXe=class extends Fs{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;qt(e.value)}return this.upstream.next()}},IXe=class extends Fs{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},SXe=class extends Fs{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},CXe=class extends Fs{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;qt(e.value)}}},NXe=class extends Fs{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Jo.getTensorsInContainer(e.value),n=this.transform(e.value),r=Jo.getTensorsInContainer(n);for(let s of t)Jo.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},TXe=class extends Fs{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},d6=class extends Fs{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Jo.getTensorsInContainer(e.value),n=await this.transform(e.value),r=Jo.getTensorsInContainer(n);for(let s of t)Jo.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},ML=class extends Fs{constructor(){super(),this.outputQueue=new JJ,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},$Xe=class extends ML{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Jo.getTensorsInContainer(e.value),n=this.transform(e.value),r=Jo.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of t)Jo.isTensorInList(s,r)||s.dispose();return!0}},tQ=class extends Fs{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},zc;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(zc||(zc={}));var EXe=class extends Fs{constructor(e,t=zc.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(a){return a instanceof Fs?{value:a.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let s=await YJ(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case zc.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case zc.SHORTEST:return{value:null,done:!0};case zc.LONGEST:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},nQ=class extends Fs{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new ZJ(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},_Xe=class extends nQ{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=cXe.alea(n||O.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},zx=class{constructor(){this.size=null}batch(e,t=!0){let n=this;O.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),hi(async()=>(await n.iterator()).columnMajorBatch(e,t,DXe),r)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,hi(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,hi(async()=>(await t.iterator()).filter(r=>ce(()=>e(r))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return hi(async()=>(await t.iterator()).map(n=>ce(()=>e(n))),this.size)}mapAsync(e){let t=this;return hi(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return hi(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,hi(async()=>{let r=OL(async()=>({value:await t.iterator(),done:!1}));return yXe(r.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,hi(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,s=uXe.alea(t||O.now().toString());return hi(async()=>{let a=s.int32();return n&&(a+=s.int32()),(await r.iterator()).shuffle(e,a.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,hi(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};zx.MAX_BUFFER_SIZE=1e4;function hi(e,t=null){return new class extends zx{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function AXe(e){return hi(async()=>eQ(e),e.length)}function RXe(e){if(!Yg(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return hi(async()=>{let n=await YJ(e,r=>{if(r instanceof zx)return{value:r.iterator(),recurse:!1};if(Yg(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return xXe(n,zc.SHORTEST)},t)}function DXe(e){if(e===null)return null;let t=e[0];return hXe(t)?{value:FXe(e),recurse:!1}:{value:null,recurse:!0}}function FXe(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Zt?Yr(e):$a(e)}var rQ=class extends zx{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},n2='"',Pb=Symbol("out"),p6=Symbol("field"),r2=Symbol("quote"),XE=Symbol("quoteafterquote"),h6=Symbol("quoteinquote"),sQ=class extends zx{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&O.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((r,s)=>(r[s]=r[s]+1||1,r),{}),n=Object.keys(t).filter(r=>t[r]>1);if(O.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new rQ(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(O.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let s=0;s<this.fullColumnNames.length;s++){let a=this.fullColumnNames[s],i=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[s],l=null;if(o==="")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);l=void 0}else{let u=Number(o);if(isNaN(u))i&&i.dtype==="bool"?l=this.getBoolean(o):l=o;else if(!i||!i.dtype)l=u;else switch(i.dtype){case"float32":l=u;break;case"int32":l=Math.floor(u);break;case"bool":l=this.getBoolean(o);break;default:l=u}}i&&i.isLabel?r[a]=l:n[a]=l}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],r=0,s=e.length,a=Pb;for(let i=0;i<s;i++)switch(a){case Pb:switch(e.charAt(i)){case n2:r=i+1,a=r2;break;case this.delimiter:if(r=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),a=Pb;break;default:a=p6,r=i;break}break;case p6:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),a=Pb,r=i+1;break}break;case r2:switch(e.charAt(i)){case n2:a=XE;break}break;case XE:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),a=Pb,r=i+1;break;case n2:a=r2;break;default:a=h6;break}break;case h6:switch(e.charAt(i)){case n2:a=r2;break}break}if(a===XE?n.push(e.substring(r,s-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},OXe=class aQ extends Fs{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!xe().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new aQ(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(r){throw new Error(`Error thrown while initializing video stream: ${r.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,r=await this.getAudioData();if(this.includeSpectrogram){let s=this.flattenQueue(r.freqDataQueue);t=this.getTensorFromAudioDataArray(s,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let s=this.flattenQueue(r.timeDataQueue);n=this.getTensorFromAudioDataArray(s,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],r=0;return new Promise(s=>{let a=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&s({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++r===this.numFrames&&(clearInterval(a),s({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,r=new Float32Array(t.length*n);return t.forEach((s,a)=>r.set(s,a*n)),r}getTensorFromAudioDataArray(t,n){let r=new Float32Array(O.sizeFromShape(n));return r.set(t,r.length-t.length),$a(r,n)}},MXe=class iQ extends Fs{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Ln([0],"int32"),this.webcamConfig.centerCrop){let r=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,s=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,a=(1-r)/2,i=(1-s)/2,o=a+r,l=s+i;this.cropBox=Kl([i,a,l,o],[1,4])}else this.cropBox=Kl([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!xe().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new iQ(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&O.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=uw.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return ce(()=>{let n=$s(Ke(t,"float32"),0),r;r=Bi.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let s=r.shape;return ue(r,s.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},oQ=class{},lQ=class extends Fs{split(e){return new LXe(this,e)}},LXe=class extends lQ{constructor(e,t){super(),this.upstream=e,this.impl=new PXe(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},PXe=class extends ML{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},zXe=class extends Fs{decodeUTF8(){return new BXe(this)}},BXe=class extends lQ{constructor(e){super(),this.upstream=e,this.impl=new WXe(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},WXe=class extends ML{constructor(e){if(super(),this.upstream=e,xe().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=mK();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return xe().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},uQ=class extends zXe{constructor(e,t={}){super(),this.file=e,this.options=t,O.assert(e instanceof Uint8Array||(xe().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=a=>{let i=r.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},r.onabort=a=>t(new Error("Aborted")),r.onerror=a=>t(new Error(a.type));let s=this.file.slice(this.offset,n);r.readAsArrayBuffer(s)}this.offset=n}),done:!1}}};async function VXe(e,t={},n){let r,s;typeof e=="string"?r=e:(r=e.url,s=UXe(e));let a=await(0,O.fetch)(r,s);if(a.ok){let i=new Uint8Array(await a.arrayBuffer());return new uQ(i,t)}else throw new Error(a.statusText)}var UXe=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function cQ(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var dQ=class extends oQ{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(cQ(this.input)&&xe().get("IS_NODE")){let e=T3();this.input=e.readFileSync(this.input.slice(7))}return new uQ(this.input,this.options)}},pQ=class extends oQ{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return cQ(this.url)?new dQ(this.url,this.fileOptions).iterator():VXe(this.url,this.fileOptions)}};function GXe(e,t={}){return new sQ(new pQ(e),t)}function jXe(e){let t=OL(e);return hi(async()=>t)}function HXe(e){return hi(async()=>{let t=await e();return OL(()=>t.next())})}async function qXe(e,t){return MXe.create(e,t)}async function KXe(e){return OXe.create(e)}var XXe="4.22.0";function wt(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&O.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var YXe=du.whereImpl,LL=class hQ extends w1{nextDataId(){return hQ.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new UC(this,fo())}write(t,n,r){this.firstUse&&(this.firstUse=!1,xe().get("IS_NODE")&&V.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:r,refCount:1}),s}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&O.isString(r[0])){let a=r.map(i=>O.encodeString(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return{dataId:s,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,r,s,a){this.data.set(t,{values:n,dtype:s,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:r}=this.data.get(t);if(n==="complex64"){let s=this.readSync(r.real.dataId),a=this.readSync(r.imag.dataId);return V.mergeRealAndImagArrays(s,a)}return O.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(s=>O.decodeString(s));return tn(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return tn(t.shape,t.dtype,n)}makeOutput(t,n,r){return fo().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=O.now();return t(),{kernelMs:O.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){wt([t],"where");let n=this.readSync(t.dataId);return YXe(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};LL.nextDataId=0;var PL={};Kt(PL,{addImpl:()=>gQ,bincountImpl:()=>BL,bincountReduceImpl:()=>yQ,bitwiseAndImpl:()=>xQ,castImpl:()=>mQ,ceilImpl:()=>bQ,concatImpl:()=>WL,equalImpl:()=>vQ,expImpl:()=>kQ,expm1Impl:()=>SQ,floorDivImpl:()=>NQ,floorImpl:()=>CQ,gatherNdImpl:()=>TQ,gatherV2Impl:()=>$Q,greaterEqualImpl:()=>_Q,greaterImpl:()=>EQ,lessEqualImpl:()=>RQ,lessImpl:()=>AQ,linSpaceImpl:()=>DQ,logImpl:()=>FQ,maxImpl:()=>OQ,maximumImpl:()=>MQ,minimumImpl:()=>LQ,multiplyImpl:()=>VL,negImpl:()=>PQ,notEqualImpl:()=>zQ,prodImpl:()=>BQ,raggedGatherImpl:()=>WQ,raggedRangeImpl:()=>VQ,raggedTensorToTensorImpl:()=>UQ,rangeImpl:()=>GL,rsqrtImpl:()=>GQ,scatterImpl:()=>Mp,sigmoidImpl:()=>XYe,simpleAbsImpl:()=>fQ,sliceImpl:()=>BI,sparseFillEmptyRowsImpl:()=>HQ,sparseReshapeImpl:()=>qQ,sparseSegmentReductionImpl:()=>jL,sqrtImpl:()=>JYe,squaredDifferenceImpl:()=>KQ,staticRegexReplaceImpl:()=>XQ,stridedSliceImpl:()=>YQ,stringNGramsImpl:()=>HL,stringSplitImpl:()=>qL,stringToHashBucketFastImpl:()=>KL,subImpl:()=>ZQ,tileImpl:()=>JQ,topKImpl:()=>eee,transposeImpl:()=>UL,uniqueImpl:()=>YL});function fQ(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var ZXe=e=>{let{x:t}=e.inputs,n=e.backend;wt(t,"abs");let r=new Float32Array(O.sizeFromShape(t.shape)),s=n.data.get(t.dataId).values;return r=fQ(s),n.makeOutput(r,t.shape,t.dtype)},JXe={kernelName:Ty,backendName:"cpu",kernelFunc:ZXe};function Ur(e){return(t,n,r,s,a)=>{let i=V.assertAndGetBroadcastShape(t,n),o=i.length,l=O.computeStrides(i),u=O.sizeFromShape(i),c=O.getTypedArrayFromDType(a,u),d=t.length,p=n.length,h=O.computeStrides(t),m=O.computeStrides(n),g=V.getBroadcastDims(t,i),y=V.getBroadcastDims(n,i);if(g.length+y.length===0)for(let b=0;b<c.length;++b)c[b]=e(r[b%r.length],s[b%s.length]);else for(let b=0;b<c.length;++b){let v=O.indexToLoc(b,o,l),k=v.slice(-d);g.forEach(T=>k[T]=0);let I=O.locToIndex(k,d,h),S=v.slice(-p);y.forEach(T=>S[T]=0);let N=O.locToIndex(S,p,m);c[b]=e(r[I],s[N])}return[c,i]}}function gi(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}var QXe={kernelName:HC,backendName:"cpu",kernelFunc:gi};function zI(e,t,n="float32"){if(n==="complex64"){let s=zI(e,t,"float32"),a=zI(e,t,"float32");return gi({inputs:{real:s,imag:a},backend:e})}let r=O.makeZerosTypedArray(O.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function au(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var eYe={kernelName:vf,backendName:"cpu",kernelFunc:au};function Ch(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}var tYe={kernelName:sN,backendName:"cpu",kernelFunc:Ch};function mQ(e,t,n,r){if(r==="int32"){let s=Int32Array.from(e);return[t,"int32",s]}if(r==="bool"){let s=O.toTypedArray([0],n),[a,i]=Ur((o,l)=>o!==l?1:0)(t,[],e,s,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function fd(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return au({inputs:{x:s},backend:n});let c=zI(n,s.shape,s.dtype),d=fd({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),p=gi({inputs:{real:d,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),p}if(s.dtype==="complex64"){let c=Ch({inputs:{input:s},backend:n}),d=fd({inputs:{x:c},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(c),d}if(!O.hasEncodingLoss(s.dtype,a)){let c=au({inputs:{x:s},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:a}}let i=n.data.get(s.dataId).values,[o,l,u]=mQ(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}var nYe={kernelName:ef,backendName:"cpu",kernelFunc:fd};function bs(e,t,n,r){return n==null?({inputs:s,backend:a})=>{let{a:i,b:o}=s,l=a;wt([i,o],e);let u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d=i.dtype==="string"?V.fromUint8ToStringArray(u):u,p=i.dtype==="string"?V.fromUint8ToStringArray(c):c,h=r||i.dtype,[m,g]=t(i.shape,o.shape,d,p,h);return l.makeTensorInfo(g,h,m)}:({inputs:s,backend:a})=>{let{a:i,b:o}=s,l=a;if(i.dtype==="complex64"||o.dtype==="complex64"){let u=fd({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),d=c.complexTensorInfos.real,p=c.complexTensorInfos.imag,h=l.data.get(d.dataId).values,m=l.data.get(p.dataId).values,g=fd({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),y=l.data.get(g.dataId),b=y.complexTensorInfos.real,v=y.complexTensorInfos.imag,k=l.data.get(b.dataId).values,I=l.data.get(v.dataId).values,[S,N,T]=n(i.shape,o.shape,h,m,k,I),A=l.makeTensorInfo(T,"float32",S),R=l.makeTensorInfo(T,"float32",N),D=gi({inputs:{real:A,imag:R},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(A),l.disposeIntermediateTensorInfo(R),D}else{let u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d=r||i.dtype,[p,h]=t(i.shape,o.shape,u,c,d);return l.makeTensorInfo(h,d,p)}}}function zL(e){return(t,n,r,s,a,i)=>{let o=V.assertAndGetBroadcastShape(t,n),l=O.sizeFromShape(o),u=o.length,c=O.computeStrides(o),d=O.getTypedArrayFromDType("float32",l),p=O.getTypedArrayFromDType("float32",l),h=V.getBroadcastDims(t,o),m=V.getBroadcastDims(n,o),g=V.mergeRealAndImagArrays(r,s),y=V.mergeRealAndImagArrays(a,i),b=t.length,v=O.computeStrides(t),k=n.length,I=O.computeStrides(n);if(h.length+m.length===0)for(let S=0;S<d.length;S++){let N=S%g.length,T=S%y.length,A=e(g[N*2],g[N*2+1],y[T*2],y[T*2+1]);d[S]=A.real,p[S]=A.imag}else for(let S=0;S<d.length;S++){let N=O.indexToLoc(S,u,c),T=N.slice(-b);h.forEach(_=>T[_]=0);let A=O.locToIndex(T,b,v),R=N.slice(-k);m.forEach(_=>R[_]=0);let D=O.locToIndex(R,k,I),$=e(g[A*2],g[A*2+1],y[D*2],y[D*2+1]);d[S]=$.real,p[S]=$.imag}return[d,p,o]}}var gQ=Ur((e,t)=>e+t),rYe=zL((e,t,n,r)=>({real:e+n,imag:t+r})),Zg=bs(Ad,gQ,rYe),sYe={kernelName:Ad,backendName:"cpu",kernelFunc:Zg};function BL(e,t,n,r,s){let a=O.sizeFromShape(r),i=O.makeZerosTypedArray(s,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(a>0?i[l]+=t[o]:i[l]+=1)}return i}function yQ(e,t,n,r=!1){let s=e.shape[0],a=e.shape[1],i=tn([s,n],t.dtype);for(let o=0;o<s;o++)for(let l=0;l<a;l++){let u=e.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(r?i.set(1,o,u):t.size>0?i.set(i.get(o,u)+t.get(o,l),o,u):i.set(i.get(o,u)+1,o,u))}return i}var xQ=Ur((e,t)=>e&t),aYe=bs(Oy,xQ),iYe={kernelName:Oy,backendName:"cpu",kernelFunc:aYe};function pu(e){return(t,n,r)=>{let s=O.getArrayFromDType(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}function Hn(e,t,n){let r=pu(t);return Bd(e,r,n)}function Bd(e,t,n){return({inputs:r,attrs:s,backend:a})=>{let{x:i}=r;wt(i,e);let o=a,l=o.data.get(i.dataId).values,u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=V.fromUint8ToStringArray(l)}else u=l;let c=n||i.dtype,d=t(u,c,s);return o.makeTensorInfo(i.shape,c,d)}}var bQ=pu(e=>Math.ceil(e)),oYe=Bd(tf,bQ),lYe={kernelName:tf,backendName:"cpu",kernelFunc:oYe};function WL(e,t,n,r){let s=O.getArrayFromDType(n,O.sizeFromShape(t));if(r&&n!=="string"){let a=0;e.forEach(i=>{let o=O.sizeFromShape(i.shape);s.set(i.vals,a),a+=o})}else{let a=0;e.forEach(i=>{let o=n==="string"?V.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let u=0;u<i.shape[0];++u){let c=u*t[1]+a;for(let d=0;d<i.shape[1];++d)s[c+d]=o[l++]}a+=i.shape[1]})}return s}var vQ=Ur((e,t)=>e===t?1:0),wQ=bs(Uy,vQ,null,"bool"),uYe={kernelName:Uy,backendName:"cpu",kernelFunc:wQ},kQ=pu(e=>Math.exp(e)),IQ=Bd(ff,kQ,"float32"),cYe={kernelName:ff,backendName:"cpu",kernelFunc:IQ},SQ=pu(e=>Math.expm1(e)),dYe=Bd(mf,SQ),pYe={kernelName:mf,backendName:"cpu",kernelFunc:dYe},CQ=pu(e=>Math.floor(e)),hYe=Bd(gf,CQ),fYe={kernelName:gf,backendName:"cpu",kernelFunc:hYe},NQ=Ur((e,t)=>Math.floor(e/t)),mYe=bs(yf,NQ,null,"int32"),gYe={kernelName:yf,backendName:"cpu",kernelFunc:mYe};function TQ(e,t,n,r,s,a,i,o,l){let u=tn([r,a],n);for(let c=0;c<r;c++){let d=[],p=0;for(let h=0;h<s;h++){let m=e[c*s+h];p+=m*i[h],d.push(m)}if(p<0||p>=l/a)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let h=0;h<a;h++)u.values[c*a+h]=t.get(...t.indexToLoc(p*a+h))}return u}function $Q(e,t,n){let r=tn(n,e.dtype);for(let s=0;s<r.size;++s){let a=r.indexToLoc(s).slice(),i=a[0],o=a[2],l=t.locToIndex([i,o]);a[2]=t.values[l];let u=e.locToIndex(a);0<=u&&u<e.values.length&&(r.values[s]=e.values[u])}return r}var EQ=Ur((e,t)=>e>t?1:0),yYe=bs(Ky,EQ,null,"bool"),xYe={kernelName:Ky,backendName:"cpu",kernelFunc:yYe},_Q=Ur((e,t)=>e>=t?1:0),bYe=bs(bf,_Q,null,"bool"),vYe={kernelName:bf,backendName:"cpu",kernelFunc:bYe},AQ=Ur((e,t)=>e<t?1:0),wYe=bs(Xy,AQ,null,"bool"),kYe={kernelName:Xy,backendName:"cpu",kernelFunc:wYe},RQ=Ur((e,t)=>e<=t?1:0),IYe=bs(Yy,RQ,null,"bool"),SYe={kernelName:Yy,backendName:"cpu",kernelFunc:IYe};function DQ(e,t,n){let r=(t-e)/(n-1),s=O.makeZerosTypedArray(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}var FQ=pu(e=>Math.log(e)),CYe=Bd(Cf,FQ),NYe={kernelName:Cf,backendName:"cpu",kernelFunc:CYe};function OQ(e,t,n,r){let s=O.getTypedArrayFromDType(r,O.sizeFromShape(n));for(let a=0;a<s.length;++a){let i=a*t,o=e[i];for(let l=0;l<t;++l){let u=e[i+l];(Number.isNaN(u)||u>o)&&(o=u)}s[a]=o}return s}var MQ=Ur((e,t)=>Math.max(e,t)),TYe=bs(Ef,MQ),$Ye={kernelName:Ef,backendName:"cpu",kernelFunc:TYe},LQ=Ur((e,t)=>Math.min(e,t)),EYe=bs(Df,LQ),_Ye={kernelName:Df,backendName:"cpu",kernelFunc:EYe},VL=Ur((e,t)=>e*t),AYe=zL((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),cT=bs(Mf,VL,AYe),RYe={kernelName:Mf,backendName:"cpu",kernelFunc:cT};function PQ(e,t,n){let r=O.createScalarValue(-1,n);return VL([],t,r,e,n)}function DYe(e){let{inputs:t,backend:n}=e,{x:r}=t;wt(r,"neg");let s=n.data.get(r.dataId).values,[a,i]=PQ(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}var FYe={kernelName:sx,backendName:"cpu",kernelFunc:DYe},zQ=Ur((e,t)=>e!==t?1:0),OYe=bs(ax,zQ,null,"bool"),MYe={kernelName:ax,backendName:"cpu",kernelFunc:OYe};function UL(e,t,n,r,s){let a=t.length,i=O.sizeFromShape(t),o=O.computeStrides(t),l=O.computeStrides(s),u=O.getTypedArrayFromDType(n,O.sizeFromShape(s));for(let c=0;c<i;++c){let d=O.indexToLoc(c,a,o),p=new Array(d.length);for(let m=0;m<p.length;m++)p[m]=d[r[m]];let h=O.locToIndex(p,a,l);u[h]=e[c]}return u}function ti(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;wt(s,"transpose");let i=s.shape.length,o=new Array(i);for(let c=0;c<o.length;c++)o[c]=s.shape[a[c]];let l=r.data.get(s.dataId).values,u=UL(l,s.shape,s.dtype,a,o);return{dataId:r.write(u,o,s.dtype),shape:o,dtype:s.dtype}}var LYe={kernelName:Ru,backendName:"cpu",kernelFunc:ti};function BQ(e,t,n,r){let[s,a]=V.computeOutAndReduceShapes(e,r),i=Ki(t,"int32"),o=O.makeZerosTypedArray(O.sizeFromShape(s),i),l=O.sizeFromShape(a);for(let u=0;u<o.length;++u){let c=u*l,d=1;for(let p=0;p<l;++p)d*=n[c+p];o[u]=d}return{outVals:o,outShape:s,outDtype:i}}function PYe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;wt(s,"prod");let o=s.shape.length,l=O.parseAxisParam(a,s.shape),u=V.getAxesPermutation(l,o),c=l,d=s,p=[];u!=null&&(d=ti({inputs:{x:s},backend:n,attrs:{perm:u}}),p.push(d),c=V.getInnerMostAxes(c.length,o));let h=n.data.get(d.dataId).values,{outVals:m,outShape:g,outDtype:y}=BQ(d.shape,d.dtype,h,c),b=g;return i&&(b=V.expandShapeToKeepDim(g,l)),p.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(b,y,m)}var zYe={kernelName:Wf,backendName:"cpu",kernelFunc:PYe};function BYe(e,t,n){e.forEach((r,s)=>{if(r<0||r>=n){let a=O.indexToLoc(s,t.length,O.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${r} is not in [0, ${n})`)}})}function WYe(e,t){for(let n=0;n<e.length;++n){let r=e[n],s=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let a=1;a<r.length;++a)if(r[a-1]>r[a])throw new Error("Ragged splits must be sorted in ascending order")}}function VYe(e,t,n,r){let s=[],a=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);WYe(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let c=t[u+1];for(let d=1;d<l+1;++d)o[u].push(d*c)}for(let u=0;u<e.length;++u){let c=e[u],d=e[u]+1;for(let p=0;p<n.length;++p){let h=n[p],m=p+t.length-1;if(m>=0){let g=o[m],y=g[g.length-1]-h[c];for(let b=c;b<d;++b)o[m].push(h[b+1]+y)}c=h[c],d=h[d]}d!==c&&(s.push([c,d]),a+=d-c)}return{outSplits:o,valueSlices:s,numValues:a}}function UYe(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,s=O.getArrayFromDType("int32",r);t.push(s),e[n].forEach((a,i)=>s[i]=a)}return t}function f6(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function GYe(e,t,n,r,s,a){let i=f6(t,2)[1],o=f6(a,2)[1],l=0;for(let u of n)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)s[l*o+d]=e[c*i+d];++l}}function jYe(e,t,n,r,s){let a=t.slice();a[0]=s;let i=O.getArrayFromDType(n,O.sizeFromShape(a)),o=e.length,l=o===0?0:o/t[0];return GYe(e,t,r,l,i,a),[i,a]}function WQ(e,t,n,r,s,a,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(BYe(a,i,l),r.length===0)throw new Error("params.rank must be nonzero");let u=r[0],{outSplits:c,valueSlices:d,numValues:p}=VYe(a,i,e,u),h=UYe(c),m=jYe(n,r,s,d,p);return[h,m[0],m[1]]}var m6=2147483647;function VQ(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,l=s.length===0,u=i.length===0,c=[];o||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let y=1;y<c.length;++y)if(c[y]!==c[y-1])throw new Error("starts, limits, and deltas must have the same shape");let d=c.length===0?1:c[0],p=O.getArrayFromDType("int32",d+1);p[0]=0;for(let y=0;y<d;++y){let b=o?e[0]:e[y],v=l?r[0]:r[y],k=u?a[0]:a[y];if(k===0)throw new Error("Requires delta != 0");let I;if(k>0&&v<b||k<0&&v>b)I=0;else if(I=Math.ceil(Math.abs((v-b)/k)),I>m6)throw new Error(`Requires ((limit - start) / delta) <= ${m6}`);p[y+1]=p[y]+I}let h=p[d],m=O.getArrayFromDType(n,h),g=0;for(let y=0;y<d;++y){let b=p[y+1]-p[y],v=o?e[0]:e[y],k=u?a[0]:a[y];for(let I=0;I<b;++I)m[g++]=v,v+=k}return[p,m]}var po=V.RowPartitionType,HYe=class rR{constructor(t,n,r,s,a,i,o,l,u,c){this.shape=t,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=V.getRowPartitionTypesHelper(c),this.raggedRank=V.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===po.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===po.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case po.VALUE_ROWIDS:return rR.getMaxWidthValueRowID(n);case po.ROW_SPLITS:return rR.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${po[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){let a=t[s+1]-t[s];a>r&&(r=a)}return r}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let r=0,s=t[0],a=0;for(let i=1;i<n;++i){let o=t[i];o!==s&&(s=o,a=Math.max(i-r,a),r=i)}return Math.max(n-r,a)}tensorShapeFromTensor(t,n,r=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return y6(t,r)}calculateOutputSize(t){let n=this.valuesShape,r=this.defaultValueShape;V.validateDefaultValueShape(r,n);let s=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=V.combineRaggedTensorToTensorShapes(this.raggedRank,s,n);a[0]<0&&(a[0]=t);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(t,n,r){let s=Math.min(t,r),a=[],i=0;for(let o=0;o<s;++o,i+=n)a.push(i);for(let o=s;o<t;++o)a.push(-1);return O.assert(a.length===t,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(t,n,r,s){let a=t.length,i=[];for(let o=0;o<a-1;++o){let l=t[o+1]-t[o],u=Math.min(s,l),c=n[o];c===-1&&(u=0);for(let d=0;d<u;++d)i.push(c),c+=r;for(let d=0;d<l-u;++d)i.push(-1)}if(a>0&&i.length!==t[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,r,s){let a=t.length,i=[];if(a===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];i.push(u);for(let c=1;c<a;++c){let d=t[c];if(d===l)u>=0&&(++o,o<s?u+=r:u=-1);else{if(o=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);u=n[d]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,r,s){let a=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case po.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,r,s);case po.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,r,s);default:throw new Error(`Unsupported partition type: ${po[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case po.FIRST_DIM_SIZE:return t[0];case po.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case po.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${po[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let i=r.length-2;i>=0;--i)r[i]=r[i+1]*n[i+1];let s=y6(n,!1),a=O.getArrayFromDType(this.valuesDType,O.sizeFromShape(s));if(r[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,r[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,r[o],n[o]);this.setOutput(this.raggedRank,i,a,s)}return[s,a]}setOutput(t,n,r,s){if(r.length===0)return;let a=this.values,i=r,o=s.slice();o=o.slice(t+1);let l=O.sizeFromShape(o),u=n.length,c=this.defaultValue;if(c.length!==l&&c.length!==1){let m=this.defaultValueShape;ce(()=>{let g=ue(c,m);c=Gp(g,o).dataSync()})}let d=0,p=0,h=0;for(let m=0;m<=u;++m){let g=m<u?n[m]:-1;if(g===h){++h;continue}if(p<h){let y=a.subarray(d*l),b=i.subarray(p*l),v=(h-p)*l;g6(b,y,v)}if(m>=u){let y=r.length;g=Math.floor(y/l)}if(g>h)if(this.defaultValue.length===1)i.subarray(h*l,g*l).fill(this.defaultValue[0]),h=g;else for(;g>h;){let y=i.slice(h*l);g6(y,c,l),++h}g<0?(d=m+1,p=h):(d=m,p=h,h=p+1)}}};function g6(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function y6(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function UQ(e,t,n,r,s,a,i,o,l,u){return new HYe(e,t,n,r,s,a,i,o,l,u).compute()}function GL(e,t,n,r){let s=e===t,a=e<t&&n<0,i=t<e&&n>1;if(s||a||i)return O.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=O.makeZerosTypedArray(o,r);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var GQ=pu(e=>1/Math.sqrt(e)),qYe=Bd(Xf,GQ),KYe={kernelName:Xf,backendName:"cpu",kernelFunc:qYe};function Mp(e,t,n,r,s,a,i,o,l,u){let c=[r/s,s],d=e.values,p=t.values;if(r===0)return tn(n,t.dtype);let h=l instanceof Xr?l:tn(c,t.dtype);typeof l=="string"||typeof l=="number"?h.values.fill(l):typeof l=="boolean"&&h.values.fill(+l);for(let m=0;m<a;m++){let g=[],y=0;for(let b=0;b<i;b++){let v=d[m*i+b];g.push(v),y+=v*o[b]}if(y<0||y>=r/s)throw new Error(`Invalid indices: ${g} does not index into ${n}`);for(let b=0;b<s;b++)u?h.values[y*s+b]+=p[m*s+b]:h.values[y*s+b]=t.rank===0?p[0]:p[m*s+b]}return h}var XYe=pu(e=>1/(1+Math.exp(-e))),jQ=Hn(em,e=>1/(1+Math.exp(-e))),YYe={kernelName:em,backendName:"cpu",kernelFunc:jQ};function BI(e,t,n,r,s){let a=fs.isSliceContinous(r,t,n),i=O.sizeFromShape(n),o=O.computeStrides(r);if(a){let d=fs.computeFlatOffset(t,o);return s==="string"?e.slice(d,d+i):e.subarray(d,d+i)}let l=s==="string"?V.fromUint8ToStringArray(e):e,u=tn(r,s,l),c=tn(n,s);for(let d=0;d<c.size;++d){let p=c.indexToLoc(d),h=p.map((m,g)=>m+t[g]);c.set(u.get(...h),...p)}return s==="string"?V.fromStringArrayToUint8(c.values):c.values}function Nh(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;wt(s,"slice");let[o,l]=fs.parseSliceParams(s,a,i);fs.assertParamsValid(s,o,l);let u=n.data.get(s.dataId).values,c=BI(u,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,c)}var ZYe={kernelName:xx,backendName:"cpu",kernelFunc:Nh};function HQ(e,t,n,r,s,a,i){let o=t[0],l=a[0],u=new Array(l),c=new Array(o),d=t[1];if(l===0){if(o!==0)throw new Error(V.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let y=O.getArrayFromDType(n,0),b=O.getArrayFromDType(s,0);return[y,[0,d],b,u,c]}let p=!0,h=0,m=new Array(l).fill(0);for(let y=0;y<o;++y){let b=e[y*d];if(b<0)throw new Error(V.getSparseFillEmptyRowsNegativeIndexErrorMessage(y,b));if(b>=l)throw new Error(V.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(y,b,l));++m[b],p=p&&b>=h,h=b}let g=!0;for(let y=0;y<l;++y){let b=m[y]===0;u[y]=b,g=g&&!b,m[y]=Math.max(m[y],1),y>0&&(m[y]+=m[y-1])}if(g&&p){let y=e,b=r;for(let v=0;v<o;++v)c[v]=v;return[y,[o,d],b,u,c]}else{let y=m[l-1],b=O.getArrayFromDType(n,y*d),v=O.getArrayFromDType(s,y),k=new Array(l).fill(0);for(let I=0;I<o;++I){let S=e[I*d],N=k[S],T=(S===0?0:m[S-1])+N;k[S]++;for(let A=0;A<d;++A)b[T*d+A]=e[I*d+A];v[T]=r[I],c[I]=T}for(let I=0;I<l;++I)if(k[I]===0){let S=I===0?0:m[I-1];b[S*d+0]=I;for(let N=1;N<d;++N)b[S*d+N]=0;v[S]=i}return[b,[y,d],v,u,c]}}function qQ(e,t,n,r,s){let a=O.sizeFromShape(r),i=t[0],o=s.length,l=[],u=1,c=-1;for(let g=0;g<o;++g){let y=s[g];if(y===-1){if(c!==-1)throw new Error(V.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,g));c=g,l.push(1)}else{if(y<0)throw new Error(V.getSparseReshapeNegativeOutputDimErrorMessage(g,y));u*=y,l.push(y)}}if(c!==-1){if(u<=0)throw new Error(V.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(a/u);if(u*g!==a)throw new Error(V.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=g}if(O.sizeFromShape(l)!==a)throw new Error(V.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let d=r.length,p=[];if(d>0){p[d-1]=1;for(let g=d-2;g>=0;--g)p[g]=p[g+1]*r[g+1]}let h=[];if(o>0){h[o-1]=1;for(let g=o-2;g>=0;--g)h[g]=h[g+1]*l[g+1]}let m=O.getArrayFromDType(n,i*o);for(let g=0;g<i;++g){let y=0;for(let b=0;b<d;++b)y+=e[g*d+b]*p[b];for(let b=0;b<o;++b)m[g*o+b]=Math.trunc(y/h[b]),y%=h[b]}return[m,[i,o],l]}function jL(e,t,n,r,s,a=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error(V.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=c;let p=d.reduce((v,k)=>v*k,1),h=O.getArrayFromDType(n,p);if(o===0)return c>0&&h.fill(i),[h,d];if(c<=0)throw new Error(V.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,g=1,y=0,b=s[m];for(;;){let v=0;if(g<o){if(v=s[g],b===v){++g;continue}if(b>=v)throw new Error(V.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=c)throw new Error(V.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,c));b>y&&h.fill(i,y*u,b*u);for(let k=m;k<g;++k){let I=r[k];if(I<0||I>=l[0])throw new Error(V.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(k,r[k],l[0]));for(let S=0;S<u;S++)h[b*u+S]+=e[I*u+S]}if(a)for(let k=0;k<u;k++)h[b*u+k]/=g-m;if(m=g,++g,y=b+1,b=v,g>o)break}return y<c&&h.fill(i,y*u,c*u),[h,d]}var JYe=pu(e=>Math.sqrt(e)),QYe=Hn(nm,e=>Math.sqrt(e)),eZe={kernelName:nm,backendName:"cpu",kernelFunc:QYe},KQ=Ur((e,t)=>{let n=e-t;return n*n}),tZe=bs(am,KQ),nZe={kernelName:am,backendName:"cpu",kernelFunc:tZe},XQ=pu((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)}),rZe=Bd(P1,XQ),sZe={kernelName:P1,backendName:"cpu",kernelFunc:rZe};function YQ(e,t,n,r){let s=tn(e,t.dtype);for(let a=0;a<s.size;a++){let i=s.indexToLoc(a),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+r[l];s.set(t.get(...o),...i)}return s}var aZe=class{constructor(e,t,n,r,s,a){this.separator=O.encodeString(e),this.nGramWidths=t,this.leftPad=O.encodeString(n),this.rightPad=O.encodeString(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){let o=this.getPadWidth(a),l=Math.max(0,o-i),u=Math.max(0,o-(s-(i+1))),c=a-(l+u),d=t+(l>0?0:i-o),p=0;p+=l*this.leftPad.length;for(let b=0;b<c;++b)p+=e[d+b].length;p+=u*this.rightPad.length;let h=l+u+c-1;p+=h*this.separator.length,n[r+i]=new Uint8Array(p);let m=n[r+i],g=0,y=b=>b.forEach(v=>m[g++]=v);for(let b=0;b<l;++b)y(this.leftPad),y(this.separator);for(let b=0;b<c-1;++b)y(e[d+b]),y(this.separator);if(c>0){y(e[d+c-1]);for(let b=0;b<u;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<u-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<r;++l){let u=t[l]>=o;if(u=u&&t[l]<=n,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let s=r-1,a=O.getArrayFromDType("int32",r);if(n===0||r===0){let o=new Array(n);for(let l=0;l<=s;++l)a[l]=0;return[o,a]}a[0]=0;for(let o=1;o<=s;++o){let l=t[o]-t[o-1],u=0;this.nGramWidths.forEach(c=>{u+=this.getNumNGrams(l,c)}),this.preserveShort&&l>0&&u===0&&(u=1),a[o]=a[o-1]+u}let i=new Array(a[s]);for(let o=0;o<s;++o){let l=t[o],u=a[o];if(this.nGramWidths.forEach(c=>{let d=t[o+1]-t[o],p=this.getNumNGrams(d,c);this.createNGrams(e,l,i,u,p,c),u+=p}),this.preserveShort&&u===a[o]){let c=t[o+1]-t[o];if(c===0)continue;let d=c+2*this.padWidth;this.createNGrams(e,l,i,u,1,d)}}return[i,a]}};function HL(e,t,n,r,s,a,i,o){return new aZe(n,r,s,a,i,o).compute(e,t)}function iZe(e,t,n,r){if(!e.length)return;if(t.length===0){for(let a=0;a<e.length;++a)r.push(e.subarray(a,a+1));return}if(t.length===1){let a=t[0],i=e.indexOf(a);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(a)}(!n||e.length!==0)&&r.push(e);return}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||t.indexOf(e[a])!==-1){let i=e.subarray(s,a);(!n||i.length!==0)&&r.push(i),s=a+1}}function qL(e,t,n){let r=e.length,s=[],a=0,i=0,o=new Array(r);for(let p=0;p<r;++p){let h=s.length;iZe(e[p],t,n,s);let m=s.length-h;o[p]=m,a+=m,i=Math.max(i,m)}let l=O.getArrayFromDType("int32",a*2),u=new Array(a),c=[r,i],d=0;for(let p=0;p<r;++p)for(let h=0;h<o[p];++h)l[d*2]=p,l[d*2+1]=h,u[d]=s[d],++d;return[l,u,c]}function KL(e,t){let n=O.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=O.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var ZQ=Ur((e,t)=>e-t),oZe=zL((e,t,n,r)=>({real:e-n,imag:t-r})),XL=bs(im,ZQ,oZe),lZe={kernelName:im,backendName:"cpu",kernelFunc:XL};function JQ(e,t){let n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];let r=tn(n,e.dtype);for(let s=0;s<r.values.length;++s){let a=r.indexToLoc(s),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=a[l]%e.shape[l];let o=e.locToIndex(i);r.values[s]=e.values[o]}return r}var Xb=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function QQ(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let o=r-n+1,l=t-n+1,u=Math.log(o),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(o-c)/o)*Math.sign(l-o/2),p=Math.max(n,Math.floor(t-l*c/o+d)),h=Math.min(r,Math.floor(t+(o-l)*c/o+d));QQ(e,t,p,h)}let s=e[t],a=n,i=r;for(O.swap(e,n,t),Xb(e[r],s)>0&&O.swap(e,n,r);a<i;){for(O.swap(e,a,i),a++,i--;Xb(e[a],s)<0;)a=a+1;for(;Xb(e[i],s)>0;)i=i-1}Xb(e[n],s)===0?O.swap(e,n,i):(i=i+1,O.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function eee(e,t,n,r,s){let a=t[t.length-1],[i,o]=[e.length/a,a],l=O.getTypedArrayFromDType(n,i*r),u=O.getTypedArrayFromDType("int32",i*r);for(let d=0;d<i;d++){let p=d*o,h=e.subarray(p,p+o),m=new Array(h.length);h.forEach((v,k)=>m[k]={value:v,index:k}),r<m.length&&(QQ(m,r),m=m.slice(0,r)),s&&m.sort(Xb);let g=d*r,y=l.subarray(g,g+r),b=u.subarray(g,g+r);for(let v=0;v<r;v++)y[v]=m[v].value,b[v]=m[v].index}let c=t.slice();return c[c.length-1]=r,[tn(c,n,l),tn(c,"int32",u)]}function YL(e,t,n,r){let s=O.parseAxisParam(t,n)[0],a=[1,n[0],1];for(let m=0;m<s;m++)a[0]*=n[m];a[1]=n[s];for(let m=s+1;m<n.length;m++)a[2]*=n[m];let i=new Map,o=new Int32Array(n[s]),l=new Xr(a,r,e),u=[],c=a[0]===1&&a[2]===1;for(let m=0;m<n[s];m++){let g;if(c)g=e[m].toString();else{let b=[];for(let v=0;v<a[0];v++)for(let k=0;k<a[2];k++)b.push(l.get(v,m,k));g=b.join(",")}let y=i.get(g);if(y!=null)o[m]=y;else{let b=i.size;i.set(g,b),o[m]=b,u.push(m)}}let d=a.slice();d[1]=i.size;let p=new Xr(d,r);u.forEach((m,g)=>{for(let y=0;y<a[0];y++)for(let b=0;b<a[2];b++)p.set(l.get(y,m,b),y,g,b)});let h=n.slice();return h[s]=d[1],{outputValues:p.values,outputShape:h,indices:o}}var uZe="4.22.0";oN("cpu",()=>new LL,1);var tee=Hn(pf,e=>e>=0?e:Math.exp(e)-1),cZe={kernelName:pf,backendName:"cpu",kernelFunc:tee};function nee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;wt([s],"leakyRelu");let i=O.sizeFromShape(s.shape),o=n.data.get(s.dataId).values,l=O.getTypedArrayFromDType("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?a*o[u]:o[u];return n.makeTensorInfo(s.shape,"float32",l)}var dZe={kernelName:Sf,backendName:"cpu",kernelFunc:nee},pZe=Ur((e,t)=>e<0?t*e:e);function ree(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t;wt([r,s],"prelu");let a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=pZe(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}var hZe={kernelName:Bf,backendName:"cpu",kernelFunc:ree},see=Hn(Uf,e=>Math.max(0,e)),fZe={kernelName:Uf,backendName:"cpu",kernelFunc:see},aee=Hn(Hf,e=>Math.min(Math.max(0,e),6)),mZe={kernelName:Hf,backendName:"cpu",kernelFunc:aee};function WI(e,t,n,r,s){if(n==="linear")return au({inputs:{x:t},backend:e});if(n==="relu")return see({inputs:{x:t},backend:e});if(n==="elu")return tee({inputs:{x:t},backend:e});if(n==="relu6")return aee({inputs:{x:t},backend:e});if(n==="prelu")return ree({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return nee({inputs:{x:t},backend:e,attrs:{alpha:s}});if(n==="sigmoid")return jQ({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function ur(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=O.sizeFromShape(s.shape),o=O.inferFromImplicitShape(a,i),l=O.sizeFromShape(o);O.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);let u=n.data.get(s.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,d=u.complexTensorInfos.imag;c.shape=o,d.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}var gZe={kernelName:dx,backendName:"cpu",kernelFunc:ur};function iee(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;wt([s,a],"matMul");let l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=o?a.shape[u-1]:a.shape[u-2],p=i?s.shape[l-1]:s.shape[l-2],h=o?a.shape[u-2]:a.shape[u-1],m=s.shape.slice(0,-2),g=a.shape.slice(0,-2),y=O.sizeFromShape(m),b=O.sizeFromShape(g),v=Ex.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([p,h]);O.assert(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);let k=i?[y,c,p]:[y,p,c],I=o?[b,h,d]:[b,d,h],S=ur({inputs:{x:s},backend:n,attrs:{shape:k}}),N=ur({inputs:{x:a},backend:n,attrs:{shape:I}}),T=i?S.shape[1]:S.shape[2],A=i?S.shape[2]:S.shape[1],R=o?N.shape[1]:N.shape[2],D=Math.max(y,b),$=n.data.get(S.dataId).values,_=n.data.get(N.dataId).values,L=O.computeStrides(S.shape),z=O.computeStrides(N.shape),[W,G,q]=i?[L[0],1,L[1]]:[L[0],L[1],1],[B,j,H]=o?[1,z[1],z[0]]:[z[1],1,z[0]],P=A*R,X=tn([D,A,R],S.dtype),Q=X.values,re=n.blockSize;for(let le=0;le<D;le++){let ke=le%y,Ne=le%b;for(let we=0;we<A;we+=re){let _e=Math.min(we+re,A);for(let Le=0;Le<R;Le+=re){let Be=Math.min(Le+re,R);for(let Ze=0;Ze<T;Ze+=re){let ut=Math.min(Ze+re,T);for(let ft=we;ft<_e;ft++)for(let et=Le;et<Be;et++){let Qe=0;for(let ot=Ze;ot<ut;ot++){let gt=$[ke*W+ft*G+ot*q],At=_[ot*B+et*j+Ne*H];Qe+=gt*At}Q[le*P+(ft*R+et)]+=Qe}}}}}return n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(N),n.makeTensorInfo(v,X.dtype,X.values)}var yZe={kernelName:Qh,backendName:"cpu",kernelFunc:iee};function xZe(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r,p,h,m,g=[];p=iee({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(h=Zg({inputs:{a:p,b:i},backend:n}),g.push(p),p=h),c&&(m=WI(n,p,c,o,d),g.push(p),p=m);for(let y of g)n.disposeIntermediateTensorInfo(y);return p}var bZe={kernelName:ph,backendName:"cpu",kernelFunc:xZe},vZe=Hn(Gh,e=>Math.acos(e)),wZe={kernelName:Gh,backendName:"cpu",kernelFunc:vZe},kZe=Hn(jh,e=>Math.acosh(e)),IZe={kernelName:jh,backendName:"cpu",kernelFunc:kZe};function SZe(e){let{inputs:t,backend:n}=e,r=t;wt(t,"addN");let s=r.map(o=>n.data.get(o.dataId).values),a=tn(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){let l=s[o];for(let u=0;u<i.length;u++)i[u]+=l[u]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}var CZe={kernelName:Hh,backendName:"cpu",kernelFunc:SZe};function NZe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;wt(s,"all");let o=O.parseAxisParam(a,s.shape),l=o,u=V.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=ti({inputs:{x:s},backend:n,attrs:{perm:u}}),l=V.getInnerMostAxes(l.length,s.shape.length)),V.assertAxesAreInnerMostDims("all",l,c.shape.length);let[d,p]=V.computeOutAndReduceShapes(c.shape,l),h=O.sizeFromShape(p),m=O.makeZerosTypedArray(O.sizeFromShape(d),c.dtype),g=n.data.get(c.dataId).values;for(let b=0;b<m.length;++b){let v=b*h,k=g[v];for(let I=0;I<h;++I){let S=g[v+I];k=k&&S}m[b]=k}u!=null&&n.disposeIntermediateTensorInfo(c);let y=n.makeTensorInfo(d,c.dtype,m);if(i){let b=V.expandShapeToKeepDim(d,o),v=ur({inputs:{x:y},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(y),v}return y}var TZe={kernelName:$y,backendName:"cpu",kernelFunc:NZe};function $Ze(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;wt(s,"any");let o=O.parseAxisParam(a,s.shape),l=o,u=V.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=ti({inputs:{x:s},backend:n,attrs:{perm:u}}),l=V.getInnerMostAxes(l.length,s.shape.length)),V.assertAxesAreInnerMostDims("any",l,c.shape.length);let[d,p]=V.computeOutAndReduceShapes(c.shape,l),h=O.sizeFromShape(p),m=O.makeZerosTypedArray(O.sizeFromShape(d),c.dtype),g=n.data.get(c.dataId).values;for(let b=0;b<m.length;++b){let v=b*h,k=g[v];for(let I=0;I<h;++I){let S=g[v+I];k=k||S}m[b]=k}u!=null&&n.disposeIntermediateTensorInfo(c);let y=n.makeTensorInfo(d,c.dtype,m);if(i){let b=V.expandShapeToKeepDim(d,o),v=ur({inputs:{x:y},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(y),v}return y}var EZe={kernelName:Ey,backendName:"cpu",kernelFunc:$Ze};function _Ze(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;wt(s,"argMax");let i=O.parseAxisParam(a,s.shape),o=V.getAxesPermutation(i,s.shape.length),l=s,u=[];o!=null&&(l=ti({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=V.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],V.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[c,d]=V.computeOutAndReduceShapes(l.shape,i),p=O.sizeFromShape(c),h=O.makeZerosTypedArray(p,"int32"),m=O.sizeFromShape(d),g=n.data.get(l.dataId).values;for(let y=0;y<h.length;++y){let b=y*m,v=g[b],k=0;for(let I=0;I<m;++I){let S=g[b+I];S>v&&(v=S,k=I)}h[y]=k}return u.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(c,"int32",h)}var AZe={kernelName:_y,backendName:"cpu",kernelFunc:_Ze};function RZe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;wt(s,"argMin");let i=O.parseAxisParam(a,s.shape),o=V.getAxesPermutation(i,s.shape.length),l=s,u=[];o!=null&&(l=ti({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=V.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],V.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[c,d]=V.computeOutAndReduceShapes(l.shape,i),p=O.sizeFromShape(c),h=O.makeZerosTypedArray(p,"int32"),m=O.sizeFromShape(d),g=n.data.get(l.dataId).values;for(let y=0;y<h.length;++y){let b=y*m,v=g[b],k=0;for(let I=0;I<m;++I){let S=g[b+I];S<v&&(v=S,k=I)}h[y]=k}return u.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(c,"int32",h)}var DZe={kernelName:Ay,backendName:"cpu",kernelFunc:RZe},FZe=Hn(qh,e=>Math.asin(e)),OZe={kernelName:qh,backendName:"cpu",kernelFunc:FZe},MZe=Hn(Kh,e=>Math.asinh(e)),LZe={kernelName:Kh,backendName:"cpu",kernelFunc:MZe},PZe=Hn(Xh,e=>Math.atan(e)),zZe={kernelName:Xh,backendName:"cpu",kernelFunc:PZe},BZe=Ur((e,t)=>Math.atan2(e,t)),WZe=bs(Zh,BZe),VZe={kernelName:Zh,backendName:"cpu",kernelFunc:WZe},UZe=Hn(Yh,e=>Math.atanh(e)),GZe={kernelName:Yh,backendName:"cpu",kernelFunc:UZe};function ZL(e,t,n,r,s,a){let i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,h=s.padInfo.left,m=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=tn(s.outShape,n),y=g.values,b=s.outShape[1]*s.outShape[2]*s.outShape[3],v=s.outShape[2]*s.outShape[3],k=s.outShape[3];for(let I=0;I<s.batchSize;++I){let S=I*b,N=I*r[0];for(let T=0;T<s.inChannels;++T)for(let A=0;A<s.outHeight;++A){let R=A*i-p,D=Math.max(0,R),$=Math.min(s.inHeight,c+R),_=S+A*v;for(let L=0;L<s.outWidth;++L){let z=L*o-h,W=Math.max(0,z),G=Math.min(s.inWidth,d+z),q=m,B=0,j=0;for(let P=D;P<$;P+=l){let X=N+P*r[1];for(let Q=W;Q<G;Q+=u){let re=X+Q*r[2],le=e[re+T];a==="max"&&le>q?q=le:a==="avg"&&(B+=le,j++)}if(isNaN(q))break}let H=_+L*k+T;y[H]=a==="avg"?B/j:q}}}return g}function oee(e,t,n,r,s=!1,a=!1){let i=tn(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,h=r.padInfo.top,m=r.padInfo.left,g=tn(t,n,e);for(let y=0;y<r.batchSize;++y)for(let b=0;b<r.inChannels;++b)for(let v=0;v<r.outHeight;++v){let k=v*o-h,I=k;for(;I<0;)I+=u;let S=Math.min(r.inHeight,d+k);for(let N=0;N<r.outWidth;++N){let T=N*l-m,A=T;for(;A<0;)A+=c;let R=Math.min(r.inWidth,p+T),D=Number.NEGATIVE_INFINITY,$=-1;for(let _=I;_<S;_+=u){let L=_-k;for(let z=A;z<R;z+=c){let W=z-T,G=g.get(y,_,z,b);G>D&&(D=G,s?$=a?((y*r.inHeight+_)*r.inWidth+z)*r.inChannels+b:(_*r.inWidth+z)*r.inChannels+b:$=L*p+W)}}i.set($,y,v,N,b)}}return i}function lee(e,t,n,r,s,a){let i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,p=s.effectiveFilterDepth,h=s.effectiveFilterHeight,m=s.effectiveFilterWidth,g=s.padInfo.front,y=s.padInfo.top,b=s.padInfo.left,v=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,k=tn(s.outShape,n),I=k.values,S=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],N=s.outShape[2]*s.outShape[3]*s.outShape[4],T=s.outShape[3]*s.outShape[4],A=s.outShape[4];for(let R=0;R<s.batchSize;++R){let D=R*S,$=R*r[0];for(let _=0;_<s.inChannels;++_)for(let L=0;L<s.outDepth;++L){let z=L*i-g,W=z;for(;W<0;)W+=u;let G=Math.min(s.inDepth,p+z),q=D+L*N;for(let B=0;B<s.outHeight;++B){let j=B*o-y,H=j;for(;H<0;)H+=c;let P=Math.min(s.inHeight,h+j),X=q+B*T;for(let Q=0;Q<s.outWidth;++Q){let re=Q*l-b,le=re;for(;le<0;)le+=d;let ke=Math.min(s.inWidth,m+re),Ne=X+Q*A,we=v,_e=0,Le=0;for(let Ze=W;Ze<G;Ze+=u){let ut=$+Ze*r[1];for(let ft=H;ft<P;ft+=c){let et=ut+ft*r[2];for(let Qe=le;Qe<ke;Qe+=d){let ot=et+Qe*r[3],gt=e[ot+_];if(a==="max"&&gt>we?we=gt:a==="avg"&&(_e+=gt,Le++),isNaN(we))break}if(isNaN(we))break}if(isNaN(we))break}let Be=Ne+_;I[Be]=a==="avg"?_e/Math.max(Le,1):we}}}}return k}function jZe(e,t){let n=tn(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=t.padInfo.front,h=t.padInfo.top,m=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let y=0;y<t.inChannels;++y)for(let b=0;b<t.outDepth;++b){let v=b*r-p,k=v;for(;k<0;)k+=i;let I=Math.min(t.inDepth,u+v);for(let S=0;S<t.outHeight;++S){let N=S*s-h,T=N;for(;T<0;)T+=o;let A=Math.min(t.inHeight,c+N);for(let R=0;R<t.outWidth;++R){let D=R*a-m,$=D;for(;$<0;)$+=l;let _=Math.min(t.inWidth,d+D),L=Number.NEGATIVE_INFINITY,z=-1;for(let W=k;W<I;W+=i){let G=W-v;for(let q=T;q<A;q+=o){let B=q-N;for(let j=$;j<_;j+=l){let H=j-D,P=e.get(g,W,q,j,y);P>=L&&(L=P,z=G*c*d+B*c+H)}}}n.set(z,g,b,S,R,y)}}}return n}function HZe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;wt(s,"avgPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;O.assert(V.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=V.computePool2DInfo(s.shape,a,i,u,o,l),d;if(c.filterWidth===1&&c.filterHeight===1&&O.arraysEqual(c.inShape,c.outShape))d=au({inputs:{x:s},backend:n});else{let p=n.data.get(s.dataId).values,h=O.computeStrides(s.shape),m=ZL(p,s.shape,s.dtype,h,c,"avg");d=n.makeTensorInfo(c.outShape,s.dtype,m.values)}return d}var qZe={kernelName:Jh,backendName:"cpu",kernelFunc:HZe};function KZe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;wt(s,"avgPool3d");let c=V.computePool3DInfo(s.shape,a,i,1,o,l,u),d=n.data.get(s.dataId).values,p=lee(d,s.shape,s.dtype,O.computeStrides(s.shape),c,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}var XZe={kernelName:Ry,backendName:"cpu",kernelFunc:KZe};function YZe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;wt([s,a],"avgPool3DGrad");let c=V.computePool3DInfo(a.shape,i,o,1,l,u),d=c.strideDepth,p=c.strideHeight,h=c.strideWidth,m=c.filterDepth,g=c.filterHeight,y=c.filterWidth,b=c.dilationDepth,v=c.dilationHeight,k=c.dilationWidth,I=c.effectiveFilterDepth,S=c.effectiveFilterHeight,N=c.effectiveFilterWidth,T=I-1-c.padInfo.front,A=N-1-c.padInfo.left,R=S-1-c.padInfo.top,D=tn(a.shape,"float32"),$=1/(m*g*y),_=n.bufferSync(s);for(let L=0;L<c.batchSize;++L)for(let z=0;z<c.inChannels;++z)for(let W=0;W<c.inDepth;++W)for(let G=0;G<c.inHeight;++G)for(let q=0;q<c.inWidth;++q){let B=W-T,j=G-R,H=q-A,P=0;for(let X=0;X<I;X+=b){let Q=(B+X)/d;if(!(Q<0||Q>=c.outDepth||Math.floor(Q)!==Q))for(let re=0;re<S;re+=v){let le=(j+re)/p;if(!(le<0||le>=c.outHeight||Math.floor(le)!==le))for(let ke=0;ke<N;ke+=k){let Ne=(H+ke)/h;if(Ne<0||Ne>=c.outWidth||Math.floor(Ne)!==Ne)continue;let we=_.get(L,Q,le,Ne,z);P+=we}}}D.set(P*$,L,W,G,q,z)}return n.makeTensorInfo(D.shape,D.dtype,D.values)}var ZZe={kernelName:S1,backendName:"cpu",kernelFunc:YZe};function JZe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;wt([s,a],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=V.computePool2DInfo(i.shape,o,l,1,u),d=c.strideHeight,p=c.strideWidth,h=c.filterHeight,m=c.filterWidth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterHeight,v=c.effectiveFilterWidth,k=v-1-c.padInfo.left,I=b-1-c.padInfo.top,S=tn(i.shape,"float32"),N=1/(h*m),T=n.data.get(s.dataId).values,A=tn(s.shape,"float32",T);for(let R=0;R<c.batchSize;++R)for(let D=0;D<c.inChannels;++D)for(let $=0;$<c.inHeight;++$)for(let _=0;_<c.inWidth;++_){let L=$-I,z=_-k,W=0;for(let G=0;G<b;G+=g){let q=(L+G)/d;if(!(q<0||q>=c.outHeight||Math.floor(q)!==q))for(let B=0;B<v;B+=y){let j=(z+B)/p;if(j<0||j>=c.outWidth||Math.floor(j)!==j)continue;let H=A.get(R,q,j,D);W+=H}}S.set(W*N,R,$,_,D)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}var QZe={kernelName:I1,backendName:"cpu",kernelFunc:JZe};function eJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;O.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),wt([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);let c=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,p=n.data.get(l.dataId).values,h=a?n.data.get(a.dataId).values:new Float32Array([1]),m=i?n.data.get(i.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),y=m.length,b=h.length,v=p.length,k=d.length,I=0,S=0,N=0,T=0;for(let A=0;A<c.length;++A)g[A]=m[I++]+(c[A]-d[S++])*h[N++]/Math.sqrt(p[T++]+u),I>=y&&(I=0),S>=k&&(S=0),N>=b&&(N=0),T>=v&&(T=0);return n.makeTensorInfo(s.shape,s.dtype,g)}var tJe={kernelName:xf,backendName:"cpu",kernelFunc:eJe};function nJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;wt([s],"batchToSpaceND");let o=a.reduce((b,v)=>b*v),l=V.getReshaped(s.shape,a,o),u=V.getPermuted(l.length,a.length),c=V.getReshapedPermuted(s.shape,a,o),d=V.getSliceBeginCoords(i,a.length),p=V.getSliceSize(c,i,a.length),h=ur({inputs:{x:s},backend:n,attrs:{shape:l}}),m=ti({inputs:{x:h},backend:n,attrs:{perm:u}}),g=ur({inputs:{x:m},backend:n,attrs:{shape:c}}),y=Nh({inputs:{x:g},backend:n,attrs:{begin:d,size:p}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}var rJe={kernelName:Dy,backendName:"cpu",kernelFunc:nJe};function sJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=BL(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}var aJe={kernelName:Fy,backendName:"cpu",kernelFunc:sJe};function iJe(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=V.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var oJe={kernelName:C1,backendName:"cpu",kernelFunc:iJe},lJe=Hn(Rd,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),uJe={kernelName:Rd,backendName:"cpu",kernelFunc:lJe},cJe=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(O.sizeFromShape(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let c=o[u],d=l[u];r[u]=Math.hypot(c,d)}return n.makeOutput(r,t.shape,"float32")},dJe={kernelName:N1,backendName:"cpu",kernelFunc:cJe};function Jg(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}var pJe={kernelName:eN,backendName:"cpu",kernelFunc:Jg};function Qg(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=O.parseAxisParam(s,t[0].shape)[0],i=t.map(g=>g.shape);V.assertParamsConsistent(i,a);let o=V.computeOutShape(t.map(g=>g.shape),a);if(O.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(g=>O.sizeFromShape(g.shape)>0);if(l.length===1)return au({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){let g=l.map(I=>Ch({inputs:{input:I},backend:n})),y=l.map(I=>Jg({inputs:{input:I},backend:n})),b=Qg({inputs:g,backend:n,attrs:{axis:a}}),v=Qg({inputs:y,backend:n,attrs:{axis:a}}),k=gi({inputs:{real:b,imag:v},backend:n});return g.forEach(I=>n.disposeIntermediateTensorInfo(I)),y.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),k}let u=l.map(g=>{let y=[-1,O.sizeFromShape(g.shape.slice(a))];return ur({inputs:{x:g},backend:n,attrs:{shape:y}})}),c=u.map(g=>({vals:n.data.get(g.dataId).values,shape:g.shape}));o=V.computeOutShape(u.map(g=>g.shape),1);let d=u[0].shape[0]===1,p=WL(c,o,t[0].dtype,d),h=V.computeOutShape(l.map(g=>g.shape),a),m=n.makeTensorInfo(h,t[0].dtype,p);return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}var hJe={kernelName:My,backendName:"cpu",kernelFunc:Qg};function uee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;wt([s,a],"conv2d");let d=V.convertConv2DDataFormat(l),p=V.computeConv2DInfo(s.shape,a.shape,i,u,o,c,!1,d),h=p.filterHeight,m=p.filterWidth,g=p.dilationHeight,y=p.dilationWidth,b=p.padInfo.left,v=p.padInfo.top,k=p.dataFormat==="channelsLast",I=new Xr(p.outShape,s.dtype),S=O.computeStrides(s.shape),N=O.computeStrides(a.shape),T=S[0],A=k?S[1]:S[2],R=k?S[2]:1,D=k?1:S[1],$=I.strides[0],_=k?I.strides[1]:I.strides[2],L=k?I.strides[2]:1,z=k?1:I.strides[1],W=n.data.get(s.dataId).values,G=n.data.get(a.dataId).values,q=I.values;for(let B=0;B<p.batchSize;++B){let j=B*T,H=B*$;for(let P=0;P<p.outHeight;++P){let X=H+P*_,Q=P*p.strideHeight-v;for(let re=0;re<h;++re){let le=Q+re*g;if(le<0||le>=p.inHeight)continue;let ke=re*N[0],Ne=j+le*A;for(let we=0;we<p.outWidth;++we){let _e=X+we*L,Le=we*p.strideWidth-b;for(let Be=0;Be<m;++Be){let Ze=Le+Be*y;if(Ze<0||Ze>=p.inWidth)continue;let ut=ke+Be*N[1],ft=Ne+Ze*R,et=ut;for(let Qe=0;Qe<p.inChannels;++Qe){let ot=W[ft+Qe*D];for(let gt=0;gt<p.outChannels;++gt)q[_e+gt*z]+=ot*G[et+gt];et+=p.outChannels}}}}}}return n.makeTensorInfo(I.shape,I.dtype,q)}var fJe={kernelName:nf,backendName:"cpu",kernelFunc:uee};function mJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;wt([s,a],"conv2dBackpropFilter");let d=V.convertConv2DDataFormat(l),p=V.computeConv2DInfo(s.shape,c,i,1,o,u,!1,d),{strideHeight:h,strideWidth:m,filterHeight:g,filterWidth:y}=p,b=p.dataFormat==="channelsLast",v=new Xr(p.filterShape,"float32"),k=p.padInfo.left,I=p.padInfo.top,S=n.data.get(s.dataId).values,N=n.data.get(a.dataId).values,T=new Xr(s.shape,s.dtype,S),A=new Xr(a.shape,a.dtype,N);for(let R=0;R<g;++R){let D=Math.max(0,Math.ceil((I-R)/h)),$=Math.min(p.outHeight,(p.inHeight+I-R)/h);for(let _=0;_<y;++_){let L=Math.max(0,Math.ceil((k-_)/m)),z=Math.min(p.outWidth,(p.inWidth+k-_)/m);for(let W=0;W<p.inChannels;++W)for(let G=0;G<p.outChannels;++G){let q=0;for(let B=0;B<p.batchSize;++B)for(let j=D;j<$;++j){let H=R+j*h-I;for(let P=L;P<z;++P){let X=_+P*m-k;b?q+=T.get(B,H,X,W)*A.get(B,j,P,G):q+=T.get(B,W,H,X)*A.get(B,G,j,P)}}v.set(q,R,_,W,G)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var gJe={kernelName:qC,backendName:"cpu",kernelFunc:mJe};function yJe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;wt([s,a],"conv2dBackpropInput");let d=O.computeStrides(a.shape),p=O.computeStrides(s.shape),h=V.convertConv2DDataFormat(u),m=V.computeConv2DInfo(i,a.shape,o,1,l,c,!1,h),g=new Xr(m.inShape,"float32"),y=g.values,b=n.data.get(s.dataId).values,v=n.data.get(a.dataId).values,[k,I,S]=d,{batchSize:N,filterHeight:T,filterWidth:A,inChannels:R,inHeight:D,inWidth:$,outChannels:_,outHeight:L,outWidth:z,strideHeight:W,strideWidth:G}=m;h=m.dataFormat;let q=T-1-m.padInfo.top,B=A-1-m.padInfo.left,j=h==="channelsLast",H=g.strides[0],P=j?g.strides[1]:g.strides[2],X=j?g.strides[2]:1,Q=j?1:g.strides[1],re=p[0],le=j?p[1]:p[2],ke=j?p[2]:1,Ne=j?1:p[1];for(let we=0;we<N;++we)for(let _e=0;_e<R;++_e)for(let Le=0;Le<D;++Le){let Be=Le-q,Ze=Math.max(0,Math.ceil(Be/W)),ut=Math.min(L,(T+Be)/W);for(let ft=0;ft<$;++ft){let et=ft-B,Qe=Math.max(0,Math.ceil(et/G)),ot=Math.min(z,(A+et)/G),gt=0;for(let Et=Ze;Et<ut;++Et){let dn=Et*W-Be;for(let Xt=Qe;Xt<ot;++Xt){let In=Xt*G-et,Ve=re*we+le*Et+ke*Xt,tt=k*(T-1-dn)+I*(A-1-In)+S*_e;for(let Rt=0;Rt<_;++Rt){let Dt=b[Ve+Ne*Rt],Ut=v[tt+Rt];gt+=Dt*Ut}}}let At=H*we+P*Le+X*ft+Q*_e;y[At]=gt}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var xJe={kernelName:rf,backendName:"cpu",kernelFunc:yJe};function bJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;wt([s,a],"conv3d");let u=V.computeConv3DInfo(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:p,dilationDepth:h,dilationHeight:m,dilationWidth:g,padInfo:y}=u,b=y.front,v=y.left,k=y.top,I=new Xr(u.outShape,s.dtype),S=n.data.get(s.dataId).values,N=n.data.get(a.dataId).values,T=I.values,A=O.computeStrides(s.shape),R=O.computeStrides(a.shape);for(let D=0;D<u.batchSize;++D){let $=D*A[0],_=D*I.strides[0];for(let L=0;L<u.outDepth;++L){let z=_+L*I.strides[1],W=L*u.strideDepth-b;for(let G=0;G<c;++G){let q=W+G*h;if(q<0||q>=u.inDepth)continue;let B=G*R[0],j=$+q*A[1];for(let H=0;H<u.outHeight;++H){let P=z+H*I.strides[2],X=H*u.strideHeight-k;for(let Q=0;Q<d;++Q){let re=X+Q*m;if(re<0||re>=u.inHeight)continue;let le=B+Q*R[1],ke=j+re*A[2];for(let Ne=0;Ne<u.outWidth;++Ne){let we=P+Ne*u.outChannels,_e=Ne*u.strideWidth-v;for(let Le=0;Le<p;++Le){let Be=_e+Le*g;if(Be<0||Be>=u.inWidth)continue;let Ze=le+Le*R[2],ut=ke+Be*u.inChannels,ft=Ze;for(let et=0;et<u.inChannels;++et){let Qe=S[ut+et];for(let ot=0;ot<u.outChannels;++ot)T[we+ot]+=Qe*N[ft+ot];ft+=u.outChannels}}}}}}}}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var vJe={kernelName:sf,backendName:"cpu",kernelFunc:bJe};function wJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;wt([s,a],"conv3dBackpropFilterV2");let u=O.computeStrides(s.shape),c=O.computeStrides(a.shape),d=V.computeConv3DInfo(s.shape,l,i,1,o),p=d.strideDepth,h=d.strideHeight,m=d.strideWidth,g=d.filterDepth,y=d.filterHeight,b=d.filterWidth,v=new Xr(d.filterShape,"float32"),k=v.values,[I,S,N,T]=v.strides,A=n.data.get(a.dataId).values,[R,D,$,_]=c,L=n.data.get(s.dataId).values,[z,W,G,q]=u,B=d.padInfo.front,j=d.padInfo.left,H=d.padInfo.top;for(let P=0;P<g;++P){let X=Math.max(0,Math.ceil((B-P)/p)),Q=Math.min(d.outDepth,(d.inDepth+B-P)/p),re=P*I;for(let le=0;le<y;++le){let ke=Math.max(0,Math.ceil((H-le)/h)),Ne=Math.min(d.outHeight,(d.inHeight+H-le)/h),we=le*S+re;for(let _e=0;_e<b;++_e){let Le=Math.max(0,Math.ceil((j-_e)/m)),Be=Math.min(d.outWidth,(d.inWidth+j-_e)/m),Ze=_e*N+we;for(let ut=0;ut<d.inChannels;++ut){let ft=ut*T+Ze;for(let et=0;et<d.outChannels;++et){let Qe=0;for(let ot=0;ot<d.batchSize;++ot){let gt=ot*z,At=ot*R;for(let Et=X;Et<Q;++Et){let dn=(P+Et*p-B)*W+gt,Xt=Et*D+At;for(let In=ke;In<Ne;++In){let Ve=(le+In*h-H)*G+dn,tt=In*$+Xt;for(let Rt=Le;Rt<Be;++Rt){let Dt=(_e+Rt*m-j)*q+Ve,Ut=Rt*_+tt;Qe+=L[Dt+ut]*A[Ut+et]}}}}k[ft+et]=Qe}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var kJe={kernelName:Ly,backendName:"cpu",kernelFunc:wJe};function IJe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;wt([s],"conv3dBackpropInputV2");let u=O.computeStrides(s.shape),c=O.computeStrides(a.shape),d=V.computeConv3DInfo(l,a.shape,o,1,i),p=new Xr(d.inShape,"float32"),h=p.values,[m,g,y,b]=p.strides,v=n.data.get(s.dataId).values,[k,I,S,N]=u,T=n.data.get(a.dataId).values,[A,R,D,$]=c,{batchSize:_,filterDepth:L,filterHeight:z,filterWidth:W,inChannels:G,inDepth:q,inHeight:B,inWidth:j,outChannels:H,outDepth:P,outHeight:X,outWidth:Q,strideDepth:re,strideHeight:le,strideWidth:ke}=d,Ne=L-1-d.padInfo.front,we=z-1-d.padInfo.top,_e=W-1-d.padInfo.left;for(let Le=0;Le<_;++Le)for(let Be=0;Be<G;++Be)for(let Ze=0;Ze<q;++Ze){let ut=Ze-Ne,ft=Math.max(0,Math.ceil(ut/re)),et=Math.min(P,(L+ut)/re);for(let Qe=0;Qe<B;++Qe){let ot=Qe-we,gt=Math.max(0,Math.ceil(ot/le)),At=Math.min(X,(z+ot)/le);for(let Et=0;Et<j;++Et){let dn=Et-_e,Xt=Math.max(0,Math.ceil(dn/ke)),In=Math.min(Q,(W+dn)/ke),Ve=0;for(let tt=ft;tt<et;++tt){let Rt=tt*re-ut;for(let Dt=gt;Dt<At;++Dt){let Ut=Dt*le-ot;for(let Pn=Xt;Pn<In;++Pn){let dr=Pn*ke-dn,zn=k*Le+I*tt+S*Dt+N*Pn,Gr=A*(L-1-Rt)+R*(z-1-Ut)+D*(W-1-dr)+$*Be;for(let Sn=0;Sn<H;++Sn){let pn=v[zn+Sn],Fn=T[Gr+Sn];Ve+=pn*Fn}}}}h[m*Le+g*Ze+y*Qe+b*Et+Be]=Ve}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}var SJe={kernelName:Py,backendName:"cpu",kernelFunc:IJe},CJe=Hn(af,e=>Math.cos(e)),NJe={kernelName:af,backendName:"cpu",kernelFunc:CJe},TJe=Hn(of,e=>Math.cosh(e)),$Je={kernelName:of,backendName:"cpu",kernelFunc:TJe};function EJe(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,p,h]=s.shape,m=a.shape[0],[g,y]=o,b=tn([m,g,y,h],"float32"),v=n.data.get(a.dataId).values,k=n.data.get(i.dataId).values,I=n.data.get(s.dataId).values,S=O.computeStrides(s.shape),N=O.computeStrides(b.shape);for(let T=0;T<m;T++){let A=T*4,R=v[A],D=v[A+1],$=v[A+2],_=v[A+3],L=k[T];if(L>=c)continue;let z=g>1?($-R)*(d-1)/(g-1):0,W=y>1?(_-D)*(p-1)/(y-1):0;for(let G=0;G<g;G++){let q=g>1?R*(d-1)+G*z:.5*(R+$)*(d-1);if(q<0||q>d-1){for(let B=0;B<y;B++)for(let j=0;j<h;j++){let H=j+B*N[2]+G*N[1]+T*N[0];b.values[H]=u}continue}if(l==="bilinear"){let B=Math.floor(q),j=Math.ceil(q),H=q-B;for(let P=0;P<y;P++){let X=y>1?D*(p-1)+P*W:.5*(D+_)*(p-1);if(X<0||X>p-1){for(let ke=0;ke<h;ke++){let Ne=ke+P*N[2]+G*N[1]+T*N[0];b.values[Ne]=u}continue}let Q=Math.floor(X),re=Math.ceil(X),le=X-Q;for(let ke=0;ke<h;ke++){let Ne=ke+Q*S[2]+B*S[1]+L*S[0],we=I[Ne];Ne=ke+re*S[2]+B*S[1]+L*S[0];let _e=I[Ne];Ne=ke+Q*S[2]+j*S[1]+L*S[0];let Le=I[Ne];Ne=ke+re*S[2]+j*S[1]+L*S[0];let Be=I[Ne],Ze=we+(_e-we)*le,ut=Le+(Be-Le)*le;Ne=ke+P*N[2]+G*N[1]+T*N[0],b.values[Ne]=Ze+(ut-Ze)*H}}}else for(let B=0;B<y;++B){let j=y>1?D*(p-1)+B*W:.5*(D+_)*(p-1);if(j<0||j>p-1){for(let X=0;X<h;X++){let Q=X+B*N[2]+G*N[1]+T*N[0];b.values[Q]=u}continue}let H=Math.round(j),P=Math.round(q);for(let X=0;X<h;X++){let Q=X+H*S[2]+P*S[1]+L*S[0],re=X+B*N[2]+G*N[1]+T*N[0];b.values[re]=I[Q]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var _Je={kernelName:By,backendName:"cpu",kernelFunc:EJe};function AJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;wt(s,"cumprod");let l=V.getAxesPermutation([a],s.shape.length),u=s;l!=null&&(u=ti({inputs:{x:s},backend:n,attrs:{perm:l}}));let c=V.getInnerMostAxes(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=Ki(u.dtype,"int32"),p=O.makeOnesTypedArray(O.sizeFromShape(u.shape),d),h=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],g=o?(b,v)=>b+m-v-1:(b,v)=>b+v;for(let b=0;b<h.length;b+=m)for(let v=0;v<m;v++){let k=g(b,v);if(v===0)p[k]=i?1:h[k];else{let I=g(b,v-1);p[k]=i?h[I]*p[I]:h[k]*p[I]}}let y=n.makeTensorInfo(u.shape,d,p);if(l!=null){let b=V.getUndoAxesPermutation(l),v=ti({inputs:{x:y},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(u),v}return y}var RJe={kernelName:zy,backendName:"cpu",kernelFunc:AJe};function DJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;wt(s,"cumsum");let l=V.getAxesPermutation([a],s.shape.length),u=s;l!=null&&(u=ti({inputs:{x:s},backend:n,attrs:{perm:l}}));let c=V.getInnerMostAxes(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=Ki(u.dtype,"int32"),p=O.makeZerosTypedArray(O.sizeFromShape(u.shape),d),h=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],g=o?(b,v)=>b+m-v-1:(b,v)=>b+v;for(let b=0;b<h.length;b+=m)for(let v=0;v<m;v++){let k=g(b,v);if(v===0)p[k]=i?0:h[k];else{let I=g(b,v-1);p[k]=i?h[I]+p[I]:h[k]+p[I]}}let y=n.makeTensorInfo(u.shape,d,p);if(l!=null){let b=V.getUndoAxesPermutation(l),v=ti({inputs:{x:y},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(u),v}return y}var FJe={kernelName:lf,backendName:"cpu",kernelFunc:DJe};function OJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){let l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=BL(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){let l=n.bufferSync(s),u=n.bufferSync(a),c=yQ(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var MJe={kernelName:T1,backendName:"cpu",kernelFunc:OJe};function LJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;O.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*a,p=u*a,h=c/(a*a),m=n.data.get(s.dataId).values,g=new Float32Array(o*d*p*h),y=0;for(let b=0;b<o;++b)for(let v=0;v<d;++v){let k=Math.floor(v/a),I=v%a;for(let S=0;S<p;++S){let N=Math.floor(S/a),T=S%a,A=(I*a+T)*h;for(let R=0;R<h;++R){let D=R+A+c*(N+u*(k+l*b));g[y++]=m[D]}}}return n.makeTensorInfo([o,d,p,h],s.dtype,g)}var PJe={kernelName:Wy,backendName:"cpu",kernelFunc:LJe};function cee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;wt([s,a],"depthwiseConv2DNative");let c=O.computeStrides(s.shape),d=O.computeStrides(a.shape),p=l;p==null&&(p=[1,1]),O.assert(V.eitherStridesOrDilationsAreOne(i,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let h=V.computeConv2DInfo(s.shape,a.shape,i,p,o,u,!0),{filterHeight:m,filterWidth:g,dilationHeight:y,dilationWidth:b,padInfo:v}=h,k=v.left,I=v.top,S=h.outChannels/h.inChannels,N=new Xr(h.outShape,s.dtype),T=n.data.get(s.dataId).values,A=n.data.get(a.dataId).values,R=N.values;for(let D=0;D<h.batchSize;++D){let $=D*c[0],_=D*N.strides[0];for(let L=0;L<h.outHeight;++L){let z=_+L*N.strides[1],W=L*h.strideHeight-I;for(let G=0;G<m;++G){let q=W+G*y;if(q<0||q>=h.inHeight)continue;let B=G*d[0],j=$+q*c[1];for(let H=0;H<h.outWidth;++H){let P=z+H*N.strides[2],X=H*h.strideWidth-k;for(let Q=0;Q<g;++Q){let re=X+Q*b;if(re<0||re>=h.inWidth)continue;let le=B+Q*d[1],ke=j+re*h.inChannels,Ne=P,we=le;for(let _e=0;_e<h.inChannels;++_e){let Le=T[ke+_e];for(let Be=0;Be<S;++Be)R[Ne+Be]+=Le*A[we+Be];Ne+=S,we+=S}}}}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var zJe={kernelName:uf,backendName:"cpu",kernelFunc:cee};function BJe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;wt([s,a],"depthwiseConv2dNativeBackpropFilter");let d=V.computeConv2DInfo(s.shape,c,i,o,l,u,!0),{strideHeight:p,strideWidth:h,filterHeight:m,filterWidth:g}=d,y=new Xr(d.filterShape,"float32"),b=d.padInfo.left,v=d.padInfo.top,k=d.outChannels/d.inChannels,I=n.data.get(s.dataId).values,S=new Xr(s.shape,s.dtype,I),N=n.data.get(a.dataId).values,T=new Xr(a.shape,a.dtype,N);for(let A=0;A<m;++A){let R=Math.max(0,Math.ceil((v-A)/p)),D=Math.min(d.outHeight,(d.inHeight+v-A)/p);for(let $=0;$<g;++$){let _=Math.max(0,Math.ceil((b-$)/h)),L=Math.min(d.outWidth,(d.inWidth+b-$)/h);for(let z=0;z<d.outChannels;++z){let W=Math.trunc(z/k),G=z%k,q=0;for(let B=0;B<d.batchSize;++B)for(let j=R;j<D;++j){let H=A+j*p-v;for(let P=_;P<L;++P){let X=$+P*h-b;q+=S.get(B,H,X,W)*T.get(B,j,P,z)}}y.set(q,A,$,W,G)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var WJe={kernelName:KC,backendName:"cpu",kernelFunc:BJe};function VJe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;wt([s,a],"depthwiseConv2DNativeBackpropInput");let d=O.computeStrides(s.shape),p=O.computeStrides(a.shape),h=V.computeConv2DInfo(c,a.shape,i,o,l,u,!0),m=new Xr(h.inShape,"float32"),g=m.values,[y,b,v]=m.strides,k=n.data.get(s.dataId).values,[I,S,N]=d,T=n.data.get(a.dataId).values,[A,R,D]=p,{batchSize:$,filterHeight:_,filterWidth:L,inChannels:z,inHeight:W,inWidth:G,outChannels:q,outHeight:B,outWidth:j,strideHeight:H,strideWidth:P}=h,X=_-1-h.padInfo.top,Q=L-1-h.padInfo.left,re=q/z;for(let le=0;le<$;++le)for(let ke=0;ke<z;++ke)for(let Ne=0;Ne<W;++Ne){let we=Ne-X,_e=Math.max(0,Math.ceil(we/H)),Le=Math.min(B,(_+we)/H);for(let Be=0;Be<G;++Be){let Ze=Be-Q,ut=Math.max(0,Math.ceil(Ze/P)),ft=Math.min(j,(L+Ze)/P),et=0;for(let Qe=_e;Qe<Le;++Qe){let ot=Qe*H-we;for(let gt=ut;gt<ft;++gt){let At=gt*P-Ze,Et=I*le+S*Qe+N*gt,dn=A*(_-1-ot)+R*(L-1-At)+D*ke;for(let Xt=0;Xt<re;++Xt){let In=ke*re+Xt,Ve=k[Et+In],tt=T[dn+Xt];et+=Ve*tt}}}g[y*le+b*Ne+v*Be+ke]=et}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var UJe={kernelName:XC,backendName:"cpu",kernelFunc:VJe};function GJe(e){let{inputs:t,backend:n}=e,{x:r}=t,s=O.sizeFromShape(r.shape),a=n.data.get(r.dataId).values,i=tn([s,s],r.dtype),o=i.values;for(let u=0;u<a.length;u++)o[u*s+u]=a[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var jJe={kernelName:$1,backendName:"cpu",kernelFunc:GJe},HJe={kernelName:cf,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,p=s.shape.length,{batchSize:h,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:k,strideHeight:I,strideWidth:S,filterHeight:N,filterWidth:T,dilationHeight:A,dilationWidth:R,outShape:D}=V.computeDilation2DInfo(r.shape,s.shape,a,i,"NHWC",o),$=O.sizeFromShape(D),_=D.length,L=O.getArrayFromDType(r.dtype,$);for(let z=0;z<h;++z)for(let W=0;W<b;++W){let G=W*I-k.top;for(let q=0;q<v;++q){let B=q*S-k.left;for(let j=0;j<y;++j){let H=Number.MIN_SAFE_INTEGER;for(let X=0;X<N;++X){let Q=G+X*A;if(Q>=0&&Q<m)for(let re=0;re<T;++re){let le=B+re*R;if(le>=0&&le<g){let ke=O.locToIndex([z,Q,le,j],c,O.computeStrides(r.shape)),Ne=O.locToIndex([X,re,j],p,O.computeStrides(s.shape)),we=u[ke]+d[Ne];we>H&&(H=we)}}}let P=O.locToIndex([z,W,q,j],_,O.computeStrides(D));L[P]=H}}}return{dataId:l.write(O.toTypedArray(L,r.dtype),D,r.dtype),shape:D,dtype:r.dtype}}},qJe={kernelName:zg,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=O.toNestedArray(r.shape,u.data.get(r.dataId).values),d=O.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:h,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:k,strideWidth:I,filterHeight:S,filterWidth:N,dilationHeight:T,dilationWidth:A,outShape:R}=V.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",l);O.assert(a.rank===R.length,()=>`Error in ${zg}, dy must have the same rank as output ${R.length}, but got ${a.rank}`);let D=O.toNestedArray(R,u.data.get(a.dataId).values),$=O.makeZerosNestedTypedArray(s.shape,s.dtype);for(let _=0;_<p;++_)for(let L=0;L<y;++L){let z=L*k-v.top;for(let W=0;W<b;++W){let G=W*I-v.left;for(let q=0;q<g;++q){let B=Number.MIN_SAFE_INTEGER,j=0,H=0;for(let P=0;P<S;++P){let X=z+P*T;if(X>=0&&X<h)for(let Q=0;Q<N;++Q){let re=G+Q*A;if(re>=0&&re<m){let le=c[_][X][re][q]+d[P][Q][q];le>B&&(B=le,j=P,H=Q)}}}$[j][H][q]+=D[_][L][W][q]}}}return{dataId:u.write(O.toTypedArray($,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},KJe={kernelName:Pg,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=O.toNestedArray(r.shape,u.data.get(r.dataId).values),d=O.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:h,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:k,strideWidth:I,filterHeight:S,filterWidth:N,dilationHeight:T,dilationWidth:A,outShape:R}=V.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",l);O.assert(a.rank===R.length,()=>`Error in ${Pg}, dy must have the same rank as output ${R.length}, but got ${a.rank}`);let D=O.toNestedArray(R,u.data.get(a.dataId).values),$=O.makeZerosNestedTypedArray(r.shape,r.dtype);for(let _=0;_<p;++_)for(let L=0;L<y;++L){let z=L*k-v.top;for(let W=0;W<b;++W){let G=W*I-v.left;for(let q=0;q<g;++q){let B=Number.MIN_SAFE_INTEGER,j=z<0?0:z,H=G<0?0:G;for(let P=0;P<S;++P){let X=z+P*T;if(X>=0&&X<h)for(let Q=0;Q<N;++Q){let re=G+Q*A;if(re>=0&&re<m){let le=c[_][X][re][q]+d[P][Q][q];le>B&&(B=le,j=X,H=re)}}}$[_][j][H][q]+=D[_][L][W][q]}}}return{dataId:u.write(O.toTypedArray($,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function XJe(e){let{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(l==null?void 0:l.alpha)||1,c=(o==null?void 0:o.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let d=a.getContext(c,(o==null?void 0:o.contextAttributes)||{});if(d==null)throw new Error(`Could not get the context with ${c} type.`);let[p,h]=s.shape.slice(0,2),m=s.shape.length===2?1:s.shape[2],g=n.data.get(s.dataId).values,y=s.dtype==="float32"?255:1,b=new Uint8ClampedArray(h*p*4);for(let k=0;k<p*h;++k){let I=[0,0,0,255*u];for(let N=0;N<m;N++){let T=g[k*m+N];if(s.dtype==="float32"){if(T<0||T>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${T}.`)}else if(s.dtype==="int32"&&(T<0||T>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${T}.`);m===1?(I[0]=T*y,I[1]=T*y,I[2]=T*y):I[N]=T*y}let S=k*4;b[S+0]=Math.round(I[0]),b[S+1]=Math.round(I[1]),b[S+2]=Math.round(I[2]),b[S+3]=Math.round(I[3])}a.width=h,a.height=p;let v=new ImageData(b,h,p);return d.putImageData(v,0,0),s}var YJe={kernelName:YC,backendName:"cpu",kernelFunc:XJe};function xw(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;wt(s,"sum");let o;s.dtype==="bool"?o=fd({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):o=au({inputs:{x:s},backend:n});let l=o.shape.length,u=O.parseAxisParam(a,o.shape),c=V.getAxesPermutation(u,l),d=u,p=o;c!=null&&(p=ti({inputs:{x:o},backend:n,attrs:{perm:c}}),d=V.getInnerMostAxes(d.length,l)),V.assertAxesAreInnerMostDims("sum",d,p.shape.length);let[h,m]=V.computeOutAndReduceShapes(p.shape,d),g=V.upcastType(p.dtype,"int32"),y=zI(n,h,g),b=O.sizeFromShape(m),v=n.data.get(y.dataId).values,k=n.data.get(p.dataId).values;for(let I=0;I<v.length;++I){let S=I*b,N=0;for(let T=0;T<b;++T)N+=k[S+T];v[I]=N}if(i){let I=V.expandShapeToKeepDim(y.shape,u),S=y;y=ur({inputs:{x:y},backend:n,attrs:{shape:I}}),n.disposeIntermediateTensorInfo(S)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(p),y}var ZJe={kernelName:rm,backendName:"cpu",kernelFunc:xw};function JJe(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=V.decodeEinsumEquation(s,a.length);V.checkEinsumDimSizes(i.length,l,a);let{path:u,steps:c}=V.getEinsumComputePath(o,l),d=c.length,p=null,h=i.length,m=[];for(let g=0;g<d;++g){for(let y of c[g]){let{permutationIndices:b,expandDims:v}=V.getEinsumPermutation(h,l[y]),k;V.isIdentityPermutation(b)?k=a[y]:(k=ti({inputs:{x:a[y]},backend:n,attrs:{perm:b}}),m.push(k));let I=k.shape.slice();for(let S=0;S<v.length;++S)I.splice(v[S],0,1);O.arraysEqual(k.shape,I)||(k=ur({inputs:{x:k},backend:n,attrs:{shape:I}}),m.push(k)),p===null?p=k:(p=cT({inputs:{a:k,b:p},backend:n}),m.push(p))}g<d-1&&(u[g]>=0&&(p=xw({inputs:{x:p},backend:n,attrs:{axis:u[g]-(i.length-h),keepDims:!1}}),m.push(p)),h--)}for(let g of m)g!==p&&n.disposeIntermediateTensorInfo(g);return p}var QJe={kernelName:ZC,backendName:"cpu",kernelFunc:JJe};function eQe(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t;wt([r,s],"eluGrad");let a=new Float32Array(O.sizeFromShape(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let u=i[l];u>=0?a[l]=o[l]:a[l]=o[l]*(u+1)}return n.makeTensorInfo(s.shape,"float32",a)}var tQe={kernelName:Vy,backendName:"cpu",kernelFunc:eQe},nQe=V.ERF_P,rQe=V.ERF_A1,sQe=V.ERF_A2,aQe=V.ERF_A3,iQe=V.ERF_A4,oQe=V.ERF_A5,lQe=Hn(hf,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+nQe*n);return t*(1-((((oQe*r+iQe)*r+aQe)*r+sQe)*r+rQe)*r*Math.exp(-n*n))}),uQe={kernelName:hf,backendName:"cpu",kernelFunc:lQe};function VI(e){let{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(O.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),ur({inputs:{x:s},backend:n,attrs:{shape:o}})}var cQe={kernelName:Gy,backendName:"cpu",kernelFunc:VI},dQe=Ur((e,t)=>e/t),JL=bs(df,dQe),sR={kernelName:df,backendName:"cpu",kernelFunc:JL};function dee(e,t,n){let r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=O.sizeFromShape(u),d=O.getTypedArrayFromDType("float32",c),p=O.getTypedArrayFromDType("float32",c);for(let y=0;y<s;y++){let b=Nh({inputs:{x:o},backend:n,attrs:{begin:[y,0],size:[1,a]}}),v=Nh({inputs:{x:l},backend:n,attrs:{begin:[y,0],size:[1,a]}}),k=gi({inputs:{real:b,imag:v},backend:n}),{real:I,imag:S}=pQe(k,t,n),N=V.mergeRealAndImagArrays(I,S);for(let T=0;T<a;T++){let A=V.getComplexWithIndex(N,T);d[y*a+T]=A.real,p[y*a+T]=A.imag}n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(k)}let h=n.makeTensorInfo(u,"float32",d),m=n.makeTensorInfo(u,"float32",p),g=gi({inputs:{real:h,imag:m},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}function pQe(e,t,n){let r=O.sizeFromShape(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(hQe(r)){let o=aR(a,i,r,t,n),l=[e.shape[0],e.shape[1]];if(t){let u=n.makeTensorInfo(l,"float32",o.real),c=n.makeTensorInfo(l,"float32",o.imag),d=n.makeTensorInfo([],"float32",O.createScalarValue(r,"float32")),p=au({inputs:{x:d},backend:n}),h=sR.kernelFunc({inputs:{a:u,b:d},backend:n}),m=sR.kernelFunc({inputs:{a:c,b:p},backend:n}),g=n.data.get(h.dataId).values,y=n.data.get(m.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),{real:g,imag:y}}return o}else{let o=V.mergeRealAndImagArrays(a,i),l=fQe(o,r,t);return V.splitRealAndImagArrays(l)}}function hQe(e){return(e&e-1)===0}function aR(e,t,n,r,s){if(n===1)return{real:e,imag:t};let a=V.mergeRealAndImagArrays(e,t),i=n/2,o=V.complexWithEvenIndex(a),l=o.real,u=o.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),p=s.makeTensorInfo(c,"float32",u),h=gi({inputs:{real:d,imag:p},backend:s}),m=V.complexWithOddIndex(a),g=m.real,y=m.imag,b=[g.length],v=s.makeTensorInfo(b,"float32",g),k=s.makeTensorInfo(b,"float32",y),I=gi({inputs:{real:v,imag:k},backend:s}),S=aR(l,u,i,r,s),N=S.real,T=S.imag,A=[N.length],R=s.makeTensorInfo(A,"float32",N),D=s.makeTensorInfo(A,"float32",T),$=gi({inputs:{real:R,imag:D},backend:s}),_=aR(g,y,i,r,s),L=_.real,z=_.imag,W=[L.length],G=s.makeTensorInfo(W,"float32",L),q=s.makeTensorInfo(W,"float32",z),B=gi({inputs:{real:G,imag:q},backend:s}),j=V.exponents(n,r),H=[j.real.length],P=s.makeTensorInfo(H,"float32",j.real),X=s.makeTensorInfo(H,"float32",j.imag),Q=gi({inputs:{real:P,imag:X},backend:s}),re=cT({inputs:{a:Q,b:B},backend:s}),le=Zg({inputs:{a:$,b:re},backend:s}),ke=XL({inputs:{a:$,b:re},backend:s}),Ne=Ch({inputs:{input:le},backend:s}),we=Ch({inputs:{input:ke},backend:s}),_e=Jg({inputs:{input:le},backend:s}),Le=Jg({inputs:{input:ke},backend:s}),Be=Qg({inputs:[Ne,we],backend:s,attrs:{axis:0}}),Ze=Qg({inputs:[_e,Le],backend:s,attrs:{axis:0}}),ut=s.data.get(Be.dataId).values,ft=s.data.get(Ze.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(k),s.disposeIntermediateTensorInfo(I),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(X),s.disposeIntermediateTensorInfo(Q),s.disposeIntermediateTensorInfo(re),s.disposeIntermediateTensorInfo(le),s.disposeIntermediateTensorInfo(ke),s.disposeIntermediateTensorInfo(Ne),s.disposeIntermediateTensorInfo(_e),s.disposeIntermediateTensorInfo(we),s.disposeIntermediateTensorInfo(Le),s.disposeIntermediateTensorInfo(Be),s.disposeIntermediateTensorInfo(Ze),{real:ut,imag:ft}}function fQe(e,t,n){let r=new Float32Array(t*2);for(let s=0;s<t;s++){let a=0,i=0;for(let o=0;o<t;o++){let l=V.exponent(s*o,t,n),u=V.getComplexWithIndex(e,o);a+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}n&&(a/=t,i/=t),V.assignToTypedArray(r,a,i,s)}return r}function mQe(e){let{inputs:t,backend:n}=e,{input:r}=t,s=O.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=ur({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=dee(o,!1,n),u=ur({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var gQe={kernelName:JC,backendName:"cpu",kernelFunc:mQe};function QL(e){let{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||O.inferDtype(s),o=O.getArrayFromDType(i,O.sizeFromShape(r));return xQe(o,s),t.makeTensorInfo(r,i,o)}var yQe={kernelName:E1,backendName:"cpu",kernelFunc:QL};function xQe(e,t,n){e.fill(t)}var bQe={kernelName:jy,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,s=n,a=O.getTypedArrayFromDType(r.dtype,O.sizeFromShape(r.shape)),[i,o,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let d=0;d<i;d++){let p=d*l*o*u;for(let h=0;h<o;h++){let m=h*(l*u);for(let g=0;g<l;g++){let y=g*u;for(let b=0;b<u;b++){let v=Math.round(l-g-1),k=p+m+y+b,I=c[k];if(v>=0&&v<l){let S=v*u,N=p+m+S+b;I=c[N]}a[k]=I}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function vQe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=r,g=uee({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p}});if(i){let y=g;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let b=ur({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});g=Zg({inputs:{a:g,b},backend:n}),n.disposeIntermediateTensorInfo(b)}else g=Zg({inputs:{a:g,b:i},backend:n});n.disposeIntermediateTensorInfo(y)}if(h){let y=g;if(c==="NCHW"&&h==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let b=ur({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});g=WI(n,g,h,b,m),n.disposeIntermediateTensorInfo(b)}else g=WI(n,g,h,o,m);n.disposeIntermediateTensorInfo(y)}return g}var wQe={kernelName:hh,backendName:"cpu",kernelFunc:vQe};function kQe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=r,g=cee({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p}});if(i){let y=g;g=Zg({inputs:{a:g,b:i},backend:n}),n.disposeIntermediateTensorInfo(y)}if(h){let y=g;g=WI(n,g,h,o,m),n.disposeIntermediateTensorInfo(y)}return g}var IQe={kernelName:fh,backendName:"cpu",kernelFunc:kQe};function SQe(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=O.sizeFromShape(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,d]=V.prepareAndValidate(r,s);if(u===0)return n.makeTensorInfo(l,r.dtype,[]);let p=n.data.get(s.dataId).values,h=n.bufferSync(r),m=TQ(p,h,r.dtype,u,o,c,d,r.shape,a);return n.makeTensorInfo(l,r.dtype,m.values)}var CQe={kernelName:qy,backendName:"cpu",kernelFunc:SQe};function NQe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;wt([s,a],"gatherV2");let l=O.parseAxisParam(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let I=0;I<u.length;++I){let S=u[I];O.assert(S<=c-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${c-1}]`)}let d=o;o==null&&(d=0);let p=O.sizeFromShape(a.shape),h=V.segment_util.collectGatherOpShapeInfo(s,a,l,d),m=ur({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),g=ur({inputs:{x:a},backend:n,attrs:{shape:[h.batchSize,p/h.batchSize]}}),y=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],b=n.bufferSync(g),v=n.bufferSync(m),k=$Q(v,b,y);return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(h.outputShape,k.dtype,k.values)}var TQe={kernelName:Hy,backendName:"cpu",kernelFunc:NQe};function $Qe(e){let{inputs:t,backend:n}=e,{input:r}=t,s=O.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=ur({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=dee(o,!0,n),u=ur({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var EQe={kernelName:QC,backendName:"cpu",kernelFunc:$Qe},_Qe=Hn(wf,e=>Number.isFinite(e)?1:0,"bool"),AQe={kernelName:wf,backendName:"cpu",kernelFunc:_Qe},RQe=Hn(kf,e=>Math.abs(e)===1/0?1:0,"bool"),DQe={kernelName:kf,backendName:"cpu",kernelFunc:RQe},FQe=Hn(If,e=>Number.isNaN(e)?1:0,"bool"),OQe={kernelName:If,backendName:"cpu",kernelFunc:FQe};function MQe(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=DQ(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}var LQe={kernelName:Zy,backendName:"cpu",kernelFunc:MQe},PQe=Hn(Nf,e=>Math.log1p(e)),zQe={kernelName:Nf,backendName:"cpu",kernelFunc:PQe},BQe=Ur((e,t)=>e&&t),WQe=bs(Jy,BQe,null,"bool"),VQe={kernelName:Jy,backendName:"cpu",kernelFunc:WQe},UQe=Hn(Qy,e=>e?0:1,"bool"),GQe={kernelName:Qy,backendName:"cpu",kernelFunc:UQe},jQe=Ur((e,t)=>e||t),HQe=bs(ex,jQe,null,"bool"),qQe={kernelName:ex,backendName:"cpu",kernelFunc:HQe};function KQe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;wt(s,"LRN");let u=s.shape[3],c=u-1,d=n.data.get(s.dataId).values,p=O.sizeFromShape(s.shape),h=new Float32Array(p);function m(g){let y=g%u,b=g-y+Math.max(0,y-a),v=g-y+Math.min(y+a,c),k=0;for(;b<=v;b++){let I=d[b];k+=I*I}return k}for(let g=0;g<p;g++){let y=m(g),b=d[g]*Math.pow(i+o*y,-l);h[g]=b}return n.makeTensorInfo(s.shape,s.dtype,h)}var XQe={kernelName:Tf,backendName:"cpu",kernelFunc:KQe};function YQe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;wt(i,"LRNGrad");let d=O.sizeFromShape(i.shape),p=i.shape[3],h=n.data.get(i.dataId).values,m=n.data.get(s.dataId).values,g=n.data.get(a.dataId).values,y=new Float32Array(d),b=d;for(let v=0;v<b;v++){let k=v%p,I=v-k+Math.max(0,k-o),S=v-k+Math.min(p,k+o+1),N=0;for(let T=I;T<S;T++)N+=Math.pow(m[T],2);N=u*N+l;for(let T=I;T<S;T++){let A=-2*u*c*m[T]*g[v]/N;v===T&&(A+=Math.pow(N,-c)),A*=h[v],y[T]+=A}}return n.makeTensorInfo(i.shape,s.dtype,y)}var ZQe={kernelName:tx,backendName:"cpu",kernelFunc:YQe};function pee(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n,l=s.shape,u=l.length,c=O.parseAxisParam(a,l),d=c,p=V.getAxesPermutation(d,u),h=o.data.get(s.dataId).values;if(p!=null){let I=new Array(u);for(let S=0;S<I.length;S++)I[S]=l[p[S]];h=UL(h,l,s.dtype,p,I),d=V.getInnerMostAxes(d.length,u),l=I}wt(s,"max"),V.assertAxesAreInnerMostDims("max",d,u);let[m,g]=V.computeOutAndReduceShapes(l,d),y=O.sizeFromShape(g),b=OQ(h,y,m,s.dtype),v=o.write(b,m,s.dtype),k=m;return i&&(k=V.expandShapeToKeepDim(m,c)),{dataId:v,shape:k,dtype:s.dtype}}var JQe={kernelName:$f,backendName:"cpu",kernelFunc:pee};function QQe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;wt(s,"maxPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;O.assert(V.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=V.computePool2DInfo(s.shape,a,i,u,o,l),d;if(c.filterWidth===1&&c.filterHeight===1&&O.arraysEqual(c.inShape,c.outShape))d=au({inputs:{x:s},backend:n});else{let p=n.data.get(s.dataId).values,h=O.computeStrides(s.shape),m=ZL(p,s.shape,s.dtype,h,c,"max");d=n.makeTensorInfo(c.outShape,s.dtype,m.values)}return d}var eet={kernelName:_f,backendName:"cpu",kernelFunc:QQe};function tet(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;wt(s,"maxPool3d");let c=V.computePool3DInfo(s.shape,a,i,1,o,l,u),d=n.data.get(s.dataId).values,p=lee(d,s.shape,s.dtype,O.computeStrides(s.shape),c,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}var net={kernelName:nx,backendName:"cpu",kernelFunc:tet};function ret(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;wt([s,a],"maxPool3DGrad");let c=V.computePool3DInfo(a.shape,i,o,1,l,u),d=n.bufferSync(a),p=jZe(d,c),h=c.strideDepth,m=c.strideHeight,g=c.strideWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,k=c.effectiveFilterDepth,I=c.effectiveFilterHeight,S=c.effectiveFilterWidth,N=k-1-c.padInfo.front,T=S-1-c.padInfo.left,A=I-1-c.padInfo.top,R=tn(a.shape,"float32"),D=n.bufferSync(s);for(let $=0;$<c.batchSize;++$)for(let _=0;_<c.inChannels;++_)for(let L=0;L<c.inDepth;++L)for(let z=0;z<c.inHeight;++z)for(let W=0;W<c.inWidth;++W){let G=L-N,q=z-A,B=W-T,j=0;for(let H=0;H<k;H+=y){let P=(G+H)/h;if(!(P<0||P>=c.outDepth||Math.floor(P)!==P))for(let X=0;X<I;X+=b){let Q=(q+X)/m;if(!(Q<0||Q>=c.outHeight||Math.floor(Q)!==Q))for(let re=0;re<S;re+=v){let le=(B+re)/g;if(le<0||le>=c.outWidth||Math.floor(le)!==le)continue;let ke=k*I*S-1-p.get($,P,Q,le,_),Ne=H*I*S+X*S+re,we=ke===Ne?1:0;if(we===0)continue;let _e=D.get($,P,Q,le,_);j+=_e*we}}}R.set(j,$,L,z,W,_)}return n.makeTensorInfo(R.shape,R.dtype,R.values)}var set={kernelName:A1,backendName:"cpu",kernelFunc:ret};function aet(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;wt([a,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,p=V.computePool2DInfo(o.shape,l,u,1,c,d),h=n.data.get(o.dataId).values,m=tn(p.outShape,o.dtype,oee(h,o.shape,o.dtype,p).values),g=p.strideHeight,y=p.strideWidth,b=p.dilationHeight,v=p.dilationWidth,k=p.effectiveFilterHeight,I=p.effectiveFilterWidth,S=I-1-p.padInfo.left,N=k-1-p.padInfo.top,T=tn(o.shape,"float32"),A=n.data.get(s.dataId).values,R=tn(s.shape,"float32",A);for(let D=0;D<p.batchSize;++D)for(let $=0;$<p.inChannels;++$)for(let _=0;_<p.inHeight;++_)for(let L=0;L<p.inWidth;++L){let z=_-N,W=L-S,G=0;for(let q=0;q<k;q+=b){let B=(z+q)/g;if(!(B<0||B>=p.outHeight||Math.floor(B)!==B))for(let j=0;j<I;j+=v){let H=(W+j)/y;if(H<0||H>=p.outWidth||Math.floor(H)!==H)continue;let P=k*I-1-m.get(D,B,H,$),X=q*I+j,Q=P===X?1:0;if(Q===0)continue;let re=R.get(D,B,H,$);G+=re*Q}}T.set(G,D,_,L,$)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var iet={kernelName:_1,backendName:"cpu",kernelFunc:aet};function oet(e,t,n,r,s){let a=O.computeStrides(t),i=ZL(e,t,n,a,s,"max"),o=oee(e,t,n,s,!0,r);return[i.values,o.values]}var uet={kernelName:R1,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;wt(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,c=V.computePool2DInfo(r.shape,s,a,[1,1],i),[d,p]=oet(u,r.shape,r.dtype,o,c),h=l.write(d,c.outShape,r.dtype),m=l.write(p,c.outShape,r.dtype);return[{dataId:h,shape:c.outShape,dtype:r.dtype},{dataId:m,shape:c.outShape,dtype:"int32"}]}};function cet(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=O.parseAxisParam(a,s.shape),l=V.computeOutAndReduceShapes(s.shape,o)[1],u=O.sizeFromShape(l),c=[],d=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(d);let p=fd({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});c.push(p);let h=JL({inputs:{a:p,b:d},backend:n});c.push(h);let m=xw({inputs:{x:h},backend:n,attrs:{axis:a,keepDims:i}});return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}var det={kernelName:Af,backendName:"cpu",kernelFunc:cet};function pet(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;wt(s,"min");let o=O.parseAxisParam(a,s.shape),l=o,u=V.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=ti({inputs:{x:s},backend:n,attrs:{perm:u}}),l=V.getInnerMostAxes(l.length,s.shape.length)),V.assertAxesAreInnerMostDims("min",l,c.shape.length);let[d,p]=V.computeOutAndReduceShapes(c.shape,l),h=O.sizeFromShape(p),m=O.makeZerosTypedArray(O.sizeFromShape(d),c.dtype),g=n.data.get(c.dataId).values;for(let b=0;b<m.length;++b){let v=b*h,k=g[v];for(let I=0;I<h;++I){let S=g[v+I];(Number.isNaN(S)||S<k)&&(k=S)}m[b]=k}u!=null&&n.disposeIntermediateTensorInfo(c);let y=n.makeTensorInfo(d,c.dtype,m);if(i){let b=V.expandShapeToKeepDim(d,o),v=ur({inputs:{x:y},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(y),v}return y}var het={kernelName:Rf,backendName:"cpu",kernelFunc:pet};function fet(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;wt(s,"mirrorPad");let o=a.map((v,k)=>v[0]+s.shape[k]+v[1]),l=a.map(v=>v[0]),u=a.map((v,k)=>v[0]+s.shape[k]),c=i==="reflect"?0:1,d=n.data.get(s.dataId).values,p=s.shape.length,h=O.computeStrides(s.shape),m=O.sizeFromShape(o),g=o.length,y=O.computeStrides(o),b=O.getTypedArrayFromDType(s.dtype,m);for(let v=0;v<m;v++){let k=O.indexToLoc(v,g,y);for(let S=0;S<g;S++)k[S]<l[S]?k[S]=l[S]*2-k[S]-c:k[S]>=u[S]&&(k[S]=(u[S]-1)*2-k[S]+c);k=k.map((S,N)=>S-l[N]);let I=O.locToIndex(k,p,h);b[v]=d[I]}return{dataId:n.write(b,o,s.dtype),shape:o,dtype:s.dtype}}var met={kernelName:Ff,backendName:"cpu",kernelFunc:fet},get=Ur((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),yet=bs(Of,get),xet={kernelName:Of,backendName:"cpu",kernelFunc:yet},bet=_d(VC());function hee(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length,o=a;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=O.parseAxisParam([o],s.shape),u=pee({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=V.expandShapeToKeepDim(u.shape,l),d=ur({inputs:{x:u},backend:n,attrs:{shape:c}}),p=XL({inputs:{a:s,b:d},backend:n}),h=IQ({inputs:{x:p},backend:n}),m=xw({inputs:{x:h},backend:n,attrs:{axis:l,keepDims:!1}}),g=ur({inputs:{x:m},backend:n,attrs:{shape:c}}),y=JL({inputs:{a:h,b:g},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}var vet={kernelName:sm,backendName:"cpu",kernelFunc:hee};function wet(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;wt(s,"multinomial");let l=o?s:hee({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,p=[u,a],h=O.makeZerosTypedArray(O.sizeFromShape(p),"int32");for(let m=0;m<u;++m){let g=m*c,y=new Float32Array(c-1);y[0]=d[g];for(let k=1;k<y.length;++k)y[k]=y[k-1]+d[g+k];let b=bet.alea(i.toString()),v=m*a;for(let k=0;k<a;++k){let I=b();h[v+k]=y.length;for(let S=0;S<y.length;S++)if(I<y[S]){h[v+k]=S;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(p,"int32",h)}var ket={kernelName:rx,backendName:"cpu",kernelFunc:wet},Iet=du.nonMaxSuppressionV3Impl;function Cet(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;wt(s,"NonMaxSuppression");let u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d}=Iet(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var Net={kernelName:ix,backendName:"cpu",kernelFunc:Cet},Tet=du.nonMaxSuppressionV4Impl;function $et(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;wt(s,"NonMaxSuppressionPadded");let c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:p,validOutputs:h}=Tet(c,d,i,o,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var Eet={kernelName:ox,backendName:"cpu",kernelFunc:$et},_et=du.nonMaxSuppressionV5Impl;function Aet(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;wt(s,"NonMaxSuppressionWithScore");let c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,p=i,h=o,m=l,g=u,{selectedIndices:y,selectedScores:b}=_et(c,d,p,h,m,g);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var Ret={kernelName:lx,backendName:"cpu",kernelFunc:Aet};function Det(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r;wt(s,"oneHot");let u=O.sizeFromShape(s.shape),c=new Float32Array(u*i);c.fill(l);let d=n.data.get(s.dataId).values;for(let p=0;p<u;++p)d[p]>=0&&d[p]<i&&(c[p*i+d[p]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}var Fet={kernelName:Lf,backendName:"cpu",kernelFunc:Det};function UI(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let s=Ch({inputs:{input:r},backend:n}),a=UI({inputs:{x:s},backend:n}),i=Jg({inputs:{input:r},backend:n}),o=UI({inputs:{x:i},backend:n}),l=gi({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return QL({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var Oet={kernelName:Tx,backendName:"cpu",kernelFunc:UI};function fee(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let s=Ch({inputs:{input:r},backend:n}),a=fee({inputs:{x:s},backend:n}),i=Jg({inputs:{input:r},backend:n}),o=UI({inputs:{x:i},backend:n}),l=gi({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return QL({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var Met={kernelName:ux,backendName:"cpu",kernelFunc:fee};function mee(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return VI({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,i=t[0].dtype;t.forEach(c=>{O.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),O.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(c=>{let d=VI({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=Qg({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var Let={kernelName:cx,backendName:"cpu",kernelFunc:mee};function Pet(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;wt(s,"pad");let o=a.map((b,v)=>b[0]+s.shape[v]+b[1]),l=a.map(b=>b[0]),u=n.data.get(s.dataId).values,c=O.sizeFromShape(s.shape),d=s.shape.length,p=O.computeStrides(s.shape),h=O.sizeFromShape(o),m=o.length,g=O.computeStrides(o),y=O.getTypedArrayFromDType(s.dtype,h);i!==0&&y.fill(i);for(let b=0;b<c;b++){let v=O.indexToLoc(b,d,p).map((I,S)=>I+l[S]),k=O.locToIndex(v,m,g);y[k]=u[b]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}var gee={kernelName:Pf,backendName:"cpu",kernelFunc:Pet},zet=Ur((e,t)=>Math.pow(e,t)),Bet=bs(zf,zet),Wet={kernelName:zf,backendName:"cpu",kernelFunc:Bet};function Vet(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map(b=>n.data.get(b.dataId).values),u=s.map(b=>b.shape),c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,[p,h,m]=WQ(l,u,c,a.shape,a.dtype,d,i.shape),g=p.map(b=>n.makeTensorInfo([b.length],"int32",b)),y=n.makeTensorInfo(m,a.dtype,h);return g.concat([y])}var Uet={kernelName:tN,backendName:"cpu",kernelFunc:Vet};function Get(e){let{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=VQ(i,r.shape,r.dtype,o,s.shape,l,a.shape),d=n.makeTensorInfo([u.length],"int32",u),p=n.makeTensorInfo([c.length],r.dtype,c);return[d,p]}var jet={kernelName:nN,backendName:"cpu",kernelFunc:Get};function Het(e){let{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,p=o.map(y=>n.data.get(y.dataId).values),h=o.map(y=>y.shape),[m,g]=UQ(u,s.shape,c,a.shape,a.dtype,d,i.shape,p,h,l);return n.makeTensorInfo(m,a.dtype,g)}var qet={kernelName:rN,backendName:"cpu",kernelFunc:Het};function Ket(e){let{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=GL(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}var Xet={kernelName:D1,backendName:"cpu",kernelFunc:Ket},Yet=Hn(Vf,e=>1/e),Zet={kernelName:Vf,backendName:"cpu",kernelFunc:Yet};function Jet(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;wt(s,"resizeBilinear");let l=O.computeStrides(s.shape),[u,c]=o,[d,p,h,m]=s.shape,g=n.data.get(s.dataId).values,y=new Float32Array(O.sizeFromShape([d,u,c,m])),b=[a&&u>1?p-1:p,a&&c>1?h-1:h],v=[a&&u>1?u-1:u,a&&c>1?c-1:c],k=0,I=b[0]/v[0],S=b[1]/v[1];for(let N=0;N<d;N++)for(let T=0;T<u;T++){let A;i?A=I*(T+.5)-.5:A=I*T;let R=Math.max(0,Math.floor(A)),D=A-R,$=Math.min(p-1,Math.ceil(A)),_=N*l[0]+R*l[1],L=N*l[0]+$*l[1];for(let z=0;z<c;z++){let W;i?W=S*(z+.5)-.5:W=S*z;let G=Math.max(0,Math.floor(W)),q=W-G,B=Math.min(h-1,Math.ceil(W)),j=_+G*l[2],H=L+G*l[2],P=_+B*l[2],X=L+B*l[2];for(let Q=0;Q<m;Q++){let re=g[j+Q],le=g[H+Q],ke=g[P+Q],Ne=g[X+Q],we=re+(ke-re)*q,_e=le+(Ne-le)*q,Le=we+(_e-we)*D;y[k++]=Le}}}return n.makeTensorInfo([d,u,c,m],"float32",y)}var Qet={kernelName:jf,backendName:"cpu",kernelFunc:Jet};function ett(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;wt([a,s],"resizeBilinearGrad");let o=O.computeStrides(s.shape),[l,u,c,d]=s.shape,[,p,h]=a.shape,m=new Float32Array(l*u*c*d),g=[i&&p>1?u-1:u,i&&h>1?c-1:c],y=[i&&p>1?p-1:p,i&&h>1?h-1:h],b=g[0]/y[0],v=g[1]/y[1],k=n.data.get(a.dataId).values,I=0;for(let S=0;S<l;S++){let N=S*o[0];for(let T=0;T<p;T++){let A=T*b,R=Math.floor(A),D=Math.min(Math.ceil(A),u-1),$=N+R*o[1],_=N+D*o[1],L=A-R,z=1-L;for(let W=0;W<h;W++){let G=W*v,q=Math.floor(G),B=Math.min(Math.ceil(G),c-1),j=G-q,H=1-j,P=$+q*o[2],X=$+B*o[2],Q=_+q*o[2],re=_+B*o[2],le=z*H,ke=z*j,Ne=L*H,we=L*j;for(let _e=0;_e<d;_e++){let Le=k[I++];m[P+_e]+=Le*le,m[X+_e]+=Le*ke,m[Q+_e]+=Le*Ne,m[re+_e]+=Le*we}}}}return n.makeTensorInfo([l,c,u,d],"float32",m)}var ttt={kernelName:hx,backendName:"cpu",kernelFunc:ett};function ntt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;wt(s,"resizeNearestNeighbor");let l=O.computeStrides(s.shape),[u,c]=o,[d,p,h,m]=s.shape,g=n.data.get(s.dataId).values,y=new Float32Array(d*u*c*m),b=[a&&u>1?p-1:p,a&&c>1?h-1:h],v=[a&&u>1?u-1:u,a&&c>1?c-1:c],k=b[0]/v[0],I=b[1]/v[1],S=0;for(let N=0;N<d;N++){let T=N*l[0];for(let A=0;A<u;A++){let R=i?k*(A+.5):k*A,D=Math.min(p-1,a?Math.round(R):Math.floor(R));i&&(D=Math.max(0,D));let $=T+D*l[1];for(let _=0;_<c;_++){let L=i?I*(_+.5):I*_,z=Math.min(h-1,a?Math.round(L):Math.floor(L));i&&(z=Math.max(0,z));let W=$+z*l[2];for(let G=0;G<m;G++){let q=g[W+G];y[S++]=q}}}}return n.makeTensorInfo([d,u,c,m],s.dtype,y)}var rtt={kernelName:Gf,backendName:"cpu",kernelFunc:ntt};function stt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;wt([a,s],"resizeNearestNeighborGrad");let o=O.computeStrides(s.shape),l=O.computeStrides(a.shape),[u,c,d,p]=s.shape,[,h,m]=a.shape,g=new Float32Array(u*c*d*p),y=n.data.get(a.dataId).values,b=[i&&h>1?c-1:c,i&&m>1?d-1:d],v=[i&&h>1?h-1:h,i&&m>1?m-1:m],k=b[0]/v[0],I=b[1]/v[1],S=1/k,N=1/I,T=Math.ceil(S)*2+2,A=Math.ceil(N)*2+2;for(let R=0;R<u;R++){let D=R*o[0];for(let $=0;$<c;$++){let _=D+$*o[1],L=Math.floor($*S),z=Math.floor(L-T/2);for(let W=0;W<d;W++){let G=_+W*o[2],q=Math.floor(W*N),B=Math.floor(q-A/2);for(let j=0;j<p;j++){let H=0;for(let P=0;P<T;P++){let X=P+z;if(X<0||X>=h)continue;let Q=D+X*l[1],re=X*k,le=Math.min(c-1,i?Math.round(re):Math.floor(re));if($===le)for(let ke=0;ke<A;ke++){let Ne=ke+B;if(Ne<0||Ne>=m)continue;let we=Q+Ne*l[2],_e=Ne*I,Le=Math.min(d-1,i?Math.round(_e):Math.floor(_e));W===Le&&(H+=y[we+j])}}g[G+j]=H}}}}return n.makeTensorInfo(s.shape,s.dtype,g)}var att={kernelName:px,backendName:"cpu",kernelFunc:stt};function itt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;wt(s,"reverse");let i=s.shape.length,o=O.parseAxisParam(a,s.shape);if(i===0)return au({inputs:{x:s},backend:n});let l=new Xr(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){let d=l.indexToLoc(c),p=d.slice();o.forEach(h=>p[h]=s.shape[h]-1-p[h]),l.set(u.get(...p),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var ott={kernelName:qf,backendName:"cpu",kernelFunc:itt},ltt={kernelName:$x,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=O.getTypedArrayFromDType(r.dtype,O.sizeFromShape(r.shape)),[u,c,d,p]=r.shape,[h,m]=V.getImageCenter(i,c,d),g=255,y=Math.sin(s),b=Math.cos(s),v=o.data.get(r.dataId).values;for(let k=0;k<u;k++){let I=k*d*c*p;for(let S=0;S<c;S++){let N=S*(d*p);for(let T=0;T<d;T++){let A=T*p;for(let R=0;R<p;R++){let D=[u,S,T,R],$=D[2],_=D[1],L=($-h)*b-(_-m)*y,z=($-h)*y+(_-m)*b;L=Math.round(L+h),z=Math.round(z+m);let W=a;if(typeof a!="number"&&(R===3?W=g:W=a[R]),L>=0&&L<d&&z>=0&&z<c){let q=z*(d*p),B=L*p,j=I+q+B+R;W=v[j]}let G=I+N+A+R;l[G]=W}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},utt=Hn(Kf,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),ctt={kernelName:Kf,backendName:"cpu",kernelFunc:utt};function dtt(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=V.calculateShapes(a,s,i),p=!0,h=n.bufferSync(s),m=n.bufferSync(a),g=Mp(h,m,i,d,u,l,o,c,0,p);return n.makeTensorInfo(i,g.dtype,g.values)}var ptt={kernelName:fx,backendName:"cpu",kernelFunc:dtt};function htt(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function ftt(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}function mtt(e,t,n,r,s,a){let i=O.getArrayFromDType("int32",n*s);for(let o=0;o<n;++o){let l=e.slice(o*r,(o+1)*r),u=o*s;for(let c=0;c<s;++c)i[u+c]=a==="left"?htt(l,t[c+u]):ftt(l,t[c+u])}return i}function gtt(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=mtt(o,l,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",u)}var ytt={kernelName:gx,backendName:"cpu",kernelFunc:gtt};function xtt(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;wt([r,s,a],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=Ki(s.dtype,a.dtype),d=O.makeZerosTypedArray(O.sizeFromShape(s.shape),c),p=0,h=i===0||i>1||s.shape.length===1?1:O.sizeFromShape(s.shape.slice(1));for(let m=0;m<o.length;m++)for(let g=0;g<h;g++)o[m]===1?d[p++]=l[m]:d[p++]=u[m];return n.makeTensorInfo(s.shape,c,d)}var btt={kernelName:yx,backendName:"cpu",kernelFunc:xtt},vtt=V.SELU_SCALEALPHA,wtt=V.SELU_SCALE,ktt=Hn(Yf,e=>e>=0?wtt*e:vtt*(Math.exp(e)-1)),Itt={kernelName:Yf,backendName:"cpu",kernelFunc:ktt},Stt=Hn(Qf,e=>e<0?-1:e>0?1:0),Ctt={kernelName:Qf,backendName:"cpu",kernelFunc:Stt},Ntt=Hn(Zf,e=>Math.sin(e)),Ttt={kernelName:Zf,backendName:"cpu",kernelFunc:Ntt},$tt=Hn(Jf,e=>Math.sinh(e)),Ett={kernelName:Jf,backendName:"cpu",kernelFunc:$tt},_tt=11920928955078125e-23,x6=Math.log(_tt)+2,Att=Hn(tm,e=>{let t=e>-x6,n=e<x6,r=Math.exp(e),s;return n?s=r:t?s=e:s=Math.log(1+r),s}),Rtt={kernelName:tm,backendName:"cpu",kernelFunc:Att};function Dtt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;wt([s],"spaceToBatchND");let o=O.sizeFromShape(a),l=[[0,0]];l.push(...i);for(let y=1+a.length;y<s.shape.length;++y)l.push([0,0]);let u=gee.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=V.getReshaped(u.shape,a,o,!1),d=V.getPermuted(c.length,a.length,!1),p=V.getReshapedPermuted(u.shape,a,o,!1),h=ur({inputs:{x:u},backend:n,attrs:{shape:c}}),m=ti({inputs:{x:h},backend:n,attrs:{perm:d}}),g=ur({inputs:{x:m},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}var Ftt={kernelName:bx,backendName:"cpu",kernelFunc:Dtt};function Ott(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[d,p,h,m,g]=HQ(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(p,r.dtype,d),n.makeTensorInfo([p[0]],s.dtype,h),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(y=>Number(y)))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}var Mtt={kernelName:F1,backendName:"cpu",kernelFunc:Ott};function Ltt(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,d]=qQ(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var Ptt={kernelName:wx,backendName:"cpu",kernelFunc:Ltt};function ztt(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=jL(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var Btt={kernelName:O1,backendName:"cpu",kernelFunc:ztt};function Wtt(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=jL(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}var Vtt={kernelName:M1,backendName:"cpu",kernelFunc:Wtt};function Utt(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=V.calculateShapes(a,s,o),h=!1,m=n.bufferSync(s),g;switch(a.dtype){case"bool":{let y=n.bufferSync(a),b=!!n.data.get(i.dataId).values[0];g=Mp(m,y,o,p,c,u,l,d,b,h);break}case"float32":{let y=n.bufferSync(a),b=n.data.get(i.dataId).values[0];g=Mp(m,y,o,p,c,u,l,d,b,h);break}case"int32":{let y=n.bufferSync(a),b=n.data.get(i.dataId).values[0];g=Mp(m,y,o,p,c,u,l,d,b,h);break}case"string":{let y=n.bufferSync(a),b=O.decodeString(n.data.get(i.dataId).values[0]);g=Mp(m,y,o,p,c,u,l,d,b,h);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,g.dtype,g.values)}var Gtt={kernelName:kx,backendName:"cpu",kernelFunc:Utt};function jtt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=O.parseAxisParam(i,s.shape)[0],l=V.prepareSplitSize(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{let p=[...c];p[o]=d;let h=Nh({inputs:{x:s},backend:n,attrs:{begin:u,size:p}});return u[o]+=d,h})}var Htt={kernelName:vx,backendName:"cpu",kernelFunc:jtt},qtt={kernelName:L1,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;wt(n,"square");let s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let i=0;i<s.length;++i){let o=s[i];a[i]=o*o}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},Ktt=Hn(Fd,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),Xtt={kernelName:Fd,backendName:"cpu",kernelFunc:Ktt};function Ytt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=r;wt(s,"stridedSlice");let{finalShapeSparse:h,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:k,strides:I}=fs.sliceInfo(s.shape,a,i,o,l,u,c,d,p),S;if(g)S=ur({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){O.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let N=fs.computeOutShape(v,k,I),T=Nh({inputs:{x:s},backend:n,attrs:{begin:v,size:N}});S=ur({inputs:{x:T},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(T)}else{let N=n.bufferSync(s),T=YQ(h,N,I,v);S=n.makeTensorInfo(m,T.dtype,T.values)}return S}var Ztt={kernelName:Ix,backendName:"cpu",kernelFunc:Ytt};function Jtt(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,p=n.data.get(c.dataId).values,h=n.data.get(d.dataId).values,[m,g]=HL(p,h,s,a,i,o,l,u);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(d.shape,"int32",g)]}var Qtt={kernelName:z1,backendName:"cpu",kernelFunc:Jtt};function ent(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=qL(o,l,s),p=c.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var tnt={kernelName:B1,backendName:"cpu",kernelFunc:ent};function nnt(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(a.dataId).values,o=KL(i,s);return n.makeTensorInfo(a.shape,"int32",o)}var rnt={kernelName:W1,backendName:"cpu",kernelFunc:nnt},snt=Hn(om,e=>Math.tan(e)),ant={kernelName:om,backendName:"cpu",kernelFunc:snt},int=Hn(lm,e=>Math.tanh(e)),ont={kernelName:lm,backendName:"cpu",kernelFunc:int};function lnt(e){let{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=V.calculateShapes(a,s,r.shape),d=!1,p=n.bufferSync(s),h=n.bufferSync(a),m=n.bufferSync(r),g=Mp(p,h,r.shape,c,l,o,i,u,m,d);return n.makeTensorInfo(r.shape,g.dtype,g.values)}var unt={kernelName:mx,backendName:"cpu",kernelFunc:lnt};function cnt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;wt(s,"tile");let i=JQ(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var dnt={kernelName:Dd,backendName:"cpu",kernelFunc:cnt};function pnt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;wt(s,"topk");let o=n.data.get(s.dataId).values,[l,u]=eee(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var hnt={kernelName:Sx,backendName:"cpu",kernelFunc:pnt};function fnt(e){let{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,p,h]=s.shape,[m,g]=u??[d,p],y=[c,m,g,h],b=O.computeStrides(s.shape),v=b[0],k=b[1],I=b[2],S=O.computeStrides(y),N=S[0],T=S[1],A=S[2],R=O.getTypedArrayFromDType(s.dtype,O.sizeFromShape(y));R.fill(l);let D=r.data.get(s.dataId).values,$=r.data.get(a.dataId).values;for(let _=0;_<c;++_){let L=a.shape[0]===1?$:$.subarray(_*8,_*8+8);for(let z=0;z<m;++z)for(let W=0;W<g;++W)for(let G=0;G<h;++G){let q,B=L[6]*W+L[7]*z+1;if(B===0)continue;let j=(L[0]*W+L[1]*z+L[2])/B,H=(L[3]*W+L[4]*z+L[5])/B,P=b6(j,p,o),X=b6(H,d,o);switch(i){case"nearest":q=vnt(D,d,p,v,k,I,_,X,P,G,l);break;case"bilinear":q=wnt(D,d,p,v,k,I,_,X,P,G,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let Q=_*N+z*T+W*A+G;R[Q]=q}return r.makeTensorInfo(y,s.dtype,R)}return{dataId:r.write(R,y,s.dtype),shape:s.shape,dtype:s.dtype}}var mnt={kernelName:Cx,backendName:"cpu",kernelFunc:fnt};function b6(e,t,n){switch(n){case"reflect":return gnt(e,t);case"wrap":return ynt(e,t);case"nearest":return bnt(e,t);case"constant":default:return xnt(e)}}function gnt(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return O.clamp(0,n,t-1)}function ynt(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return O.clamp(0,n,t-1)}function xnt(e,t){return e}function bnt(e,t){return O.clamp(0,e,t-1)}function Yb(e,t,n,r,s,a,i,o,l,u,c){let d=i*r+o*s+l*a+u;return 0<=o&&o<t&&0<=l&&l<n?e[d]:c}function vnt(e,t,n,r,s,a,i,o,l,u,c){let d=Math.round(o),p=Math.round(l);return Yb(e,t,n,r,s,a,i,d,p,u,c)}function wnt(e,t,n,r,s,a,i,o,l,u,c){let d=Math.floor(o),p=Math.floor(l),h=d+1,m=p+1,g=(m-l)*Yb(e,t,n,r,s,a,i,d,p,u,c)+(l-p)*Yb(e,t,n,r,s,a,i,d,m,u,c),y=(m-l)*Yb(e,t,n,r,s,a,i,h,p,u,c)+(l-p)*Yb(e,t,n,r,s,a,i,h,m,u,c);return(h-o)*g+(o-d)*y}function knt(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;wt(a,"unique");let i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=YL(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var Int={kernelName:V1,backendName:"cpu",kernelFunc:knt};function Snt(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let i=s.shape.length,o=s.shape[a],l=new Array(i-1),u=0;for(let h=0;h<i;h++)h!==a&&(l[u++]=s.shape[h]);let c=new Array(i).fill(0),d=s.shape.slice();d[a]=1;let p=new Array(o);for(let h=0;h<p.length;h++){c[a]=h;let m=Nh({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});p[h]=ur({inputs:{x:m},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(m)}return p}var Cnt={kernelName:Nx,backendName:"cpu",kernelFunc:Snt};function Nnt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;wt(s,"unsortedSegmentSum");let o=s.shape.length,l=a.shape.length,u=[],c=[],d=o-l,p=a;for(let m=0;m<d;++m){let g=VI({inputs:{input:p},backend:n,attrs:{dim:m+1}});p=g,c.push(g)}for(let m=0;m<i;++m){let g=O.createScalarValue(m,"int32"),y=n.makeTensorInfo([],"int32",g),b=wQ({inputs:{a:y,b:p},backend:n}),v=fd({inputs:{x:b},backend:n,attrs:{dtype:"float32"}}),k=cT({inputs:{a:v,b:s},backend:n}),I=xw({inputs:{x:k},backend:n,attrs:{axis:0,keepDims:!1}});u.push(I),c.push(y),c.push(b),c.push(v),c.push(k),c.push(I)}let h=mee({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),h}var Tnt={kernelName:U1,backendName:"cpu",kernelFunc:Nnt},$nt=[bZe,JXe,wZe,IZe,sYe,CZe,TZe,EZe,AZe,DZe,OZe,LZe,zZe,VZe,GZe,qZe,XZe,ZZe,QZe,yZe,tJe,rJe,aJe,iYe,oJe,nYe,lYe,uJe,QXe,dJe,hJe,fJe,gJe,xJe,vJe,kJe,SJe,NJe,$Je,_Je,RJe,FJe,MJe,PJe,zJe,WJe,UJe,jJe,HJe,qJe,KJe,YJe,QJe,cZe,tQe,uYe,uQe,cYe,cQe,pYe,gQe,yQe,bQe,fYe,gYe,wQe,IQe,CQe,TQe,xYe,vYe,eYe,EQe,pJe,AQe,DQe,OQe,dZe,kYe,SYe,LQe,NYe,zQe,VQe,GQe,qQe,XQe,ZQe,JQe,$Ye,eet,net,set,iet,uet,det,het,_Ye,met,xet,ket,RYe,FYe,Net,Eet,Ret,MYe,Fet,Met,Let,gee,Wet,hZe,zYe,Uet,jet,qet,Xet,tYe,sR,Zet,fZe,mZe,gZe,Qet,ttt,rtt,att,ott,ltt,ctt,KYe,ptt,ytt,btt,Itt,YYe,Ctt,Ttt,Ett,ZYe,vet,Rtt,Ftt,Mtt,Ptt,Btt,Vtt,Gtt,Htt,eZe,qtt,nZe,sZe,Xtt,Ztt,Qtt,tnt,rnt,lZe,ZJe,ant,ont,unt,dnt,hnt,mnt,LYe,Int,Cnt,Tnt,Oet];for(let e of $nt)G1(e);var yee={};Kt(yee,{assertNotComplex:()=>Wx,bindCanvasToFramebuffer:()=>znt,bindColorTextureToFramebuffer:()=>E2,bindTextureToProgramUniformSampler:()=>Dee,bindTextureUnit:()=>_ee,bindVertexBufferToProgramAttribute:()=>iR,callAndCheck:()=>st,canBeRepresented:()=>bee,createFragmentShader:()=>kee,createFramebuffer:()=>Eee,createProgram:()=>Iee,createStaticIndexBuffer:()=>Nee,createStaticVertexBuffer:()=>Cee,createTexture:()=>Tee,createVertexShader:()=>wee,getBatchDim:()=>Th,getExtensionOrThrow:()=>Zb,getFramebufferErrorMessage:()=>Fee,getMaxTexturesInShader:()=>Pee,getNumChannels:()=>Lnt,getProgramUniformLocation:()=>Ree,getProgramUniformLocationOrThrow:()=>Aee,getRowsCols:()=>$h,getShapeAs3D:()=>Qb,getTextureShapeFromLogicalShape:()=>Mee,getWebGLDisjointQueryTimerVersion:()=>zee,getWebGLErrorMessage:()=>vee,getWebGLMaxTextureSize:()=>Lee,hasExtension:()=>Vi,isCapableOfRenderingToFloatTexture:()=>Bee,isDownloadFloatTextureEnabled:()=>Wee,isReshapeFree:()=>Bv,isWebGLFenceEnabled:()=>Vee,isWebGLVersionEnabled:()=>lR,linkProgram:()=>See,logShaderSourceAndInfoLog:()=>tP,resetMaxTextureSize:()=>Bnt,resetMaxTexturesInShader:()=>Wnt,unbindColorTextureFromFramebuffer:()=>oR,unbindTextureUnit:()=>Pnt,validateFramebuffer:()=>Jb,validateProgram:()=>$2,validateTextureSize:()=>$ee});var Ap={},s2={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function xee(e,t){Ap[e]=t}function cl(e,t){if(!(e in Ap)||t!=null){let r=_nt(e,t);if(r!==null)Ap[e]=r;else return console.log("Could not get context for WebGL version",e),null}let n=Ap[e];return n==null||n.isContextLost()?(delete Ap[e],cl(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Ap[e])}function Ent(e){if(!xe().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function _nt(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??Ent(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Ap[e]},!1),xe().getBool("SOFTWARE_WEBGL_ENABLED")&&(s2.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",s2)||n.getContext("experimental-webgl",s2):n.getContext("webgl2",s2)}var zv;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(zv||(zv={}));var Wi;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(Wi||(Wi={}));var Hs;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Hs||(Hs={}));function bw(e,t){return[t,e]}function Ant(e,t){return e*t}function a2(e){let t=O.sizeFromShape(e),n=Math.ceil(t/4);return O.sizeToSquarishShape(n)}function Bx(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function Rnt(e,t){let[n,r]=Bx(e,t);return n*r*4}function eP(e,t){let n=e,r,s,a,i,o,l,u,c,d,p;return xe().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,p=n.FLOAT,l=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=t!=null?t.HALF_FLOAT_OES:null,p=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:p}}function st(e,t){let n=t();return xe().getBool("DEBUG")&&Dnt(e),n}function Dnt(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+vee(e,t))}var Fnt=596e-10,Ont=65504;function bee(e){return!!(xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||Fnt<Math.abs(e)&&Math.abs(e)<Ont)}function vee(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Zb(e,t){return nc(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function wee(e,t){let n=nc(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(st(e,()=>e.shaderSource(n,t)),st(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function kee(e,t){let n=nc(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(st(e,()=>e.shaderSource(n,t)),st(e,()=>e.compileShader(n)),xe().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw tP(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var Mnt=/ERROR: [0-9]+:([0-9]+):/g;function tP(e,t){let n=Mnt.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],s=e.split(`
`),a=s.length.toString().length+2,i=s.map((d,p)=>O.rightPad((p+1).toString(),a)+d),o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);let l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${O.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function Iee(e){return nc(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function See(e,t){if(st(e,()=>e.linkProgram(t)),!xe().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function $2(e,t){if(st(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function Cee(e,t){let n=nc(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return st(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),st(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Nee(e,t){let n=nc(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return st(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),st(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Lnt(){return xe().getNumber("WEBGL_VERSION")===2?1:4}function Tee(e){return nc(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function $ee(e,t){let n=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function Eee(e){return nc(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function iR(e,t,n,r,s,a,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(st(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),st(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i)),st(e,()=>e.enableVertexAttribArray(o)),!0)}function _ee(e,t,n){Oee(e,n),st(e,()=>e.activeTexture(e.TEXTURE0+n)),st(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function Pnt(e,t){Oee(e,t),st(e,()=>e.activeTexture(e.TEXTURE0+t)),st(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function Aee(e,t,n){return nc(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function Ree(e,t,n){return e.getUniformLocation(t,n)}function Dee(e,t,n,r){st(e,()=>_ee(e,t,r)),st(e,()=>e.uniform1i(n,r))}function znt(e){st(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),st(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),st(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function E2(e,t,n){st(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),st(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function oR(e,t){st(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),st(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Jb(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Fee(e,t))}function Fee(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function nc(e,t,n){let r=st(e,()=>t());if(r==null)throw new Error(n);return r}function Oee(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Th(e,t=2){return O.sizeFromShape(e.slice(0,e.length-t))}function $h(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Qb(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Th(e),...$h(e)]),t}function Mee(e,t=!1){let n=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=xe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&xe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,l)=>l>=e.length-2?O.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=O.squeezeShape(e).newShape);let s=O.sizeFromShape(e),a=null;e.length<=1&&s<=n?a=[1,s]:e.length===2&&e[0]<=n&&e[1]<=n?a=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);let i=a!=null&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(a==null||i)if(t){let o=Th(e),l=2,u=2;e.length&&([l,u]=$h(e)),s=o*(l/2)*(u/2),a=O.sizeToSquarishShape(s).map(c=>c*2)}else a=O.sizeToSquarishShape(s);return a}function i2(e){return e%2===0}function Bv(e,t){if(e=e.slice(-2),t=t.slice(-2),O.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||i2(n)&&i2(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&i2(e[0])&&i2(t[0])}var _2,A2;function Lee(e){if(_2==null){let t=cl(e);_2=t.getParameter(t.MAX_TEXTURE_SIZE)}return _2}function Bnt(){_2=null}function Wnt(){A2=null}function Pee(e){if(A2==null){let t=cl(e);A2=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,A2)}function zee(e){if(e===0)return 0;let t,n=cl(e);return Vi(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:Vi(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function Vi(e,t){return e.getExtension(t)!=null}function lR(e){try{if(cl(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Bee(e){if(e===0)return!1;let t=cl(e);if(e===1){if(!Vi(t,"OES_texture_float"))return!1}else if(!Vi(t,"EXT_color_buffer_float"))return!1;return uR(t)}function Wee(e){if(e===0)return!1;let t=cl(e);if(e===1){if(!Vi(t,"OES_texture_float")||!Vi(t,"WEBGL_color_buffer_float"))return!1}else{if(Vi(t,"EXT_color_buffer_float"))return uR(t);let n="EXT_color_buffer_half_float";if(Vi(t,n)){let r=t.getExtension(n);return Vnt(t,r)}return!1}return uR(t)}function uR(e){let t=eP(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function Vnt(e,t){let n=eP(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),a}function Vee(e){return e!==2?!1:cl(e).fenceSync!=null}function Wx(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&O.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var St=xe();St.registerFlag("HAS_WEBGL",()=>St.getNumber("WEBGL_VERSION")>0);St.registerFlag("WEBGL_VERSION",()=>lR(2)?2:lR(1)?1:0);St.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);St.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>St.get("WEBGL_VERSION")===2);St.registerFlag("WEBGL_CPU_FORWARD",()=>!0);St.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);St.registerFlag("WEBGL_PACK",()=>St.getBool("HAS_WEBGL"));St.registerFlag("WEBGL_PACK_NORMALIZATION",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_CLIP",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_REDUCE",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_LAZILY_UNPACK",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_CONV_IM2COL",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>St.getBool("WEBGL_PACK"));St.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Lee(St.getNumber("WEBGL_VERSION")));St.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Pee(St.getNumber("WEBGL_VERSION")));St.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=St.getNumber("WEBGL_VERSION");return e===0?0:zee(e)});St.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>St.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!q1.isMobile());St.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Bee(St.getNumber("WEBGL_VERSION")));St.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>St.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:St.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));St.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Wee(St.getNumber("WEBGL_VERSION")));St.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Vee(St.getNumber("WEBGL_VERSION")));St.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>St.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);St.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});St.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>q1.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});St.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);St.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);St.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);St.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);St.registerFlag("WEBGL_EXP_CONV",()=>!1);St.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>St.getBool("IS_TEST"));St.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);St.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);St.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);St.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function La(){let e,t,n,r,s,a,i,o,l,u;return xe().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=xe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function gm(e,t,n="index"){let r=O.computeStrides(t);return r.map((s,a)=>{let i=`int ${e[a]} = ${n} / ${s}`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${s}`:`index -= ${e[a]} * ${s}`;return`${i}; ${o};`}).join("")}function dT(e,t,n="index"){let r=O.computeStrides(t);return r.map((s,a)=>{let i=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${i}; ${o};`}).join("")}function Unt(e,t){let n=e.length,r=e.map(a=>`${t}[${a}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function Gnt(e,t,n="index"){let r=e.map((a,i)=>i),s=Unt(r,t);return s.map((a,i)=>{let o=`int ${e[i]} = ${n} / ${s[i]}`,l=i===s.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${s[i]}`:`index -= ${e[i]} * ${s[i]}`;return`${o}; ${l};`}).join("")}function nP(e){let t=O.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function rP(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var Uee=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:Gee}=V;function jnt(e,t,n){let r=[];if(e.forEach(p=>{let h=O.sizeFromShape(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?r.push(`uniform float ${p.name}${h>1?`[${h}]`:""};`):(r.push(`uniform sampler2D ${p.name};`),r.push(`uniform int offset${p.name};`)),n.enableShapeUniforms){let{uniformShape:m}=sP(n.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${p.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${p.name}Shape;`);break}r.push(`uniform ivec2 ${p.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(p=>{r.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});let s=r.join(`
`),a=e.map(p=>Hnt(p,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=La(),l=Xnt(o),u,c,d=Jnt(o);return t.isPacked?(u=qnt(t.logicalShape,i,n.enableShapeUniforms),c=Znt(o)):(u=Knt(t.logicalShape,i,n.enableShapeUniforms),c=Ynt(o)),n.packedInputs&&(d+=nrt),[d,l,c,s,u,a,n.userCode].join(`
`)}function Vx(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return frt(e,t);case 1:return grt(e,t);case 2:return xrt(e,t);case 3:return vrt(e,t);case 4:return krt(e,t);case 5:return Irt(e);case 6:return Srt(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function jee(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return hrt(e);case 1:return mrt(e,t);case 2:return yrt(e,t);case 3:return brt(e,t);default:return wrt(e,t)}}function Hnt(e,t,n=!1,r){let s="";n?s+=jee(e,r):s+=Vx(e,r);let a=e.shapeInfo.logicalShape,i=t.logicalShape;return a.length<=i.length&&(n?s+=Crt(e,t):s+=Nrt(e,t)),s}function qnt(e,t,n){switch(e.length){case 0:return Hee();case 1:return rrt(e,t,n);case 2:return drt(e,t,n);case 3:return art(e,t,n);default:return ort(e,t,n)}}function Knt(e,t,n){switch(e.length){case 0:return Hee();case 1:return srt(e,t,n);case 2:return prt(e,t,n);case 3:return irt(e,t,n);case 4:return lrt(e,t,n);case 5:return urt(e,t);case 6:return crt(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function Xnt(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function Ynt(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function Znt(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function Jnt(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Qnt}
    ${ert}
    ${trt}
  `}var Qnt=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,ert=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,trt=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,nrt=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Hee(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function rrt(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function srt(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function art(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function irt(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${dT(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=gm(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function ort(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2),i=a,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+o,l=`b${u}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${e.length}(${l});
    }
  `}function lrt(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${dT(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=gm(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function urt(e,t){let n=gm(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function crt(e,t){let n=gm(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function drt(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(O.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let s=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function prt(e,t,n){return O.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function ym(e){return`offset${e}`}function hrt(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=La();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function frt(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[s,a]=e.shapeInfo.texShape;if(s===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=ym(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function mrt(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=La();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function grt(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Ux(e)}
      }
    `;let s=e.shapeInfo.texShape,a=s[0],i=s[1];if(i===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=ym(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function yrt(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],l=La();if(a!=null&&O.arraysEqual(n,a))return t?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function xrt(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(a!=null&&O.arraysEqual(n,a)){if(t)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let p=a[0],h=a[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:o}=O.squeezeShape(n),l=i;if(l.length<n.length){let p=Gx(e,l),h=["row","col"];return`
      ${Vx(p,t)}
      float ${s}(int row, int col) {
        return ${s}(${jx(h,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Ux(e)}
      }
    `;let u=a[0],c=a[1],d=ym(r);return c===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function brt(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){let p=n.slice(1),h=[1,2],m=Gx(e,p),g=["b","row","col"];return`
        ${jee(m,t)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${jx(g,h)});
        }
      `}let o=La();if(t)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;let l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${d}, ${c}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function vrt(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=O.squeezeShape(n),u=o;if(u.length<n.length){let g=Gx(e,u),y=["row","col","depth"];return`
        ${Vx(g,t)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${jx(y,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${i}, 1)));
        ${Ux(e)}
      }
    `;let c=e.shapeInfo.texShape,d=c[0],p=c[1],h=e.shapeInfo.flatOffset;if(p===a&&h==null)return t?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(p===i&&h==null)return t?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;let m=ym(r);return t?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${i} + depth + ${m};
        vec2 uv = uvFromFlat(${d}, ${p}, index);
        return sampleTexture(${r}, uv);
      }
  `}function wrt(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=La();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;let a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(a[i-1]/2),p=d*Math.ceil(a[i-2]/2),h="int b, int row, int col",m=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<i-1;g++)h=`int b${g}, `+h,p*=a[i-g-1],m=`b${g} * ${p} + `+m;return`
    vec4 ${r}(${h}) {
      int index = ${m};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${s.texture2D}(${n}, uv);
    }
  `}function krt(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=O.squeezeShape(n);if(l.length<n.length){let v=Gx(e,l),k=["row","col","depth","depth2"];return`
      ${Vx(v,t)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${jx(k,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${a}, 1)));
        ${Ux(e)}
      }
    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1],m=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,y=`int stride0 = ${r}Shape[1] * stride1;`;if(h===o&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${m}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(h===a&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;let b=ym(r);return t?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${p}, ${h}, index + ${b});
      return sampleTexture(${r}, uv);
    }
  `}function Irt(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=O.squeezeShape(t);if(l.length<t.length){let g=Gx(e,l),y=["row","col","depth","depth2","depth3"];return`
      ${Vx(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${jx(y,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${a}, ${s})) +
          depth3;
        ${Ux(e)}
      }
    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1];if(h===o&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(h===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=ym(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${a} +
          depth2 * ${s} + depth3 + ${m};
      vec2 uv = uvFromFlat(${p}, ${h}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Srt(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=O.squeezeShape(t);if(s.length<t.length){let y=Gx(e,s),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${Vx(y)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${jx(b,a)});
      }
    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Ux(e)}
      }
    `;let d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],m=p[1];if(m===c&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===i&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;let g=ym(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${g};
      vec2 uv = uvFromFlat(${h}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Ux(e){let t=e.name,n=O.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Crt(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=Gee(e.shapeInfo.logicalShape,t.logicalShape),l=tr(i),u=i-a,c,d=["x","y","z","w","u","v"];a===0?c="":i<2&&o.length>=1?c="coords = 0;":c=o.map(y=>`coords.${d[y+u]} = 0;`).join(`
`);let p="";i<2&&a>0?p="coords":p=e.shapeInfo.logicalShape.map((y,b)=>`coords.${d[b+u]}`).join(", ");let h="return outputValue;",m=O.sizeFromShape(e.shapeInfo.logicalShape)===1,g=O.sizeFromShape(t.logicalShape)===1;if(a===1&&!m&&!g)h=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!g)i===1?h=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:h=`
        return vec4(outputValue.x);
      `;else if(o.length){let y=a-2,b=a-1;o.indexOf(y)>-1&&o.indexOf(b)>-1?h="return vec4(outputValue.x);":o.indexOf(y)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(b)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${p});
      ${h}
    }
  `}function Nrt(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&O.arraysEqual(i,a))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let u=tr(l),c=Gee(e.shapeInfo.logicalShape,t.logicalShape),d=l-o,p,h=["x","y","z","w","u","v"];o===0?p="":l<2&&c.length>=1?p="coords = 0;":p=c.map(g=>`coords.${h[g+d]} = 0;`).join(`
`);let m="";return l<2&&o>0?m="coords":m=e.shapeInfo.logicalShape.map((g,y)=>`coords.${h[y+d]}`).join(", "),`
    float ${s}() {
      ${u} coords = getOutputCoords();
      ${p}
      return get${r}(${m});
    }
  `}function tr(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function sP(e,t,n){let{newShape:r,keptDims:s}=O.squeezeShape(t),a=t.length,i=e&&a===3&&t[0]===1,o=i?t.slice(1):r,l=!e&&a>1&&!O.arraysEqual(t,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:s}}function Gx(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function jx(e,t){return t.map(n=>e[n]).join(", ")}function Trt(e,t,n,r){let s=n.map((c,d)=>{let p={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(p.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:p}}),a=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=jnt(s,i,t),l=kee(e.gl,o),u=e.createProgram(l);return xe().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},qee(e,t,u)))}function qee(e,t,n){let r=[],s=[],a,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),xe().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));let c=!1;for(let d of t.variableNames){let p={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(p.shape=e.getUniformLocation(n,`${d}Shape`,c),p.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),r.push(p)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(let d of t.customUniforms)s.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function v6(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let s=n.logicalShape,a=t[r],i=a.shape;if(!O.arraysEqual(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&a.isUniform)return;let o=n.texShape,l=a.isUniform?null:a.texData.texShape;if(!O.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function $rt(e,t,n,r,s){t.program.enableShapeUniforms||(v6(t.inShapeInfos,n),v6([t.outShapeInfo],[r]));let a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),xe().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let u=n[l],{uniform:c,offset:d,shape:p,texShape:h}=t.variablesLocations[l];if(p){let{uniformShape:m}=sP(t.program.packedInputs,u.shape,u.texData.texShape);switch(m.length){case 1:e.gl.uniform1iv(p,new Int32Array(m));break;case 2:e.gl.uniform2iv(p,new Int32Array(m));break;case 3:e.gl.uniform3iv(p,new Int32Array(m));break;case 4:e.gl.uniform4iv(p,new Int32Array(m));break}}if(h&&e.gl.uniform2i(h,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(O.sizeFromShape(u.shape)<2)e.gl.uniform1f(c,u.uniformValues[0]);else{let m=u.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),e.gl.uniform1fv(c,m)}continue}u.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,c,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){let l=O.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let l=0;l<t.program.customUniforms.length;++l){let u=t.program.customUniforms[l],c=t.customUniformLocations[l],d=s[l];if(u.type==="float")e.gl.uniform1fv(c,d);else if(u.type==="vec2")e.gl.uniform2fv(c,d);else if(u.type==="vec3")e.gl.uniform3fv(c,d);else if(u.type==="vec4")e.gl.uniform4fv(c,d);else if(u.type==="int")e.gl.uniform1iv(c,d);else if(u.type==="ivec2")e.gl.uniform2iv(c,d);else if(u.type==="ivec3")e.gl.uniform3iv(c,d);else if(u.type==="ivec4")e.gl.uniform4iv(c,d);else throw Error(`uniform type ${u.type} is not supported yet.`)}e.executeProgram()}function Ert(e,t,n){let r="";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=sP(e.packedInputs,i.shape,l),p="",h="",m="";if(c.length===1&&e.packedInputs){let S=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${S[0]>1}_${S[1]>1}`}else if(c.length===2&&!e.packedInputs)h=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){let S=O.computeStrides(c);m=`${S[0]===l[1]}_${S[S.length-1]===l[1]}`}let g=i.shape.length,y=c.length===2&&O.arraysEqual(i.shape,l),b=O.sizeFromShape(i.shape)===1,v=V.getBroadcastDims(i.shape,n.shape),k=!e.packedInputs&&g===n.shape.length&&O.arraysEqual(l,n.texData.texShape),I=e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${g}_${k}_${u?d:""}_${c.length}_${b}_${v}_${y}_${p}_${h}_${m}_${I}_${o}`}else{let l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${o}`}});let s=e.userCode,a=e.constructor.name;return a+="_"+r+"_"+s+`${xe().getNumber("WEBGL_VERSION")}`,a}function ha(e){return xe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var _rt=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=zv.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=La();this.outputShape=e,this.enableShapeUniforms=ha(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?dT(["r","c","d"],e):gm(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},Art=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=zv.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=La();this.outputShape=e,this.enableShapeUniforms=ha(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?dT(["r","c","d"],e):gm(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},Rrt=class{constructor(e){this.variableNames=["A"],this.outTexUsage=Wi.DOWNLOAD;let t=La();this.outputShape=e,this.userCode=`
      ${Uee}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},Drt=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Wi.DOWNLOAD;let t=La();this.outputShape=e,this.userCode=`
      ${Uee}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},Frt={R:0,G:1,B:2,A:3},w6=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=La();this.outputShape=e,this.enableShapeUniforms=ha(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let i=0;i<n.length;i++){let o=n[i];a+=`
          if(offset == ${i}) {
            result = values[${Frt[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?rP():nP(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}},Ort=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=La();this.outputShape=e,this.enableShapeUniforms=ha(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){let o=a*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?rP():nP(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${s};
        }
    `}},Kee={};Kt(Kee,{bindVertexProgramAttributeStreams:()=>rte,createBufferFromOutputTexture:()=>ite,createFloat16MatrixTexture:()=>Qee,createFloat16PackedMatrixTexture:()=>nte,createFloat32MatrixTexture:()=>Jee,createIndexBuffer:()=>Zee,createPackedMatrixTexture:()=>tte,createUnsignedBytesMatrixTexture:()=>ete,createVertexBuffer:()=>Yee,createVertexShader:()=>Xee,downloadByteEncodedFloatMatrixFromOutputTexture:()=>lte,downloadFloat32MatrixFromBuffer:()=>ote,downloadMatrixFromPackedOutputTexture:()=>cte,downloadPackedMatrixFromBuffer:()=>ute,getInternalFormatForFloat16MatrixTexture:()=>iP,getInternalFormatForFloat16PackedMatrixTexture:()=>uP,getInternalFormatForFloat32MatrixTexture:()=>aP,getInternalFormatForPackedMatrixTexture:()=>lP,getInternalFormatForUnsignedBytesMatrixTexture:()=>oP,uploadDenseMatrixToTexture:()=>ste,uploadPixelDataToTexture:()=>ate});function Xee(e){let t=La(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return wee(e,n)}function Yee(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Cee(e,t)}function Zee(e){let t=new Uint16Array([0,1,2,2,1,3]);return Nee(e,t)}function vw(e,t,n,r,s,a){$ee(t,n);let i=Tee(e),o=e.TEXTURE_2D;return st(e,()=>e.bindTexture(o,i)),st(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),st(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),st(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),st(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),xe().getNumber("WEBGL_VERSION")===1?st(e,()=>e.texImage2D(o,0,r,t,n,0,s,a,null)):st(e,()=>e.texStorage2D(o,1,r,t,n)),st(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function aP(e){return e.internalFormatFloat}function Jee(e,t,n,r){let[s,a]=bw(t,n);return vw(e,s,a,aP(r),r.textureFormatFloat,e.FLOAT)}function iP(e){return e.internalFormatHalfFloat}function Qee(e,t,n,r){let[s,a]=bw(t,n);return vw(e,s,a,iP(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function oP(e){return e.downloadTextureFormat}function ete(e,t,n,r){let[s,a]=bw(t,n);return vw(e,s,a,oP(r),e.RGBA,e.UNSIGNED_BYTE)}function lP(e){return e.internalFormatPackedFloat}function tte(e,t,n,r){let[s,a]=Bx(t,n);return vw(e,s,a,lP(r),e.RGBA,e.FLOAT)}function uP(e){return e.internalFormatPackedHalfFloat}function nte(e,t,n,r){let[s,a]=Bx(t,n);return vw(e,s,a,uP(r),e.RGBA,r.textureTypeHalfFloat)}function rte(e,t,n){return st(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),iR(e,t,"clipSpacePos",n,3,20,0)&&iR(e,t,"uv",n,2,20,12)}function ste(e,t,n,r,s,a){st(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),xe().getNumber("WEBGL_VERSION")===2?st(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):st(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),st(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function ate(e,t,n){st(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?xe().getNumber("WEBGL_VERSION")===2?st(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):st(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):xe().getNumber("WEBGL_VERSION")===2?st(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):st(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),st(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function ite(e,t,n,r){let s=e.createBuffer();st(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));let a=4*4*t*n;return st(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),st(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),st(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function ote(e,t,n){let r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function lte(e,t,n,r){let[s,a]=bw(t,n),i=4,o=new Uint8Array(Ant(t*n,i));return st(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function ute(e,t,n,r,s,a,i,o){let l=e,u=new Float32Array(Rnt(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function cte(e,t,n){let r=new Float32Array(t*n*4);return st(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var R2=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=xe().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,xee(t,e)):this.gl=cl(t),e=this.gl,xe().getNumber("WEBGL_VERSION")===2){let s=e;this.createVertexArray=()=>st(s,()=>s.createVertexArray()),this.bindVertexArray=a=>st(s,()=>s.bindVertexArray(a)),this.deleteVertexArray=a=>st(s,()=>s.deleteVertexArray(a)),this.getVertexArray=()=>st(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(e!=null){let s=e.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>st(e,()=>s.createVertexArrayOES()),this.bindVertexArray=a=>st(e,()=>s.bindVertexArrayOES(a)),this.deleteVertexArray=a=>st(e,()=>s.deleteVertexArrayOES(a)),this.getVertexArray=()=>st(e,()=>e.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),xe().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Zb(this.gl,s),Vi(this.gl,a))this.textureHalfFloatExtension=Zb(this.gl,a);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Vi(this.gl,r))this.colorBufferHalfFloatExtension=Zb(this.gl,r);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Vi(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Vi(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Yee(this.gl),this.indexBuffer=Zee(this.gl),this.framebuffer=Eee(this.gl),this.textureConfig=eP(this.gl,this.textureHalfFloatExtension)}get debug(){return xe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;st(e,()=>e.finish()),st(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),st(e,()=>e.deleteFramebuffer(this.framebuffer)),st(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),st(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),st(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Jee(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Qee(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),ete(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),ate(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),ste(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),nte(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),tte(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(oR(this.gl,this.framebuffer),this.outputTexture=null),st(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>lte(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return ute(this.gl,e,t,n,r,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return ote(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=ite(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(xe().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let a=r.clientWaitSync(s,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=s}else xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>cte(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=Xee(t));let n=Iee(t);st(t,()=>t.attachShader(n,this.vertexShader)),st(t,()=>t.attachShader(n,e)),See(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&$2(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;st(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),rte(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(st(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&$2(this.gl,this.program),st(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?Aee(this.gl,e,t):Ree(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),st(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),Dee(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,s]=Bx(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&$2(this.gl,this.program),Jb(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}st(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),st(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Zb(this.gl,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await O.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=Mrt(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in xe().platform&&(n=xe().platform.setTimeoutCustom.bind(xe().platform)),O.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),E2(this.gl,e,this.framebuffer),this.debug&&Jb(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(E2(this.gl,this.outputTexture,this.framebuffer),this.debug&&Jb(this.gl)):oR(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;E2(r,e,this.framebuffer),this.debug&&Jb(r),this.outputTexture=e,st(r,()=>r.viewport(0,0,t,n)),st(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),st(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Mrt(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:Lrt,bincountImpl:dte,bincountReduceImpl:Prt,bitwiseAndImpl:zrt,castImpl:Brt,ceilImpl:Wrt,concatImpl:Vrt,equalImpl:Urt,expImpl:Grt,expm1Impl:jrt,floorImpl:Hrt,gatherNdImpl:qrt,gatherV2Impl:Krt,greaterImpl:Xrt,greaterEqualImpl:Yrt,lessImpl:Zrt,lessEqualImpl:Jrt,linSpaceImpl:Qrt,logImpl:est,maxImpl:tst,maximumImpl:nst,minimumImpl:rst,multiplyImpl:sst,negImpl:ast,notEqualImpl:ist,prodImpl:ost,raggedGatherImpl:lst,raggedRangeImpl:ust,raggedTensorToTensorImpl:cst,rangeImpl:dst,rsqrtImpl:pst,scatterImpl:hst,sigmoidImpl:fst,simpleAbsImpl:pte,sliceImpl:mst,sparseFillEmptyRowsImpl:gst,sparseReshapeImpl:yst,sparseSegmentReductionImpl:hte,sqrtImpl:xst,staticRegexReplaceImpl:bst,stridedSliceImpl:vst,stringNGramsImpl:wst,stringSplitImpl:kst,stringToHashBucketFastImpl:Ist,subImpl:Sst,tileImpl:Cst,topKImpl:Nst,transposeImpl:cP,uniqueImpl:Tst}=PL;function fte(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Na(e,t){return t===1?[e]:fte(e,t)}function $st(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var Est=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=ha(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=Na("rc",this.rank),n=tr(this.rank),r=this.getOutOfBoundsCondition(t),s=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)s=`${e[e.length-1-a]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},mte=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=ha(this.outputShape.length);let n="";for(let r=0;r<4;r++){let s="thisRC = rc;";r%2===1&&(s+="thisRC.z += 1;"),r>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${_st(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?rP():nP(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function _st(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Gnt(["r","c","d"],"inputShape"):gm(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var Ast=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=I6(t,n),s=S6(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let a=k6(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let o=this.freeTextures[s].pop();return this.usedTextures[s].push(o),o}let i;return r===Hs.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Hs.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Hs.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Hs.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Hs.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let s=I6(n,r),a=S6(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);let i=k6(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=xe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[a],u=l&&l.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Rst(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function k6(e,t,n,r,s){let a=Dst(t,r),i;if(s){let[l,u]=Bx(e[0],e[1]);i=l*u}else{let[l,u]=bw(e[0],e[1]);i=l*u}let o=Rst(n,a);return i*o}function Dst(e,t){switch(e){case Hs.PACKED_2X2_FLOAT32:return lP(t);case Hs.PACKED_2X2_FLOAT16:return uP(t);case Hs.UNPACKED_FLOAT32:return aP(t);case Hs.UNPACKED_FLOAT16:return iP(t);case Hs.PACKED_4X1_UNSIGNED_BYTE:return oP(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function Fst(e){return xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Hs.PACKED_2X2_FLOAT32:Hs.UNPACKED_FLOAT32:e?Hs.PACKED_2X2_FLOAT16:Hs.UNPACKED_FLOAT16}function I6(e,t){if(e===Wi.UPLOAD)return Hs.PACKED_2X2_FLOAT32;if(e===Wi.RENDER||e==null)return Fst(t);if(e===Wi.DOWNLOAD||e===Wi.PIXELS)return Hs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function S6(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var Bl=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=ha(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Eo="if (isnan(x)) return x;",Ost="return x;",C6="return abs(x);",Mst="return (x >= 0.0) ? x : (exp(x) - 1.0);",Lst=Eo+`
  return (x < 0.0) ? 0.0 : x;
`,Pst=Eo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Rc="return x;",zst="return 1.0 / (1.0 + exp(-1.0 * x));",Bst="return x;",Wst=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Vst=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ust=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Gst="return 1.0 / (1.0 + exp(-1.0 * x));",Bc=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=ha(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},jst=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=ha(this.outputShape.length);let t=e.length,n=Na("rc",t),r=tr(t),s=$st(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},Hst=du.whereImpl,qst=1e-7,Kst=1e-4,YE={};function Xst(e){return e in YE||(YE[e]={}),YE[e]}var Yst=xe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Zst=600;function Jst(){return xe().global.screen==null?1024:xe().global.screen.height*xe().global.screen.width*window.devicePixelRatio*Zst/1024/1024}var dP=class gte extends w1{nextDataId(){return gte.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!xe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof R2)n=t;else{let r=cl(xe().getNumber("WEBGL_VERSION"),t);n=new R2(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let r=cl(xe().getNumber("WEBGL_VERSION"));n=new R2(r),this.binaryCache=Xst(xe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Ast(this.gpgpu),this.numMBBeforeWarning=Jst(),this.texData=new UC(this,fo())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,r,s,a,i){let o=this.makeTensorInfo(n,r),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[s,a]},l.texShape=[s,a];let u=Qb(n),c=new w6(u,!1,i),d=this.runWebGLProgram(c,[o],r,[[s,a]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(t,n,r){if((xe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||xe().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:t,usage:Wi.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,r,s,a){if(xe().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:s,values:n,usage:Wi.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:r,dtype:s,complexTensorInfos:a,slice:i,shape:o,isPacked:l}=n;if(i!=null){let p;l?p=new Bc(o,Rc):p=new Bl(o,Rc);let h=this.runWebGLProgram(p,[{dataId:t,shape:o,dtype:s}],s),m=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),m}if(r!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return r;let u=this.activeTimers!=null,c;u&&(c=O.now());let d;if(s==="complex64"){let p=this.readSync(a.real.dataId),h=this.readSync(a.imag.dataId);d=V.mergeRealAndImagArrays(p,h)}else d=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=O.now()-c),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){let m=this.pendingRead.get(t);return new Promise(g=>m.push(g))}let n=this.texData.get(t),{values:r,shape:s,slice:a,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(a!=null){let m;l?m=new Bc(s,Rc):m=new Bl(s,Rc);let g=this.runWebGLProgram(m,[{dataId:t,shape:s,dtype:i}],i),y=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(r!=null)return this.convertAndCacheOnCPU(t);if(xe().getBool("DEBUG")&&!xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&xe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(i!=="complex64"&&xe().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let m=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(m.texture.texture,...a2(s))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(i==="complex64"){let m=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),g=m[0],y=m[1];d=V.mergeRealAndImagArrays(g,y)}else if(u==null)d=this.getValuesFromTexture(t);else{let m=O.sizeFromShape(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(u,m)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){let m=this.gpgpu.gl;st(m,()=>m.deleteBuffer(u))}let p=this.convertAndCacheOnCPU(t,d),h=this.pendingRead.get(t);return this.pendingRead.delete(t),h.forEach(m=>m(p)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&fo().removeDataId(t,this),this.pendingDeletes--),p}readToGPU(t,n={}){let r=this.texData.get(t),{values:s,shape:a,slice:i,dtype:o,isPacked:l,texture:u}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let h;l?h=new Bc(a,Rc):h=new Bl(a,Rc);let m=this.runWebGLProgram(h,[{dataId:t,shape:a,dtype:o}],o),g=this.readToGPU(m,n);return this.disposeIntermediateTensorInfo(m),g}if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(t,n.customTexShape),d=fo().makeTensorFromTensorInfo(c),p=this.texData.get(c.dataId);return Object.assign({tensorRef:d},p.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(s=>O.decodeString(s));return tn(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return tn(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let r=t[n];if(!bee(r))throw xe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:r,isPacked:s}=this.texData.get(t),a=O.sizeFromShape(n);if(xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let p=this.decode(t),h=this.texData.get(p.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...a2(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(p),m}let i=xe().getBool("WEBGL_PACK")&&s===!0,o=i?Qb(n):n,l=i?new Drt(o):new Rrt(o),u=this.runWebGLProgram(l,[{shape:o,dtype:r,dataId:t}],"float32"),c=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let n=this.activeTimers,r=[],s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,t();let a=O.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=O.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(a);o.kernelMs=O.sum(l),o.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:O.now(),endMs:null}}endTimer(t){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=O.now(),t)}async getQueryTime(t){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:r,texShape:s,usage:a,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,a,i)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=Yst){return xe().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&O.sizeFromShape(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){V.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return Hst(t.shape,n)}packedUnaryOp(t,n,r){let s=new Bc(t.shape,n),a=this.compileAndRun(s,[t],r);return fo().makeTensorFromTensorInfo(a)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let s=pte(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,s)}if(xe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,C6,t.dtype);let n=new Bl(t.shape,C6),r=this.compileAndRun(n,[t]);return fo().makeTensorFromTensorInfo(r)}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&O.isString(r[0])){let a=r.map(i=>O.encodeString(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:n}}makeOutput(t,n,r){return fo().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,r),this)}unpackTensor(t){let n=new jst(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new Est(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let r=[Th(t.shape),...$h(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},a=[Th(n),...$h(n)],i=new mte(a,r),o=!0,l=[r],u=this.runWebGLProgram(i,[s],t.dtype,l,o);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(t,n){let r=this.texData.get(t),{isPacked:s,shape:a,dtype:i}=r;if(n!=null){let p=O.sizeFromShape(a),h=n[0]*n[1]*4;O.assert(p<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=Qb(a),l;s?l=new Art(o):l=new _rt(o);let u=!0,c=[n??a2(o)],d=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,c,u,n);return{dtype:i,shape:a,dataId:d.dataId}}runWebGLProgram(t,n,r,s,a=!1,i){let o=this.makeTensorInfo(t.outputShape,r),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===zv.DENSE){let b=i??a2(t.outputShape);l.texShape=b.map(v=>v*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),O.sizeFromShape(o.shape)===0)return l.values=O.getTypedArrayFromDType(o.dtype,0),o;let u=[],c=n.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let v=this.texData.get(b.dataId);if(v.texture==null){if(!t.packedInputs&&O.sizeFromShape(b.shape)<=xe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:v.values};t.packedInputs&&(v.isPacked=!0,v.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!v.isPacked!=!!t.packedInputs)b=v.isPacked?this.unpackTensor(b):this.packTensor(b),u.push(b),v=this.texData.get(b.dataId);else if(v.isPacked&&!Bv(v.shape,b.shape)){let k=b,I=b.shape;b.shape=v.shape,b=this.packedReshape(b,I),u.push(b),v=this.texData.get(b.dataId),k.shape=I}return{shape:b.shape,texData:v,isUniform:!1}});this.uploadToGPU(o.dataId);let d={shape:o.shape,texData:l,isUniform:!1},p=Ert(t,c,d),h=this.getAndSaveBinary(p,()=>Trt(this.gpgpu,t,c,d)),m=this.activeTimers!=null,g;m&&(g=this.startTimer()),xe().get("ENGINE_COMPILE_ONLY")||$rt(this.gpgpu,h,c,d,s),u.forEach(b=>this.disposeIntermediateTensorInfo(b)),m&&(g=this.endTimer(g),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(g)}));let y=xe().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){let b=O.now();b-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!xe().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&a===!1){let b=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),b}return o}compileAndRun(t,n,r,s,a=!1){return r=r||n[0].dtype,this.runWebGLProgram(t,n,r,s,a)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(xe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ce(()=>{if(!xe().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=xe().getBool("DEBUG");xe().set("DEBUG",!1);let n=this.abs(Tt(1e-8)).dataSync()[0];if(xe().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?qst:Kst}uploadToGPU(t){let n=this.texData.get(t),{shape:r,dtype:s,values:a,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;let u=this.activeTimers!=null,c;u&&(c=O.now());let d=n.texShape;if(d==null&&(d=Mee(r,l),n.texShape=d),a!=null){let p=Qb(r),h,m=d[1],g=d[0],y=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(l||!y)&&([m,g]=Bx(d[0],d[1])),l?h=new Ort(p,y):h=new w6(p,y);let b=y?[g,m]:d,v=this.makeTensorInfo(b,s),k=this.texData.get(v.dataId);y?k.usage=Wi.PIXELS:k.usage=Wi.UPLOAD,k.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),m,g,a);let I=[[g,m]],S=this.runWebGLProgram(h,[v],s,I,!0),N=this.texData.get(S.dataId);n.texShape=N.texShape,n.isPacked=N.isPacked,n.usage=N.usage,xe().get("ENGINE_COMPILE_ONLY")?this.disposeData(S.dataId):(n.texture=N.texture,n.values=null,this.texData.delete(S.dataId)),this.disposeIntermediateTensorInfo(v),u&&(this.uploadWaitMs+=O.now()-c)}else{let p=this.acquireTexture(d,o,s,l);n.texture=p}}convertAndCacheOnCPU(t,n){let r=this.texData.get(t),{dtype:s}=r;return n!=null&&(r.values=Qst(n,s)),r.values}acquireTexture(t,n,r,s){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,s)}computeBytes(t,n){return t[0]*t[1]*O.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(a){throw a}});t.push(r)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await eM(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(tP(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=qee(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=r,t.infLoc=s,t.nanLoc=a,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,r){t.channels=t.channels||"RGBA";let{texture:s,height:a,width:i,channels:o}=t,l=fo().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let u=l.writeTexture(s,n,r,a,i,o);return fo().makeTensorFromDataId(u,n,r,l)}};dP.nextDataId=0;function Qst(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}var eat="4.22.0";function yte(){xe().set("WEBGL_FORCE_F16_TEXTURES",!0)}q1.isBrowser()&&oN("webgl",()=>new dP,2);var tat={forceHalfFloat:yte},pP=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,Eh=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=V.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=ha(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},xm=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,Hx=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=V.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length;this.enableShapeUniforms=ha(s);let a="";if(r)if(s===0||O.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${tr(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=Na("coords",s);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function $i(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var nat={kernelName:vf,backendName:"webgl",kernelFunc:$i};function Wd(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=$i({inputs:{x:r},backend:n}),l=$i({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}var rat={kernelName:HC,backendName:"webgl",kernelFunc:Wd},xte="return (a < 0.) ? b * a : a;",bte=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function sat(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",O.createScalarValue(a,"float32")),o=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Hx(bte,s.shape,i.shape):new Eh(xte,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var aat={kernelName:Sf,backendName:"webgl",kernelFunc:sat},vte="return (a < 0.) ? b * a : a;",wte=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function iat(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Hx(wte,r.shape,s.shape):new Eh(vte,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}var oat={kernelName:Bf,backendName:"webgl",kernelFunc:iat},qx="if (isnan(x)) return x;";function kn({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{let{x:i}=s,o=a,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let d=o.texData.get(i.dataId),p=n(d.values,l);return o.makeTensorInfo(i.shape,l,p)}let u=xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return u?c=new Bc(i.shape,t):c=new Bl(i.shape,e),o.runWebGLProgram(c,[i],l)}}function Js({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{let{a:l,b:u}=i,c=o;if(r&&l.dtype==="complex64"){let m=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[y,b]=[[m.complexTensorInfos.real,g.complexTensorInfos.real],[m.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(k=>{let[I,S]=k,N={dataId:I.dataId,dtype:I.dtype,shape:l.shape},T={dataId:S.dataId,dtype:S.dtype,shape:u.shape},A=new Eh(e,l.shape,u.shape);return c.runWebGLProgram(A,[N,T],Ki(I.dtype,S.dtype))}),v=Wd({inputs:{real:y,imag:b},backend:c});return c.disposeIntermediateTensorInfo(y),c.disposeIntermediateTensorInfo(b),v}let d=a||Ki(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&s!=null){let m=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,y=l.dtype==="string"?V.fromUint8ToStringArray(m):m,b=l.dtype==="string"?V.fromUint8ToStringArray(g):g,[v,k]=s(l.shape,u.shape,y,b,d),I=c.makeTensorInfo(k,d),S=c.texData.get(I.dataId);return S.values=v,I}let p=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,h;return p?h=new Hx(t,l.shape,u.shape,n):h=new Eh(e,l.shape,u.shape),c.runWebGLProgram(h,[l,u],d)}}function Wv(e,t=!1){if(e==="linear")return t?Bst:Ost;if(e==="relu")return t?Vst:Lst;if(e==="elu")return t?Wst:Mst;if(e==="relu6")return t?Ust:Pst;if(e==="prelu")return t?wte:vte;if(e==="leakyrelu")return t?bte:xte;if(e==="sigmoid")return t?Gst:zst;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var kte=class{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=ha(this.outputShape.length);let u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=s?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",y="";i&&(o?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,y="result = activation(result);");let b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let v="rc.x",k="rc.x";e[0]<t[0]?v=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(k=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${v};
        int batchB = ${k};
        for (int i = 0; i < ${c}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${m[0]});
          result += (${h[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}},N6={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},T6=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=V.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},$6="return a * b;";function hP(e){let{inputs:t,backend:n}=e,{a:r,b:s}=t,a=V.upcastType(r.dtype,s.dtype);if(r.dtype==="complex64"){let o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),u=new T6(N6.REAL,r.shape,s.shape),c=new T6(N6.IMAG,r.shape,s.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],p=n.runWebGLProgram(u,d,"float32"),h=n.runWebGLProgram(c,d,"float32"),m=Wd({inputs:{real:p,imag:h},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),m}if(n.shouldExecuteOnCPU([r,s])){let o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[u,c]=sst(r.shape,s.shape,o.values,l.values,a),d=n.makeTensorInfo(c,a),p=n.texData.get(d.dataId);return p.values=u,d}let i;return xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Hx($6,r.shape,s.shape):i=new Eh($6,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}var lat={kernelName:Mf,backendName:"webgl",kernelFunc:hP};function uat(e,t,n){let r=[Th(e.shape),...$h(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[Th(t),...$h(t)],i=new mte(a,r),o=!0,l=[r],u=n.runWebGLProgram(i,[s],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function rt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=O.sizeFromShape(s.shape),l=O.inferFromImplicitShape(a,o),u=O.sizeFromShape(l);O.assert(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(s.dataId);return c.isPacked&&!Bv(s.shape,l)&&!(c.texture!==null&&Bv(c.shape,l))?uat(s,l,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}var cat={kernelName:dx,backendName:"webgl",kernelFunc:rt},E6=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i=Math.floor(n/4)*4,o=n%4,l="sumValue += dot(values, ones);";if(t!=null){let c=1/t;l=`sumValue += dot(values * ${O.isInt(c)?c.toPrecision(2):c}, ones);`}let u="";s%n>0&&(u=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},dat=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let u=Math.floor(n/4)*4,c=n%4,d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(i="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(i="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let h="";s%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${c===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${c===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function pat(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=V.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function bm(e,t,n,r){let s=pat(e.shape),a=e;for(let i=0;i<s.length;i++){let{inSize:o,windowSize:l,outSize:u}=s[i],c,d;n==="mean"?c=i===0?new E6({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new E6({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):c=new dat({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=a,a=r.runWebGLProgram(c,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}var hat=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;let r=tr(this.rank),s=fat(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function fat(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}var mat=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=tr(this.rank),s=fte("rc",this.rank),a=new Array(this.rank);for(let u=0;u<t.length;u++)a[t[u]]=s[u];let i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function pT(e,t,n){let r=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mat(e.shape,t):new hat(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function gat(e,t,n,r){let s=t,a=e.shape.length,i=O.parseAxisParam(s,e.shape),o=i,l=V.getAxesPermutation(o,a),u=l!=null,c=e;u&&(c=pT(e,l,r),o=V.getInnerMostAxes(o.length,a)),V.assertAxesAreInnerMostDims("sum",o,a);let[d,p]=V.computeOutAndReduceShapes(c.shape,o),h=d;n&&(h=V.expandShapeToKeepDim(d,i));let m=O.sizeFromShape(p),g=O.sizeFromShape(e.shape)/m,y=rt({inputs:{x:c},attrs:{shape:[g,m]},backend:r}),b=iN(e.dtype),v=bm(y,b,"sum",r),k=rt({inputs:{x:v},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(v),u&&r.disposeIntermediateTensorInfo(c),k}function hT(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return gat(s,a,i,n)}var yat={kernelName:rm,backendName:"webgl",kernelFunc:hT};function Aa(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=s.shape[a[c]];let u;if(i.shouldExecuteOnCPU([s])){let c=i.texData.get(s.dataId).values,d=cP(c,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype);let p=i.texData.get(u.dataId);p.values=d}else u=pT(s,a,i);return u}var xat={kernelName:Ru,backendName:"webgl",kernelFunc:Aa},Ite=1e3;function GI({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u=e.shape.length,c=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],p=r?t.shape[c-1]:t.shape[c-2],h=n?e.shape[u-1]:e.shape[u-2],m=r?t.shape[c-2]:t.shape[c-1],g=e.shape.slice(0,-2),y=t.shape.slice(0,-2),b=O.sizeFromShape(g),v=O.sizeFromShape(y),k=Ex.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,m]);O.assert(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let I=n?[b,d,h]:[b,h,d],S=r?[v,m,p]:[v,p,m],N=rt({inputs:{x:e},backend:s,attrs:{shape:I}}),T=rt({inputs:{x:t},backend:s,attrs:{shape:S}}),A=[N,T],R=Math.max(b,v),D=n?N.shape[1]:N.shape[2],$=a!=null,_=i!=null,L=l==="leakyrelu",z=l!=null?Wv(l,!0):null,W=$||_||L||z!=null,G;if((h===1||m===1)&&D>Ite&&W===!1){let B=N,j=T;n&&(B=Aa({inputs:{x:N},backend:s,attrs:{perm:[0,2,1]}}),A.push(B)),r&&(j=Aa({inputs:{x:T},backend:s,attrs:{perm:[0,2,1]}}),A.push(j));let H=m!==1,P=m===1,X=B;H&&(X=rt({inputs:{x:B},backend:s,attrs:{shape:[R,D,1]}}),A.push(X));let Q=m===1?2:1,re=j;P&&(re=rt({inputs:{x:j},backend:s,attrs:{shape:[R,1,D]}}),A.push(re));let le=hP({inputs:{a:X,b:re},backend:s});G=hT({inputs:{x:le},backend:s,attrs:{axis:Q,keepDims:!0}}),A.push(le)}else{let B=Ki(e.dtype,t.dtype),j=new kte(I,S,[R,h,m],n,r,$,z,_,L),H=[N,T];if(a!=null&&H.push(a),_&&H.push(i),L){let P=s.makeTensorInfo([],"float32",O.createScalarValue(o,"float32"));H.push(P),A.push(P)}G=s.runWebGLProgram(j,H,B)}let q=rt({inputs:{x:G},backend:s,attrs:{shape:k}});A.push(G);for(let B of A)s.disposeIntermediateTensorInfo(B);return q}function bat(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return GI({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}var vat={kernelName:ph,backendName:"webgl",kernelFunc:bat},_6="return abs(x);";function wat(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let a=n.texData.get(r.dataId),i=pte(a.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Bc(r.shape,_6):s=new Bl(r.shape,_6),n.runWebGLProgram(s,[r],r.dtype)}var kat={kernelName:Ty,backendName:"webgl",kernelFunc:wat},Iat=Eo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Sat=kn({opSnippet:Iat}),Cat={kernelName:Gh,backendName:"webgl",kernelFunc:Sat},Nat=Eo+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Tat=kn({opSnippet:Nat}),$at={kernelName:jh,backendName:"webgl",kernelFunc:Tat},A6="return a + b;",Eat=Js({opSnippet:A6,packedOpSnippet:A6,supportsComplex:!0,cpuKernelImpl:Lrt}),_at={kernelName:Ad,backendName:"webgl",kernelFunc:Eat},Aat=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},Rat=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function D2(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return $i({inputs:{x:r[0]},backend:n});if(r.length>xe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(r.length/2),l=D2({inputs:r.slice(0,o),backend:n}),u=D2({inputs:r.slice(o),backend:n});return D2({inputs:[l,u],backend:n})}let s=r.map(o=>o.dtype).reduce((o,l)=>Ki(o,l)),a=r.map(o=>o.shape),i=xe().getBool("WEBGL_PACK")?new Rat(r[0].shape,a):new Aat(r[0].shape,a);return n.runWebGLProgram(i,r,s)}var Dat={kernelName:Hh,backendName:"webgl",kernelFunc:D2};function Fat(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=O.parseAxisParam(a,s.shape),u=l,c=V.getAxesPermutation(u,o),d=s;c!=null&&(d=Aa({inputs:{x:s},backend:n,attrs:{perm:c}}),u=V.getInnerMostAxes(u.length,o)),V.assertAxesAreInnerMostDims("all",u,o);let[p,h]=V.computeOutAndReduceShapes(d.shape,u),m=O.sizeFromShape(h),g=rt({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=bm(g,g.dtype,"all",n),b;if(i){let v=V.expandShapeToKeepDim(p,l);b=rt({inputs:{x:y},backend:n,attrs:{shape:v}})}else b=rt({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),c!=null&&n.disposeIntermediateTensorInfo(d),b}var Oat={kernelName:$y,backendName:"webgl",kernelFunc:Fat};function Mat(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=O.parseAxisParam(a,s.shape),u=l,c=V.getAxesPermutation(u,o),d=s;c!=null&&(d=Aa({inputs:{x:s},backend:n,attrs:{perm:c}}),u=V.getInnerMostAxes(u.length,o)),V.assertAxesAreInnerMostDims("any",u,o);let[p,h]=V.computeOutAndReduceShapes(d.shape,u),m=O.sizeFromShape(h),g=rt({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=bm(g,g.dtype,"any",n),b;if(i){let v=V.expandShapeToKeepDim(p,l);b=rt({inputs:{x:y},backend:n,attrs:{shape:v}})}else b=rt({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),c!=null&&n.disposeIntermediateTensorInfo(d),b}var Lat={kernelName:Ey,backendName:"webgl",kernelFunc:Mat},Pat=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];let i=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},zat=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,O.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,l=tr(o),u=Na("coords",o),c,d;if(a===1){d=o+1;let T=tr(d);c=`
        ${T} sourceLocR = ${T}(${u.join()}, 0);
        ++${u[o-1]};
        ${T} sourceLocG = ${T}(${u.join()}, 0);
        ++${u[o-2]};
        ${T} sourceLocA = ${T}(${u.join()}, 0);
        --${u[o-1]};
        ${T} sourceLocB = ${T}(${u.join()}, 0);
        --${u[o-2]};`}else d=o,c=`
        ${l} sourceLocR = coords;
        ++${u[o-1]};
        ${l} sourceLocG = coords;
        ++${u[o-2]};
        ${l} sourceLocA = coords;
        --${u[o-1]};
        ${l} sourceLocB = coords;
        --${u[o-2]};`;let p=["x","y","z","w","u","v"].slice(0,d),h="."+p[d-1],m=p.map(T=>"int "+T),g=Na("sourceLocR",d-1).concat("inIdx.r"),y=Na("sourceLocG",d-1).concat("inIdx.g"),b=Na("sourceLocB",d-1).concat("inIdx.b"),v=Na("sourceLocA",d-1).concat("inIdx.a"),k=n==="max"?"greaterThan":"lessThan",I=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${v.join()})));`,S=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,N=r?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${N}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${S};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${S};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${k}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function Ste(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];r!=null&&(s=r.shape[0],a=r.shape[1]);let i=V.computeOptimalWindowSize(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new Pat(o,n,r==null),u=[t];r!=null&&u.push(r);let c=e.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;let d=Ste(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function Cte(e,t,n,r=null){let s=r!=null?r.shape:t.shape,a=s[s.length-1],i=V.computeOptimalWindowSize(a),o=new zat(s,i,n,r==null),l=r==null?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let c=Cte(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}return u}function Nte(e,t,n,r){let s=[n];if(V.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!xe().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let a=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,l=t;o&&(l=e.unpackTensor(t),a.push(l));let[u,c]=V.computeOutAndReduceShapes(l.shape,s),d=O.sizeFromShape(c),p=rt({inputs:{x:l},backend:e,attrs:{shape:[-1,d]}});a.push(p);let h=Ste(e,p,r);a.push(h);let m=rt({inputs:{x:h},backend:e,attrs:{shape:u}});return a.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}return Cte(e,t,r)}function Bat(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,i=O.parseAxisParam(a,s.shape),o=V.getAxesPermutation(i,s.shape.length),l=s,u=[];o!=null&&(l=Aa({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=V.getInnerMostAxes(i.length,l.shape.length)),V.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let c=Nte(n,l,i[0],"max");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}var Wat={kernelName:_y,backendName:"webgl",kernelFunc:Bat};function Vat(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,i=O.parseAxisParam(a,s.shape),o=V.getAxesPermutation(i,s.shape.length),l=s,u=[];o!=null&&(l=Aa({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=V.getInnerMostAxes(i.length,l.shape.length)),V.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let c=Nte(n,l,i[0],"min");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}var Uat={kernelName:Ay,backendName:"webgl",kernelFunc:Vat},Gat=Eo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,jat=kn({opSnippet:Gat}),Hat={kernelName:qh,backendName:"webgl",kernelFunc:jat},qat=Eo+"return log(x + sqrt(x * x + 1.0));",Kat=kn({opSnippet:qat}),Xat={kernelName:Kh,backendName:"webgl",kernelFunc:Kat},Yat=Eo+`
  return atan(x);
`,Zat=kn({opSnippet:Yat}),Jat={kernelName:Xh,backendName:"webgl",kernelFunc:Zat},Qat=pP+`
  return atan(a, b);
`,eit=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xm+`
  return result;
`,tit=Js({opSnippet:Qat,packedOpSnippet:eit}),nit={kernelName:Zh,backendName:"webgl",kernelFunc:tit},rit=Eo+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,sit=kn({opSnippet:rit}),ait={kernelName:Yh,backendName:"webgl",kernelFunc:sit},Vv=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;let m=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,b="0.0";if(m||(b="-1.0 / 1e-20"),n){let T=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${p}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${T} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?s?g:y:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / max(count, 1.0)");let I=Math.floor(a/4)*4,S=a%4,N=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${p}, ${h});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${N}
          }

          int xC = xCCorner + ${I};
          if (${S===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${S===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${S===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${N}
          }
        }
        setOutput(${k});
      }
    `}},fP=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;let v=t==="avg",k="0.0";if(v||(k="-1.0 / 1e-20"),n){let R=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${R} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let I="max",S=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(S="avgValue / max(count, 1.0)");let N=Math.floor(a/4)*4,T=a%4,A=`
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${k};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${k});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${N}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${A}
            }

            int xC = xCCorner + ${N};
            if (${T===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${T===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${T===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${A}
            }
          }
        }
        setOutput(${S});
      }
    `}};function iit(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Wx(s,"avgPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;O.assert(V.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=V.computePool2DInfo(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&O.arraysEqual(c.inShape,c.outShape))return $i({inputs:{x:s},backend:n});let d=new Vv(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}var oit={kernelName:Jh,backendName:"webgl",kernelFunc:iit};function lit(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],d=V.computePool3DInfo(s.shape,a,i,c,o,l,u),p=new fP(d,"avg",!1);return n.runWebGLProgram(p,[s],"float32")}var uit={kernelName:Ry,backendName:"webgl",kernelFunc:lit},cit=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${c});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},dit=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=c-1-e.padInfo.front,m=d-1-e.padInfo.top,g=p-1-e.padInfo.left,y=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${h}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function pit(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],p=V.computePool3DInfo(i.shape,o,l,d,u,c),h=new dit(p);return n.runWebGLProgram(h,[s],i.dtype)}var hit={kernelName:S1,backendName:"webgl",kernelFunc:pit};function fit(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;Wx([s,a],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=V.computePool2DInfo(i.shape,o,l,1,u),d=new cit(c);return n.runWebGLProgram(d,[s],i.dtype)}var mit={kernelName:I1,backendName:"webgl",kernelFunc:fit};function git(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return GI({a:s,b:a,transposeA:i,transposeB:o,backend:n})}var yit={kernelName:Qh,backendName:"webgl",kernelFunc:git},xit=class{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],V.assertAndGetBroadcastShape(e,t),V.assertAndGetBroadcastShape(e,n);let i="0.0";r!=null&&(V.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";s!=null&&(V.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},bit=class{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],V.assertAndGetBroadcastShape(e,t),V.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";r!=null&&(V.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";s!=null&&(V.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}},vit=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:s,variance:a,offset:i,scale:o}=e;O.assert(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O.assert(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O.assert(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let u=[r,s,a],c=null;i!=null&&(c=i.shape,u.push(i));let d=null;o!=null&&(d=o.shape,u.push(o));let p=xe().getBool("WEBGL_PACK_NORMALIZATION")?new bit(r.shape,s.shape,a.shape,c,d,l):new xit(r.shape,s.shape,a.shape,c,d,l);return t.runWebGLProgram(p,u,u[0].dtype)},wit={kernelName:xf,backendName:"webgl",kernelFunc:vit},kit=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=tr(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=Iit(this.rank),r,s=e.map((a,i)=>`sourceLoc.${cR[i]} = start[${i}] + coords.${cR[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},cR=["x","y","z","w","u","v"];function Iit(e){if(e===1)return"sourceLoc";if(e<=6)return cR.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var Sit=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=tr(this.rank),n=Na("coords",this.rank),r=Na("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,c)=>`start[${c}]`).join()});`:e.map((u,c)=>`${r[c]} = ${n[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function Cit(e,t,n,r){let s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=fs.computeFlatOffset(t,O.computeStrides(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}function Kx(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=fs.parseSliceParams(s,a,i);if(fs.assertParamsValid(s,o,l),O.sizeFromShape(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){let d=n.texData.get(s.dataId),p=mst(d.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,p)}let{isPacked:u}=n.texData.get(s.dataId),c=fs.isSliceContinous(s.shape,o,l);if(u||!c){let d=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Sit(l):new kit(l),p=[o];return n.runWebGLProgram(d,[s],s.dtype,p)}return n.uploadToGPU(s.dataId),Cit(s,o,l,n)}var Nit={kernelName:xx,backendName:"webgl",kernelFunc:Kx},Tit=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;O.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=a.reduce((v,k)=>v*k),l=V.getReshaped(s.shape,a,o),u=V.getPermuted(l.length,a.length),c=V.getReshapedPermuted(s.shape,a,o),d=V.getSliceBeginCoords(i,a.length),p=V.getSliceSize(c,i,a.length),h=[],m=rt({inputs:{x:s},backend:n,attrs:{shape:l}}),g=Aa({inputs:{x:m},backend:n,attrs:{perm:u}}),y=rt({inputs:{x:g},backend:n,attrs:{shape:c}}),b=Kx({inputs:{x:y},backend:n,attrs:{begin:d,size:p}});return h.push(m),h.push(g),h.push(y),h.forEach(v=>n.disposeIntermediateTensorInfo(v)),b},$it={kernelName:Dy,backendName:"webgl",kernelFunc:Tit};function Eit(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=dte(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}var _it={kernelName:Fy,backendName:"webgl",kernelFunc:Eit},Ait=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Rit=`
  return float(int(a.r) & int(b.r));
`;function Dit(e){let{inputs:t,backend:n}=e,{a:r,b:s}=t,a=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=xe().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||i===1){let l=n.texData.get(r.dataId).values,u=n.texData.get(s.dataId).values,[c,d]=zrt(r.shape,s.shape,l,u,r.dtype),p=n.makeTensorInfo(d,r.dtype),h=n.texData.get(p.dataId);return h.values=c,p}let o;return a?o=new Hx(Ait,r.shape,s.shape,!1):o=new Eh(Rit,r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}var Fit={kernelName:Oy,backendName:"webgl",kernelFunc:Dit};function Oit(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=V.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Mit={kernelName:C1,backendName:"webgl",kernelFunc:Oit},Lit="return float(a != b);",Tte=Js({opSnippet:Lit,cpuKernelImpl:ist,dtype:"bool"}),Pit={kernelName:ax,backendName:"webgl",kernelFunc:Tte};function ww(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return $i({inputs:{x:s.complexTensorInfos.real},backend:n})}var zit={kernelName:sN,backendName:"webgl",kernelFunc:ww},Bit="return float(int(x));";function Wit(e,t){let n=new Bl(e.shape,Bit),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function dR(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return $i({inputs:{x:s},backend:n});let i=Cr(s.shape),o=dR({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Wd({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(s.dtype==="complex64"){let i=ww({inputs:{input:s},backend:n}),o=dR({inputs:{x:i},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(i),o}if(!O.hasEncodingLoss(s.dtype,a)){let i=$i({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(n.shouldExecuteOnCPU([s])){let i=n.texData.get(s.dataId).values,[o,l,u]=Brt(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}if(a==="int32")return Wit(s,n);if(a==="bool"){let i=n.makeTensorInfo([],"bool",O.getTypedArrayFromDType("bool",1)),o=Tte({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}var Vit={kernelName:ef,backendName:"webgl",kernelFunc:dR},R6="return ceil(x);",Uit=kn({opSnippet:R6,packedOpSnippet:R6,cpuKernelImpl:Wrt}),Git={kernelName:tf,backendName:"webgl",kernelFunc:Uit},jit=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},Hit=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function qit(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r,o;xe().getBool("WEBGL_PACK_CLIP")?o=new Hit(s.shape):o=new jit(s.shape);let l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}var Kit={kernelName:Rd,backendName:"webgl",kernelFunc:qit},Xit=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function D6(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function Yit(e){let{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new Xit(r.shape),i=[D6(r,s.complexTensorInfos.real),D6(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}var Zit={kernelName:N1,backendName:"webgl",kernelFunc:Yit},Jit=class{constructor(e){this.outputShape=[],this.outputShape=V.computeOutShape(e,1),this.variableNames=e.map((a,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){let i=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${i}));`)}let r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},Qit=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=V.computeOutShape(e,t);let n=this.outputShape,r=n.length,s=tr(r),a=Na("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((m,g)=>`T${g}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let m=1;m<o.length;m++)o[m]=o[m-1]+e[m][t];let l=i[t],u=i.slice(-2),c=i.join(),d=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${c}), vec2(${u.join()}));
        }`;for(let m=1;m<o.length;m++){let g=o[m-1];d+=`
        if (${l} < ${o[m]}  && ${l} >= ${o[m-1]}) {
          return getChannel(
            getT${m}(${o2(i,l,g)}),
            vec2(${o2(u,l,g)}));
        }`}let p=o.length,h=o[o.length-1];d+=`
        return getChannel(
          getT${p}(${o2(i,l,h)}),
          vec2(${o2(u,l,h)}));`,this.userCode=`
      float getValue(${i.map(m=>"int "+m)}) {
        ${d}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${n[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${n[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${n[r-2]} &&
            ${a[r-1]} < ${n[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function o2(e,t,n){let r=e.indexOf(t);return e.map((s,a)=>a===r?`${s} - ${n}`:s).join()}function fT(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return $i({inputs:{x:s.complexTensorInfos.imag},backend:n})}var eot={kernelName:eN,backendName:"webgl",kernelFunc:fT};function ev(e,t,n){let r=e[0].dtype;if(r==="complex64"){let h=e.map(v=>ww({inputs:{input:v},backend:n})),m=e.map(v=>fT({inputs:{input:v},backend:n})),g=ev(h,t,n),y=ev(m,t,n),b=Wd({inputs:{real:g,imag:y},backend:n});return h.forEach(v=>n.disposeIntermediateTensorInfo(v)),m.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),b}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){let h=e.map(I=>{let S=[-1,O.sizeFromShape(I.shape.slice(t))];return rt({inputs:{x:I},backend:n,attrs:{shape:S}})}),m=h.map(I=>({vals:n.readSync(I.dataId),shape:I.shape})),g=V.computeOutShape(h.map(I=>I.shape),1),y=h[0].shape[0]===1,b=Vrt(m,g,r,y),v=V.computeOutShape(e.map(I=>I.shape),t),k=n.makeTensorInfo(v,r,b);return h.forEach(I=>n.disposeIntermediateTensorInfo(I)),k}let a=e.filter(h=>O.sizeFromShape(h.shape)>0),i=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){let h=i?new Bl(e[0].shape,Rc):new Bc(e[0].shape,Rc);return n.runWebGLProgram(h,e,r)}let o=xe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){let h=[];for(let g=0;g<a.length;g+=o){let y=a.slice(g,g+o);h.push(ev(y,t,n))}let m=ev(h,t,n);for(let g of h)n.disposeIntermediateTensorInfo(g);return m}if(i){let h=new Qit(a.map(m=>m.shape),t);return n.runWebGLProgram(h,a,r)}let{tensors2D:l,outShape:u}=tot(a,t,n),c=new Jit(l.map(h=>h.shape)),d=n.runWebGLProgram(c,l,r);l.forEach(h=>n.disposeIntermediateTensorInfo(h));let p=rt({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),p}function tot(e,t,n){let r=V.computeOutShape(e.map(s=>s.shape),t);return{tensors2D:e.map(s=>rt({inputs:{x:s},attrs:{shape:[-1,O.sizeFromShape(s.shape.slice(t))]},backend:n})),outShape:r}}function $te(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=O.parseAxisParam(s,t[0].shape)[0],i=t.map(u=>u.shape);V.assertParamsConsistent(i,a);let o=V.computeOutShape(t.map(u=>u.shape),a);if(O.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(u=>O.sizeFromShape(u.shape)>0);return l.length===1?$i({inputs:{x:l[0]},backend:n}):ev(l,a,n)}var not={kernelName:My,backendName:"webgl",kernelFunc:$te},Ete=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,h=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,v=g?3:1,k="",I="";n&&(r?k=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?k=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:k=`
          float activation(float x) {
            ${n}
          }
        `,I="result = activation(result);");let S=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${k}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${v}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${S}
        ${I}
        setOutput(result);
      }
    `}},rot=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,p=e.filterWidth,h=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},_te=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ha(this.outputShape.length);let a=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u,d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)d+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<u;g++)d+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(c+1)/2;g++){let y=g*2;if(d+=`
           xC = xCCorner + ${y*o};
           `,i===1){if(y<u&&(a%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,o===1&&y>0?d+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<u)){let b=a%2===0?O.nearestLargerEven(o):o;o%2===0&&a%2===1||o%2!==0&&a%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,o>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:d+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?d+=`
                     xC${y+1} = xTexelC${y};
                     `:d+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<u&&(a%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<u&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<u&&(d+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<u&&(d+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<u&&(d+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",h="";n&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:s?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:p=`vec4 activation(vec4 x) {
           ${n}
         }`,h="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${h}
         setOutput(result);
       }
     `}},sot=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=ha(this.outputShape.length);let{dataFormat:n}=t,r=La(),s=n==="channelsLast",a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let c=0;c<=1;c++)l+=`
          blockIndex = rc.z + ${c};
          pos = rc.y + ${u};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+c}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+c}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}};function jI(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function Ate({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){let l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],p=n.outChannels,h=n.dataFormat==="channelsLast",m=!1,g=!1,y,b=[];if(a!=null){let v=jI(a.shape,h);v!=null&&(a=rt({inputs:{x:a},backend:r,attrs:{shape:v}}),b.push(a))}if(s!=null){let v=jI(s.shape,h);v!=null&&(s=rt({inputs:{x:s},backend:r,attrs:{shape:v}}),b.push(s))}if(!((d===1||p===1)&&c>Ite)&&u.isPacked&&h&&u.texture!=null&&l[2]%2!==0&&O.arraysEqual(u.shape.slice(-3),l.slice(-3))){let v=l[0]*l[1]*(l[2]+1),k={dataId:e.dataId,shape:[1,v,n.inChannels],dtype:e.dtype},I=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,O.assert(Bv(u.shape,k.shape),()=>`packed reshape ${u.shape} to ${k.shape} isn't free`);let S=rt({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});b.push(S);let N=GI({a:k,b:S,backend:r,transposeA:m,transposeB:g,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),T=r.texData.get(N.dataId);O.assert(T.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=I,T.shape=n.outShape,y=$i({inputs:{x:N},backend:r}),y.shape=n.outShape,b.push(N)}else{let v=n.outHeight*n.outWidth,k=rt({inputs:{x:e},backend:r,attrs:{shape:h?[n.batchSize,v,n.inChannels]:[n.batchSize,n.inChannels,v]}}),I=rt({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),S=GI({a:h?k:I,b:h?I:k,transposeA:!h,transposeB:g,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});y=rt({inputs:{x:S},backend:r,attrs:{shape:n.outShape}}),b.push(k),b.push(I),b.push(S)}for(let v of b)r.disposeIntermediateTensorInfo(v);return y}function Rte({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:p,dataFormat:h}=n,m=h==="channelsLast",g=l*u*c,y=p*d,b=[n.batchSize,g,y],v=!0,k=!1,I=[];if(a!=null){let B=jI(a.shape,m);B!=null&&(a=rt({inputs:{x:a},backend:r,attrs:{shape:B}}),I.push(a))}if(s!=null){let B=jI(s.shape,m);B!=null&&(s=rt({inputs:{x:s},backend:r,attrs:{shape:B}}),I.push(s))}let S=rt({inputs:{x:t},backend:r,attrs:{shape:[1,g,O.sizeFromShape(t.shape)/g]}});I.push(S);let N=new sot(b,n),T=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],A=r.runWebGLProgram(N,[e],"float32",T),R=rt({inputs:{x:A},backend:r,attrs:{shape:b}});I.push(A),I.push(R);let D=s!=null,$=a!=null,_=o==="leakyrelu",L=o?Wv(o,!0):null,z=new kte(m?R.shape:S.shape,m?S.shape:R.shape,m?[n.batchSize,y,n.outChannels]:[n.batchSize,n.outChannels,y],v,k,D,L,$,_),W=m?[R,S]:[S,R];if(s&&W.push(s),$&&W.push(a),_){let B=r.makeTensorInfo([],"float32",O.createScalarValue(i,"float32"));W.push(B),I.push(B)}let G=r.runWebGLProgram(z,W,"float32"),q=rt({inputs:{x:G},backend:r,attrs:{shape:n.outShape}});I.push(G);for(let B of I)r.disposeIntermediateTensorInfo(B);return q}function aot(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=V.convertConv2DDataFormat(l),p=V.computeConv2DInfo(s.shape,a.shape,i,u,o,c,!1,d),h;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))h=Ate({x:s,filter:a,convInfo:p,backend:n});else if(p.strideWidth<=2&&d==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){let g=new _te(p),y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];h=n.runWebGLProgram(g,[s,a],"float32",y)}else if(xe().getBool("WEBGL_CONV_IM2COL"))h=Rte({x:s,filter:a,convInfo:p,backend:n});else{let g=new Ete(p);h=n.runWebGLProgram(g,[s,a],"float32")}let m=rt({inputs:{x:h},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(h),m}var iot={kernelName:nf,backendName:"webgl",kernelFunc:aot},oot=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},lot=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=a?1:2,u=a?2:3,c=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},uot=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},cot=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function dot(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=V.convertConv2DDataFormat(l),p=V.computeConv2DInfo(s.shape,c,i,1,o,u,!1,d),h=new oot(p);return n.runWebGLProgram(h,[s,a],"float32")}var pot={kernelName:qC,backendName:"webgl",kernelFunc:dot},hot=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=ha(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function fot(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=V.convertConv2DDataFormat(u),p=V.computeConv2DInfo(i,a.shape,o,1,l,c,!1,d);if(xe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){let h=[[p.strideHeight,p.strideWidth]],m=new hot(p);return n.runWebGLProgram(m,[s,a],"float32",h)}else{let h=new lot(p);return n.runWebGLProgram(h,[s,a],"float32")}}var mot={kernelName:rf,backendName:"webgl",kernelFunc:fot};function got(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=V.computeConv3DInfo(s.shape,a.shape,i,l,o),c=new rot(u);return n.runWebGLProgram(c,[s,a],"float32")}var yot={kernelName:sf,backendName:"webgl",kernelFunc:got};function xot(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=V.computeConv3DInfo(s.shape,l,i,1,o),c=new uot(u);return n.runWebGLProgram(c,[s,a],"float32")}var bot={kernelName:Ly,backendName:"webgl",kernelFunc:xot};function vot(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=V.computeConv3DInfo(l,a.shape,o,1,i),c=new cot(u);return n.runWebGLProgram(c,[s,a],"float32")}var wot={kernelName:Py,backendName:"webgl",kernelFunc:vot},kot=qx+`
  return cos(x);
`,Iot=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${xm}
  return result;
`,Sot=kn({opSnippet:kot,packedOpSnippet:Iot}),Cot={kernelName:af,backendName:"webgl",kernelFunc:Sot},Not=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Tot=kn({opSnippet:Not}),$ot={kernelName:of,backendName:"webgl",kernelFunc:Tot},Eot=class{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[a,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];let p=r==="bilinear"?1:0,[h,m]=[`${i-1}.0`,`${o-1}.0`],[g,y,b]=c>1?[`${(i-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[v,k,I]=d>1?[`${(o-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${v});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${k};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${I};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},_ot=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new Eot(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")},Aot={kernelName:By,backendName:"webgl",kernelFunc:_ot},Uv;(function(e){e.Prod="*",e.Sum="+"})(Uv||(Uv={}));var F6=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,a=this.op===Uv.Prod?"1.0":"0.0",i=n?a:`getX(${O6(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?`end != ${o-1}`:"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${tr(s)} coords = getOutputCoords();
        int end = ${M6(s,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${M6(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${O6(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function O6(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function M6(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Dte(e,t,n,r,s,a){let i=t.shape.length,o=V.getAxesPermutation([r],i),l=t;o!=null&&(l=Aa({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=V.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let c=l.shape[u],d=$i({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(c))-1;p++){let h=new F6(e,l.shape,!1,a),m=[[p]],g=d;d=n.runWebGLProgram(h,[d],d.dtype,m),n.disposeIntermediateTensorInfo(g)}if(s){let p=new F6(e,l.shape,s,a),h=d;d=n.runWebGLProgram(p,[d],d.dtype),n.disposeIntermediateTensorInfo(h)}if(o!=null){let p=V.getUndoAxesPermutation(o),h=Aa({inputs:{x:d},backend:n,attrs:{perm:p}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),h}return d}function Rot(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return Dte(Uv.Prod,s,n,a,i,o)}var Dot={kernelName:zy,backendName:"webgl",kernelFunc:Rot};function Fot(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return Dte(Uv.Sum,s,n,a,i,o)}var Oot={kernelName:lf,backendName:"webgl",kernelFunc:Fot};function Mot(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){let l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=dte(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){let l=n.bufferSync(s),u=n.bufferSync(a),c=Prt(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var Lot={kernelName:T1,backendName:"webgl",kernelFunc:Mot},Pot=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function zot(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],u=i==="NHWC"?s.shape[2]:s.shape[3],c=i==="NHWC"?s.shape[3]:s.shape[1],d=l*a,p=u*a,h=c/(a*a),m=i==="NHWC"?[o,d,p,h]:[o,h,d,p],g=new Pot(m,a,i);return n.runWebGLProgram(g,[s],s.dtype)}var Bot={kernelName:Wy,backendName:"webgl",kernelFunc:zot},Fte=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ha(this.outputShape.length);let a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,u="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${u}
        setOutput(result);
      }
    `}},Ote=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ha(this.outputShape.length);let a=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c,p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<c;y++)p+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;p+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let y=0;y<c;y++)p+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(d+1)/2;y++){let b=y*2;if(p+=`
          xC = xCCorner + ${b*l};
          `,o===1){if(b<c&&(i%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,l===1&&b>0?p+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<c)){let v=i%2===0?O.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${v};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,l>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:p+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):v===1?p+=`
                    xC${b+1} = xTexelC${b};
                    `:p+=`
                    xCOffset = xC + ${v};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<c&&(i%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<c&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<c&&(p+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<c&&(p+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<c&&(p+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let h="",m="";n&&(r?h=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?h=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:h=`vec4 activation(vec4 x) {
          ${n}
        }`,m="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}};function Wot(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r,c=l;c==null&&(c=[1,1]),O.assert(V.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let d=V.computeConv2DInfo(s.shape,a.shape,i,c,o,u,!0),p;xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?p=new Ote(d):p=new Fte(d);let h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(p,[s,a],"float32",h)}var Vot={kernelName:uf,backendName:"webgl",kernelFunc:Wot},Uot=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Got=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function jot(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=V.computeConv2DInfo(s.shape,c,i,o,l,u,!0),p=new Uot(d);return n.runWebGLProgram(p,[s,a],"float32")}var Hot={kernelName:KC,backendName:"webgl",kernelFunc:jot};function qot(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=V.computeConv2DInfo(c,a.shape,i,o,l,u,!0),p=new Got(d);return n.runWebGLProgram(p,[s,a],"float32")}var Kot={kernelName:XC,backendName:"webgl",kernelFunc:qot},Xot=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Yot(e){let{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=O.sizeFromShape(r.shape),i=rt({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new Xot(a),l=n.runWebGLProgram(o,[i],i.dtype),u=rt({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var Zot={kernelName:$1,backendName:"webgl",kernelFunc:Yot},Jot=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${c}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Qot(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=V.computeDilation2DInfo(s.shape,a.shape,i,o,"NHWC",l),c,d=new Jot(u);c=n.runWebGLProgram(d,[s,a],"float32");let p=rt({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),p}var elt={kernelName:cf,backendName:"webgl",kernelFunc:Qot};function tlt(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=V.decodeEinsumEquation(s,a.length);V.checkEinsumDimSizes(i.length,l,a);let{path:u,steps:c}=V.getEinsumComputePath(o,l),d=c.length,p=null,h=i.length,m=[];for(let g=0;g<d;++g){for(let y of c[g]){let{permutationIndices:b,expandDims:v}=V.getEinsumPermutation(h,l[y]),k;V.isIdentityPermutation(b)?k=a[y]:(k=Aa({inputs:{x:a[y]},backend:n,attrs:{perm:b}}),m.push(k));let I=k.shape.slice();for(let S=0;S<v.length;++S)I.splice(v[S],0,1);O.arraysEqual(k.shape,I)||(k=rt({inputs:{x:k},backend:n,attrs:{shape:I}}),m.push(k)),p===null?p=k:(p=hP({inputs:{a:k,b:p},backend:n}),m.push(p))}g<d-1&&(u[g]>=0&&(p=hT({inputs:{x:p},backend:n,attrs:{axis:u[g]-(i.length-h),keepDims:!1}}),m.push(p)),h--)}for(let g of m)g!==p&&n.disposeIntermediateTensorInfo(g);return p}var nlt={kernelName:ZC,backendName:"webgl",kernelFunc:tlt},rlt="return (x >= 0.0) ? x : (exp(x) - 1.0);",slt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,alt=kn({opSnippet:rlt,packedOpSnippet:slt}),ilt={kernelName:pf,backendName:"webgl",kernelFunc:alt},olt="return (b >= 0.0) ? a : a * (b + 1.0);",llt=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,ult=e=>{let{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Hx(llt,r.shape,s.shape):new Eh(olt,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)},clt={kernelName:Vy,backendName:"webgl",kernelFunc:ult},dlt=`
  return vec4(equal(a, b));
`,plt="return float(a == b);",hlt=Js({opSnippet:plt,packedOpSnippet:dlt,dtype:"bool",cpuKernelImpl:Urt}),flt={kernelName:Uy,backendName:"webgl",kernelFunc:hlt},mlt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${V.ERF_P};
  float a1 = ${V.ERF_A1};
  float a2 = ${V.ERF_A2};
  float a3 = ${V.ERF_A3};
  float a4 = ${V.ERF_A4};
  float a5 = ${V.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,glt=kn({opSnippet:mlt}),ylt={kernelName:hf,backendName:"webgl",kernelFunc:glt},xlt=qx+`
  return exp(x);
`,blt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Mte=kn({opSnippet:xlt,packedOpSnippet:blt,cpuKernelImpl:Grt,dtype:"float32"}),vlt={kernelName:ff,backendName:"webgl",kernelFunc:Mte};function pR(e){let{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(O.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),rt({inputs:{x:a},backend:r,attrs:{shape:o}})}var wlt={kernelName:Gy,backendName:"webgl",kernelFunc:pR},L6="return exp(x) - 1.0;",klt=kn({opSnippet:L6,packedOpSnippet:L6,cpuKernelImpl:jrt}),Ilt={kernelName:mf,backendName:"webgl",kernelFunc:klt},P6=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function Lte(e,t,n){let r=n.texData.get(e.dataId),s=O.sizeFromShape(e.shape),a=e.shape[e.shape.length-1],i=s/a,o=rt({inputs:{x:e},backend:n,attrs:{shape:[i,a]}}),l=o.shape,u=new P6("real",l,t),c=new P6("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],p=n.runWebGLProgram(u,d,"float32"),h=n.runWebGLProgram(c,d,"float32"),m=Wd({inputs:{real:p,imag:h},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h);let g=rt({inputs:{x:m},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(m),g}function Slt(e){let{inputs:t,backend:n}=e,{input:r}=t;return Lte(r,!1,n)}var Clt={kernelName:JC,backendName:"webgl",kernelFunc:Slt},Nlt=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function kw(e){let{backend:t,attrs:n}=e,{shape:r,value:s}=n,{dtype:a}=n;if(a=a||O.inferDtype(s),a==="string"){let i=O.getArrayFromDType(a,O.sizeFromShape(r));return i.fill(s),t.makeTensorInfo(r,a,i)}else{let i=new Nlt(r,s),o=[[s]];return t.runWebGLProgram(i,[],a,o)}}var Tlt={kernelName:E1,backendName:"webgl",kernelFunc:kw},$lt=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},Elt={kernelName:jy,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,s=new $lt(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},z6="return floor(x);",_lt=kn({opSnippet:z6,packedOpSnippet:z6,cpuKernelImpl:Hrt}),Alt={kernelName:gf,backendName:"webgl",kernelFunc:_lt},Rlt=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Dlt=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Flt=Js({opSnippet:Rlt,packedOpSnippet:Dlt,dtype:"int32"}),Olt={kernelName:yf,backendName:"webgl",kernelFunc:Flt},Mlt=class{constructor(e){this.variableNames=["A"];let t=La(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},Llt=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=La(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},Plt={kernelName:II,backendName:"webgl",kernelFunc:zlt},tg,ZE=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function zlt(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:s}=t,{numChannels:a}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,a];if(o||i){let g=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(tg==null||g!==ZE)&&(ZE=g,tg=document.createElement("canvas").getContext("2d",{willReadFrequently:ZE})),tg.canvas.width=l,tg.canvas.height=u,tg.drawImage(s,0,0,l,u),s=tg.canvas}let p=n.makeTensorInfo(c,"int32");n.texData.get(p.dataId).usage=Wi.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),s);let h=xe().getBool("WEBGL_PACK")?new Llt(d):new Mlt(d),m=n.runWebGLProgram(h,[p],"int32");return n.disposeData(p.dataId),m}function Blt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=r,g=V.convertConv2DDataFormat(c),y=V.computeConv2DInfo(s.shape,a.shape,l,d,u,p,!1,g),b,v=[],k=i!=null,I=o!=null,S=h==="leakyrelu",N=()=>{let A=[s,a],R=(D,$)=>{if($==="NCHW"&&D.shape.length===1&&D.shape[0]!==1){let _=rt({inputs:{x:D},backend:n,attrs:{shape:[D.shape[0],1,1]}});return v.push(_),_}return D};if(k&&A.push(R(i,c)),I&&A.push(R(o,c)),S){let D=n.makeTensorInfo([],"float32",O.createScalarValue(m,"float32"));A.push(D),v.push(D)}return A};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))b=Ate({x:s,filter:a,convInfo:y,backend:n,bias:i,activation:h,preluActivationWeights:o,leakyreluAlpha:m});else if(y.strideWidth<=2&&g==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){let A=h?Wv(h,!0):null,R=new _te(y,k,A,I,S),D=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],$=N();b=n.runWebGLProgram(R,$,"float32",D)}else if(xe().getBool("WEBGL_CONV_IM2COL"))b=Rte({x:s,filter:a,convInfo:y,backend:n,bias:i,activation:h,preluActivationWeights:o,leakyreluAlpha:m});else{let A=h?Wv(h,!1):null,R=new Ete(y,k,A,I,S),D=N();b=n.runWebGLProgram(R,D,"float32")}let T=rt({inputs:{x:b},backend:n,attrs:{shape:y.outShape}});return v.push(b),v.forEach(A=>n.disposeIntermediateTensorInfo(A)),T}var Wlt={kernelName:hh,backendName:"webgl",kernelFunc:Blt};function Vlt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:h}=r,m=[],g=c;g==null&&(g=[1,1]),O.assert(V.eitherStridesOrDilationsAreOne(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);let y=V.computeConv2DInfo(s.shape,a.shape,l,g,u,d,!0),b=xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,v=p?Wv(p,b):null,k=[s,a],I=i!=null,S=o!=null,N=p==="leakyrelu";if(I&&k.push(i),S&&k.push(o),N){let D=n.makeTensorInfo([],"float32",O.createScalarValue(h,"float32"));k.push(D),m.push(D)}let T;b?T=new Ote(y,I,v,S,N):T=new Fte(y,I,v,S,N);let A=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],R=n.runWebGLProgram(T,k,"float32",A);return m.forEach(D=>n.disposeIntermediateTensorInfo(D)),R}var Ult={kernelName:fh,backendName:"webgl",kernelFunc:Vlt},Glt=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let s=tr(n.length),a=`
    int index;`;for(let i=0;i<this.sliceDim;i++)a+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function jlt(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=O.sizeFromShape(r.shape),[l,u,c,d]=V.prepareAndValidate(r,s),p=rt({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),h=rt({inputs:{x:r},backend:n,attrs:{shape:[O.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let b=n.readSync(s.dataId),v=n.bufferSync(r),k=qrt(b,v,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,k.values)}let m=new Glt(i,d,[u,c],r.shape),g=n.runWebGLProgram(m,[h,p],h.dtype),y=rt({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),y}var Hlt={kernelName:qy,backendName:"webgl",kernelFunc:jlt},qlt=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=tr(this.rank),r=Klt(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function Klt(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}function Pte(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=O.parseAxisParam(i,s.shape)[0];if(xe().get("DEBUG")){let v=n.readSync(a.dataId),k=s.shape[l];for(let I=0;I<v.length;++I){let S=v[I];O.assert(S<=k-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${k-1}]`)}}let u=V.segment_util.collectGatherOpShapeInfo(s,a,l,o),c=O.sizeFromShape(a.shape),d=[],p=rt({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),h=rt({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(p),d.push(h);let m=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||s.dtype==="string"){let v=n.bufferSync(h),k=n.bufferSync(p),I=Krt(k,v,m);return d.forEach(S=>n.disposeIntermediateTensorInfo(S)),n.makeTensorInfo(u.outputShape,I.dtype,I.values)}let g=new qlt(p.shape,m),y=n.runWebGLProgram(g,[p,h],p.dtype);d.push(y);let b=rt({inputs:{x:y},backend:n,attrs:{shape:u.outputShape}});return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),b}var Xlt={kernelName:Hy,backendName:"webgl",kernelFunc:Pte},Ylt="return float(a > b);",Zlt=`
  return vec4(greaterThan(a, b));
`,Jlt=Js({opSnippet:Ylt,packedOpSnippet:Zlt,cpuKernelImpl:Xrt,dtype:"bool"}),Qlt={kernelName:Ky,backendName:"webgl",kernelFunc:Jlt},eut="return float(a >= b);",tut=`
  return vec4(greaterThanEqual(a, b));
`,nut=Js({opSnippet:eut,packedOpSnippet:tut,dtype:"bool",cpuKernelImpl:Yrt}),rut={kernelName:bf,backendName:"webgl",kernelFunc:nut};function sut(e){let{inputs:t,backend:n}=e,{input:r}=t;return Lte(r,!0,n)}var aut={kernelName:QC,backendName:"webgl",kernelFunc:sut},iut="return float(!isnan(x) && !isinf(x));",out=kn({opSnippet:iut,dtype:"bool"}),lut={kernelName:wf,backendName:"webgl",kernelFunc:out},uut="return float(isinf(x));",cut=kn({opSnippet:uut,dtype:"bool"}),dut={kernelName:kf,backendName:"webgl",kernelFunc:cut},put="return float(isnan(x));",hut=kn({opSnippet:put,dtype:"bool"}),fut={kernelName:If,backendName:"webgl",kernelFunc:hut},mut="return float(a < b);",gut=`
  return vec4(lessThan(a, b));
`,yut=Js({opSnippet:mut,packedOpSnippet:gut,cpuKernelImpl:Zrt,dtype:"bool"}),xut={kernelName:Xy,backendName:"webgl",kernelFunc:yut},but="return float(a <= b);",vut=`
  return vec4(lessThanEqual(a, b));
`,wut=Js({opSnippet:but,packedOpSnippet:vut,cpuKernelImpl:Jrt,dtype:"bool"}),kut={kernelName:Yy,backendName:"webgl",kernelFunc:wut};function Iut(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=Qrt(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}var Sut={kernelName:Zy,backendName:"webgl",kernelFunc:Iut},Cut=qx+`
  return x < 0.0 ? 0./0. : log(x);
`,Nut=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Tut=kn({opSnippet:Cut,packedOpSnippet:Nut,cpuKernelImpl:est}),$ut={kernelName:Cf,backendName:"webgl",kernelFunc:Tut},Eut=qx+`
  return log(1.0 + x);
`,_ut=kn({opSnippet:Eut}),Aut={kernelName:Nf,backendName:"webgl",kernelFunc:_ut},Rut="return float(a >= 1.0 && b >= 1.0);",Dut=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Fut=Js({opSnippet:Rut,packedOpSnippet:Dut,dtype:"bool"}),Out={kernelName:Jy,backendName:"webgl",kernelFunc:Fut},Mut="return float(!(x >= 1.0));",Lut=kn({opSnippet:Mut}),Put={kernelName:Qy,backendName:"webgl",kernelFunc:Lut},zut="return float(a >= 1.0 || b >= 1.0);",But=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Wut=Js({opSnippet:zut,packedOpSnippet:But,dtype:"bool"}),Vut={kernelName:ex,backendName:"webgl",kernelFunc:Wut},Uut=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];let a=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;s===.5?o=`inversesqrt(${l})`:s===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},Gut=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;s===.5?o=`inversesqrt(${l})`:s===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},jut=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=xe().getBool("WEBGL_PACK_NORMALIZATION")?new Gut(s.shape,a,i,o,l):new Uut(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)},Hut={kernelName:Tf,backendName:"webgl",kernelFunc:jut},qut=class{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},Kut=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new qut(s.shape,o,l,u,c);return n.runWebGLProgram(d,[s,a,i],s.dtype)},Xut={kernelName:tx,backendName:"webgl",kernelFunc:Kut};function Yut(e,t,n,r){let s=O.sizeFromShape(t),a=O.sizeFromShape(e.shape)/s,i=rt({inputs:{x:e},attrs:{shape:[a,s]},backend:r}),o=bm(i,e.dtype,"max",r),l=rt({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}function zte(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=O.parseAxisParam(a,s.shape),u=l,c=V.getAxesPermutation(u,o),d=c!=null,p=n.shouldExecuteOnCPU([s]),h=s;if(d){if(p){let v=n.texData.get(h.dataId).values,k=new Array(o);for(let N=0;N<k.length;N++)k[N]=s.shape[c[N]];let I=cP(v,s.shape,s.dtype,c,k);h=n.makeTensorInfo(k,s.dtype);let S=n.texData.get(h.dataId);S.values=I}else h=pT(s,c,n);u=V.getInnerMostAxes(u.length,o)}V.assertAxesAreInnerMostDims("max",u,o);let[m,g]=V.computeOutAndReduceShapes(h.shape,u),y=m;i&&(y=V.expandShapeToKeepDim(m,l));let b;if(p){let v=n.texData.get(h.dataId).values,k=tst(v,O.sizeFromShape(g),y,s.dtype);b=n.makeTensorInfo(y,s.dtype);let I=n.texData.get(b.dataId);I.values=k}else b=Yut(h,g,y,n);return d&&n.disposeIntermediateTensorInfo(h),b}var Zut={kernelName:$f,backendName:"webgl",kernelFunc:zte},Jut=pP+`
  return max(a, b);
`,Qut=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xm+`
  return result;
`,ect=Js({opSnippet:Jut,packedOpSnippet:Qut,cpuKernelImpl:nst}),tct={kernelName:Ef,backendName:"webgl",kernelFunc:ect};function nct(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Wx(s,"maxPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;O.assert(V.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=V.computePool2DInfo(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&O.arraysEqual(c.inShape,c.outShape))return $i({inputs:{x:s},backend:n});let d=new Vv(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}var rct={kernelName:_f,backendName:"webgl",kernelFunc:nct};function sct(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],d=V.computePool3DInfo(s.shape,a,i,c,o,u,l),p=new fP(d,"max",!1);return n.runWebGLProgram(p,[s],s.dtype)}var act={kernelName:nx,backendName:"webgl",kernelFunc:sct},ict=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,l=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},oct=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,p=u-1-e.padInfo.left,h=o*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function lct(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],p=V.computePool3DInfo(i.shape,o,l,d,u,c),h=new fP(p,"max",!0),m=n.runWebGLProgram(h,[i],i.dtype),g=new oct(p),y=n.runWebGLProgram(g,[s,m],i.dtype);return n.disposeIntermediateTensorInfo(m),y}var uct={kernelName:A1,backendName:"webgl",kernelFunc:lct};function cct(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;Wx([a,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,p=V.computePool2DInfo(o.shape,l,u,1,c,d),h=!0,m=new Vv(p,"max",h),g=n.runWebGLProgram(m,[o],o.dtype),y=new ict(p),b=n.runWebGLProgram(y,[s,g],o.dtype);return n.disposeIntermediateTensorInfo(g),b}var dct={kernelName:_1,backendName:"webgl",kernelFunc:cct};function pct(e,t,n,r){let s=new Vv(n,"max",!1),a=r.runWebGLProgram(s,[e],"float32");s=new Vv(n,"max",!0,!0,t);let i=r.runWebGLProgram(s,[e],"float32");return[a,i]}var hct={kernelName:R1,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;O.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];O.assert(V.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=V.computePool2DInfo(r.shape,s,a,u,i),[d,p]=pct(r,o,c,l);return[d,p]}};function fct(e,t,n,r){let s=O.sizeFromShape(t),a=O.sizeFromShape(e.shape)/s,i=rt({inputs:{x:e},attrs:{shape:[a,s]},backend:r}),o=bm(i,"float32","mean",r),l=rt({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}var mct={kernelName:Af,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,l=O.parseAxisParam(a,r.shape),u=l,c=V.getAxesPermutation(u,o),d=c!=null,p=i.shouldExecuteOnCPU([r]),h=[],m=r;if(d){if(p){let k=i.texData.get(m.dataId).values,I=new Array(o);for(let T=0;T<I.length;T++)I[T]=r.shape[c[T]];let S=cP(k,r.shape,r.dtype,c,I);m=i.makeTensorInfo(I,r.dtype);let N=i.texData.get(m.dataId);N.values=S}else m=pT(r,c,i);h.push(m),u=V.getInnerMostAxes(u.length,o)}V.assertAxesAreInnerMostDims("sum",u,o);let[g,y]=V.computeOutAndReduceShapes(m.shape,u),b=g;s&&(b=V.expandShapeToKeepDim(g,l));let v=fct(m,y,b,i);for(let k of h)i.disposeIntermediateTensorInfo(k);return v}};function gct(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=O.parseAxisParam(a,s.shape),u=l,c=V.getAxesPermutation(u,o),d=s;c!=null&&(d=Aa({inputs:{x:s},backend:n,attrs:{perm:c}}),u=V.getInnerMostAxes(u.length,s.shape.length)),V.assertAxesAreInnerMostDims("min",u,o);let[p,h]=V.computeOutAndReduceShapes(d.shape,u),m=O.sizeFromShape(h),g=rt({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=bm(g,g.dtype,"min",n),b;if(i){let v=V.expandShapeToKeepDim(p,l);b=rt({inputs:{x:y},backend:n,attrs:{shape:v}})}else b=rt({inputs:{x:y},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),c!=null&&n.disposeIntermediateTensorInfo(d),b}var yct={kernelName:Rf,backendName:"webgl",kernelFunc:gct},xct=pP+`
  return min(a, b);
`,bct=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xm+`
  return result;
`,vct=Js({opSnippet:xct,packedOpSnippet:bct,cpuKernelImpl:rst}),wct={kernelName:Df,backendName:"webgl",kernelFunc:vct},kct=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);let r=e.length,s=tr(r),a=t.map(u=>u[0]).join(","),i=t.map((u,c)=>u[0]+e[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},Ict=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((h,m)=>h[0]+e[m]+h[1]);let r=e.length,s=tr(r),a=t.map(h=>h[0]).join(","),i=t.map((h,m)=>h[0]+e[m]).join(","),o=Na("rc",r),l=Na("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${l.slice(-2).join()})`,d=n==="reflect"?0:1,p="";if(r===1){let h=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${o[r-1]} += 1;
        if(${u}) {
          ${h}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
      `}else{let h=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${o[r-1]} += 1;
        if(${u}) {
          ${h}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
        rc = outputLoc;
        ${o[r-2]} += 1;
        if(${o[r-2]} < ${this.outputShape[r-2]}) {
          ${h}
          result[2] = getChannel(getX(${l.join()}), ${c});
          ${o[r-1]} += 1;
          if(${u}) {
            ${h}
            result[3] = getChannel(getX(${l.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}},Sct=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:s,mode:a}=n,i=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ict(r.shape,s,a):new kct(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)},Cct={kernelName:Ff,backendName:"webgl",kernelFunc:Sct},Nct=`if (b == 0.0) return NAN;
  return mod(a, b);`,Tct=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+xm+`
  return result;
`,$ct=Js({opSnippet:Nct,packedOpSnippet:Tct}),Ect={kernelName:Of,backendName:"webgl",kernelFunc:$ct},_ct=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},Act=`
if (a == b) {
  return 1.0;
};
return a / b;`,Rct=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Bte=Js({opSnippet:Act,packedOpSnippet:Rct,checkOutOfBounds:!0}),Dct={kernelName:df,backendName:"webgl",kernelFunc:Bte},B6="return a - b;",Wte=Js({opSnippet:B6,packedOpSnippet:B6,supportsComplex:!0,cpuKernelImpl:Sst}),Fct={kernelName:im,backendName:"webgl",kernelFunc:Wte};function Vte(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=O.parseAxisParam([a],s.shape),o=zte({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=V.expandShapeToKeepDim(o.shape,i),u=rt({inputs:{x:o},backend:n,attrs:{shape:l}}),c=Wte({inputs:{a:s,b:u},backend:n}),d=Mte({inputs:{x:c},backend:n}),p=hT({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),h=rt({inputs:{x:p},backend:n,attrs:{shape:l}}),m=Bte({inputs:{a:d,b:h},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),m}var Oct={kernelName:sm,backendName:"webgl",kernelFunc:Vte};function Mct(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:Vte({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new _ct(u,c,a),p=[[i]],h=n.runWebGLProgram(d,[l],"int32",p);return o||n.disposeIntermediateTensorInfo(l),h}var Lct={kernelName:rx,backendName:"webgl",kernelFunc:Mct},Pct=Eo+`
  return -x;
`,zct=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Bct(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let a=n.texData.get(r.dataId),[i,o]=ast(a.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let s;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Bc(r.shape,zct):s=new Bl(r.shape,Pct),n.runWebGLProgram(s,[r],r.dtype)}var Wct={kernelName:sx,backendName:"webgl",kernelFunc:Bct},Vct=du.nonMaxSuppressionV3Impl;function Uct(e){V.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=Vct(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var Gct={kernelName:ix,backendName:"webgl",kernelFunc:Uct},jct=du.nonMaxSuppressionV4Impl;function Hct(e){V.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),{selectedIndices:p,validOutputs:h}=jct(c,d,i,o,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var qct={kernelName:ox,backendName:"webgl",kernelFunc:Hct},Kct=du.nonMaxSuppressionV5Impl;function Xct(e){V.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),p=i,h=o,m=l,g=u,{selectedIndices:y,selectedScores:b}=Kct(c,d,p,h,m,g);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var Yct={kernelName:lx,backendName:"webgl",kernelFunc:Xct},Zct=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},Jct=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=O.sizeFromShape(s.shape),c=new Zct(u,i,o,l),d=rt({inputs:{x:s},backend:n,attrs:{shape:[u]}}),p=n.runWebGLProgram(c,[d],a);n.disposeIntermediateTensorInfo(d);let h=[...s.shape,i],m=rt({inputs:{x:p},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(p),m},Qct={kernelName:Lf,backendName:"webgl",kernelFunc:Jct};function HI(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let s=ww({inputs:{input:r},backend:n}),a=HI({inputs:{x:s},backend:n}),i=fT({inputs:{input:r},backend:n}),o=HI({inputs:{x:i},backend:n}),l=Wd({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return kw({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var edt={kernelName:Tx,backendName:"webgl",kernelFunc:HI};function Ute(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let s=ww({inputs:{input:r},backend:n}),a=Ute({inputs:{x:s},backend:n}),i=fT({inputs:{input:r},backend:n}),o=HI({inputs:{x:i},backend:n}),l=Wd({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return kw({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var tdt={kernelName:ux,backendName:"webgl",kernelFunc:Ute};function ndt(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return pR({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,i=t[0].dtype;t.forEach(c=>{O.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),O.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(c=>{let d=pR({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=$te({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var rdt={kernelName:cx,backendName:"webgl",kernelFunc:ndt},sdt=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,u)=>l[0]+e[u]+l[1]);let r=e.length,s=tr(r),a=t.map(l=>l[0]).join(","),i=t.map((l,u)=>l[0]+e[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},adt=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,g)=>m[0]+e[g]+m[1]);let r=e.length,s=tr(r),a=t.map(m=>m[0]).join(","),i=t.map((m,g)=>m[0]+e[g]).join(","),o=Na("rc",r),l=Na("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;
       if(${u}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${o[r-2]} += 1;
       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${o[r-1]} += 1;
         if(${u}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let m=0,g=r===1?2:4;m<g;m++)h+=`
        ${d[m]}
        if (${p}) {
          result[${m}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${m}] = getChannel(getX(${l.join()}), ${c});
        }
      `;h+=r===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}},Gte=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(O.sizeFromShape(s.shape)===0){let u=a.map((c,d)=>c[0]+s.shape[d]+c[1]);return kw({backend:n,attrs:{shape:u,value:i,dtype:s.dtype}})}let o=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new adt(s.shape,a,i):new sdt(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},idt={kernelName:Pf,backendName:"webgl",kernelFunc:Gte},odt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,ldt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+xm+`
  return result;
`,udt=Js({opSnippet:odt,packedOpSnippet:ldt}),cdt={kernelName:zf,backendName:"webgl",kernelFunc:udt};function ddt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=O.parseAxisParam(a,s.shape),c=u,d=V.getAxesPermutation(c,o),p=s;d!=null&&(p=Aa({inputs:{x:s},backend:n,attrs:{perm:d}}),c=V.getInnerMostAxes(c.length,o),l.push(p)),V.assertAxesAreInnerMostDims("prod",c,o);let h;if(n.shouldExecuteOnCPU([p])){let m=n.texData.get(p.dataId).values,{outVals:g,outShape:y,outDtype:b}=ost(p.shape,p.dtype,m,c);h=n.makeTensorInfo(y,b,g)}else{let[m,g]=V.computeOutAndReduceShapes(p.shape,c),y=O.sizeFromShape(g),b=rt({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),v=iN(s.dtype),k=bm(b,v,"prod",n);h=rt({inputs:{x:k},backend:n,attrs:{shape:m}}),l.push(b),l.push(k)}if(i){l.push(h);let m=V.expandShapeToKeepDim(h.shape,u);h=rt({inputs:{x:h},backend:n,attrs:{shape:m}})}return l.forEach(m=>n.disposeIntermediateTensorInfo(m)),h}var pdt={kernelName:Wf,backendName:"webgl",kernelFunc:ddt};function hdt(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map(b=>n.readSync(b.dataId)),u=s.map(b=>b.shape),c=n.readSync(a.dataId),d=n.readSync(i.dataId),[p,h,m]=lst(l,u,c,a.shape,a.dtype,d,i.shape,o),g=p.map(b=>n.makeTensorInfo([b.length],"int32",b)),y=n.makeTensorInfo(m,a.dtype,h);return g.concat([y])}var fdt={kernelName:tN,backendName:"webgl",kernelFunc:hdt};function mdt(e){let{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=ust(i,r.shape,r.dtype,o,s.shape,l,a.shape),d=n.makeTensorInfo([u.length],"int32",u),p=n.makeTensorInfo([c.length],r.dtype,c);return[d,p]}var gdt={kernelName:nN,backendName:"webgl",kernelFunc:mdt};function ydt(e){let{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),d=n.readSync(i.dataId),p=o.map(y=>n.readSync(y.dataId)),h=o.map(y=>y.shape),[m,g]=cst(u,s.shape,c,a.shape,a.dtype,d,i.shape,p,h,l);return n.makeTensorInfo(m,a.dtype,g)}var xdt={kernelName:rN,backendName:"webgl",kernelFunc:ydt},jte=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=dst(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},bdt={kernelName:D1,backendName:"webgl",kernelFunc:jte},vdt="return 1.0 / x;",wdt=kn({opSnippet:vdt}),kdt={kernelName:Vf,backendName:"webgl",kernelFunc:wdt},Idt=Eo+`
  return (x < 0.0) ? 0.0 : x;
`,Sdt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Cdt=kn({opSnippet:Idt,packedOpSnippet:Sdt}),Ndt={kernelName:Uf,backendName:"webgl",kernelFunc:Cdt},Tdt=Eo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,$dt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Edt=kn({opSnippet:Tdt,packedOpSnippet:$dt}),_dt={kernelName:Hf,backendName:"webgl",kernelFunc:Edt},Adt=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[a,i,o,l]=e;this.outputShape=[a,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;s?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},Rdt=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,o,l]=e;this.outputShape=[a,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;s?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/c[0]},
          ${u[1]/c[1]},
          ${u[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function Ddt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Rdt(s.shape,l,u,a,i):new Adt(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}var Fdt={kernelName:jf,backendName:"webgl",kernelFunc:Ddt},Odt=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,p=1/c,h=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${h});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Mdt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Odt(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}var Ldt={kernelName:hx,backendName:"webgl",kernelFunc:Mdt},Pdt=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[a,i,o,l]=e;this.outputShape=[a,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0",p;s?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},zdt=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,o,l]=e;this.outputShape=[a,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0",p;s?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/c[0]},
          ${u[1]/c[1]},
          ${u[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Bdt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new zdt(s.shape,l,u,a,i):new Pdt(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}var Wdt={kernelName:Gf,backendName:"webgl",kernelFunc:Bdt},Vdt=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,p=1/c,h=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${h});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Udt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Vdt(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}var Gdt={kernelName:px,backendName:"webgl",kernelFunc:Udt},jdt=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,s=e.map((i,o)=>r(o)).join(","),a=tr(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}},Hdt=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=Na("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=tr(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(r.slice())};
          if(${s}){
            result.g = ${l(r.slice())};
          }
          if(${a}) {
            result.b = ${u(r.slice())};
            if(${s}) {
              result.a = ${c(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(h){return d(h)}function l(h){return h[n-1]="("+h[n-1]+" + 1)",d(h)}function u(h){return h[n-2]="("+h[n-2]+" + 1)",d(h)}function c(h){return h[n-1]="("+h[n-1]+" + 1)",h[n-2]="("+h[n-2]+" + 1)",d(h)}function d(h){let m=e.map((b,v)=>p(v,h)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function p(h,m){return t.indexOf(h)!==-1&&e[h]!==1?`${e[h]} - ${m[h]} - 1`:`${m[h]}`}}};function qdt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=O.parseAxisParam(a,s.shape);if(i===0)return $i({inputs:{x:s},backend:n});let l=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Hdt(s.shape,o):new jdt(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}var Kdt={kernelName:qf,backendName:"webgl",kernelFunc:qdt},Xdt=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},Ydt={kernelName:$x,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=new Xdt(r.shape,a),[u,c]=V.getImageCenter(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(l,[r],r.dtype,d)}},Zdt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Jdt=kn({opSnippet:Zdt}),Qdt={kernelName:Kf,backendName:"webgl",kernelFunc:Jdt},ept="return inversesqrt(x);",tpt=kn({opSnippet:ept,cpuKernelImpl:pst}),npt={kernelName:Xf,backendName:"webgl",kernelFunc:tpt},mP=class{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;let l=tr(s.length),u=tr(a.length),c="";n===1?c="i":n===2&&(c="i, j");let d=`getIndices(${c})`,p="";r===1?p="i":r===2&&(p="i, coords[1]");let h=`getUpdates(${p})`,m="";o&&(m="coords[0], coords[1]");let g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}},rpt=class{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;let l=tr(s.length),u=tr(a.length),c="";n===1?c="i":n===2&&(c="i, j");let d=`getIndices(${c})`,p="";r===1?p="i":r===2&&(p="i, coords[1]");let h=`getUpdates(${p})`,m="";o&&(m="coords[0], coords[1]");let g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${h};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}};function spt(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=V.calculateShapes(a,s,i),p=[d/u,u];if(d===0)return n.makeTensorInfo(i,s.dtype);let h=rt({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),m=rt({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0])),y;xe().getBool("WEBGL_PACK")?y=new rpt(l,o,h.shape.length,m.shape.length,c,p):y=new mP(l,o,h.shape.length,m.shape.length,c,p);let b=n.runWebGLProgram(y,[m,h,g],m.dtype),v=rt({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),v}var apt={kernelName:fx,backendName:"webgl",kernelFunc:spt},ipt=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let s="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=xe().getNumber("WEBGL_VERSION")===2?s:a,o=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function opt(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new ipt(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}var lpt={kernelName:gx,backendName:"webgl",kernelFunc:opt},upt=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",r="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let u=0;u<t.length;u++)l.push(`${i[u]}`),u<e&&o.push(`${i[u]}`);r=o.join(),s=l.join()}let a=tr(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function cpt(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new upt(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],Ki(s.dtype,a.dtype))}var dpt={kernelName:yx,backendName:"webgl",kernelFunc:cpt},ppt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${V.SELU_SCALEALPHA};
  float scale = ${V.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,hpt=kn({opSnippet:ppt}),fpt={kernelName:Yf,backendName:"webgl",kernelFunc:hpt},mpt=qx+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,gpt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ypt=kn({opSnippet:mpt,packedOpSnippet:gpt,cpuKernelImpl:fst}),xpt={kernelName:em,backendName:"webgl",kernelFunc:ypt},bpt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,vpt=kn({opSnippet:bpt}),wpt={kernelName:Qf,backendName:"webgl",kernelFunc:vpt},kpt=qx+`
  return sin(x);
`,Ipt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${xm}
  return result;
`,Spt=kn({opSnippet:kpt,packedOpSnippet:Ipt}),Cpt={kernelName:Zf,backendName:"webgl",kernelFunc:Spt},Npt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Tpt=kn({opSnippet:Npt}),$pt={kernelName:Jf,backendName:"webgl",kernelFunc:Tpt},Ept=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,_pt=kn({opSnippet:Ept}),Apt={kernelName:tm,backendName:"webgl",kernelFunc:_pt},Rpt=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;O.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=a.reduce((b,v)=>b*v),l=[[0,0]];l.push(...i);for(let b=1+a.length;b<s.shape.length;++b)l.push([0,0]);let u=[],c=Gte({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=V.getReshaped(c.shape,a,o,!1),p=V.getPermuted(d.length,a.length,!1),h=V.getReshapedPermuted(c.shape,a,o,!1),m=rt({inputs:{x:c},backend:n,attrs:{shape:d}}),g=Aa({inputs:{x:m},backend:n,attrs:{perm:p}}),y=rt({inputs:{x:g},backend:n,attrs:{shape:h}});return u.push(c),u.push(m),u.push(g),u.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},Dpt={kernelName:bx,backendName:"webgl",kernelFunc:Rpt};function Fpt(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[d,p,h,m,g]=gst(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(p,r.dtype,d),n.makeTensorInfo([p[0]],s.dtype,h),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(y=>Number(y)))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}var Opt={kernelName:F1,backendName:"webgl",kernelFunc:Fpt};function Mpt(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,d]=yst(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var Lpt={kernelName:wx,backendName:"webgl",kernelFunc:Mpt};function Ppt(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);let i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=hte(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var zpt={kernelName:O1,backendName:"webgl",kernelFunc:Ppt};function Bpt(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);let i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=hte(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}var Wpt={kernelName:M1,backendName:"webgl",kernelFunc:Bpt};function Vpt(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=V.calculateShapes(a,s,o),h=!1;if(a.dtype==="string"){let b=n.bufferSync(s),v=n.bufferSync(a),k=O.decodeString(n.readSync(i.dataId)[0]),I=hst(b,v,o,p,c,u,l,d,k,h);return n.makeTensorInfo(o,I.dtype,I.values)}let m=new mP(u,l,s.shape.length,a.shape.length,d,[p,1],h),g=n.runWebGLProgram(m,[a,s,i],a.dtype),y=rt({inputs:{x:g},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(g),y}var Upt={kernelName:kx,backendName:"webgl",kernelFunc:Vpt};function Gpt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=O.parseAxisParam(i,s.shape)[0],l=V.prepareSplitSize(s,a,o),u=s.shape.length,c=new Array(u).fill(0),d=s.shape.slice();return l.map(p=>{let h=[...d];h[o]=p;let m=Kx({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});return c[o]+=p,m})}var jpt={kernelName:vx,backendName:"webgl",kernelFunc:Gpt},W6="return sqrt(x);",Hpt=kn({opSnippet:W6,packedOpSnippet:W6,cpuKernelImpl:xst}),qpt={kernelName:nm,backendName:"webgl",kernelFunc:Hpt},Kpt="return x * x;",Xpt=kn({opSnippet:Kpt}),Ypt={kernelName:L1,backendName:"webgl",kernelFunc:Xpt},V6="return (a - b) * (a - b);",Zpt=Js({opSnippet:V6,packedOpSnippet:V6}),Jpt={kernelName:am,backendName:"webgl",kernelFunc:Zpt};function Qpt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");let a=n.readSync(s.dataId),i=V.fromUint8ToStringArray(a),o=bst(i,"string",r);return n.makeTensorInfo(s.shape,"string",o)}var eht={kernelName:P1,backendName:"webgl",kernelFunc:Qpt};function tht({inputs:e,attrs:t,backend:n}){let{x:r}=e,s=Eo+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new Bl(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}var nht={kernelName:Fd,backendName:"webgl",kernelFunc:tht},rht=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,s=tr(n.length),a=tr(n.length),i="";if(r===1)i="coords * strides + begin";else{let o=0;i=n.map((l,u)=>(o++,n.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${o-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function sht(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=r,{finalShapeSparse:h,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:k,strides:I}=fs.sliceInfo(s.shape,a,i,o,l,u,c,d,p),S;if(g)S=rt({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){O.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let T=fs.computeOutShape(v,k,I),A=Kx({inputs:{x:s},backend:n,attrs:{begin:v,size:T}});S=rt({inputs:{x:A},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(A)}else if(n.shouldExecuteOnCPU([s])){let T=n.readSync(s.dataId),A=tn(s.shape,s.dtype,T),R=vst(h,A,I,v);S=n.makeTensorInfo(m,s.dtype,R.values)}else{let T=new rht(v,I,h);S=n.runWebGLProgram(T,[s],s.dtype)}let N=rt({inputs:{x:S},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(S),N}var aht={kernelName:Ix,backendName:"webgl",kernelFunc:sht};function iht(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,p=n.readSync(c.dataId),h=n.readSync(d.dataId),[m,g]=wst(p,h,s,a,i,o,l,u);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(d.shape,"int32",g)]}var oht={kernelName:z1,backendName:"webgl",kernelFunc:iht};function lht(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=kst(o,l,s),p=c.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var uht={kernelName:B1,backendName:"webgl",kernelFunc:lht};function cht(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(a.dataId),o=Ist(i,s);return n.makeTensorInfo(a.shape,"int32",o)}var dht={kernelName:W1,backendName:"webgl",kernelFunc:cht},pht="return tan(x);",hht=kn({opSnippet:pht}),fht={kernelName:om,backendName:"webgl",kernelFunc:hht},mht=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,ght=kn({opSnippet:mht}),yht={kernelName:lm,backendName:"webgl",kernelFunc:ght};function xht(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=V.calculateShapes(i,a,s.shape),p=[d/u,u];if(d===0)return n.makeTensorInfo(s.shape,a.dtype);let h=rt({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),m=rt({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),g=rt({inputs:{x:s},backend:n,attrs:{shape:p}}),y=new mP(l,o,h.shape.length,m.shape.length,c,p,!1,!0),b=n.runWebGLProgram(y,[m,h,g],g.dtype),v=rt({inputs:{x:b},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),v}var bht={kernelName:mx,backendName:"webgl",kernelFunc:xht},vht=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;let r=tr(this.rank),s=wht(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function wht(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}function Hte(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if(s.dtype==="string"||s.shape.length>5){let o=n.readSync(s.dataId),l=s.dtype==="string"?o.map(d=>O.decodeString(d)):o,u=tn(s.shape,s.dtype,l),c=Cst(u,a);return n.makeTensorInfo(c.shape,c.dtype,c.values)}let i=new vht(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}var kht={kernelName:Dd,backendName:"webgl",kernelFunc:Hte},Iht=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Sht=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function xp(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function U6(e){let t=1;for(;t<e;)t*=2;return t}function Cht(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=xe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=xe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){let R=n.readSync(s.dataId),[D,$]=Nst(R,u,s.dtype,a,i);return[n.makeTensorInfo(D.shape,D.dtype,D.values),n.makeTensorInfo($.shape,$.dtype,$.values)]}if(a===0)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[s,kw({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let d=n.texData.get(s.dataId),p=d!==null&&d.isPacked,h=p?n.unpackTensor(s):s,m=O.sizeFromShape(u)/c,g=rt({inputs:{x:h},attrs:{shape:[m,c]},backend:n});p&&xp(n,h);let y=U6(a),b=U6(c),v=null,k=()=>v===null?[g,g]:[g,v],I=(R,D,$)=>{let _=k(),L=new Iht($),z=[[c],[v===null?1:0],[Number.NEGATIVE_INFINITY],[R],[D]],W=v;v=n.runWebGLProgram(L,_,"int32",z),xp(n,W)};for(let R=1;R<y;R*=2){let D=R*2;for(let $=R;$>=1;$/=2)I(D,$,[m,b])}for(let R=b;R>y;R/=2){let D=k(),$=new Sht([m,R/2]),_=[[c],[v===null?1:0],[y]],L=v;v=n.runWebGLProgram($,D,"int32",_),xp(n,L);let z=y/2,W=z*2;for(let G=z;G>=1;G/=2)I(W,G,v.shape)}let S=v;v=Kx({inputs:{x:v},backend:n,attrs:{begin:0,size:[m,a]}}),xp(n,S);let N=Pte({inputs:{x:g,indices:v},backend:n,attrs:{axis:1,batchDims:1}});xp(n,g);let T=u.slice(0,-1);T.push(a),S=v,v=rt({inputs:{x:v},attrs:{shape:T},backend:n}),xp(n,S);let A=N;return N=rt({inputs:{x:N},attrs:{shape:T},backend:n}),xp(n,A),[N,v]}var Nht={kernelName:Sx,backendName:"webgl",kernelFunc:Cht},Tht=class{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;let i=n==="nearest"?1:2,o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function $ht(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,p,h]=s.shape,[m,g]=u??[d,p],y=[c,m,g,h],b=new Tht(d,p,i,o,l,y);return n.runWebGLProgram(b,[s,a],"float32")}var Eht={kernelName:Cx,backendName:"webgl",kernelFunc:$ht};function _ht(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;Wx(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=Tst(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var Aht={kernelName:V1,backendName:"webgl",kernelFunc:_ht};function Rht(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1),c=0;for(let g=0;g<o;g++)g!==a&&(u[c++]=i.shape[g]);let d=[],p=new Array(o).fill(0),h=i.shape.slice();h[a]=1;let m=new Array(l);for(let g=0;g<m.length;g++){p[a]=g;let y=Kx({inputs:{x:i},backend:n,attrs:{begin:p,size:h}}),b=rt({inputs:{x:y},backend:n,attrs:{shape:u}});m[g]=b,d.push(y)}return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}var Dht={kernelName:Nx,backendName:"webgl",kernelFunc:Rht},Fht=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];let o="0.0",l="sumValue",u=Math.floor(n/4)*4,c=n%4,d=`
        sumValue += dot(values, segFilter);
    `,p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let h="";s%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function Oht(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[],u=0,c=V.getAxesPermutation([u],o),d=s;c!=null&&(d=Aa({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(d),u=V.getInnerMostAxes(1,o)[0]);let p=V.segment_util.computeOutShape(d.shape,u,i),h=O.sizeFromShape([d.shape[u]]),m=rt({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}});l.push(m);let g=iN(s.dtype),y=(I,S,N,T,A)=>{let R=I.shape[0],D=I.shape[1],$=V.segment_util.segOpComputeOptimalWindowSize(D,A),_={windowSize:$,inSize:D,batchSize:R,numSegments:A},L=new Fht(_,S),z=n.compileAndRun(L,[I,N],T);if(l.push(z),z.shape[1]===A)return z;let W=jte({backend:n,attrs:{start:0,stop:A,step:1,dtype:"float32"}}),G=Hte({inputs:{x:W},backend:n,attrs:{reps:[D/$]}});return l.push(W),l.push(G),y(z,S,G,T,A)},b=y(m,"unsortedSegmentSum",a,g,i),v=rt({inputs:{x:b},backend:n,attrs:{shape:p}}),k=v;if(c!=null){l.push(v);let I=V.getUndoAxesPermutation(c);k=Aa({inputs:{x:k},backend:n,attrs:{perm:I}})}return l.forEach(I=>n.disposeIntermediateTensorInfo(I)),k}var Mht={kernelName:U1,backendName:"webgl",kernelFunc:Oht},Lht=[vat,kat,Cat,$at,_at,Dat,Oat,Lat,Wat,Uat,Hat,Xat,Jat,nit,ait,oit,uit,hit,mit,yit,wit,$it,_it,Fit,Mit,Vit,Git,Kit,rat,Zit,not,iot,pot,mot,yot,bot,wot,Cot,$ot,Aot,Dot,Oot,Lot,Bot,Vot,Hot,Kot,Zot,elt,nlt,ilt,clt,flt,ylt,vlt,wlt,Ilt,Clt,Tlt,Elt,Alt,Olt,Plt,Wlt,Ult,Hlt,Xlt,Qlt,rut,nat,aut,eot,lut,dut,fut,aat,xut,kut,Sut,$ut,Aut,Out,Put,Vut,Hut,Xut,Zut,tct,rct,act,uct,dct,hct,mct,yct,wct,Cct,Ect,Lct,lat,Wct,Gct,qct,Yct,Pit,Qct,tdt,rdt,idt,cdt,oat,pdt,fdt,gdt,xdt,bdt,zit,Dct,kdt,Ndt,_dt,cat,Fdt,Ldt,Wdt,Gdt,Kdt,Ydt,Qdt,npt,apt,lpt,dpt,fpt,xpt,wpt,Cpt,$pt,Nit,Oct,Apt,Dpt,Opt,Lpt,zpt,Wpt,Upt,jpt,qpt,Ypt,Jpt,eht,nht,aht,oht,uht,dht,Fct,yat,fht,yht,bht,kht,Nht,Eht,xat,Aht,Dht,Mht,edt];for(let e of Lht)G1(e);var Tn;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(Tn||(Tn={}));var Gv;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(Gv||(Gv={}));var qte;function Pht(e){qte=e.wasm.cwrap(ph,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function zht(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r,p=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(a.dataId).id,m=0;if(i!=null){let A=n.dataIdMap.get(i.dataId);if(A.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${A.shape.length}.`);m=A.id}let g=o==null?0:n.dataIdMap.get(o.dataId).id,y=Gv[c];if(y==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let b=l?s.shape[2]:s.shape[1],v=u?a.shape[1]:a.shape[2],k=Ex.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)),I=n.makeOutput([...k,b,v],s.dtype),S=n.dataIdMap.get(I.dataId).id,N=new Uint8Array(new Int32Array(s.shape).buffer),T=new Uint8Array(new Int32Array(a.shape).buffer);return qte(p,N,s.shape.length,h,T,a.shape.length,l,u,y,m,g,d||0,S),I}var Bht={kernelName:ph,backendName:"wasm",setupFunc:Pht,kernelFunc:zht};function yn(e,t){let n;function r(a){n=a.wasm.cwrap(e,null,["number","number","number"])}function s(a){let{backend:i,inputs:{x:o}}=a,l=i.dataIdMap.get(o.dataId).id,u=i.makeOutput(o.shape,t||o.dtype),c=i.dataIdMap.get(u.dataId).id;return O.sizeFromShape(u.shape)===0||n(l,Tn[o.dtype],c),u}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:s}}var Wht=yn(Ty),Vht=yn(Gh),Uht=yn(jh);function ts(e,t,n){let r;function s(i){r=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function a(i){let{backend:o,inputs:l}=i,{a:u,b:c}=l,d=o.dataIdMap.get(u.dataId).id,p=o.dataIdMap.get(c.dataId).id,h=n??u.dtype,m=V.assertAndGetBroadcastShape(u.shape,c.shape),g=o.makeOutput(m,h);if(O.sizeFromShape(m)===0)return g;let y=new Uint8Array(new Int32Array(u.shape).buffer),b=new Uint8Array(new Int32Array(c.shape).buffer),v=o.dataIdMap.get(g.dataId).id;return r(d,y,u.shape.length,p,b,c.shape.length,Tn[u.dtype],v),g}return{kernelName:e,backendName:"wasm",setupFunc:s,kernelFunc:a}}var Ght=ts(Ad),Kte;function jht(e){Kte=e.wasm.cwrap(Hh,null,["array","number","number","number"])}function Hht(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(O.sizeFromShape(r.shape)===0)return r;let s=t.map(o=>n.dataIdMap.get(o.dataId).id),a=new Uint8Array(new Int32Array(s).buffer),i=n.dataIdMap.get(r.dataId).id;return Kte(a,s.length,Tn[r.dtype],i),r}var qht={kernelName:Hh,backendName:"wasm",setupFunc:jht,kernelFunc:Hht};function mT(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return $a(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(s),r}var Kht={kernelName:vf,backendName:"wasm",kernelFunc:mT},Xte;function Xht(e){Xte=e.wasm.cwrap(Ru,null,["number","array","number","number","number","array","number"])}function md(e){let{inputs:t,backend:n,attrs:r}=e,[s,a]=Zht(t.x.shape,r.perm),i=!0;for(let m=0;m<a.length;m++)a[m]!==m&&(i=!1);let o=Yht(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:s,dtype:t.x.dtype};if(i){let m=mT({inputs:t,backend:n});return m.shape=o,m}let u=n.makeOutput(o,l.dtype),c=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,p=new Uint8Array(new Int32Array(a).buffer),h=new Uint8Array(new Int32Array(l.shape).buffer);return Xte(c,h,l.shape.length,Tn[l.dtype],d,p,a.length),u}function Yht(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function Zht(e,t){let n=[],r=[];for(let s=0;s<e.length;++s)e[s]!==1&&n.push(e[s]),e[t[s]]!==1&&r.push(t[s]);for(let s=0;s<r.length;++s){let a=-1;for(let i=0;i<r.length;++i)r[i]>=s&&(a===-1||r[a]>r[i])&&(a=i);r[a]=s}return[n,r]}var Jht={kernelName:Ru,backendName:"wasm",kernelFunc:md,setupFunc:Xht};function Vd(e,t,n){let r=e.shape,s=e.shape.length,a=O.parseAxisParam(t,r),i=a,o=V.getAxesPermutation(i,s),l=null,u=!1;if(o!=null){let c=new Array(s);for(let p=0;p<c.length;p++)c[p]=r[o[p]];i=V.getInnerMostAxes(i.length,s),l=md({inputs:{x:e},attrs:{perm:o},backend:n});let d=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==d&&(u=!0)}return{transposed:l,originalAxes:a,axes:i,inputWasTransposed:u}}var Yte;function Qht(e){Yte=e.wasm.cwrap($y,null,["number, number, number"])}function eft(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:p}=Vd(i,s,t);if(p){let v=t.dataIdMap.get(u.dataId).id;l=u,o=v}let h=l.shape.length;V.assertAxesAreInnerMostDims("all",c,h);let[m,g]=V.computeOutAndReduceShapes(l.shape,c),y=O.sizeFromShape(g),b=t.makeOutput(m,i.dtype);if(O.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(b.dataId).id;Yte(o,y,v)}if(p&&t.disposeData(u.dataId),a){let v=V.expandShapeToKeepDim(b.shape,d);b.shape=v}return b}var tft={kernelName:$y,backendName:"wasm",setupFunc:Qht,kernelFunc:eft},Zte;function nft(e){Zte=e.wasm.cwrap(Ey,null,["number, number, number"])}function rft(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:p}=Vd(i,s,t);if(p){let v=t.dataIdMap.get(u.dataId).id;l=u,o=v}let h=l.shape.length;V.assertAxesAreInnerMostDims("any",c,h);let[m,g]=V.computeOutAndReduceShapes(l.shape,c),y=O.sizeFromShape(g),b=t.makeOutput(m,i.dtype);if(O.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(b.dataId).id;Zte(o,y,v)}if(p&&t.disposeData(u.dataId),a){let v=V.expandShapeToKeepDim(b.shape,d);b.shape=v}return b}var sft={kernelName:Ey,backendName:"wasm",setupFunc:nft,kernelFunc:rft};function Jte(e){let t;function n(s){t=s.wasm.cwrap(e,null,["number","number","number","number","number"])}function r(s){let{backend:a,inputs:i,attrs:o}=s,{axis:l}=o,{x:u}=i,c=a.dataIdMap.get(u.dataId).id,d=c,p=u,{transposed:h,axes:m,inputWasTransposed:g}=Vd(u,l,a);if(g){let S=a.dataIdMap.get(h.dataId).id;S!==c&&(p=h,d=S)}let y=p.shape.slice(0,-1),b=a.makeOutput(y,"int32"),v=a.dataIdMap.get(b.dataId).id,k=O.sizeFromShape(b.shape),I=p.shape[m[0]];return t(d,Tn[p.dtype],k,I,v),g&&a.disposeData(h.dataId),b}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}var aft=Jte(_y),ift=Jte(Ay),oft=yn(qh),lft=yn(Kh),uft=yn(Xh),cft=ts(Zh),dft=yn(Yh),Qte;function pft(e){Qte=e.wasm.cwrap(Jh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function hft(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=V.computePool2DInfo(s.shape,i,o,1,l,u),d=c.filterHeight,p=c.filterWidth,h=c.padInfo.top,m=c.padInfo.right,g=c.padInfo.bottom,y=c.padInfo.left,b=c.strideHeight,v=c.strideWidth,k=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let I=r.makeOutput(c.outShape,"float32"),S=r.dataIdMap.get(I.dataId).id;return Qte(a,s.shape[0],s.shape[1],s.shape[2],d,p,h,m,g,y,b,v,k,S),I}var fft={kernelName:Jh,backendName:"wasm",setupFunc:pft,kernelFunc:hft},ene;function mft(e){ene=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function gft(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=V.computePool3DInfo(s.shape,a,i,1,o,l,u),d=n.makeOutput(c.outShape,s.dtype);return ene(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}var yft={kernelName:Ry,backendName:"wasm",setupFunc:mft,kernelFunc:gft},tne;function xft(e){tne=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function bft(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=V.computePool3DInfo(a.shape,i,o,1,l,u),d=n.makeOutput(a.shape,a.dtype);return tne(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),d}var vft={kernelName:S1,backendName:"wasm",setupFunc:xft,kernelFunc:bft},nne;function wft(e){nne=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function kft(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l}=r,u=V.computePool2DInfo(a.shape,i,o,1,l),c=n.makeOutput(a.shape,a.dtype);return nne(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),c}var Ift={kernelName:I1,backendName:"wasm",setupFunc:wft,kernelFunc:kft};function Ya(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:s}=n,a=O.sizeFromShape(r.shape),i=O.inferFromImplicitShape(s,a);return O.assert(a===O.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var Sft={kernelName:dx,backendName:"wasm",kernelFunc:Ya},rne;function Cft(e){rne=e.wasm.cwrap(Qh,null,["number","array","number","number","array","number","number","number","number"])}function Nft(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=o?a.shape[u-1]:a.shape[u-2],p=i?s.shape[l-1]:s.shape[l-2],h=o?a.shape[u-2]:a.shape[u-1],m=s.shape.slice(0,-2),g=a.shape.slice(0,-2),y=O.sizeFromShape(m),b=O.sizeFromShape(g),v=Ex.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([p,h]);O.assert(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);let k=i?[y,c,p]:[y,p,c],I=o?[b,h,d]:[b,d,h],S=Ya({inputs:{x:s},backend:n,attrs:{shape:k}}),N=Ya({inputs:{x:a},backend:n,attrs:{shape:I}}),T=n.dataIdMap.get(S.dataId).id,A=n.dataIdMap.get(N.dataId).id,R=i?S.shape[2]:S.shape[1],D=o?N.shape[1]:N.shape[2],$=Math.max(y,b),_=n.makeOutput([$,R,D],S.dtype),L=n.dataIdMap.get(_.dataId).id,z=new Uint8Array(new Int32Array(S.shape).buffer),W=new Uint8Array(new Int32Array(N.shape).buffer);return rne(T,z,S.shape.length,A,W,N.shape.length,i,o,L),n.disposeData(S.dataId),n.disposeData(N.dataId),_.shape=v,_}var Tft={kernelName:Qh,backendName:"wasm",setupFunc:Cft,kernelFunc:Nft};function _h(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:s}=e,[a,i]=fs.parseSliceParams(t,n,r),o=fs.isSliceContinous(t.shape,a,i),l=s.readSync(t.dataId),u=s.makeOutput(i,t.dtype),c=O.computeStrides(t.shape),d=s.dataIdMap.get(u.dataId);if(o){let m=fs.computeFlatOffset(a,c);return t.dtype==="string"?d.stringBytes=l.slice(m,m+O.sizeFromShape(i)):s.typedArrayFromHeap(u).set(l.subarray(m,m+O.sizeFromShape(i))),u}if(t.dtype==="string"){let m=BI(l,a,i,t.shape,t.dtype);return d.stringBytes=m,u}let p=s.typedArrayFromHeap(u),h=t.shape.length;if(h===2)$ft(l,c[0],p,a,i);else if(h===3)Eft(l,c[0],c[1],p,a,i);else if(h===4)_ft(l,c[0],c[1],c[2],p,a,i);else{let m=BI(l,a,i,t.shape,t.dtype);p.set(m)}return u}function $ft(e,t,n,r,s){let a=0,i=r[0],o=r[1],l=i+s[0];for(let u=i;u<l;u++){let c=u*t+o;n.set(e.subarray(c,c+s[1]),a),a+=s[1]}}function Eft(e,t,n,r,s,a){let i=0,o=s[0],l=s[1],u=s[2],c=o+a[0],d=l+a[1];for(let p=o;p<c;p++)for(let h=l;h<d;h++){let m=p*t+h*n+u;r.set(e.subarray(m,m+a[2]),i),i+=a[2]}}function _ft(e,t,n,r,s,a,i){let o=0,l=a[0],u=a[1],c=a[2],d=l+i[0],p=u+i[1],h=c+i[2],m=a[3];for(let g=l;g<d;g++)for(let y=u;y<p;y++)for(let b=c;b<h;b++){let v=g*t+y*n+b*r+m;s.set(e.subarray(v,v+i[3]),o),o+=i[3]}}var Aft={kernelName:xx,backendName:"wasm",kernelFunc:_h};function Rft(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r,o=a.reduce((b,v)=>b*v),l=V.getReshaped(s.shape,a,o),u=V.getPermuted(l.length,a.length),c=V.getReshapedPermuted(s.shape,a,o),d=V.getSliceBeginCoords(i,a.length),p=V.getSliceSize(c,i,a.length),h=Ya({inputs:{x:s},backend:n,attrs:{shape:l}}),m=md({inputs:{x:h},backend:n,attrs:{perm:u}}),g=Ya({inputs:{x:m},backend:n,attrs:{shape:c}}),y=_h({inputs:{x:g},backend:n,attrs:{begin:d,size:p}});return n.disposeData(h.dataId),n.disposeData(m.dataId),n.disposeData(g.dataId),y}var Dft={kernelName:Dy,backendName:"wasm",kernelFunc:Rft},sne;function Fft(e){sne=e.wasm.cwrap(Fy,null,["number","number","boolean","number","number","number"])}function Oft(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,weights:a}=n,{size:i}=r,o=a.shape.reduce((d,p)=>d*p,1)!==0,l=s.shape.length===1?[i]:[s.shape[0],i],u=t.makeOutput(l,a.dtype);function c(d){return t.dataIdMap.get(d.dataId).id}return sne(c(s),i,o,c(a),Tn[a.dtype],c(u)),u}var Mft={kernelName:Fy,backendName:"wasm",setupFunc:Fft,kernelFunc:Oft},Lft=ts(Oy);function Pft(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(s),o=V.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var zft={kernelName:C1,backendName:"wasm",kernelFunc:Pft};function Ud(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,s=r.makeOutput(t.shape,n),a=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(s).set(a),s}var Bft={kernelName:ef,backendName:"wasm",kernelFunc:Ud},Wft=yn(tf),ane;function Vft(e){ane=e.wasm.cwrap(Rd,null,["number","number","number","number"])}function Uft(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r,o=n.dataIdMap.get(s.dataId).id,l=n.makeOutput(s.shape,s.dtype),u=n.dataIdMap.get(l.dataId).id;return ane(o,a,i,u),l}var Gft={kernelName:Rd,backendName:"wasm",setupFunc:Vft,kernelFunc:Uft};function ine(e){let{inputs:t,backend:n}=e,r=O.parseAxisParam(e.attrs.axis,t[0].shape)[0],s=t.map(h=>h.shape);V.assertParamsConsistent(s,r);let a=V.computeOutShape(t.map(h=>h.shape),r),i=t.filter(h=>O.sizeFromShape(h.shape)>0);if(i.length===1)return mT({inputs:{x:i[0]},backend:n});let o=n.makeOutput(a,t[0].dtype);if(O.sizeFromShape(a)===0)return o;if(i[0].dtype==="string"){let h=i.map(k=>{let I=[-1,O.sizeFromShape(k.shape.slice(r))];return Ya({inputs:{x:k},backend:n,attrs:{shape:I}})}),m=h.map(k=>({vals:n.readSync(k.dataId),shape:k.shape}));a=V.computeOutShape(h.map(k=>k.shape),1);let g=h[0].shape[0]===1,y=WL(m,a,t[0].dtype,g),b=V.computeOutShape(i.map(k=>k.shape),r);o.shape=b;let v=n.dataIdMap.get(o.dataId);return v.stringBytes=V.fromStringArrayToUint8(y),h.forEach(k=>n.disposeData(k.dataId)),o}let l=O.sizeFromShape(i[0].shape.slice(0,r)),u=0,c=i.map(h=>{let m=O.sizeFromShape(h.shape.slice(r));return u+=m,m}),d=i.map(h=>n.typedArrayFromHeap(h)),p=n.typedArrayFromHeap(o);for(let h=0;h<l;h++){let m=h*u;for(let g=0;g<d.length;g++){let y=c[g],b=h*y,v=d[g].subarray(b,b+y);p.set(v,m),m+=y}}return o}var jft={kernelName:My,backendName:"wasm",kernelFunc:ine},one;function Hft(e){one=e.wasm.cwrap(nf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function qft(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,i=r.dataIdMap.get(s.dataId).id,o=r.dataIdMap.get(a.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d,dataFormat:p}=n,h=V.convertConv2DDataFormat(p),m=V.computeConv2DInfo(s.shape,a.shape,l,u,c,d,!1,h),g=m.filterHeight,y=m.filterWidth,b=m.padInfo.top,v=m.padInfo.right,k=m.padInfo.bottom,I=m.padInfo.left,S=m.dilationHeight,N=m.dilationWidth,T=m.strideHeight,A=m.strideWidth,R=m.inChannels,D=m.outChannels,$=m.padInfo.type==="SAME"?1:0;if(m.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${m.dataFormat}'. Please use 'channelsLast'.`);let _=r.makeOutput(m.outShape,"float32"),L=r.dataIdMap.get(_.dataId).id;return one(i,s.shape[0],s.shape[1],s.shape[2],o,g,y,b,v,k,I,$,S,N,T,A,R,D,L),_}var Kft={kernelName:nf,backendName:"wasm",setupFunc:Hft,kernelFunc:qft},lne;function Xft(e){lne=e.wasm.cwrap(rf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Yft(e){let{backend:t,inputs:n,attrs:r}=e,{dy:s,filter:a}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:c}=r,d=1,p=V.convertConv2DDataFormat(l),h=V.computeConv2DInfo(c,a.shape,i,d,o,u,!1,p),{batchSize:m,filterHeight:g,filterWidth:y,inChannels:b,inHeight:v,inWidth:k,outChannels:I,outHeight:S,outWidth:N,strideHeight:T,strideWidth:A}=h,R=g-1-h.padInfo.top,D=y-1-h.padInfo.left,$=h.dataFormat==="channelsLast",_=O.computeStrides(h.inShape),L=O.computeStrides(s.shape),[z,W,G]=O.computeStrides(a.shape),q=_[0],B=$?_[1]:_[2],j=$?_[2]:1,H=$?1:_[1],P=L[0],X=$?L[1]:L[2],Q=$?L[2]:1,re=$?1:L[1],le=t.makeOutput(h.inShape,"float32"),ke=t.dataIdMap.get(le.dataId).id,Ne=t.dataIdMap.get(s.dataId).id,we=t.dataIdMap.get(a.dataId).id;return lne(Ne,we,m,g,y,v,k,b,S,N,I,T,A,R,D,z,W,G,q,B,j,H,P,X,Q,re,ke),le}var Zft={kernelName:rf,backendName:"wasm",setupFunc:Xft,kernelFunc:Yft},une;function Jft(e){une=e.wasm.cwrap(sf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Qft(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;if(s.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let u=V.computeConv3DInfo(s.shape,a.shape,i,l,o),c=n.makeOutput(u.outShape,s.dtype);return une(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var emt={kernelName:sf,backendName:"wasm",setupFunc:Jft,kernelFunc:Qft},cne;function tmt(e){cne=e.wasm.cwrap(Ly,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function nmt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;if(s.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let u=V.computeConv3DInfo(s.shape,l,i,1,o),c=n.makeOutput(u.filterShape,a.dtype);return cne(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var rmt={kernelName:Ly,backendName:"wasm",setupFunc:tmt,kernelFunc:nmt},dne;function smt(e){dne=e.wasm.cwrap(Py,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function amt(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;if(s.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let u=V.computeConv3DInfo(l,a.shape,o,1,i),c=n.makeOutput(u.inShape,s.dtype);return dne(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var imt={kernelName:Py,backendName:"wasm",setupFunc:smt,kernelFunc:amt},omt=yn(af),lmt=yn(of),hR;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(hR||(hR={}));var pne;function umt(e){pne=e.wasm.cwrap(By,null,["number","number","number","number","array","number","number","number","number","number"])}function cmt(e){let{backend:t,inputs:n,attrs:r}=e,{method:s,extrapolationValue:a,cropSize:i}=r,{image:o,boxes:l,boxInd:u}=n,c=l.shape[0],[d,p]=i,h=[c,d,p,o.shape[3]],m=t.dataIdMap.get(o.dataId),g;o.dtype!=="float32"&&(g=Ud({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));let y=m.id,b=t.dataIdMap.get(l.dataId).id,v=t.dataIdMap.get(u.dataId).id,k=t.makeOutput(h,"float32"),I=t.dataIdMap.get(k.dataId).id,S=new Uint8Array(new Int32Array(o.shape).buffer);return pne(y,b,v,c,S,d,p,hR[s],a,I),g!=null&&t.disposeData(g.dataId),k}var dmt={kernelName:By,backendName:"wasm",setupFunc:umt,kernelFunc:cmt},hne;function pmt(e){hne=e.wasm.cwrap(zy,null,["number","number","number","number","number","number"])}function hmt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r,l=s.shape.length;O.assert(s.dtype==="float32"||s.dtype==="int32",()=>`cumprod does not support ${s.dtype} tensors in the WASM backend`);let u=V.getAxesPermutation([a],l),c=s;u!==null&&(c=md({inputs:{x:s},attrs:{perm:u},backend:n}));let d=V.getInnerMostAxes(1,l)[0];V.assertAxesAreInnerMostDims("cumprod",[d],l);let p=n.makeOutput(c.shape,c.dtype),h=c.shape[d],m=n.dataIdMap.get(c.dataId).id,g=n.dataIdMap.get(p.dataId).id;hne(m,i?1:0,o?1:0,h,g,Tn[s.dtype]);let y=p;if(u!==null){let b=V.getUndoAxesPermutation(u);y=md({inputs:{x:p},attrs:{perm:b},backend:n}),n.disposeData(c.dataId),n.disposeData(p.dataId)}return y}var fmt={kernelName:zy,backendName:"wasm",setupFunc:pmt,kernelFunc:hmt},fne;function mmt(e){fne=e.wasm.cwrap(lf,null,["number","number","number","number","number","number"])}function gmt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r,l=s.shape.length;O.assert(s.dtype==="float32"||s.dtype==="int32",()=>`cumsum does not support ${s.dtype} tensors in the WASM backend`);let u=V.getAxesPermutation([a],l),c=s;u!==null&&(c=md({inputs:{x:s},attrs:{perm:u},backend:n}));let d=V.getInnerMostAxes(1,l)[0];V.assertAxesAreInnerMostDims("cumsum",[d],l);let p=n.makeOutput(c.shape,c.dtype),h=c.shape[d],m=n.dataIdMap.get(c.dataId).id,g=n.dataIdMap.get(p.dataId).id;fne(m,i?1:0,o?1:0,h,g,Tn[s.dtype]);let y=p;if(u!==null){let b=V.getUndoAxesPermutation(u);y=md({inputs:{x:p},attrs:{perm:b},backend:n}),n.disposeData(c.dataId),n.disposeData(p.dataId)}return y}var ymt={kernelName:lf,backendName:"wasm",setupFunc:mmt,kernelFunc:gmt},mne;function xmt(e){mne=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function bmt(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,weights:a}=n,{size:i,binaryOutput:o}=r,l=a.shape.reduce((p,h)=>p*h,1)!==0,u=s.shape.length===1?[i]:[s.shape[0],i],c=t.makeOutput(u,a.dtype);function d(p){return t.dataIdMap.get(p.dataId).id}return mne(d(s),new Uint8Array(new Int32Array(s.shape).buffer),s.shape.length,i,l,d(a),Tn[a.dtype],o,d(c)),c}var vmt={kernelName:T1,backendName:"wasm",setupFunc:xmt,kernelFunc:bmt},gne;function wmt(e){gne=e.wasm.cwrap(Wy,null,["number","number","number","array","number","array","array","number","number"])}function kmt(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],u=i==="NHWC"?s.shape[2]:s.shape[3],c=i==="NHWC"?s.shape[3]:s.shape[1],d=l*a,p=u*a,h=c/(a*a),m=i==="NHWC"?[o,d,p,h]:[o,h,d,p],g=t.makeOutput(m,"float32"),y=t.dataIdMap.get(s.dataId).id,b=new Uint8Array(new Int32Array(O.computeStrides(s.shape)).buffer),v=new Uint8Array(new Int32Array(m).buffer),k=new Uint8Array(new Int32Array(O.computeStrides(m)).buffer),I=t.dataIdMap.get(g.dataId).id;return gne(y,a,i==="NHWC"?1:0,b,s.shape.length-1,v,k,m.length,I),g}var Imt={kernelName:Wy,backendName:"wasm",setupFunc:wmt,kernelFunc:kmt},yne;function Smt(e){yne=e.wasm.cwrap(uf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Cmt(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,i=r.dataIdMap.get(s.dataId).id,o=r.dataIdMap.get(a.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d}=n,p=u??[1,1],h=V.computeConv2DInfo(s.shape,a.shape,l,p,c,d,!0),m=h.filterHeight,g=h.filterWidth,y=h.padInfo.top,b=h.padInfo.right,v=h.padInfo.bottom,k=h.padInfo.left,I=h.dilationHeight,S=h.dilationWidth,N=h.strideHeight,T=h.strideWidth,A=h.inChannels,R=h.outChannels,D=h.padInfo.type==="SAME"?1:0;if(h.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let $=r.makeOutput(h.outShape,"float32"),_=r.dataIdMap.get($.dataId).id;return yne(i,s.shape[0],s.shape[1],s.shape[2],o,m,g,y,b,v,k,D,I,S,N,T,A,R,_),$}var Nmt={kernelName:uf,backendName:"wasm",setupFunc:Smt,kernelFunc:Cmt},xne;function Tmt(e){xne=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function $mt(e){let{inputs:t,backend:n}=e,{x:r}=t,s=O.sizeFromShape(r.shape),a=n.makeOutput([...r.shape,...r.shape],r.dtype);return xne(n.dataIdMap.get(r.dataId).id,Tn[r.dtype],s,n.dataIdMap.get(a.dataId).id),a}var Emt={kernelName:$1,backendName:"wasm",setupFunc:Tmt,kernelFunc:$mt},bne;function _mt(e){bne=e.wasm.cwrap(cf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Amt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;if(s.dtype!==a.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${s.dtype} and ${a.dtype}`);let u=V.computeDilation2DInfo(s.shape,a.shape,i,o,"NHWC",l),c=n.makeOutput(u.outShape,s.dtype);return bne(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,Tn[s.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),c}var Rmt={kernelName:cf,backendName:"wasm",setupFunc:_mt,kernelFunc:Amt},vne;function Dmt(e){vne=e.wasm.cwrap(zg,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Fmt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(s.dtype!==a.dtype||s.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${s.dtype}, ${a.dtype}, and ${i.dtype}`);let c=V.computeDilation2DInfo(s.shape,a.shape,o,l,"NHWC",u),d=n.makeOutput(a.shape,a.dtype);return vne(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Tn[s.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}var Omt={kernelName:zg,backendName:"wasm",setupFunc:Dmt,kernelFunc:Fmt},wne;function Mmt(e){wne=e.wasm.cwrap(Pg,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Lmt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(s.dtype!==a.dtype||s.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${s.dtype}, ${a.dtype}, and ${i.dtype}`);let c=V.computeDilation2DInfo(s.shape,a.shape,o,l,"NHWC",u),d=n.makeOutput(s.shape,s.dtype);return wne(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Tn[s.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}var Pmt={kernelName:Pg,backendName:"wasm",setupFunc:Mmt,kernelFunc:Lmt},zmt=yn(pf),kne;function Bmt(e){kne=e.wasm.cwrap(Vy,null,["number","number","number"])}function Wmt(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=n.makeOutput(s.shape,"float32"),i=o=>n.dataIdMap.get(o.dataId).id;return kne(i(s),i(r),i(a)),a}var Vmt={kernelName:Vy,backendName:"wasm",setupFunc:Bmt,kernelFunc:Wmt},Umt=!1,Gmt=ts(Uy,Umt,"bool"),jmt=yn(hf),Hmt=yn(ff,"float32");function fR(e){let{inputs:t,attrs:n,backend:r}=e,{input:s}=t,{dim:a}=n,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(O.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),Ya({inputs:{x:s},backend:r,attrs:{shape:o}})}var qmt={kernelName:Gy,backendName:"wasm",kernelFunc:fR},Kmt=yn(mf,"float32");function Ine(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:s}}=e;s=s||O.inferDtype(n);let a=r.makeOutput(t,s);return r.typedArrayFromHeap(a).fill(n),a}var Xmt={kernelName:E1,backendName:"wasm",kernelFunc:Ine},Sne;function Ymt(e){Sne=e.wasm.cwrap(jy,null,["number","number","number","number","number","number"])}function Zmt(e){let{inputs:t,backend:n}=e,{image:r}=t,s=n.makeOutput(r.shape,r.dtype),a=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id,[o,l,u,c]=r.shape;return Sne(a,o,l,u,c,i),s}var Jmt={kernelName:jy,backendName:"wasm",kernelFunc:Zmt,setupFunc:Ymt},Qmt=yn(gf),egt=ts(yf),Cne;function tgt(e){Cne=e.wasm.cwrap(xf,null,["number","number","number","number","number","number","number"])}function ngt(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:s}=r,{x:a,mean:i,variance:o,offset:l,scale:u}=n,c=t.dataIdMap.get(a.dataId).id,d=t.dataIdMap.get(i.dataId).id,p=t.dataIdMap.get(o.dataId).id,h=l!=null?t.dataIdMap.get(l.dataId).id:0,m=u!=null?t.dataIdMap.get(u.dataId).id:0,g=t.makeOutput(a.shape,a.dtype);if(O.sizeFromShape(a.shape)===0)return g;let y=t.dataIdMap.get(g.dataId).id;return Cne(c,d,p,h,m,s,y),g}var rgt={kernelName:xf,backendName:"wasm",setupFunc:tgt,kernelFunc:ngt},Nne;function sgt(e){Nne=e.wasm.cwrap(hh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function agt(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=n,g=V.computeConv2DInfo(s.shape,a.shape,l,c,u,p),y=Gv[h];if(y==null)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);let b=r.dataIdMap.get(s.dataId).id,v=r.dataIdMap.get(a.dataId).id,k=g.outChannels,I=0;if(i!=null){let Q=r.dataIdMap.get(i.dataId);if(Q.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${Q.shape.length}.`);if(Q.shape[0]!==k)throw new Error(`FusedConv2D bias shape (${Q.shape}) does not match the number of output channels (${k})`);I=Q.id}let S=g.filterHeight,N=g.filterWidth,T=g.padInfo.top,A=g.padInfo.right,R=g.padInfo.bottom,D=g.padInfo.left,$=g.dilationHeight,_=g.dilationWidth,L=g.strideHeight,z=g.strideWidth,W=g.inChannels,G=g.padInfo.type==="SAME"?1:0,q=g.batchSize,B=g.inHeight,j=g.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let H=r.makeOutput(g.outShape,"float32"),P=r.dataIdMap.get(H.dataId).id,X=o==null?0:r.dataIdMap.get(o.dataId).id;return Nne(b,q,B,j,v,S,N,I,T,A,R,D,G,$,_,L,z,W,k,y,X,m||0,P),H}var igt={kernelName:hh,backendName:"wasm",setupFunc:sgt,kernelFunc:agt},Tne;function ogt(e){Tne=e.wasm.cwrap(fh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function lgt(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:p,activation:h,leakyreluAlpha:m}=n,g=V.computeConv2DInfo(s.shape,a.shape,l,c,u,p,!0),y=Gv[h];if(y==null)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let b=r.dataIdMap.get(s.dataId).id,v=r.dataIdMap.get(a.dataId).id,k=g.outChannels,I=0;if(i!=null){let Q=r.dataIdMap.get(i.dataId);if(Q.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${Q.shape.length}.`);if(Q.shape[0]!==k)throw new Error(`FusedDepthwiseConv2D bias shape (${Q.shape}) does not match the number of output channels (${k})`);I=Q.id}let S=g.filterHeight,N=g.filterWidth,T=g.padInfo.top,A=g.padInfo.right,R=g.padInfo.bottom,D=g.padInfo.left,$=g.dilationHeight,_=g.dilationWidth,L=g.strideHeight,z=g.strideWidth,W=g.inChannels,G=g.padInfo.type==="SAME"?1:0,q=g.batchSize,B=g.inHeight,j=g.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let H=r.makeOutput(g.outShape,"float32"),P=r.dataIdMap.get(H.dataId).id,X=o==null?0:r.dataIdMap.get(o.dataId).id;return Tne(b,q,B,j,v,S,N,I,T,A,R,D,G,$,_,L,z,W,k,y,X,m||0,P),H}var ugt={kernelName:fh,backendName:"wasm",setupFunc:ogt,kernelFunc:lgt},$ne;function cgt(e){$ne=e.wasm.cwrap(qy,null,["number","number","number","number","number","number","array","number"])}function dgt(e){let{backend:t,inputs:n}=e,{params:r,indices:s}=n,[a,i,o,l]=QO.prepareAndValidate(r,s),u=t.makeOutput(a,r.dtype);if(i===0)return u;let c=s.shape,d=c[c.length-1],p=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(l).buffer),g=t.dataIdMap.get(u.dataId).id;return $ne(p,Tn[r.dtype],h,i,d,o,m,g),u}var pgt={kernelName:qy,backendName:"wasm",setupFunc:cgt,kernelFunc:dgt},Ene;function hgt(e){Ene=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function fgt(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,indices:a}=n,{axis:i,batchDims:o}=r,l=O.parseAxisParam(i,s.shape)[0],u=t.readSync(a.dataId),c=s.shape[l];for(let T=0;T<u.length;++T){let A=u[T];O.assert(A<=c-1&&A>=0,()=>`GatherV2: the index value ${A} is not in [0, ${c-1}]`)}let d=V.segment_util.collectGatherOpShapeInfo(s,a,l,o),p=Ya({inputs:{x:s},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),h=O.sizeFromShape(a.shape),m=Ya({inputs:{x:a},attrs:{shape:[d.batchSize,h/d.batchSize]},backend:t}),g=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize],y=t.makeOutput(g,s.dtype);if(O.sizeFromShape(s.shape)===0)return y;let b=p.shape.length-1,v=t.dataIdMap.get(p.dataId).id,k=t.dataIdMap.get(m.dataId).id,I=t.dataIdMap.get(y.dataId).id,S=new Uint8Array(new Int32Array(O.computeStrides(p.shape)).buffer),N=new Uint8Array(new Int32Array(O.computeStrides(g)).buffer);return Ene(v,Tn[s.dtype],S,b,k,d.batchSize,N,I),t.disposeData(p.dataId),t.disposeData(m.dataId),y.shape=d.outputShape,y}var mgt={kernelName:Hy,backendName:"wasm",setupFunc:hgt,kernelFunc:fgt},ggt=!1,ygt=ts(Ky,ggt,"bool"),xgt=!1,bgt=ts(bf,xgt,"bool"),vgt=yn(wf,"bool"),wgt=yn(kf,"bool"),kgt=yn(If,"bool"),_ne;function Igt(e){_ne=e.wasm.cwrap(Sf,null,["number","number","number","number"])}function Sgt(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,s=r.dataIdMap.get(t.dataId).id,a=r.makeOutput(t.shape,"float32");if(O.sizeFromShape(t.shape)!==0){let i=r.dataIdMap.get(a.dataId).id;_ne(s,Tn[t.dtype],n,i)}return a}var Cgt={kernelName:Sf,backendName:"wasm",setupFunc:Igt,kernelFunc:Sgt},Ngt=!1,Tgt=ts(Xy,Ngt,"bool"),$gt=!1,Egt=ts(Yy,$gt,"bool"),Ane;function _gt(e){Ane=e.wasm.cwrap(Zy,null,["number","number","number","number"])}function Agt(e){let{attrs:t,backend:n}=e,{start:r,stop:s,num:a}=t,i=Math.floor(a),o=n.makeOutput([i],"float32");return Ane(n.dataIdMap.get(o.dataId).id,r,s,i),o}var Rgt={kernelName:Zy,backendName:"wasm",setupFunc:_gt,kernelFunc:Agt},Dgt=yn(Cf),Fgt=yn(Nf),Ogt=!1,Mgt=ts(Jy,Ogt,"bool"),Lgt=yn(Qy),Pgt=!1,zgt=ts(ex,Pgt,"bool"),Bgt=!1,Wgt=ts(_K,Bgt,"bool"),Rne;function Vgt(e){Rne=e.wasm.cwrap(Tf,null,["number","number","number","number","number","number","number"])}function Ugt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;if(s.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(s.shape,s.dtype);return Rne(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,s.shape[3],a,i,o,l),u}var Ggt={kernelName:Tf,backendName:"wasm",setupFunc:Vgt,kernelFunc:Ugt},Dne;function jgt(e){Dne=e.wasm.cwrap(tx,null,["number","number","number","number","number","number","number","number","number"])}function Hgt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;if(s.dtype!=="float32"||a.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let d=n.makeOutput(s.shape,s.dtype);return Dne(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,l,u,c),d}var qgt={kernelName:tx,backendName:"wasm",setupFunc:jgt,kernelFunc:Hgt},Fne;function Kgt(e){Fne=e.wasm.cwrap($f,null,["number","number","number","number"])}function Xgt(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:p}=Vd(i,s,t);if(p){let v=t.dataIdMap.get(u.dataId).id;l=u,o=v}let h=l.shape.length;V.assertAxesAreInnerMostDims("max",c,h);let[m,g]=V.computeOutAndReduceShapes(l.shape,c),y=O.sizeFromShape(g),b=t.makeOutput(m,i.dtype);if(O.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(b.dataId).id;Fne(o,Tn[i.dtype],y,v)}if(p&&t.disposeData(u.dataId),a){let v=V.expandShapeToKeepDim(b.shape,d);b.shape=v}return b}var Ygt={kernelName:$f,backendName:"wasm",setupFunc:Kgt,kernelFunc:Xgt},Zgt=ts(Ef),One;function Jgt(e){One=e.wasm.cwrap(_f,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Qgt(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id;O.assert(s.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${s.dtype}.`);let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=V.computePool2DInfo(s.shape,i,o,1,l,u),d=c.filterHeight,p=c.filterWidth,h=c.padInfo.top,m=c.padInfo.right,g=c.padInfo.bottom,y=c.padInfo.left,b=c.dilationHeight,v=c.dilationWidth,k=c.strideHeight,I=c.strideWidth,S=c.inChannels,N=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let T=r.makeOutput(c.outShape,"float32"),A=r.dataIdMap.get(T.dataId).id;return One(a,s.shape[0],s.shape[1],s.shape[2],d,p,h,m,g,y,b,v,k,I,S,N,A),T}var eyt={kernelName:_f,backendName:"wasm",setupFunc:Jgt,kernelFunc:Qgt},Mne;function tyt(e){Mne=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function nyt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=V.computePool3DInfo(s.shape,a,i,1,o,l,u),d=n.makeOutput(c.outShape,s.dtype);return Mne(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}var ryt={kernelName:nx,backendName:"wasm",setupFunc:tyt,kernelFunc:nyt},Lne;function syt(e){Lne=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ayt(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=V.computePool3DInfo(a.shape,i,o,1,l,u),d=n.makeOutput(a.shape,a.dtype);return Lne(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}var iyt={kernelName:A1,backendName:"wasm",setupFunc:syt,kernelFunc:ayt},Pne;function oyt(e){Pne=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function lyt(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=V.computePool2DInfo(a.shape,i,o,1,l,u),d=n.makeOutput(a.shape,a.dtype);return Pne(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),d}var uyt={kernelName:_1,backendName:"wasm",setupFunc:oyt,kernelFunc:lyt},zne;function cyt(e){zne=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function dyt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,includeBatchInIndex:l}=r;O.assert(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);let u=[1,1];O.assert(V.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=V.computePool2DInfo(s.shape,a,i,[1,1],o),d=n.makeOutput(c.outShape,s.dtype),p=n.makeOutput(c.outShape,"int32");return zne(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(p.dataId).id,Tn[s.dtype],l,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),[d,p]}var pyt={kernelName:R1,backendName:"wasm",setupFunc:cyt,kernelFunc:dyt},Bne;function hyt(e){Bne=e.wasm.cwrap(Af,null,["number, number, number"])}function fyt(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=Vd(i,s,t),m=d;if(h){let I=t.dataIdMap.get(c.dataId).id;I!==o&&(u=c,l=I,m=V.getInnerMostAxes(m.length,u.shape.length))}V.assertAxesAreInnerMostDims("mean",m,u.shape.length);let[g,y]=V.computeOutAndReduceShapes(u.shape,m),b=O.sizeFromShape(y),v=u;u.dtype!=="float32"&&(v=Ud({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(v.dataId).id);let k=t.makeOutput(g,"float32");if(O.sizeFromShape(u.shape)!==0){let I=t.dataIdMap.get(k.dataId).id;Bne(l,b,I)}if(h&&t.disposeData(c.dataId),a){let I=V.expandShapeToKeepDim(k.shape,p);k.shape=I}return u.dtype!=="float32"&&t.disposeData(v.dataId),k}var myt={kernelName:Af,backendName:"wasm",setupFunc:hyt,kernelFunc:fyt},Wne;function gyt(e){Wne=e.wasm.cwrap(Rf,null,["number","number","number","number"])}function yyt(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=Vd(i,s,t);if(h){let k=t.dataIdMap.get(c.dataId).id;k!==o&&(u=c,l=k)}let m=u.shape.length;V.assertAxesAreInnerMostDims("min",d,m);let[g,y]=V.computeOutAndReduceShapes(u.shape,d),b=O.sizeFromShape(y),v=t.makeOutput(g,u.dtype);if(O.sizeFromShape(u.shape)!==0){let k=t.dataIdMap.get(v.dataId).id;Wne(l,Tn[i.dtype],b,k)}if(h&&t.disposeData(c.dataId),a){let k=V.expandShapeToKeepDim(v.shape,p);v.shape=k}return v}var xyt={kernelName:Rf,backendName:"wasm",setupFunc:gyt,kernelFunc:yyt},byt=ts(Df),mR;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(mR||(mR={}));var Vne;function vyt(e){Vne=e.wasm.cwrap(Ff,null,["number","array","number","number","array","array","number","number"])}function wyt(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:s}}=e,a=r.map((m,g)=>m[0]+t.shape[g]+m[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(a,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map(m=>m[0]),d=r.map(m=>m[1]),p=new Uint8Array(new Int32Array(c).buffer),h=new Uint8Array(new Int32Array(d).buffer);return Vne(i,u,t.shape.length,Tn[t.dtype],p,h,mR[s],l),o}var kyt={kernelName:Ff,backendName:"wasm",kernelFunc:wyt,setupFunc:vyt},Une;function Iyt(e){Une=e.wasm.cwrap(sm,null,["number","number","number","number"])}function Gne(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,s=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(a.dataId).id,o=n.shape[r],l=O.sizeFromShape(n.shape)/o;return O.sizeFromShape(a.shape)===0||Une(s,i,o,l),a}var Syt={kernelName:sm,backendName:"wasm",setupFunc:Iyt,kernelFunc:Gne},jne;function Cyt(e){jne=e.wasm.cwrap(rx,null,["number","number","number","number","number","number"])}function Nyt(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;if(s.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${s.dtype}`);let l=o?s:Gne({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),[u,c]=l.shape,d=n.makeOutput([u,a],"int32");return jne(n.dataIdMap.get(l.dataId).id,u,c,a,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(l.dataId),d}var Tyt={kernelName:rx,backendName:"wasm",setupFunc:Cyt,kernelFunc:Nyt},$yt=ts(Of),Eyt=ts(Mf),_yt=yn(sx);function gP(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],s=n[1],a=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:s,pSelectedScores:a,pValidOutputs:i}}var Hne;function Ayt(e){Hne=e.wasm.cwrap(ix,"number",["number","number","number","number","number"])}function Ryt(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(l.dataId).id,d=Hne(u,c,a,s,i),{pSelectedIndices:p,selectedSize:h,pSelectedScores:m,pValidOutputs:g}=gP(t,d);return t.wasm._free(m),t.wasm._free(g),t.makeOutput([h],"int32",p)}var Dyt={kernelName:ix,backendName:"wasm",setupFunc:Ayt,kernelFunc:Ryt},qne;function Fyt(e){qne=e.wasm.cwrap(ox,"number",["number","number","number","number","number","bool"])}function Oyt(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,p=qne(c,d,a,s,i,o),{pSelectedIndices:h,selectedSize:m,pSelectedScores:g,pValidOutputs:y}=gP(t,p);t.wasm._free(g);let b=t.makeOutput([m],"int32",h),v=t.makeOutput([],"int32",y);return[b,v]}var Myt={kernelName:ox,backendName:"wasm",setupFunc:Fyt,kernelFunc:Oyt},Kne;function Lyt(e){Kne=e.wasm.cwrap(lx,"number",["number","number","number","number","number","number"])}function Pyt(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,p=Kne(c,d,a,s,i,o),{pSelectedIndices:h,selectedSize:m,pSelectedScores:g,pValidOutputs:y}=gP(t,p);t.wasm._free(y);let b=t.makeOutput([m],"int32",h),v=t.makeOutput([m],"float32",g);return[b,v]}var zyt={kernelName:lx,backendName:"wasm",setupFunc:Lyt,kernelFunc:Pyt},Byt=!1,Wyt=ts(ax,Byt,"bool"),Xne;function Vyt(e){Xne=e.wasm.cwrap(Lf,null,["number","number","number","number","number"])}function Uyt(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=n.makeOutput([...s.shape,i],a),c=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(s.dataId).id;return Xne(d,i,o,l,c),u}var Gyt={kernelName:Lf,backendName:"wasm",setupFunc:Vyt,kernelFunc:Uyt};function jyt(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var Hyt={kernelName:ux,backendName:"wasm",kernelFunc:jyt};function qyt(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return fR({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,i=t[0].dtype;t.forEach(c=>{O.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),O.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(c=>{let d=fR({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=ine({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeData(c.dataId)),u}var Kyt={kernelName:cx,backendName:"wasm",kernelFunc:qyt},Yne;function Xyt(e){Yne=e.wasm.cwrap(Pf,null,["number","array","number","number","array","array","number","number"])}function Yyt(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:s}}=e,a=r.map((m,g)=>m[0]+t.shape[g]+m[1]);if(O.sizeFromShape(t.shape)===0)return Ine({backend:n,attrs:{shape:a,value:s,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(a,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map(m=>m[0]),d=r.map(m=>m[1]),p=new Uint8Array(new Int32Array(c).buffer),h=new Uint8Array(new Int32Array(d).buffer);return Yne(i,u,t.shape.length,Tn[t.dtype],p,h,s,l),o}var Zne={kernelName:Pf,backendName:"wasm",kernelFunc:Yyt,setupFunc:Xyt},Zyt=ts(zf),Jne;function Jyt(e){Jne=e.wasm.cwrap(Bf,null,["number","number","number"])}function Qyt(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id,o=a,l=r,u=l;l.dtype!=="float32"&&(u=Ud({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let c=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(c.dataId).id;return Jne(o,i,d),l.dtype!=="float32"&&n.disposeData(u.dataId),c}var ext={kernelName:Bf,backendName:"wasm",setupFunc:Jyt,kernelFunc:Qyt},Qne;function txt(e){Qne=e.wasm.cwrap(Wf,null,["number","number","number","number"])}function nxt(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=Vd(i,s,t),m=d;if(h){let k=t.dataIdMap.get(c.dataId).id;k!==o&&(u=c,l=k,m=V.getInnerMostAxes(m.length,u.shape.length))}V.assertAxesAreInnerMostDims("prod",m,u.shape.length);let[g,y]=V.computeOutAndReduceShapes(u.shape,m),b=O.sizeFromShape(y),v=t.makeOutput(g,u.dtype);if(O.sizeFromShape(u.shape)!==0){let k=t.dataIdMap.get(v.dataId).id;Qne(l,b,Tn[v.dtype],k)}if(h&&t.disposeData(c.dataId),a){let k=V.expandShapeToKeepDim(v.shape,p);v.shape=k}return v}var rxt={kernelName:Wf,backendName:"wasm",setupFunc:txt,kernelFunc:nxt},sxt=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=GL(r,s,a,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},axt={kernelName:D1,backendName:"wasm",kernelFunc:sxt},ixt=ts(df),oxt=yn(Vf),lxt=yn(Uf),uxt=yn(Hf),ere;function cxt(e){ere=e.wasm.cwrap(jf,null,["number","number","number","number","number","number","number","number","number","number"])}function dxt(e){let{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,[c,d,p,h]=s.shape,m=[c,l,u,h],g=t.dataIdMap.get(s.dataId),y;g.dtype!=="float32"&&(y=Ud({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(y.dataId));let b=g.id,v=t.makeOutput(m,"float32");if(O.sizeFromShape(s.shape)===0)return v;let k=t.dataIdMap.get(v.dataId).id;return ere(b,c,d,p,h,l,u,a?1:0,i?1:0,k),y!=null&&t.disposeData(y.dataId),v}var pxt={kernelName:jf,backendName:"wasm",setupFunc:cxt,kernelFunc:dxt},tre;function hxt(e){tre=e.wasm.cwrap(hx,null,["number","number","number","array","array","boolean"])}function fxt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=n.makeOutput(s.shape,"float32"),l=n.dataIdMap.get(s.dataId),u;return l.dtype!=="float32"&&(u=Ud({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),tre(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var mxt={kernelName:hx,backendName:"wasm",setupFunc:hxt,kernelFunc:fxt},nre;function gxt(e){nre=e.wasm.cwrap(Gf,null,["number","number","number","number","number","number","number","number","number","number"])}function yxt(e){let{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,[c,d,p,h]=s.shape,m=[c,l,u,h],g=t.makeOutput(m,"float32");if(O.sizeFromShape(s.shape)===0)return g;let y=t.dataIdMap.get(s.dataId),b;y.dtype!=="float32"&&(b=Ud({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),y=t.dataIdMap.get(b.dataId));let v=y.id,k=t.dataIdMap.get(g.dataId).id;return nre(v,c,d,p,h,l,u,a?1:0,i?1:0,k),b!=null&&t.disposeData(b.dataId),g}var xxt={kernelName:Gf,backendName:"wasm",setupFunc:gxt,kernelFunc:yxt},rre;function bxt(e){rre=e.wasm.cwrap(px,null,["number","number","number","array","array","boolean"])}function vxt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=n.makeOutput(s.shape,"float32"),l=n.dataIdMap.get(s.dataId),u;return l.dtype!=="float32"&&(u=Ud({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),rre(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var wxt={kernelName:px,backendName:"wasm",setupFunc:bxt,kernelFunc:vxt},sre;function kxt(e){sre=e.wasm.cwrap(qf,null,["number","array","number","array","number","number"])}function Ixt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=O.parseAxisParam(a,s.shape);if(s.shape.length===0)return mT({inputs:{x:s},backend:n});let o=n.makeOutput(s.shape,s.dtype),l=n.dataIdMap.get(s.dataId).id,u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(s.shape).buffer);sre(l,c,i.length,d,s.shape.length,u);let p=Ya({inputs:{x:o},attrs:{shape:s.shape},backend:n});return n.disposeData(o.dataId),p}var Sxt={kernelName:qf,backendName:"wasm",kernelFunc:Ixt,setupFunc:kxt},are;function Cxt(e){are=e.wasm.cwrap($x,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Nxt(e){let{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{radians:a,fillValue:i,center:o}=r,l=n.makeOutput(s.shape,s.dtype),u=n.dataIdMap.get(s.dataId).id,c=n.dataIdMap.get(l.dataId).id,[d,p,h,m]=s.shape,[g,y]=V.getImageCenter(o,p,h),b=i===0,v=255,k=typeof i=="number"?[i,i,i,b?0:v]:[...i,v],I=new Uint8Array(new Int32Array(k).buffer);return are(u,d,p,h,m,a,g,y,I,k.length,c),l}var Txt={kernelName:$x,backendName:"wasm",kernelFunc:Nxt,setupFunc:Cxt},$xt=yn(Kf),Ext=yn(Xf),ire;function _xt(e){ire=e.wasm.cwrap(fx,null,["number","number","number","number","number","number","array","number","number"])}function Axt(e){let{backend:t,inputs:n,attrs:r}=e,{indices:s,updates:a}=n,{shape:i}=r,o=t.makeOutput(i,a.dtype);if(O.sizeFromShape(i)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=AN.calculateShapes(a,s,i),h=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),y=t.dataIdMap.get(o.dataId).id;return ire(h,m,Tn[a.dtype],l,u,c,g,p,y),o}var Rxt={kernelName:fx,backendName:"wasm",setupFunc:_xt,kernelFunc:Axt},ore;function Dxt(e){ore=e.wasm.cwrap(gx,null,["number","number","number","number","number","number","bool","number"])}function Fxt(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r;if(s.dtype!==a.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${s.dtype} and ${a.dtype}`);let o=n.makeOutput(a.shape,"int32");function l(u){return n.dataIdMap.get(u.dataId).id}return ore(l(s),l(a),s.shape[0],s.shape[1],a.shape[1],Tn[s.dtype],i==="left",l(o)),o}var Oxt={kernelName:gx,backendName:"wasm",setupFunc:Dxt,kernelFunc:Fxt},lre;function Mxt(e){lre=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function Lxt(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(s.dataId).id,l=n.dataIdMap.get(a.dataId).id,u=n.makeOutput(s.shape,s.dtype),c=n.dataIdMap.get(u.dataId).id,d=r.shape.length,p=s.shape.length,h=d===0||d>1||p===1?1:O.sizeFromShape(s.shape.slice(1));return lre(i,o,l,h,c),u}var Pxt={kernelName:yx,backendName:"wasm",kernelFunc:Lxt,setupFunc:Mxt},zxt=yn(Yf),ure;function Bxt(e){ure=e.wasm.cwrap(em,null,["number","number"])}function Wxt(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),a=t.dataIdMap.get(s.dataId).id;return O.sizeFromShape(s.shape)===0||ure(r,a),s}var Vxt={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Bxt,kernelFunc:Wxt},Uxt=yn(Qf),Gxt=yn(Zf),jxt=yn(Jf),Hxt=yn(tm);function qxt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r,o=O.sizeFromShape(a),l=[[0,0]];l.push(...i);for(let y=1+a.length;y<s.shape.length;++y)l.push([0,0]);let u=Zne.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=V.getReshaped(u.shape,a,o,!1),d=V.getPermuted(c.length,a.length,!1),p=V.getReshapedPermuted(u.shape,a,o,!1),h=Ya({inputs:{x:u},backend:n,attrs:{shape:c}}),m=md({inputs:{x:h},backend:n,attrs:{perm:d}}),g=Ya({inputs:{x:m},backend:n,attrs:{shape:p}});return n.disposeData(u.dataId),n.disposeData(h.dataId),n.disposeData(m.dataId),g}var Kxt={kernelName:bx,backendName:"wasm",kernelFunc:qxt},cre;function Xxt(e){cre=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function Yxt(e){let{backend:t,inputs:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=n,o=r.shape[0],l=r.shape[1],u=t.readSync(a.dataId)[0],c=[o+u,l],d=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(s.dataId).id,h=t.dataIdMap.get(i.dataId).id,m=t.makeOutput(c,r.dtype),g=t.dataIdMap.get(m.dataId).id,y=t.makeOutput(c.slice(0,1),s.dtype),b=t.dataIdMap.get(y.dataId).id,v=t.makeOutput([u],"bool"),k=t.dataIdMap.get(v.dataId).id,I=t.makeOutput([o],r.dtype),S=t.dataIdMap.get(I.dataId).id,N=t.makeOutput([4],"int32"),T=t.dataIdMap.get(N.dataId).id,A=cre(d,p,Tn[s.dtype],o,u,l,h,g,b,k,S,T),R=t.readSync(N.dataId),D;switch(R[0]){case 1:{D=V.getSparseFillEmptyRowsIndicesDenseShapeMismatch(R[1]);break}case 2:{D=V.getSparseFillEmptyRowsNegativeIndexErrorMessage(R[1],R[2]);break}case 3:D=V.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(R[1],R[2],R[3]);break;default:D=""}if(t.disposeData(N.dataId),D)throw t.disposeData(m.dataId),t.disposeData(y.dataId),t.disposeData(v.dataId),t.disposeData(I.dataId),new Error(D);let $=m,_=y;return A!==c[0]&&($=_h({inputs:{x:m},attrs:{begin:0,size:[A,l]},backend:t}),_=_h({inputs:{x:y},attrs:{begin:0,size:A},backend:t}),t.disposeData(m.dataId),t.disposeData(y.dataId)),[$,_,v,I]}var Zxt={kernelName:F1,backendName:"wasm",setupFunc:Xxt,kernelFunc:Yxt},dre;function Jxt(e){dre=e.wasm.cwrap(wx,null,["number","number","number","number","number","number","number"])}function Qxt(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:s,newShape:a}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(a.dataId).id,u=r.shape[0],c=O.sizeFromShape(a.shape),d=t.makeOutput([u,c],r.dtype),p=t.dataIdMap.get(d.dataId).id,h=t.makeOutput([c],a.dtype),m=t.dataIdMap.get(h.dataId).id,g=t.makeOutput([3],"int32"),y=t.dataIdMap.get(g.dataId).id;dre(i,o,l,u,p,m,y);let b=t.readSync(g.dataId),v;switch(b[0]){case 0:{v=V.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break}case 1:{v=V.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break}case 2:v=V.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let k=Array.from(t.readSync(s.dataId)),I=Array.from(t.readSync(h.dataId));v=V.getSparseReshapeInputOutputMultipleErrorMessage(k,I);break}case 4:{let k=Array.from(t.readSync(s.dataId)),I=Array.from(t.readSync(h.dataId));v=V.getSparseReshapeInputOutputMismatchErrorMessage(k,I);break}default:v=""}if(t.disposeData(g.dataId),v)throw t.disposeData(d.dataId),t.disposeData(h.dataId),new Error(v);return[d,h]}var ebt={kernelName:wx,backendName:"wasm",setupFunc:Jxt,kernelFunc:Qxt},pre;function hre(e){pre=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function fre(e,t){let{backend:n,inputs:r}=e,{data:s,indices:a,segmentIds:i}=r,o=a.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(V.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=s.shape.slice();c[0]=u;let d=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(i.dataId).id,m=n.makeOutput(c,s.dtype),g=n.dataIdMap.get(m.dataId).id,y=n.makeOutput([4],"int32"),b=n.dataIdMap.get(y.dataId).id;pre(d,Tn[s.dtype],s.shape[0],p,h,g,b,t,0);let v=n.readSync(y.dataId),k;switch(v[0]){case 0:{k=V.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{k=V.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:k=V.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v[1],v[2]);break;case 3:k=V.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v[1],v[2],v[3]);break;default:k=""}if(n.disposeData(y.dataId),k)throw n.disposeData(m.dataId),new Error(k);return m}function tbt(e){return fre(e,!0)}var nbt={kernelName:O1,backendName:"wasm",setupFunc:hre,kernelFunc:tbt};function rbt(e){return fre(e,!1)}var sbt={kernelName:M1,backendName:"wasm",setupFunc:hre,kernelFunc:rbt},mre;function abt(e){mre=e.wasm.cwrap(kx,null,["number","number","number","number","number","number","number","number","array","number","number"])}function ibt(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=n,{outputShape:o}=r,l=t.makeOutput(o,i.dtype);if(O.sizeFromShape(o)===0)return l;let{sliceRank:u,numUpdates:c,sliceSize:d,strides:p,outputSize:h}=V.calculateShapes(a,s,o),m=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(a.dataId).id,y=t.dataIdMap.get(i.dataId).id,b=new Uint8Array(new Int32Array(p).buffer),v=t.dataIdMap.get(l.dataId).id;return mre(m,g,a.shape.length,y,Tn[i.dtype],u,c,d,b,h,v),l}var obt={kernelName:kx,backendName:"wasm",setupFunc:abt,kernelFunc:ibt};function lbt(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=n,o=O.parseAxisParam(i,s.shape)[0],l=V.prepareSplitSize(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{let p=[...c];p[o]=d;let h=_h({inputs:{x:s},attrs:{begin:u,size:p},backend:r});return u[o]+=d,h})}var ubt={kernelName:vx,backendName:"wasm",kernelFunc:lbt},cbt=yn(nm),dbt=yn(L1),pbt=ts(am),gre;function hbt(e){gre=e.wasm.cwrap(Fd,null,["number","number","number","number"])}function fbt(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:s}=r,{x:a}=n,i=t.dataIdMap.get(a.dataId).id,o=t.makeOutput(a.shape,a.dtype),l=t.dataIdMap.get(o.dataId).id;return gre(i,s,Tn[a.dtype],l),o}var mbt={kernelName:Fd,backendName:"wasm",setupFunc:hbt,kernelFunc:fbt},yre;function gbt(e){yre=e.wasm.cwrap(Ix,null,["number","array","number","array","array","array","array","array","number","number"])}function ybt(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=r,{finalShapeSparse:h,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:k,strides:I}=fs.sliceInfo(s.shape,a,i,o,l,u,c,d,p),S;if(g)S=Ya({inputs:{x:s},backend:t,attrs:{shape:m}});else if(y||b){O.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let N=fs.computeOutShape(v,k,I),T=_h({inputs:{x:s},backend:t,attrs:{begin:v,size:N}});S=Ya({inputs:{x:T},backend:t,attrs:{shape:m}}),t.disposeData(T.dataId)}else{let N=t.makeOutput(h,"float32"),T=t.dataIdMap.get(s.dataId).id,A=new Uint8Array(new Int32Array(O.computeStrides(s.shape)).buffer),R=new Uint8Array(new Int32Array(v).buffer),D=new Uint8Array(new Int32Array(k).buffer),$=new Uint8Array(new Int32Array(I).buffer),_=new Uint8Array(new Int32Array(h).buffer),L=new Uint8Array(new Int32Array(O.computeStrides(h)).buffer),z=t.dataIdMap.get(N.dataId).id;yre(T,A,s.shape.length,R,D,$,_,L,h.length,z),S=Ya({inputs:{x:N},backend:t,attrs:{shape:m}}),t.disposeData(N.dataId)}return S}var xbt={kernelName:Ix,backendName:"wasm",setupFunc:gbt,kernelFunc:ybt};function bbt(e){let{backend:t,inputs:n,attrs:r}=e,{data:s,dataSplits:a}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:u,padWidth:c,preserveShortSequences:d}=r,p=t.readSync(s.dataId),h=t.readSync(a.dataId),[m,g]=HL(p,h,i,o,l,u,c,d),y=t.makeOutput([m.length],"string"),b=t.dataIdMap.get(y.dataId);b.stringBytes=m;let v=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(v).set(g),[y,v]}var vbt={kernelName:z1,backendName:"wasm",kernelFunc:bbt};function wbt(e){let{backend:t,inputs:n,attrs:r}=e,{input:s,delimiter:a}=n,{skipEmpty:i}=r,o=t.readSync(s.dataId),l=t.readSync(a.dataId),[u,c,d]=qL(o,l[0],i),p=c.length,h=t.makeOutput([p,2],"int32");t.typedArrayFromHeap(h).set(u);let m=t.makeOutput([p],"string"),g=t.dataIdMap.get(m.dataId);g.stringBytes=c;let y=t.makeOutput([2],"int32");return t.typedArrayFromHeap(y).set(d),[h,m,y]}var kbt={kernelName:B1,backendName:"wasm",kernelFunc:wbt};function Ibt(e){let{backend:t,inputs:n,attrs:r}=e,{input:s}=n,{numBuckets:a}=r,i=t.readSync(s.dataId),o=KL(i,a),l=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(l).set(o),l}var Sbt={kernelName:W1,backendName:"wasm",kernelFunc:Ibt},Cbt=ts(im),xre;function Nbt(e){xre=e.wasm.cwrap(rm,null,["number","number","number","number"])}function Tbt(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:p,inputWasTransposed:h}=Vd(i,s,t),m=d;if(h){let k=t.dataIdMap.get(c.dataId).id;k!==o&&(u=c,l=k,m=V.getInnerMostAxes(m.length,u.shape.length))}V.assertAxesAreInnerMostDims("sum",m,u.shape.length);let[g,y]=V.computeOutAndReduceShapes(u.shape,m),b=O.sizeFromShape(y),v=t.makeOutput(g,u.dtype);if(O.sizeFromShape(u.shape)!==0){let k=t.dataIdMap.get(v.dataId).id;xre(l,b,Tn[v.dtype],k)}if(h&&t.disposeData(c.dataId),a){let k=V.expandShapeToKeepDim(v.shape,p);v.shape=k}return v}var $bt={kernelName:rm,backendName:"wasm",setupFunc:Nbt,kernelFunc:Tbt},Ebt=yn(om),_bt=yn(lm),bre;function Abt(e){bre=e.wasm.cwrap(mx,null,["number","number","number","number","number","number","array","number","number","number"])}function Rbt(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=n,o=t.makeOutput(s.shape,s.dtype);if(O.sizeFromShape(s.shape)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=AN.calculateShapes(i,a,s.shape),h=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(i.dataId).id,g=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(d).buffer),b=t.dataIdMap.get(o.dataId).id;return bre(h,m,Tn[i.dtype],l,u,c,y,p,b,g),o}var Dbt={kernelName:mx,backendName:"wasm",setupFunc:Abt,kernelFunc:Rbt},vre;function Fbt(e){vre=e.wasm.cwrap(Dd,null,["number","array","number","array","number","number"])}function Obt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,a=n.dataIdMap.get(s.dataId).id,{reps:i}=r,o=new Array(s.shape.length);for(let p=0;p<o.length;p++)o[p]=s.shape[p]*i[p];let l=new Uint8Array(new Int32Array(s.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),c=n.makeOutput(o,s.dtype),d=n.dataIdMap.get(c.dataId).id;return vre(a,l,s.shape.length,u,o.length,Tn[c.dtype],d),c}var Mbt={kernelName:Dd,backendName:"wasm",setupFunc:Fbt,kernelFunc:Obt},wre;function Lbt(e){wre=e.wasm.cwrap(Sx,null,["number","array","number","number","number","bool","number","number"])}var Pbt=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:s,sorted:a}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=s;let u=t.makeOutput(l,r.dtype),c=t.dataIdMap.get(u.dataId).id,d=t.makeOutput(l,"int32"),p=t.dataIdMap.get(d.dataId).id;return wre(i,o,r.shape.length,Tn[r.dtype],s,a,c,p),[u,d]},zbt={kernelName:Sx,backendName:"wasm",setupFunc:Lbt,kernelFunc:Pbt},kre;function Bbt(e){kre=e.wasm.cwrap(Cx,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function Wbt(e){let{backend:t,inputs:n,attrs:r}=e,{image:s,transforms:a}=n,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,p,h]=s.shape,[m,g]=u??[d,p],y=[c,m,g,h],b=new Uint8Array(new Int32Array(O.computeStrides(s.shape)).buffer),v=new Uint8Array(new Int32Array(O.computeStrides(y)).buffer),k=t.makeOutput(y,s.dtype),I=t.dataIdMap.get(k.dataId).id,S=t.dataIdMap.get(s.dataId).id,N=t.dataIdMap.get(a.dataId).id,T=i==="nearest"?1:2,A;switch(o){case"constant":A=1;break;case"reflect":A=2;break;case"wrap":A=3;break;case"nearest":A=4;break;default:A=1;break}return kre(S,N,a.shape[0]>1,c,m,g,h,p,d,b,s.shape.length-1,v,y.length-1,T,A,l,I),k}var Vbt={kernelName:Cx,backendName:"wasm",setupFunc:Bbt,kernelFunc:Wbt};function Ubt(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t,{outputValues:i,outputShape:o,indices:l}=YL(r.readSync(a.dataId),s,a.shape,a.dtype);return[r.makeOutput(o,a.dtype,void 0,i),r.makeOutput([l.length],"int32",void 0,l)]}var Gbt={kernelName:V1,backendName:"wasm",kernelFunc:Ubt};function jbt(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let i=s.shape[a],o=s.shape.length,l=new Array(o-1),u=0;for(let h=0;h<o;h++)h!==a&&(l[u++]=s.shape[h]);let c=new Array(i),d=new Array(o).fill(0),p=s.shape.slice();p[a]=1;for(let h=0;h<c.length;h++)d[a]=h,c[h]=_h({inputs:{x:s},attrs:{begin:d,size:p},backend:n});return c.map(({dataId:h,dtype:m})=>({dataId:h,dtype:m,shape:l}))}var Hbt={kernelName:Nx,backendName:"wasm",kernelFunc:jbt};function qbt(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var Kbt={kernelName:Tx,backendName:"wasm",kernelFunc:qbt},Xbt=[Bht,Wht,Vht,Uht,Ght,qht,tft,sft,aft,ift,oft,lft,uft,cft,dft,fft,Ift,yft,vft,Tft,Dft,Mft,Lft,zft,Bft,Wft,Gft,jft,Kft,Zft,emt,rmt,imt,omt,lmt,dmt,fmt,ymt,vmt,Imt,Nmt,Emt,Rmt,Omt,Pmt,zmt,Vmt,Gmt,jmt,Hmt,qmt,Kmt,Xmt,Jmt,Qmt,egt,rgt,igt,ugt,pgt,mgt,ygt,bgt,Kht,vgt,wgt,kgt,Cgt,Tgt,Egt,Rgt,Fgt,Dgt,Mgt,Lgt,zgt,Wgt,Ggt,qgt,Ygt,Zgt,eyt,ryt,iyt,uyt,pyt,myt,xyt,byt,kyt,Tyt,$yt,Eyt,_yt,Dyt,Myt,zyt,Wyt,Gyt,Hyt,Kyt,Zne,Zyt,ext,rxt,axt,ixt,oxt,lxt,uxt,Sft,pxt,mxt,xxt,wxt,Sxt,Txt,$xt,Ext,Rxt,Oxt,Pxt,zxt,Vxt,Uxt,Gxt,jxt,Aft,Syt,Hxt,Kxt,Zxt,ebt,nbt,sbt,obt,ubt,cbt,dbt,pbt,mbt,xbt,vbt,kbt,Sbt,Cbt,$bt,Ebt,_bt,Dbt,Mbt,zbt,Vbt,Jht,Gbt,Hbt,Kbt];for(let e of Xbt)G1(e);var gR=xe();gR.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});gR.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(gR.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var G6=_d($Pe()),Ybt=_d(EPe()),j6=_d(_Pe()),H6=G6.default||G6,Zbt=j6.default||j6,Ire=class extends w1{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(Sre),yR=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new UC(this,fo())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=O.now();return e(),{kernelMs:O.now()-t}}move(e,t,n,r,s){let a=this.dataIdNextNumber++;if(r==="string"){let u=t;this.dataIdMap.set(e,{id:a,stringBytes:u,shape:n,dtype:r,memoryOffset:null,refCount:s});return}let i=O.sizeFromShape(n),o=i*O.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:a,memoryOffset:l,shape:n,dtype:r,refCount:s}),this.wasm.tfjs.registerTensor(a,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:s,shape:a,stringBytes:i}=this.dataIdMap.get(e);if(s==="string")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||O.sizeFromShape(a);let o=O.bytesPerElement(s),l=this.wasm.HEAPU8.slice(r+t*o,r+n*o);return evt(l.buffer,s)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let s;if(n==null)s=this.write(r??null,e,t);else{let a=this.dataIdNextNumber++;s={id:a},this.dataIdMap.set(s,{id:a,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=O.sizeFromShape(e);this.wasm.tfjs.registerTensor(a,i,n)}return{dataId:s,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),a=O.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,s,a);case"int32":return new Int32Array(r,s,a);case"bool":return new Uint8Array(r,s,a);default:throw new Error(`Unknown dtype ${t}`)}}};function Jbt(e){return(t,n)=>(O.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(s=>{WebAssembly.instantiate(s,t).then(a=>{n(a.instance,a.module)})})}),{})}function q6(e,t,n){if(qI!=null)return qI;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),iv!=null&&iv[r]!=null?iv[r]:n+r}async function Qbt(){let[e,t]=await Promise.all([xe().getAsync("WASM_HAS_SIMD_SUPPORT"),xe().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let s={};s.locateFile=(o,l)=>{if(o.endsWith(".worker.js")){let u=Ybt.wasmWorkerContents.replace(/\n/g,"\\n"),c=new Blob([u],{type:"application/javascript"});return URL.createObjectURL(c)}return o.endsWith(".wasm")?q6(e,t,tv??l):l+o},yP&&(s.instantiateWasm=Jbt(q6(e,t,tv??"")));let a=!1;s.onAbort=()=>{a||ov||(ov=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&qI==null?(s.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+H6.toString()],{type:"text/javascript"}),i=H6(s)):i=Zbt(s),i.then(o=>{a=!0,ov=!1;let l=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",l,["number"]),dispose:o.cwrap("dispose",l,[])},n({wasm:o})}).catch(r)})}function evt(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var tvt=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],qI=null,tv=null,iv={},ov=!1,yP=!1;function nvt(e,t=!1){if(jK("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),ov)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");qI=e,yP=t}function rvt(e,t=!1){if(ov)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")tv=e;else{iv=e;let n=tvt.filter(r=>iv[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}yP=t}var Sre=-1,yR=-1;function svt(e){Sre=e}function avt(){if(yR===-1)throw new Error("WASM backend not initialized.");return yR}var ivt="4.22.0",ovt=2;oN("wasm",async()=>{let{wasm:e}=await Qbt();return new Ire(e)},ovt);var K6="4.22.0",lvt="4.22.0",uvt="4.22.0",cvt="4.22.0",dvt="4.22.0",pvt={tfjs:K6,"tfjs-core":K6,"tfjs-converter":lvt,"tfjs-backend-cpu":uvt,"tfjs-backend-webgl":cvt,"tfjs-backend-wasm":dvt},hvt={};C3(hvt,{AnchorPosition:()=>Bre,DrawBox:()=>Ure,DrawBoxOptions:()=>Vre,DrawFaceLandmarks:()=>ise,DrawFaceLandmarksOptions:()=>ase,DrawTextField:()=>SP,DrawTextFieldOptions:()=>IP,drawContour:()=>Ec,drawDetections:()=>Nvt,drawFaceExpressions:()=>zvt,drawFaceLandmarks:()=>Wvt});function Ec(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:r,y:s},a)=>{let i=t[a];e.moveTo(i.x,i.y),e.lineTo(r,s)}),n){let r=t[t.length-1],s=t[0];if(!r||!s)return;e.moveTo(r.x,r.y),e.lineTo(s.x,s.y)}e.stroke()}var fvt={};C3(fvt,{computeReshapedDimensions:()=>$re,getCenterPoint:()=>bP,isDimensions:()=>bR,isEven:()=>xR,isFloat:()=>Tre,isTensor:()=>Xx,isTensor1D:()=>mvt,isTensor2D:()=>Nre,isTensor3D:()=>Iw,isTensor4D:()=>Fu,isValidNumber:()=>qp,isValidProbablitiy:()=>gvt,range:()=>ey,round:()=>xP});var kg=class Cre{constructor(t,n){if(!qp(t)||!qp(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new Cre(1/this.width,1/this.height)}};function Xx(e,t){return e instanceof Zt&&e.shape.length===t}function mvt(e){return Xx(e,1)}function Nre(e){return Xx(e,2)}function Iw(e){return Xx(e,3)}function Fu(e){return Xx(e,4)}function Tre(e){return e%1!==0}function xR(e){return e%2===0}function xP(e,t=2){let n=10**t;return Math.floor(e*n)/n}function bR(e){return e&&e.width&&e.height}function $re({width:e,height:t},n){let r=n/Math.max(t,e);return new kg(Math.round(e*r),Math.round(t*r))}function bP(e){return e.reduce((t,n)=>t.add(n),new Yn(0,0)).div(new Yn(e.length,e.length))}function ey(e,t,n){return Array(e).fill(0).map((r,s)=>t+s*n)}function qp(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function gvt(e){return qp(e)&&e>=0&&e<=1}var Yn=class kp{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new kp(this.x+t.x,this.y+t.y)}sub(t){return new kp(this.x-t.x,this.y-t.y)}mul(t){return new kp(this.x*t.x,this.y*t.y)}div(t){return new kp(this.x/t.x,this.y/t.y)}abs(){return new kp(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new kp(Math.floor(this.x),Math.floor(this.y))}},Ah=class Vo{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(qp)}static assertIsValidBox(t,n,r=!1){if(!Vo.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let r=t||{},s=[r.left,r.top,r.right,r.bottom].every(qp),a=[r.x,r.y,r.width,r.height].every(qp);if(!a&&!s)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[i,o,l,u]=a?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];Vo.assertIsValidBox({x:i,y:o,width:l,height:u},"Box.constructor",n),this._x=i,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Yn(this.left,this.top)}get topRight(){return new Yn(this.right,this.top)}get bottomLeft(){return new Yn(this.left,this.bottom)}get bottomRight(){return new Yn(this.right,this.bottom)}round(){let[t,n,r,s]=[this.x,this.y,this.width,this.height].map(a=>Math.round(a));return new Vo({x:t,y:n,width:r,height:s})}floor(){let[t,n,r,s]=[this.x,this.y,this.width,this.height].map(a=>Math.floor(a));return new Vo({x:t,y:n,width:r,height:s})}toSquare(){let{x:t,y:n,width:r,height:s}=this,a=Math.abs(r-s);return r<s&&(t-=a/2,r+=a),s<r&&(n-=a/2,s+=a),new Vo({x:t,y:n,width:r,height:s})}rescale(t){let n=bR(t)?t.width:t,r=bR(t)?t.height:t;return new Vo({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,s,a,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new Vo({x:r,y:s,width:a,height:i})}clipAtImageBorders(t,n){let{x:r,y:s,right:a,bottom:i}=this,o=Math.max(r,0),l=Math.max(s,0),u=a-o,c=i-l,d=Math.min(u,t-o),p=Math.min(c,n-l);return new Vo({x:o,y:l,width:d,height:p}).floor()}shift(t,n){let{width:r,height:s}=this,a=this.x+t,i=this.y+n;return new Vo({x:a,y:i,width:r,height:s})}padAtBorders(t,n){let r=this.width+1,s=this.height+1,a=1,i=1,o=r,l=s,u=this.left,c=this.top,d=this.right,p=this.bottom;return d>n&&(o=-d+n+r,d=n),p>t&&(l=-p+t+s,p=t),u<1&&(l=2-u,u=1),c<1&&(l=2-c,c=1),{dy:i,edy:l,dx:a,edx:o,y:c,ey:p,x:u,ex:d,w:r,h:s}}calibrate(t){return new Vo({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},Ere=class extends Ah{constructor(e,t,n,r,s=!1){super({left:e,top:t,right:n,bottom:r},s)}},_re=class Are{constructor(t,n,r,s,a){this._imageDims=new kg(a.width,a.height),this._score=t,this._classScore=n,this._className=r,this._box=new Ah(s).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Ah(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new Are(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},dl=class Rre extends _re{constructor(t,n,r){super(t,t,"",n,r)}forSize(t,n){let{score:r,relativeBox:s,imageDims:a}=super.forSize(t,n);return new Rre(r,s,a)}};function yvt(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),s=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),a=r*s;return n?a/(e.area+t.area-a):a/Math.min(e.area,t.area)}function xvt(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),r=t.reduce((o,l)=>l<o?l:o,1/0),s=n.reduce((o,l)=>l<o?l:o,1/0),a=t.reduce((o,l)=>o<l?l:o,0),i=n.reduce((o,l)=>o<l?l:o,0);return new Ere(r,s,a,i)}function bvt(e,t,n,r=!0){let s=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),a=[];for(;s.length>0;){let i=s.pop();a.push(i);let o=s,l=[];for(let u=0;u<o.length;u++){let c=o[u],d=e[i],p=e[c];l.push(yvt(d,p,r))}s=s.filter((u,c)=>l[c]<=n)}return a}function Sw(e,t){return ce(()=>{let[n,r,s]=t,a=wi([...e.shape.slice(0,3),1],n,"float32"),i=wi([...e.shape.slice(0,3),1],r,"float32"),o=wi([...e.shape.slice(0,3),1],s,"float32"),l=Jn([a,i,o],3);return at(e,l)})}function vvt(e,t=!1){return ce(()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let s=Math.abs(n-r),a=Math.round(s*(t?.5:1)),i=n>r?2:1,o=d=>{let p=e.shape.slice();return p[i]=d,wi(p,0,"float32")},l=o(a),u=s-l.shape[i],c=[t&&u?o(u):null,e,l].filter(d=>!!d).map(d=>Ke(d,"float32"));return Jn(c,i)})}function JE(e){return 1/(1+Math.exp(-e))}var Dre=class extends Ah{constructor(e,t,n,r,s=!1){super({x:e,y:t,width:n,height:r},s)}},wvt=.5,kvt=.43,Ivt=.45,KI=class{constructor(e,t,n=new Yn(0,0)){let{width:r,height:s}=t;this._imgDims=new kg(r,s),this._shift=n,this._positions=e.map(a=>a.mul(new Yn(r,s)).add(n))}get shift(){return new Yn(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new Yn(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new Yn(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let s=e instanceof dl?e.box.floor():new Ah(e);return this.shiftBy(s.x,s.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,s=c=>r.sub(c).magnitude(),a=(s(t)+s(n))/2,i=Math.floor(a/Ivt),o=bP(e),l=Math.floor(Math.max(0,o.x-wvt*i)),u=Math.floor(Math.max(0,o.y-kvt*i));return new Dre(l,u,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+u))}alignMinBbox(e){let t=xvt(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},Fre=class extends KI{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(bP)}};function XI(e){return e.detection instanceof dl}function Ore(e,t){return{...e,detection:t}}function Mre(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function vP(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function Lre(e){let t="";if(!e&&vP())try{e=iPe("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((r,s)=>{e.readFile(n,(a,i)=>a?s(a):r(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function Pre(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},s=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},a=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=global.fetch,o=Lre();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:r,createImageElement:s,createVideoElement:a,fetch:i,...o}}function zre(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var Is;function Svt(){if(!Is)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Is}function vR(e){Is=e}function wP(){return zre()?vR(Mre()):vP()?vR(Pre()):null}function Cvt(e){if(Is||wP(),!Is)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Is.Canvas,Image:n=Is.Image}=e;Is.Canvas=t,Is.Image=n,Is.createCanvasElement=e.createCanvasElement||(()=>new t),Is.createImageElement=e.createImageElement||(()=>new n),Is.ImageData=e.ImageData||Is.ImageData,Is.Video=e.Video||Is.Video,Is.fetch=e.fetch||Is.fetch,Is.readFile=e.readFile||Is.readFile}var ni={getEnv:Svt,setEnv:vR,initialize:wP,createBrowserEnv:Mre,createFileSystem:Lre,createNodejsEnv:Pre,monkeyPatch:Cvt,isBrowser:zre,isNodejs:vP};wP();function kP(e){return!ni.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function gd(e){let{Canvas:t,CanvasRenderingContext2D:n}=ni.getEnv();if(e instanceof n)return e;let r=kP(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let s=r.getContext("2d",{willReadFrequently:!0});if(!s)throw new Error("resolveContext2d - canvas 2d context is null");return s}var Bre=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(Bre||{}),IP=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:s,fontStyle:a,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=s||14,this.fontStyle=a||"Georgia",this.padding=i||4}},SP=class Wre{constructor(t,n,r={}){this.text=typeof t=="string"?[t]:t instanceof Wre?t.text:t,this.anchor=n,this.options=new IP(r)}measureWidth(t){let{padding:n}=this.options;return this.text.map(r=>t.measureText(r).width).reduce((r,s)=>r<s?s:r,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:r}=this.options,s=r==="BOTTOM_RIGHT"||r==="TOP_RIGHT",a=r==="BOTTOM_LEFT"||r==="BOTTOM_RIGHT",i=this.measureWidth(t),o=this.measureHeight(),l=s?this.anchor.x-i:this.anchor.x,u=a?this.anchor.y-o:this.anchor.y;if(n){let{width:c,height:d}=n,p=Math.max(Math.min(l,c-i),0),h=Math.max(Math.min(u,d-o),0);return{x:p,y:h}}return{x:l,y:u}}draw(t){let n=kP(t),r=gd(n),{backgroundColor:s,fontColor:a,fontSize:i,fontStyle:o,padding:l}=this.options;r.font=`${i}px ${o}`;let u=this.measureWidth(r),c=this.measureHeight();r.fillStyle=s;let d=this.getUpperLeft(r,n);r.fillRect(d.x,d.y,u,c),r.fillStyle=a,this.text.forEach((p,h)=>{let m=l+d.x,g=l+d.y+(h+1)*i;r.fillText(p,m,g)})}},Vre=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:s}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let a={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new IP({...a,...s})}},Ure=class{constructor(e,t={}){this.box=new Ah(e),this.options=new Vre(t)}draw(e){let t=gd(e),{boxColor:n,lineWidth:r}=this.options,{x:s,y:a,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(s,a,i,o);let{label:l}=this.options;l&&new SP([l],{x:s-r/2,y:a},this.options.drawLabelOptions).draw(e)}};function Nvt(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof dl?n.score:XI(n)?n.detection.score:void 0,s=n instanceof dl?n.box:XI(n)?n.detection.box:new Ah(n),a=r?`${xP(r)}`:void 0;new Ure(s,{label:a}).draw(e)})}function Gre(e){let{Image:t,Video:n}=ni.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function Tvt(e){return new Promise((t,n)=>{if(e instanceof ni.getEnv().Canvas||Gre(e)){t(null);return}function r(a){a.currentTarget&&(a.currentTarget.removeEventListener("load",s),a.currentTarget.removeEventListener("error",r),n(a))}function s(a){a.currentTarget&&(a.currentTarget.removeEventListener("load",s),a.currentTarget.removeEventListener("error",r),t(a))}e.addEventListener("load",s),e.addEventListener("error",r)})}function jre(e){let{Image:t,Video:n}=ni.getEnv();return e instanceof t?new kg(e.naturalWidth,e.naturalHeight):e instanceof n?new kg(e.videoWidth,e.videoHeight):new kg(e.width,e.height)}function YI({width:e,height:t}){let{createCanvasElement:n}=ni.getEnv(),r=n();return r.width=e,r.height=t,r}function Hre(e,t){let{ImageData:n}=ni.getEnv();if(!(e instanceof n)&&!Gre(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:s}=jre(e),a=YI({width:r,height:s});return e instanceof n?gd(a).putImageData(e,0,0):gd(a).drawImage(e,0,0,r,s),a}async function $vt(e,t){let n=t||ni.getEnv().createCanvasElement(),[r,s,a]=e.shape.slice(Fu(e)?1:0),i=ce(()=>e.as3D(r,s,a).toInt());return await uw.toPixels(i,n),i.dispose(),n}function X6(e){let{Image:t,Canvas:n,Video:r}=ni.getEnv();return e instanceof t||e instanceof n||e instanceof r}function Evt(e,t,n=!1){let{Image:r,Canvas:s}=ni.getEnv();if(!(e instanceof r||e instanceof s))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return YI({width:1,height:1});let a=jre(e),i=t/Math.max(a.height,a.width),o=i*a.width,l=i*a.height,u=YI({width:t,height:t}),c=e instanceof s?e:Hre(e),d=Math.abs(o-l)/2,p=n&&o<l?d:0,h=n&&l<o?d:0;return c.width>0&&c.height>0&&gd(u).drawImage(c,p,h,o,l),u}var ZI=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,r)=>{if(Iw(n)){this._imageTensors[r]=n,this._inputDimensions[r]=n.shape;return}if(Fu(n)){let a=n.shape[0];if(a!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${a} passed, but not supported in input array`);this._imageTensors[r]=n,this._inputDimensions[r]=n.shape.slice(1);return}let s=n instanceof ni.getEnv().Canvas?n:Hre(n);this._canvases[r]=s,this._inputDimensions[r]=[s.height,s.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return ey(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return $re({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,ce(()=>{let n=ey(this.batchSize,0,1).map(r=>{let s=this.getInput(r);if(s instanceof Zt){let a=Fu(s)?s:$s(s);return a=vvt(a,t),(a.shape[1]!==e||a.shape[2]!==e)&&(a=Bi.resizeBilinear(a,[e,e],!1,!1)),a.as3D(e,e,3)}if(s instanceof ni.getEnv().Canvas)return uw.fromPixels(Evt(s,e,t));throw new Error(`toBatchTensor - at batchIdx ${r}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${s}`)});return Yr(n.map(r=>Ke(r,"float32"))).as4D(this.batchSize,e,e,3)})}};async function Ra(e){if(e instanceof ZI)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=s=>Array.isArray(e)?` at input index ${s}:`:"",r=t.map(kP);return r.forEach((s,a)=>{if(!X6(s)&&!Iw(s)&&!Fu(s))throw typeof t[a]=="string"?new Error(`toNetInput -${n(a)} string passed, but could not resolve HTMLElement for element id ${t[a]}`):new Error(`toNetInput -${n(a)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(Fu(s)){let i=s.shape[0];if(i!==1)throw new Error(`toNetInput -${n(a)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(r.map(s=>X6(s)&&Tvt(s))),new ZI(r,Array.isArray(e))}async function CP(e,t){let{Canvas:n}=ni.getEnv(),r=e;if(!(e instanceof n)){let a=await Ra(e);if(a.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=a.getInput(0);r=i instanceof n?i:await $vt(i)}let s=gd(r);return t.map(a=>a instanceof dl?a.forSize(r.width,r.height).box.floor():a).map(a=>a.clipAtImageBorders(r.width,r.height)).map(({x:a,y:i,width:o,height:l})=>{let u=YI({width:o,height:l});return o>0&&l>0&&gd(u).putImageData(s.getImageData(a,i,o,l),0,0),u})}async function NP(e,t){if(!Iw(e)&&!Fu(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(Fu(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return ce(()=>{let[n,r,s]=e.shape.slice(Fu(e)?1:0);return t.map(a=>a instanceof dl?a.forSize(r,n).box:a).map(a=>a.clipAtImageBorders(r,n)).filter(a=>a.width>0&&a.height>0).map(({x:a,y:i,width:o,height:l})=>Ox(e.as3D(n,r,s),[i,a,0],[l,o,s]))})}async function _vt(e,t){let{fetch:n}=ni.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function Avt(e){return(await _vt(e)).json()}function qre(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let s=e.split("/").filter(o=>o),a=e.endsWith(".json")?s[s.length-1]:n,i=r+(e.endsWith(".json")?s.slice(0,s.length-1):s).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${a}`:`${i}/${a}`}}async function Rvt(e,t){let{manifestUri:n,modelBaseUri:r}=qre(e,t),s=await Avt(n);return qs.loadWeights(s,r)}var Gd=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof mh)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof mh))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=$a(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await Rvt(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=ni.getEnv(),{manifestUri:n,modelBaseUri:r}=qre(e,this.getDefaultModelName()),s=l=>Promise.all(l.map(u=>t(u).then(c=>typeof c=="string"?Buffer.from(c):c.buffer))),a=qs.weightsLoaderFactory(s),i=JSON.parse((await t(n)).toString()),o=await a(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((s,a)=>{if(!s.nextObj.hasOwnProperty(a))throw new Error(`traversePropertyPath - object does not have property ${a}, for path ${e}`);return{obj:s.nextObj,objProp:a,nextObj:s.nextObj[a]}},{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof Zt))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function Ui(e,t,n){return ce(()=>{let r=Fx(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=Ae(r,t.bias),r})}function QE(e,t,n=!1){return ce(()=>{let r=Un(n?Ae(_a(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):Ui(e,t.conv0,[2,2])),s=Ui(r,t.conv1,[1,1]),a=Un(Ae(r,s)),i=Ui(a,t.conv2,[1,1]);return Un(Ae(r,Ae(s,i)))})}function l2(e,t,n=!1,r=!0){return ce(()=>{let s=Un(n?Ae(_a(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):Ui(e,t.conv0,r?[2,2]:[1,1])),a=Ui(s,t.conv1,[1,1]),i=Un(Ae(s,a)),o=Ui(i,t.conv2,[1,1]),l=Un(Ae(s,Ae(a,o))),u=Ui(l,t.conv3,[1,1]);return Un(Ae(s,Ae(a,Ae(o,u))))})}function lv(e,t,n="same",r=!1){return ce(()=>{let s=Ae(_a(e,t.filters,[1,1],n),t.bias);return r?Un(s):s})}function jd(e,t){Object.keys(e).forEach(n=>{t.some(r=>r.originalPath===n)||e[n].dispose()})}function TP(e,t){return(n,r,s,a)=>{let i=ud(e(n*r*s*s),[s,s,n,r]),o=Ln(e(r));return t.push({paramPath:`${a}/filters`},{paramPath:`${a}/bias`}),{filters:i,bias:o}}}function Kre(e,t){return(n,r,s)=>{let a=Kl(e(n*r),[n,r]),i=Ln(e(r));return t.push({paramPath:`${s}/weights`},{paramPath:`${s}/bias`}),{weights:a,bias:i}}}var Xre=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function $P(e,t){return(n,r,s)=>{let a=ud(e(9*n),[3,3,n,1]),i=ud(e(n*r),[1,1,n,r]),o=Ln(e(r));return t.push({paramPath:`${s}/depthwise_filter`},{paramPath:`${s}/pointwise_filter`},{paramPath:`${s}/bias`}),new Xre(a,i,o)}}function EP(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),s=e(`${t}/bias`,1);return new Xre(n,r,s)}}function vm(e,t){return(n,r,s)=>{let a=e[n];if(!Xx(a,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${a}`);return t.push({originalPath:n,paramPath:s||n}),a}}function Hd(e){let t=e;function n(s){let a=t.slice(0,s);return t=t.slice(s),a}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function Yre(e,t){let n=TP(e,t),r=$P(e,t);function s(i,o,l,u=!1){let c=u?n(i,o,3,`${l}/conv0`):r(i,o,`${l}/conv0`),d=r(o,o,`${l}/conv1`),p=r(o,o,`${l}/conv2`);return{conv0:c,conv1:d,conv2:p}}function a(i,o,l,u=!1){let{conv0:c,conv1:d,conv2:p}=s(i,o,l,u),h=r(o,o,`${l}/conv3`);return{conv0:c,conv1:d,conv2:p,conv3:h}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:a}}function Dvt(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Hd(e),{extractDenseBlock4Params:s}=Yre(n,t),a=s(3,32,"dense0",!0),i=s(32,64,"dense1"),o=s(64,128,"dense2"),l=s(128,256,"dense3");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:a,dense1:i,dense2:o,dense3:l}}}function Zre(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function Jre(e,t){let n=vm(e,t),r=Zre(n),s=EP(n);function a(o,l=!1){let u=l?r(`${o}/conv0`):s(`${o}/conv0`),c=s(`${o}/conv1`),d=s(`${o}/conv2`);return{conv0:u,conv1:c,conv2:d}}function i(o,l=!1){let u=l?r(`${o}/conv0`):s(`${o}/conv0`),c=s(`${o}/conv1`),d=s(`${o}/conv2`),p=s(`${o}/conv3`);return{conv0:u,conv1:c,conv2:d,conv3:p}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:i}}function Fvt(e){let t=[],{extractDenseBlock4Params:n}=Jre(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return jd(e,t),{params:r,paramMappings:t}}var Qre=class extends Gd{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return ce(()=>{let n=Ke(e.toBatchTensor(112,!0),"float32"),r=Sw(n,[122.782,117.001,104.298]).div(255),s=l2(r,t.dense0,!0);return s=l2(s,t.dense1),s=l2(s,t.dense2),s=l2(s,t.dense3),s=Zu(s,[7,7],[2,2],"valid"),s})}async forward(e){return this.forwardInput(await Ra(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return Fvt(e)}extractParams(e){return Dvt(e)}};function wR(e,t){return ce(()=>Ae(Qt(e,t.weights),t.bias))}function Ovt(e,t,n){let r=[],{extractWeights:s,getRemainingWeights:a}=Hd(e),i=Kre(s,r)(t,n,"fc");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:r,params:{fc:i}}}function Mvt(e){let t=[],n=vm(e,t);function r(a){let i=n(`${a}/weights`,2),o=n(`${a}/bias`,1);return{weights:i,bias:o}}let s={fc:r("fc")};return jd(e,t),{params:s,paramMappings:t}}function ese(e){let t={},n={};return Object.keys(e).forEach(r=>{let s=r.startsWith("fc")?n:t;s[r]=e[r]}),{featureExtractorMap:t,classifierMap:n}}var tse=class extends Gd{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ce(()=>{let n=e instanceof ZI?this.faceFeatureExtractor.forwardInput(e):e;return wR(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return Ovt(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=ese(e);return this.faceFeatureExtractor.loadFromWeightMap(t),Mvt(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,s=e.slice(0,e.length-r),a=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(s),this.extractClassifierParams(a)}},Y6=["neutral","happy","sad","angry","fearful","disgusted","surprised"],_P=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);Y6.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return Y6.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},Lvt=class extends tse{constructor(e=new Qre){super("FaceExpressionNet",e)}forwardInput(e){return ce(()=>Pd(this.runNet(e)))}async forward(e){return this.forwardInput(await Ra(e))}async predictExpressions(e){let t=await Ra(e),n=await this.forwardInput(t),r=await Promise.all(Fr(n).map(async a=>{let i=a.dataSync();return a.dispose(),i}));n.dispose();let s=r.map(a=>new _P(a));return t.isBatchInput?s:s[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function Pvt(e){return e.expressions instanceof _P}function nse(e,t){return{...e,expressions:t}}function zvt(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach(s=>{let a=s instanceof _P?s:Pvt(s)?s.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=a.asSortedArray().filter(l=>l.probability>n),o=XI(s)?s.detection.box.bottomLeft:r||new Yn(0,0);new SP(i.map(l=>`${l.expression} (${xP(l.probability)})`),o).draw(e)})}function rse(e){return XI(e)&&e.landmarks instanceof KI&&e.unshiftedLandmarks instanceof KI&&e.alignedRect instanceof dl}function Bvt(e){let t=l=>l*180/Math.PI,n=(l,u)=>Math.sqrt((l.x-u.x)**2+(l.y-u.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0},s=(l,u,c)=>{let d=Math.floor(l.x-u.x),p=Math.floor(u.x-c.x);return d-p},a=(l,u)=>{let c=Math.hypot(u.x-l.x,u.y-l.y),d=u.y-l.y,p=Math.asin(d/c),h=t(p),m=Math.floor(90-h),g=u.x-l.x<0?-1:1;return m*g},i=(l,u,c)=>{let d=n(l,c),p=new Yn((l.x+c.x)/2,(l.y+c.y)/2),h=n(u,p),m=Math.atan(h/d),g=Math.floor(t(m)),y=p.y-u.y<0?-1:1;return g*y};if(!e||!e.positions||e.positions.length!==68)return r;let o=e.positions;return r.roll=a(o[27],o[66]),r.pitch=i(o[14],o[30],o[2]),r.yaw=s(o[14],o[33],o[2]),r}function sse(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),s=r.align(),{imageDims:a}=e.detection,i=new dl(e.detection.score,s.rescale(a.reverse()),a),o=Bvt(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var ase=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:s,pointSize:a,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=a||2,this.lineColor=s||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},ise=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new ase(t)}draw(e){let t=gd(e),{drawLines:n,drawPoints:r,lineWidth:s,lineColor:a,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof Fre&&(t.strokeStyle=a,t.lineWidth=s,Ec(t,this.faceLandmarks.getJawOutline()),Ec(t,this.faceLandmarks.getLeftEyeBrow()),Ec(t,this.faceLandmarks.getRightEyeBrow()),Ec(t,this.faceLandmarks.getNose()),Ec(t,this.faceLandmarks.getLeftEye(),!0),Ec(t,this.faceLandmarks.getRightEye(),!0),Ec(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let l=u=>{t.beginPath(),t.arc(u.x,u.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(l)}}};function Wvt(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof KI?n:rse(n)?n.landmarks:void 0;if(!r)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new ise(r).draw(e)})}function Vvt(e,t){let n=TP(e,t),r=$P(e,t);function s(i,o,l){let u=r(i,o,`${l}/separable_conv0`),c=r(o,o,`${l}/separable_conv1`),d=n(i,o,1,`${l}/expansion_conv`);return{separable_conv0:u,separable_conv1:c,expansion_conv:d}}function a(i,o){let l=r(i,i,`${o}/separable_conv0`),u=r(i,i,`${o}/separable_conv1`),c=r(i,i,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:c}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:a}}function Uvt(e,t){let n=[],{extractWeights:r,getRemainingWeights:s}=Hd(e),{extractConvParams:a,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=Vvt(r,n),u=a(3,32,3,"entry_flow/conv_in"),c=o(32,64,"entry_flow/reduction_block_0"),d=o(64,128,"entry_flow/reduction_block_1"),p={conv_in:u,reduction_block_0:c,reduction_block_1:d},h={};ey(t,0,1).forEach(b=>{h[`main_block_${b}`]=l(128,`middle_flow/main_block_${b}`)});let m=o(128,256,"exit_flow/reduction_block"),g=i(256,512,"exit_flow/separable_conv"),y={reduction_block:m,separable_conv:g};if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:n,params:{entry_flow:p,middle_flow:h,exit_flow:y}}}function Gvt(e,t){let n=vm(e,t),r=Zre(n),s=EP(n);function a(o){let l=s(`${o}/separable_conv0`),u=s(`${o}/separable_conv1`),c=r(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:u,expansion_conv:c}}function i(o){let l=s(`${o}/separable_conv0`),u=s(`${o}/separable_conv1`),c=s(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:c}}return{extractConvParams:r,extractSeparableConvParams:s,extractReductionBlockParams:a,extractMainBlockParams:i}}function jvt(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:s,extractReductionBlockParams:a,extractMainBlockParams:i}=Gvt(e,n),o=r("entry_flow/conv_in"),l=a("entry_flow/reduction_block_0"),u=a("entry_flow/reduction_block_1"),c={conv_in:o,reduction_block_0:l,reduction_block_1:u},d={};ey(t,0,1).forEach(g=>{d[`main_block_${g}`]=i(`middle_flow/main_block_${g}`)});let p=a("exit_flow/reduction_block"),h=s("exit_flow/separable_conv"),m={reduction_block:p,separable_conv:h};return jd(e,n),{params:{entry_flow:c,middle_flow:d,exit_flow:m},paramMappings:n}}function ose(e,t,n){return Ae(_a(e,t.filters,n,"same"),t.bias)}function e_(e,t,n=!0){let r=n?Un(e):e;return r=Ui(r,t.separable_conv0,[1,1]),r=Ui(Un(r),t.separable_conv1,[1,1]),r=Ss(r,[3,3],[2,2],"same"),r=Ae(r,ose(e,t.expansion_conv,[2,2])),r}function Hvt(e,t){let n=Ui(Un(e),t.separable_conv0,[1,1]);return n=Ui(Un(n),t.separable_conv1,[1,1]),n=Ui(Un(n),t.separable_conv2,[1,1]),n=Ae(n,e),n}var qvt=class extends Gd{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return ce(()=>{let n=Ke(e.toBatchTensor(112,!0),"float32"),r=Sw(n,[122.782,117.001,104.298]).div(255),s=Un(ose(r,t.entry_flow.conv_in,[2,2]));return s=e_(s,t.entry_flow.reduction_block_0,!1),s=e_(s,t.entry_flow.reduction_block_1),ey(this._numMainBlocks,0,1).forEach(a=>{s=Hvt(s,t.middle_flow[`main_block_${a}`])}),s=e_(s,t.exit_flow.reduction_block),s=Un(Ui(s,t.exit_flow.separable_conv,[1,1])),s})}async forward(e){return this.forwardInput(await Ra(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return jvt(e,this._numMainBlocks)}extractParams(e){return Uvt(e,this._numMainBlocks)}};function Kvt(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Hd(e),s=Kre(n,t),a=s(512,1,"fc/age"),i=s(512,2,"fc/gender");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:a,gender:i}}}}function Xvt(e){let t=[],n=vm(e,t);function r(a){let i=n(`${a}/weights`,2),o=n(`${a}/bias`,1);return{weights:i,bias:o}}let s={fc:{age:r("fc/age"),gender:r("fc/gender")}};return jd(e,t),{params:s,paramMappings:t}}var Yvt=(e=>(e.FEMALE="female",e.MALE="male",e))(Yvt||{}),Zvt=class extends Gd{constructor(e=new qvt(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ce(()=>{let n=e instanceof ZI?this.faceFeatureExtractor.forwardInput(e):e,r=Zu(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),s=wR(r,t.fc.age).as1D(),a=wR(r,t.fc.gender);return{age:s,gender:a}})}forwardInput(e){return ce(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:Pd(n)}})}async forward(e){return this.forwardInput(await Ra(e))}async predictAgeAndGender(e){let t=await Ra(e),n=await this.forwardInput(t),r=Fr(n.age),s=Fr(n.gender),a=r.map((o,l)=>({ageTensor:o,genderTensor:s[l]})),i=await Promise.all(a.map(async({ageTensor:o,genderTensor:l})=>{let u=o.dataSync()[0],c=l.dataSync()[0],d=c>.5,p=d?"male":"female",h=d?c:1-c;return o.dispose(),l.dispose(),{age:u,gender:p,genderProbability:h}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return Kvt(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=ese(e);return this.faceFeatureExtractor.loadFromWeightMap(t),Xvt(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},lse=class extends tse{postProcess(e,t,n){let r=n.map(({width:a,height:i})=>{let o=t/Math.max(i,a);return{width:a*o,height:i*o}}),s=r.length;return ce(()=>{let a=(u,c)=>Yr([wi([68],u,"float32"),wi([68],c,"float32")],1).as2D(1,136).as1D(),i=(u,c)=>{let{width:d,height:p}=r[u];return c(d,p)?Math.abs(d-p)/2:0},o=u=>i(u,(c,d)=>c<d),l=u=>i(u,(c,d)=>d<c);return e.mul(wi([s,136],t,"float32")).sub(Yr(Array.from(Array(s),(u,c)=>a(o(c),l(c))))).div(Yr(Array.from(Array(s),(u,c)=>a(r[c].width,r[c].height))))})}forwardInput(e){return ce(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,r])=>({height:n,width:r})))})}async forward(e){return this.forwardInput(await Ra(e))}async detectLandmarks(e){let t=await Ra(e),n=ce(()=>Fr(this.forwardInput(t))),r=await Promise.all(n.map(async(s,a)=>{let i=Array.from(s.dataSync()),o=i.filter((u,c)=>xR(c)),l=i.filter((u,c)=>!xR(c));return new Fre(Array(68).fill(0).map((u,c)=>new Yn(o[c],l[c])),{height:t.getInputHeight(a),width:t.getInputWidth(a)})}));return n.forEach(s=>s.dispose()),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},Jvt=class extends lse{constructor(e=new Qre){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function Qvt(e){let t=[],{extractDenseBlock3Params:n}=Jre(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return jd(e,t),{params:r,paramMappings:t}}function e0t(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Hd(e),{extractDenseBlock3Params:s}=Yre(n,t),a=s(3,32,"dense0",!0),i=s(32,64,"dense1"),o=s(64,128,"dense2");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:a,dense1:i,dense2:o}}}var t0t=class extends Gd{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return ce(()=>{let n=Ke(e.toBatchTensor(112,!0),"float32"),r=Sw(n,[122.782,117.001,104.298]).div(255),s=QE(r,t.dense0,!0);return s=QE(s,t.dense1),s=QE(s,t.dense2),s=Zu(s,[14,14],[2,2],"valid"),s})}async forward(e){return this.forwardInput(await Ra(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return Qvt(e)}extractParams(e){return e0t(e)}},n0t=class extends lse{constructor(e=new t0t){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function r0t(e,t){return Ae(oe(e,t.weights),t.biases)}function AP(e,t,n,r,s="same"){let{filters:a,bias:i}=t.conv,o=_a(e,a,n,s);return o=Ae(o,i),o=r0t(o,t.scale),r?Un(o):o}function s0t(e,t){return AP(e,t,[1,1],!0)}function use(e,t){return AP(e,t,[1,1],!1)}function cse(e,t){return AP(e,t,[2,2],!0,"valid")}function a0t(e,t){function n(o,l,u){let c=e(o),d=c.length/(l*u*u);if(Tre(d))throw new Error(`depth has to be an integer: ${d}, weights.length: ${c.length}, numFilters: ${l}, filterSize: ${u}`);return ce(()=>en(ud(c,[l,d,u,u]),[2,3,1,0]))}function r(o,l,u,c){let d=n(o,l,u),p=Ln(e(l));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/bias`}),{filters:d,bias:p}}function s(o,l){let u=Ln(e(o)),c=Ln(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:u,biases:c}}function a(o,l,u,c){let d=r(o,l,u,`${c}/conv`),p=s(l,`${c}/scale`);return{conv:d,scale:p}}function i(o,l,u,c,d=!1){let p=a((d?.5:1)*o,l,u,`${c}/conv1`),h=a(o,l,u,`${c}/conv2`);return{conv1:p,conv2:h}}return{extractConvLayerParams:a,extractResidualLayerParams:i}}function i0t(e){let{extractWeights:t,getRemainingWeights:n}=Hd(e),r=[],{extractConvLayerParams:s,extractResidualLayerParams:a}=a0t(t,r),i=s(4704,32,7,"conv32_down"),o=a(9216,32,3,"conv32_1"),l=a(9216,32,3,"conv32_2"),u=a(9216,32,3,"conv32_3"),c=a(36864,64,3,"conv64_down",!0),d=a(36864,64,3,"conv64_1"),p=a(36864,64,3,"conv64_2"),h=a(36864,64,3,"conv64_3"),m=a(147456,128,3,"conv128_down",!0),g=a(147456,128,3,"conv128_1"),y=a(147456,128,3,"conv128_2"),b=a(589824,256,3,"conv256_down",!0),v=a(589824,256,3,"conv256_1"),k=a(589824,256,3,"conv256_2"),I=a(589824,256,3,"conv256_down_out"),S=ce(()=>en(Kl(t(256*128),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:c,conv64_1:d,conv64_2:p,conv64_3:h,conv128_down:m,conv128_1:g,conv128_2:y,conv256_down:b,conv256_1:v,conv256_2:k,conv256_down_out:I,fc:S},paramMappings:r}}function o0t(e,t){let n=vm(e,t);function r(i){let o=n(`${i}/scale/weights`,1),l=n(`${i}/scale/biases`,1);return{weights:o,biases:l}}function s(i){let o=n(`${i}/conv/filters`,4),l=n(`${i}/conv/bias`,1),u=r(i);return{conv:{filters:o,bias:l},scale:u}}function a(i){return{conv1:s(`${i}/conv1`),conv2:s(`${i}/conv2`)}}return{extractConvLayerParams:s,extractResidualLayerParams:a}}function l0t(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=o0t(e,t),s=n("conv32_down"),a=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),c=r("conv64_2"),d=r("conv64_3"),p=r("conv128_down"),h=r("conv128_1"),m=r("conv128_2"),g=r("conv256_down"),y=r("conv256_1"),b=r("conv256_2"),v=r("conv256_down_out"),{fc:k}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!Nre(k))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${k}`);let I={conv32_down:s,conv32_1:a,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:c,conv64_3:d,conv128_down:p,conv128_1:h,conv128_2:m,conv256_down:g,conv256_1:y,conv256_2:b,conv256_down_out:v,fc:k};return jd(e,t),{params:I,paramMappings:t}}function Cl(e,t){let n=s0t(e,t.conv1);return n=use(n,t.conv2),n=Ae(n,e),n=Un(n),n}function u2(e,t){let n=cse(e,t.conv1);n=use(n,t.conv2);let r=Zu(e,2,2,"valid"),s=Cr(r.shape),a=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let o=Cr(i);n=Jn([n,o],1);let l=[...n.shape];l[2]=1;let u=Cr(l);n=Jn([n,u],2)}return r=a?Jn([r,s],3):r,n=Ae(r,n),n=Un(n),n}var u0t=class extends Gd{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return ce(()=>{let n=Ke(e.toBatchTensor(150,!0),"float32"),r=Sw(n,[122.782,117.001,104.298]).div(255),s=cse(r,t.conv32_down);s=Ss(s,3,2,"valid"),s=Cl(s,t.conv32_1),s=Cl(s,t.conv32_2),s=Cl(s,t.conv32_3),s=u2(s,t.conv64_down),s=Cl(s,t.conv64_1),s=Cl(s,t.conv64_2),s=Cl(s,t.conv64_3),s=u2(s,t.conv128_down),s=Cl(s,t.conv128_1),s=Cl(s,t.conv128_2),s=u2(s,t.conv256_down),s=Cl(s,t.conv256_1),s=Cl(s,t.conv256_2),s=u2(s,t.conv256_down_out);let a=s.mean([1,2]);return Qt(a,t.fc)})}async forward(e){return this.forwardInput(await Ra(e))}async computeFaceDescriptor(e){var t;if((t=e==null?void 0:e.shape)!=null&&t.some(a=>a<=0))return new Float32Array(128);let n=await Ra(e),r=ce(()=>Fr(this.forwardInput(n))),s=await Promise.all(r.map(a=>a.data()));return r.forEach(a=>a.dispose()),n.isBatchInput?s:s[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return l0t(e)}extractParams(e){return i0t(e)}};function dse(e,t){return{...e,descriptor:t}}function pse(e,t){return{...e,age:t}}function hse(e,t,n){return{...e,gender:t,genderProbability:n}}function c0t(e,t){function n(l,u){let c=ud(e(9*l),[3,3,l,1]),d=Ln(e(l)),p=Ln(e(l)),h=Ln(e(l)),m=Ln(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/batch_norm_scale`},{paramPath:`${u}/batch_norm_offset`},{paramPath:`${u}/batch_norm_mean`},{paramPath:`${u}/batch_norm_variance`}),{filters:c,batch_norm_scale:d,batch_norm_offset:p,batch_norm_mean:h,batch_norm_variance:m}}function r(l,u,c,d,p){let h=ud(e(l*u*c*c),[c,c,l,u]),m=Ln(e(u));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/${p?"batch_norm_offset":"bias"}`}),{filters:h,bias:m}}function s(l,u,c,d){let{filters:p,bias:h}=r(l,u,c,d,!0);return{filters:p,batch_norm_offset:h}}function a(l,u,c){let d=n(l,`${c}/depthwise_conv`),p=s(l,u,1,`${c}/pointwise_conv`);return{depthwise_conv:d,pointwise_conv:p}}function i(){let l=s(3,32,3,"mobilenetv1/conv_0"),u=a(32,64,"mobilenetv1/conv_1"),c=a(64,128,"mobilenetv1/conv_2"),d=a(128,128,"mobilenetv1/conv_3"),p=a(128,256,"mobilenetv1/conv_4"),h=a(256,256,"mobilenetv1/conv_5"),m=a(256,512,"mobilenetv1/conv_6"),g=a(512,512,"mobilenetv1/conv_7"),y=a(512,512,"mobilenetv1/conv_8"),b=a(512,512,"mobilenetv1/conv_9"),v=a(512,512,"mobilenetv1/conv_10"),k=a(512,512,"mobilenetv1/conv_11"),I=a(512,1024,"mobilenetv1/conv_12"),S=a(1024,1024,"mobilenetv1/conv_13");return{conv_0:l,conv_1:u,conv_2:c,conv_3:d,conv_4:p,conv_5:h,conv_6:m,conv_7:g,conv_8:y,conv_9:b,conv_10:v,conv_11:k,conv_12:I,conv_13:S}}function o(){let l=s(1024,256,1,"prediction_layer/conv_0"),u=s(256,512,3,"prediction_layer/conv_1"),c=s(512,128,1,"prediction_layer/conv_2"),d=s(128,256,3,"prediction_layer/conv_3"),p=s(256,128,1,"prediction_layer/conv_4"),h=s(128,256,3,"prediction_layer/conv_5"),m=s(256,64,1,"prediction_layer/conv_6"),g=s(64,128,3,"prediction_layer/conv_7"),y=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),b=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),v=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),k=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),I=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),S=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),N=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),T=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),A=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),R=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),D=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),$=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:l,conv_1:u,conv_2:c,conv_3:d,conv_4:p,conv_5:h,conv_6:m,conv_7:g,box_predictor_0:{box_encoding_predictor:y,class_predictor:b},box_predictor_1:{box_encoding_predictor:v,class_predictor:k},box_predictor_2:{box_encoding_predictor:I,class_predictor:S},box_predictor_3:{box_encoding_predictor:N,class_predictor:T},box_predictor_4:{box_encoding_predictor:A,class_predictor:R},box_predictor_5:{box_encoding_predictor:D,class_predictor:$}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function d0t(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Hd(e),{extractMobilenetV1Params:s,extractPredictionLayerParams:a}=c0t(n,t),i=s(),o=a(),l={extra_dim:_N(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function p0t(e,t){let n=vm(e,t);function r(u,c,d){let p=n(`${u}/Conv2d_${c}_pointwise/weights`,4,`${d}/filters`),h=n(`${u}/Conv2d_${c}_pointwise/convolution_bn_offset`,1,`${d}/batch_norm_offset`);return{filters:p,batch_norm_offset:h}}function s(u){let c=`mobilenetv1/conv_${u}`,d=`MobilenetV1/Conv2d_${u}_depthwise`,p=`${c}/depthwise_conv`,h=`${c}/pointwise_conv`,m=n(`${d}/depthwise_weights`,4,`${p}/filters`),g=n(`${d}/BatchNorm/gamma`,1,`${p}/batch_norm_scale`),y=n(`${d}/BatchNorm/beta`,1,`${p}/batch_norm_offset`),b=n(`${d}/BatchNorm/moving_mean`,1,`${p}/batch_norm_mean`),v=n(`${d}/BatchNorm/moving_variance`,1,`${p}/batch_norm_variance`);return{depthwise_conv:{filters:m,batch_norm_scale:g,batch_norm_offset:y,batch_norm_mean:b,batch_norm_variance:v},pointwise_conv:r("MobilenetV1",u,h)}}function a(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:s(1),conv_2:s(2),conv_3:s(3),conv_4:s(4),conv_5:s(5),conv_6:s(6),conv_7:s(7),conv_8:s(8),conv_9:s(9),conv_10:s(10),conv_11:s(11),conv_12:s(12),conv_13:s(13)}}function i(u,c){let d=n(`${u}/weights`,4,`${c}/filters`),p=n(`${u}/biases`,1,`${c}/bias`);return{filters:d,bias:p}}function o(u){let c=i(`Prediction/BoxPredictor_${u}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${u}/box_encoding_predictor`),d=i(`Prediction/BoxPredictor_${u}/ClassPredictor`,`prediction_layer/box_predictor_${u}/class_predictor`);return{box_encoding_predictor:c,class_predictor:d}}function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:a,extractPredictionLayerParams:l}}function h0t(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=p0t(e,t),s=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!Iw(s))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${s}`);let a={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:s}};return jd(e,t),{params:a,paramMappings:t}}function El(e,t,n){return ce(()=>{let r=_a(e,t.filters,n,"same");return r=Ae(r,t.batch_norm_offset),oa(r,0,6)})}var f0t=.0010000000474974513;function m0t(e,t,n){return ce(()=>{let r=cm(e,t.filters,n,"same");return r=um(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,f0t),oa(r,0,6)})}function g0t(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function y0t(e,t){return ce(()=>{let n,r=El(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((s,a)=>{let i=a+1,o=g0t(i);r=m0t(r,s.depthwise_conv,o),r=El(r,s.pointwise_conv,[1,1]),i===11&&(n=r)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}function x0t(e,t,n){let r=e.arraySync(),s=Math.min(r[t][0],r[t][2]),a=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),c=Math.max(r[n][0],r[n][2]),d=Math.max(r[n][1],r[n][3]),p=(i-s)*(o-a),h=(c-l)*(d-u);if(p<=0||h<=0)return 0;let m=Math.max(s,l),g=Math.max(a,u),y=Math.min(i,c),b=Math.min(o,d),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+h-v)}function b0t(e,t,n,r,s){let a=e.shape[0],i=Math.min(n,a),o=t.map((c,d)=>({score:c,boxIndex:d})).filter(c=>c.score>s).sort((c,d)=>d.score-c.score),l=c=>c<=r?1:0,u=[];return o.forEach(c=>{if(u.length>=i)return;let d=c.score;for(let p=u.length-1;p>=0;--p){let h=x0t(e,c.boxIndex,u[p]);if(h!==0&&(c.score*=l(h),c.score<=s))break}d===c.score&&u.push(c.boxIndex)}),u}function v0t(e){let t=Fr(en(e,[1,0])),n=[at(t[2],t[0]),at(t[3],t[1])],r=[Ae(t[0],ht(n[0],2)),Ae(t[1],ht(n[1],2))];return{sizes:n,centers:r}}function w0t(e,t){let{sizes:n,centers:r}=v0t(e),s=Fr(en(t,[1,0])),a=ht(oe(la(ht(s[2],5)),n[0]),2),i=Ae(oe(ht(s[0],10),n[0]),r[0]),o=ht(oe(la(ht(s[3],5)),n[1]),2),l=Ae(oe(ht(s[1],10),n[1]),r[1]);return en(Yr([at(i,a),at(l,o),Ae(i,a),Ae(l,o)]),[1,0])}function k0t(e,t,n){return ce(()=>{let r=e.shape[0],s=w0t(ue(xi(n.extra_dim,[r,1,1]),[-1,4]),ue(e,[-1,4]));s=ue(s,[r,s.shape[0]/r,4]);let a=vo(hn(t,[0,0,1],[-1,-1,-1])),i=hn(a,[0,0,0],[-1,-1,1]);i=ue(i,[r,i.shape[1]]);let o=Fr(s),l=Fr(i);return{boxes:o,scores:l}})}function ng(e,t){return ce(()=>{let n=e.shape[0],r=ue(lv(e,t.box_encoding_predictor),[n,-1,1,4]),s=ue(lv(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:s}})}function I0t(e,t,n){return ce(()=>{let r=El(e,n.conv_0,[1,1]),s=El(r,n.conv_1,[2,2]),a=El(s,n.conv_2,[1,1]),i=El(a,n.conv_3,[2,2]),o=El(i,n.conv_4,[1,1]),l=El(o,n.conv_5,[2,2]),u=El(l,n.conv_6,[1,1]),c=El(u,n.conv_7,[2,2]),d=ng(t,n.box_predictor_0),p=ng(e,n.box_predictor_1),h=ng(s,n.box_predictor_2),m=ng(i,n.box_predictor_3),g=ng(l,n.box_predictor_4),y=ng(c,n.box_predictor_5),b=Jn([d.boxPredictionEncoding,p.boxPredictionEncoding,h.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding,y.boxPredictionEncoding],1),v=Jn([d.classPrediction,p.classPrediction,h.classPrediction,m.classPrediction,g.classPrediction,y.classPrediction],1);return{boxPredictions:b,classPredictions:v}})}var gT=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},S0t=class extends Gd{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return ce(()=>{let n=Ke(e.toBatchTensor(512,!1),"float32"),r=at(ht(n,127.5),1),s=y0t(r,t.mobilenetv1),{boxPredictions:a,classPredictions:i}=I0t(s.out,s.conv11,t.prediction_layer);return k0t(a,i,t.output_layer)})}async forward(e){return this.forwardInput(await Ra(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new gT(t),s=await Ra(e),{boxes:a,scores:i}=this.forwardInput(s),o=a[0],l=i[0];for(let b=1;b<a.length;b++)a[b].dispose(),i[b].dispose();let u=Array.from(l.dataSync()),c=b0t(o,u,n,.5,r),d=s.getReshapedInputDimensions(0),p=s.inputSize,h=p/d.width,m=p/d.height,g=o.arraySync(),y=c.map(b=>{let[v,k]=[Math.max(0,g[b][0]),Math.min(1,g[b][2])].map(N=>N*m),[I,S]=[Math.max(0,g[b][1]),Math.min(1,g[b][3])].map(N=>N*h);return new dl(u[b],new Dre(I,v,S-I,k-v),{height:s.getInputHeight(0),width:s.getInputWidth(0)})});return o.dispose(),l.dispose(),y}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return h0t(e)}extractParams(e){return d0t(e)}},C0t=.4,N0t=[new Yn(.738768,.874946),new Yn(2.42204,2.65704),new Yn(4.30971,7.04493),new Yn(10.246,4.59428),new Yn(12.6868,11.8741)],T0t=[new Yn(1.603231,2.094468),new Yn(6.041143,7.080126),new Yn(2.882459,3.518061),new Yn(4.266906,5.178857),new Yn(9.041765,10.66308)],$0t=[117.001,114.697,97.404],E0t="tiny_yolov2_model",_0t="tiny_yolov2_separable_conv_model",c2=e=>typeof e=="number";function A0t(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!c2(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>c2(t.x)&&c2(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(c2)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function RP(e){return ce(()=>{let t=oe(e,Tt(.10000000149011612));return Ae(Un(at(e,t)),t)})}function Cc(e,t){return ce(()=>{let n=ml(e,[[0,0],[1,1],[1,1],[0,0]]);return n=_a(n,t.conv.filters,[1,1],"valid"),n=at(n,t.bn.sub),n=oe(n,t.bn.truediv),n=Ae(n,t.conv.bias),RP(n)})}function Nc(e,t){return ce(()=>{let n=ml(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Fx(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=Ae(n,t.bias),RP(n)})}function R0t(e,t){let n=TP(e,t);function r(i,o){let l=Ln(e(i)),u=Ln(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:u}}function s(i,o,l){let u=n(i,o,3,`${l}/conv`),c=r(o,`${l}/bn`);return{conv:u,bn:c}}let a=$P(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}}function D0t(e,t,n,r){let{extractWeights:s,getRemainingWeights:a}=Hd(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:u}=R0t(s,i),c;if(t.withSeparableConvs){let[d,p,h,m,g,y,b,v,k]=r,I=t.isFirstLayerConv2d?o(d,p,3,"conv0"):u(d,p,"conv0"),S=u(p,h,"conv1"),N=u(h,m,"conv2"),T=u(m,g,"conv3"),A=u(g,y,"conv4"),R=u(y,b,"conv5"),D=v?u(b,v,"conv6"):void 0,$=k?u(v,k,"conv7"):void 0,_=o(k||v||b,5*n,1,"conv8");c={conv0:I,conv1:S,conv2:N,conv3:T,conv4:A,conv5:R,conv6:D,conv7:$,conv8:_}}else{let[d,p,h,m,g,y,b,v,k]=r,I=l(d,p,"conv0"),S=l(p,h,"conv1"),N=l(h,m,"conv2"),T=l(m,g,"conv3"),A=l(g,y,"conv4"),R=l(y,b,"conv5"),D=l(b,v,"conv6"),$=l(v,k,"conv7"),_=o(k,5*n,1,"conv8");c={conv0:I,conv1:S,conv2:N,conv3:T,conv4:A,conv5:R,conv6:D,conv7:$,conv8:_}}if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:c,paramMappings:i}}function F0t(e,t){let n=vm(e,t);function r(o){let l=n(`${o}/sub`,1),u=n(`${o}/truediv`,1);return{sub:l,truediv:u}}function s(o){let l=n(`${o}/filters`,4),u=n(`${o}/bias`,1);return{filters:l,bias:u}}function a(o){let l=s(`${o}/conv`),u=r(`${o}/bn`);return{conv:l,bn:u}}let i=EP(n);return{extractConvParams:s,extractConvWithBatchNormParams:a,extractSeparableConvParams:i}}function O0t(e,t){let n=[],{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}=F0t(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?r("conv0"):a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:o>7?a("conv6"):void 0,conv7:o>8?a("conv7"):void 0,conv8:r("conv8")}}else i={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:r("conv8")};return jd(e,n),{params:i,paramMappings:n}}var DP=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},fse=class mse extends Gd{constructor(t){super("TinyYolov2"),A0t(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let r=Cc(t,n.conv0);return r=Ss(r,[2,2],[2,2],"same"),r=Cc(r,n.conv1),r=Ss(r,[2,2],[2,2],"same"),r=Cc(r,n.conv2),r=Ss(r,[2,2],[2,2],"same"),r=Cc(r,n.conv3),r=Ss(r,[2,2],[2,2],"same"),r=Cc(r,n.conv4),r=Ss(r,[2,2],[2,2],"same"),r=Cc(r,n.conv5),r=Ss(r,[2,2],[1,1],"same"),r=Cc(r,n.conv6),r=Cc(r,n.conv7),lv(r,n.conv8,"valid",!1)}runMobilenet(t,n){let r=this.config.isFirstLayerConv2d?RP(lv(t,n.conv0,"valid",!1)):Nc(t,n.conv0);return r=Ss(r,[2,2],[2,2],"same"),r=Nc(r,n.conv1),r=Ss(r,[2,2],[2,2],"same"),r=Nc(r,n.conv2),r=Ss(r,[2,2],[2,2],"same"),r=Nc(r,n.conv3),r=Ss(r,[2,2],[2,2],"same"),r=Nc(r,n.conv4),r=Ss(r,[2,2],[2,2],"same"),r=Nc(r,n.conv5),r=Ss(r,[2,2],[1,1],"same"),r=n.conv6?Nc(r,n.conv6):r,r=n.conv7?Nc(r,n.conv7):r,lv(r,n.conv8,"valid",!1)}forwardInput(t,n){let{params:r}=this;if(!r)throw new Error("TinyYolov2 - load model before inference");return ce(()=>{let s=Ke(t.toBatchTensor(n,!1),"float32");return s=this.config.meanRgb?Sw(s,this.config.meanRgb):s,s=s.div(255),this.config.withSeparableConvs?this.runMobilenet(s,r):this.runTinyYolov2(s,r)})}async forward(t,n){return this.forwardInput(await Ra(t),n)}async detect(t,n={}){let{inputSize:r,scoreThreshold:s}=new DP(n),a=await Ra(t),i=await this.forwardInput(a,r),o=ce(()=>Fr(i)[0].expandDims()),l={width:a.getInputWidth(0),height:a.getInputHeight(0)},u=await this.extractBoxes(o,a.getReshapedInputDimensions(0),s);i.dispose(),o.dispose();let c=u.map(m=>m.box),d=u.map(m=>m.score),p=u.map(m=>m.classScore),h=u.map(m=>this.config.classes[m.label]);return bvt(c.map(m=>m.rescale(r)),d,this.config.iouThreshold,!0).map(m=>new _re(d[m],p[m],h[m],c[m],l))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return O0t(t,this.config)}extractParams(t){let n=this.config.filterSizes||mse.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(r!==7&&r!==8&&r!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return D0t(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,r){let{width:s,height:a}=n,i=Math.max(s,a),o=i/s,l=i/a,u=t.shape[1],c=this.config.anchors.length,[d,p,h]=ce(()=>{let b=t.reshape([u,u,c,this.boxEncodingSize]),v=b.slice([0,0,0,0],[u,u,c,4]),k=b.slice([0,0,0,4],[u,u,c,1]),I=this.withClassScores?Pd(b.slice([0,0,0,5],[u,u,c,this.config.classes.length]),3):Tt(0);return[v,k,I]}),m=[],g=await p.array(),y=await d.array();for(let b=0;b<u;b++)for(let v=0;v<u;v++)for(let k=0;k<c;k++){let I=JE(g[b][v][k][0]);if(!r||I>r){let S=(v+JE(y[b][v][k][0]))/u*o,N=(b+JE(y[b][v][k][1]))/u*l,T=Math.exp(y[b][v][k][2])*this.config.anchors[k].x/u*o,A=Math.exp(y[b][v][k][3])*this.config.anchors[k].y/u*l,R=S-T/2,D=N-A/2,$={row:b,col:v,anchor:k},{classScore:_,label:L}=this.withClassScores?await this.extractPredictedClass(h,$):{classScore:1,label:0};m.push({box:new Ere(R,D,R+T,D+A),score:I,classScore:I*_,label:L,...$})}}return d.dispose(),p.dispose(),h.dispose(),m}async extractPredictedClass(t,n){let{row:r,col:s,anchor:a}=n,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,l)=>i[r][s][a][l]).map((o,l)=>({classScore:o,label:l})).reduce((o,l)=>o.classScore>l.classScore?o:l)}};fse.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var gse=fse,M0t=class extends gse{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:C0t,classes:["face"],...e?{anchors:T0t,meanRgb:$0t}:{anchors:N0t,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new dl(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?_0t:E0t}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},yse=class extends DP{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Cw=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function yT(e,t,n,r,s=({alignedRect:a})=>a){let a=e.map(l=>rse(l)?s(l):l.detection),i=r||(t instanceof Zt?await NP(t,a):await CP(t,a)),o=await n(i);return i.forEach(l=>l instanceof Zt&&l.dispose()),o}async function FP(e,t,n,r,s){return yT([e],t,async a=>n(a[0]),r,s)}var L0t=.4,P0t=[new Yn(1.603231,2.094468),new Yn(6.041143,7.080126),new Yn(2.882459,3.518061),new Yn(4.266906,5.178857),new Yn(9.041765,10.66308)],z0t=[117.001,114.697,97.404],B0t=class extends gse{constructor(){let e={withSeparableConvs:!0,iouThreshold:L0t,classes:["face"],anchors:P0t,meanRgb:z0t,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new dl(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},qa={ssdMobilenetv1:new S0t,tinyFaceDetector:new B0t,tinyYolov2:new M0t,faceLandmark68Net:new Jvt,faceLandmark68TinyNet:new n0t,faceRecognitionNet:new u0t,faceExpressionNet:new Lvt,ageGenderNet:new Zvt},xse=class extends Cw{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},OP=class extends xse{async run(){let e=await this.parentTask,t=await yT(e,this.input,async n=>Promise.all(n.map(r=>qa.faceExpressionNet.predictExpressions(r))),this.extractedFaces);return e.map((n,r)=>nse(n,t[r]))}withAgeAndGender(){return new zP(this,this.input)}},MP=class extends xse{async run(){let e=await this.parentTask;if(!e)return;let t=await FP(e,this.input,n=>qa.faceExpressionNet.predictExpressions(n),this.extractedFaces);return nse(e,t)}withAgeAndGender(){return new BP(this,this.input)}},LP=class extends OP{withAgeAndGender(){return new WP(this,this.input)}withFaceDescriptors(){return new UP(this,this.input)}},PP=class extends MP{withAgeAndGender(){return new VP(this,this.input)}withFaceDescriptor(){return new GP(this,this.input)}},bse=class extends Cw{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},zP=class extends bse{async run(){let e=await this.parentTask,t=await yT(e,this.input,async n=>Promise.all(n.map(r=>qa.ageGenderNet.predictAgeAndGender(r))),this.extractedFaces);return e.map((n,r)=>{let{age:s,gender:a,genderProbability:i}=t[r];return pse(hse(n,a,i),s)})}withFaceExpressions(){return new OP(this,this.input)}},BP=class extends bse{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await FP(e,this.input,s=>qa.ageGenderNet.predictAgeAndGender(s),this.extractedFaces);return pse(hse(e,n,r),t)}withFaceExpressions(){return new MP(this,this.input)}},WP=class extends zP{withFaceExpressions(){return new LP(this,this.input)}withFaceDescriptors(){return new UP(this,this.input)}},VP=class extends BP{withFaceExpressions(){return new PP(this,this.input)}withFaceDescriptor(){return new GP(this,this.input)}},vse=class extends Cw{constructor(e,t){super(),this.parentTask=e,this.input=t}},UP=class extends vse{async run(){let e=await this.parentTask;return(await yT(e,this.input,t=>Promise.all(t.map(n=>qa.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>dse(e[n],t))}withFaceExpressions(){return new LP(this,this.input)}withAgeAndGender(){return new WP(this,this.input)}},GP=class extends vse{async run(){let e=await this.parentTask;if(!e)return;let t=await FP(e,this.input,n=>qa.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return dse(e,t)}withFaceExpressions(){return new PP(this,this.input)}withAgeAndGender(){return new VP(this,this.input)}},wse=class extends Cw{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?qa.faceLandmark68TinyNet:qa.faceLandmark68Net}},W0t=class extends wse{async run(){let e=await this.parentTask,t=e.map(s=>s.detection),n=this.input instanceof Zt?await NP(this.input,t):await CP(this.input,t),r=await Promise.all(n.map(s=>this.landmarkNet.detectLandmarks(s)));return n.forEach(s=>s instanceof Zt&&s.dispose()),e.filter((s,a)=>r[a]).map((s,a)=>sse(s,r[a]))}withFaceExpressions(){return new LP(this,this.input)}withAgeAndGender(){return new WP(this,this.input)}withFaceDescriptors(){return new UP(this,this.input)}},V0t=class extends wse{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof Zt?await NP(this.input,[t]):await CP(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(s=>s instanceof Zt&&s.dispose()),sse(e,r)}withFaceExpressions(){return new PP(this,this.input)}withAgeAndGender(){return new VP(this,this.input)}withFaceDescriptor(){return new GP(this,this.input)}},kse=class extends Cw{constructor(e,t=new gT){super(),this.input=e,this.options=t}},U0t=class extends kse{async run(){let{input:e,options:t}=this,n;if(t instanceof yse)n=qa.tinyFaceDetector.locateFaces(e,t);else if(t instanceof gT)n=qa.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof DP)n=qa.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(r=>Ore({},r)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new W0t(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new OP(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new zP(this.runAndExtendWithFaceDetections(),this.input)}},G0t=class extends kse{async run(){let e=await new U0t(this.input,this.options),t=e[0];return e.forEach(n=>{n.score>t.score&&(t=n)}),t}runAndExtendWithFaceDetection(){return new Promise(async e=>{let t=await this.run();e(t?Ore({},t):void 0)})}withFaceLandmarks(e=!1){return new V0t(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new MP(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new BP(this.runAndExtendWithFaceDetection(),this.input)}};function j0t(e,t=new gT){return new G0t(e,t)}const t_="/models/face-api";let Z6=!1;const rg=async(e,t,n,r)=>{e(n),t(r),await new Promise(s=>setTimeout(s,100))},H0t=async e=>Se(()=>{const t=yH(e),n=yo.resizeBilinear(t,[128,128]);return lt(n,"float32").div(255)}),q0t=async e=>Se(()=>{try{const t=py(e.expandDims(),[2,2],[1,1],"same").squeeze(),r=e.sub(t).abs().mean().dataSync()[0];return Math.min(Math.max(r*5,0),1)}catch(t){return console.error("ELA Analysis error:",t),.5}}),K0t=async e=>Se(()=>{try{const t=py(e.expandDims(),[3,3],[1,1],"same").squeeze(),n=e.sub(t);return Math.min(n.abs().mean().dataSync()[0]*10,1)}catch(t){return console.error("Noise Analysis error:",t),.5}}),X0t=e=>{const t={ela:.4,noise:.3,face:.3};return Object.entries(e).reduce((n,[r,s])=>n+s*t[r],0)},Y0t=e=>e<.3?"High confidence this is a real image (very low manipulation markers)":e<.45?"Moderate confidence this is a real image":e<.55?"Analysis is inconclusive - borderline case":e<.7?"Moderate confidence this is a deepfake image":"High confidence this is a deepfake image (strong manipulation markers)",Z0t=async e=>{try{if(!await J0t())return console.warn("Face detection models not available"),await n_(e);const n=document.createElement("canvas"),r=n.getContext("2d");n.width=e.naturalWidth,n.height=e.naturalHeight,r.drawImage(e,0,0);const s=new yse({inputSize:512,scoreThreshold:.3});console.log("Starting face detection...");const a=await j0t(n,s).withFaceLandmarks();if(console.log("Detection result:",a),!a)return console.warn("No face detected in image"),await n_(e);const i=a.landmarks,o=Q0t(i),l=e1t(i);return console.log("Analysis scores:",{symmetryScore:o,consistencyScore:l}),o*.4+l*.6}catch(t){return console.error("Facial analysis error:",t),await n_(e)}},J0t=async()=>{if(Z6)return console.log("Models already loaded"),!0;try{console.log("Loading models from:",t_),await Promise.all([qa.tinyFaceDetector.load(t_),qa.faceLandmark68Net.load(t_)]),console.log("Face-api models loaded successfully"),Z6=!0;const e={tinyFaceDetector:qa.tinyFaceDetector.isLoaded,faceLandmark68Net:qa.faceLandmark68Net.isLoaded};return console.log("Model status:",e),!0}catch(e){return console.error("Failed to load face-api models:",e),!1}},n_=async e=>Se(()=>{try{const t=yH(e),n=yo.resizeBilinear(t,[224,224]),r=lt(n,"float32").div(255),s=py(r,2,2,"valid"),a=yo.resizeBilinear(s,[r.shape[0],r.shape[1]]),i=r.sub(a).abs();return Math.min(Math.max(i.mean().dataSync()[0]*3,0),1)}catch(t){return console.error("Simplified analysis error:",t),.5}}),Q0t=e=>{try{const t=e.positions;let n=0;const r=t[27].x,s=[[0,16],[1,15],[2,14],[3,13],[4,12],[5,11],[6,10],[7,9]];return s.forEach(([a,i])=>{const o=t[a],l=t[i],u=Math.abs(r-o.x),c=Math.abs(r-l.x),d=Math.abs(u-c);n+=1-d/u}),n/s.length}catch(t){return console.error("Symmetry analysis error:",t),.5}},e1t=e=>{try{const t=e.positions,n=r_(t[36],t[45]),r=r_(t[27],t[33]),s=r_(t[48],t[54]),a=[s_(n,r,1.5,2.5),s_(s,n,.8,1.2),s_(r,s,.5,.9)];return a.reduce((i,o)=>i+o)/a.length}catch(t){return console.error("Consistency analysis error:",t),.5}},r_=(e,t)=>Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2)),s_=(e,t,n,r)=>{const s=e/t;if(s>=n&&s<=r)return 1;const a=Math.min(Math.abs(s-n),Math.abs(s-r));return Math.max(0,1-a)},t1t=async(e,t,n,r)=>{try{await rg(n,r,"Preprocessing image...",10);const s=await H0t(e);await rg(n,r,"Analyzing error levels...",30);const a=await q0t(s);await rg(n,r,"Analyzing noise patterns...",50);const i=await K0t(s);await rg(n,r,"Analyzing facial features...",70);const o=await Z0t(e);await rg(n,r,"Calculating final results...",90);const u=X0t({ela:a,noise:i,face:o});return on(s),await rg(n,r,"Analysis complete",100),{scores:{errorLevel:{value:a,label:"Error Level Analysis",description:"Analyzes image compression artifacts"},noisePattern:{value:i,label:"Noise Pattern",description:"Examines image noise consistency"},facial:{value:o,label:"Facial Analysis",description:"Analyzes facial feature consistency"}},finalScore:u,prediction:u>.5?"Deepfake":"Real",confidence:Math.round(Math.abs(u-.5)*200),reason:Y0t(u),detailedAnalysis:!0}}catch(s){throw console.error("Analysis error:",s),new Error("Failed to complete image analysis")}},n1t=()=>{const[e,t]=ee.useState(null),[n,r]=ee.useState(null),[s,a]=ee.useState(!1),[i,o]=ee.useState(""),[l,u]=ee.useState(0),[c,d]=ee.useState(null),[p]=ra(Gu,{volume:3.9}),[h]=ra(xd,{volume:3.9}),m=ee.useCallback(async k=>{try{a(!0),d(null),u(0);const I=await t1t(k,null,o,u);r(I)}catch(I){console.error("Analysis failed:",I),d("Failed to analyze image: "+I.message)}finally{a(!1)}},[]),g=ee.useCallback(async k=>{h();const I=k[0];if(!I)return;const S=new Image;S.onload=()=>{t(S),m(S)},S.onerror=()=>{d("Failed to load image")},S.src=URL.createObjectURL(I)},[m,h]),{getRootProps:y,getInputProps:b,isDragActive:v}=R5({onDrop:g,accept:{"image/*":[".jpeg",".jpg",".png"]},multiple:!1});return J.jsxs("div",{className:"auth-container",children:[J.jsx(bd,{}),J.jsx("div",{className:"detector-content",children:J.jsxs("div",{className:"detector-box",children:[J.jsxs("div",{className:"header-section",children:[J.jsx("h2",{className:"login-title",children:"DEEPFAKE DETECTOR"}),J.jsx("p",{className:"auth-subtitle",children:"Upload an image to analyze for potential manipulation"})]}),J.jsxs("div",{...y(),className:`dropzone ${v?"active":""}`,onMouseEnter:()=>p(),children:[J.jsx("input",{...b()}),J.jsx(Ile,{className:"upload-icon"}),J.jsx("p",{className:"upload-text",children:"Drag & drop an image here"}),J.jsx("p",{className:"upload-subtext",children:"or click to select a file"})]}),c&&J.jsx("div",{className:"auth-message error",children:c}),J.jsxs("div",{className:"results-section",children:[e&&J.jsx("div",{className:"analysis-card",onMouseEnter:()=>p(),children:J.jsx("img",{src:e.src,alt:"Analyzed",className:"preview-image"})}),n&&J.jsxs("div",{className:"analysis-card",onMouseEnter:()=>p(),children:[J.jsxs("div",{className:"analysis-header",children:[n.prediction==="Real"?J.jsx(IG,{size:24,color:"#10b981"}):J.jsx(NG,{size:24,color:"#ef4444"}),J.jsx("h2",{className:"analysis-title",children:n.prediction})]}),J.jsx("div",{className:"metrics-grid",children:Object.entries(n.scores).map(([k,I])=>J.jsxs("div",{className:"metric-card",children:[J.jsx("h3",{className:"metric-title",children:I.label}),J.jsxs("div",{className:"metric-value",children:[(I.value*100).toFixed(1),"%"]}),J.jsx("p",{className:"metric-description",children:I.description})]},k))}),J.jsxs("div",{className:"confidence-section",children:[J.jsx("h3",{className:"confidence-title",children:"Detection Confidence"}),J.jsx("div",{className:"confidence-bar",children:J.jsx("div",{className:`confidence-fill ${n.prediction.toLowerCase()}`,style:{width:`${n.confidence}%`}})}),J.jsx("p",{className:"analysis-reason",children:n.reason})]})]})]})]})}),s&&J.jsxs(the,{children:[J.jsx("div",{className:"spinner"}),J.jsx("p",{className:"loading-text",children:i})]})]})},jP=Zr.create({baseURL:"http://localhost:5000/api",headers:{"Content-Type":"application/json"},withCredentials:!0});jP.interceptors.request.use(e=>{const t=localStorage.getItem("token");return t&&(e.headers.Authorization=`Bearer ${t}`),e},e=>Promise.reject(e));jP.interceptors.response.use(e=>e,e=>{var t;return((t=e.response)==null?void 0:t.status)===401&&(localStorage.clear(),window.location.href="/login"),Promise.reject(e)});const zb=({children:e,isAuthenticated:t})=>{const[n,r]=ee.useState(!0),[s,a]=ee.useState(t),i=Uu();return ee.useEffect(()=>{(async()=>{if(!localStorage.getItem("token")){a(!1),r(!1);return}try{await jP.get("/auth/verify"),a(!0)}catch(u){console.error("Auth verification failed:",u),localStorage.clear(),a(!1)}finally{r(!1)}})()},[]),n?J.jsxs("div",{className:"loading-container",children:[J.jsx("div",{className:"loading-spinner"}),J.jsx("p",{children:"Verifying authentication..."})]}):s?e:J.jsx(i_,{to:"/login",state:{from:i},replace:!0})},r1t=()=>J.jsx("div",{className:"mobile-restriction-overlay",children:J.jsxs("div",{className:"restriction-content",children:[J.jsx(Tle,{className:"mobile-icon"}),J.jsx(Sle,{className:"desktop-icon"}),J.jsx("h2",{children:"Desktop Only Access"}),J.jsx("p",{children:"This application requires a desktop or laptop computer to access. Please switch to a larger device."})]})});function s1t(){const[e,t]=ee.useState(localStorage.getItem("isAuthenticated")==="true");return J.jsxs(J.Fragment,{children:[J.jsxs(koe,{children:[J.jsx(r1t,{}),J.jsx("div",{className:"app-container",children:J.jsxs(Jie,{children:[J.jsx(Bo,{path:"/",element:J.jsx(Ple,{})}),J.jsx(Bo,{path:"/home",element:J.jsx(i_,{to:"/",replace:!0})}),J.jsx(Bo,{path:"/login",element:J.jsx(ice,{setIsAuthenticated:t})}),J.jsx(Bo,{path:"/register",element:J.jsx(oce,{})}),J.jsx(Bo,{path:"/dashboard",element:J.jsx(zb,{isAuthenticated:e,children:J.jsx(bce,{setIsAuthenticated:t})})}),J.jsx(Bo,{path:"/safe-browsing",element:J.jsx(zb,{isAuthenticated:e,children:J.jsx(Yde,{})})}),J.jsx(Bo,{path:"/steganography",element:J.jsx(zb,{isAuthenticated:e,children:J.jsx(Zde,{})})}),J.jsx(Bo,{path:"/emailscanner",element:J.jsx(zb,{isAuthenticated:e,children:J.jsx(tpe,{})})}),J.jsx(Bo,{path:"/detect",element:J.jsx(zb,{isAuthenticated:e,children:J.jsx(n1t,{})})}),J.jsx(Bo,{path:"*",element:J.jsx(i_,{to:"/",replace:!0})})]})})]}),J.jsx(_R,{position:"top-right",autoClose:3e3,hideProgressBar:!1,newestOnTop:!1,closeOnClick:!0,rtl:!1,pauseOnFocusLoss:!0,draggable:!0,pauseOnHover:!0,theme:"dark"})]})}oie.createRoot(document.getElementById("root")).render(J.jsx(Lt.StrictMode,{children:J.jsx(s1t,{})}));export{a1t as c,ty as g};
